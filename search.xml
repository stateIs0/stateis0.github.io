<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MappedByteBuffer vs FileChannel 孰强孰弱？</title>
    <url>/2019/05/12/2019/05-12-java-nio/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>     

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 在 JDK 1.4 引入了 ByteBuffer 等 NIO 相关的类，使得 Java 程序员可以抛弃基于 Stream ，从而使用基于 Block  的方式读写文件，另外，JDK 还引入了 IO 性能优化之王—— 零拷贝  sendFile 和 mmap。但他们的性能究竟怎么样？ 和 RandomAccessFile 比起来，快多少？ 什么情况下快？到底是 FileChannel 快还是 MappedByteBuffer 快……</p>
<p>(零拷贝参考 <a href="https://www.linuxjournal.com/article/6345">Zero Copy I: User-Mode Perspective</a>)</p>
<p>天啊，问题太多了！！！！！！</p>
<p>让我们慢慢分析。</p>
<h2 id="看看善于利用-IO-零拷贝的-MQ-们"><a href="#看看善于利用-IO-零拷贝的-MQ-们" class="headerlink" title="看看善于利用 IO 零拷贝的 MQ 们"></a>看看善于利用 IO 零拷贝的 MQ 们</h2><p>我们知道，Java 世界有很多 MQ：ActiveMQ，kafka，RocketMQ，去哪儿 MQ，而他们则是 Java 世界使用 NIO 零拷贝的大户。</p>
<p>然而，他们的性能却大相同，抛开其他的因素，例如网络传输方式，数据结构设计，文件存储方式，我们仅仅讨论 Broker 端对文件的读写，看看他们有什么不同。</p>
<p>下图是楼主查看源码总结的各个 MQ 使用的文件读写方式。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g3dlo5hhwqj30er047wem.jpg"></p>
<ul>
<li>kafka：record 的读写都是基于 FileChannel。index 读写基于 MMAP（厮大提示）。</li>
<li>RocketMQ：读盘基于 MMAP，写盘默认使用 MMAP，可通过修改配置，配置成 FileChannel，原因是作者想避免 PageCache 的锁竞争，通过两层架构实现读写分离。</li>
<li>QMQ： 去哪儿 MQ，读盘使用 MMAP，写盘使用 FileChannel。</li>
<li>ActiveMQ 5.15： 读写全部都是基于 RandomAccessFile，这也是我们抛弃 ActiveMQ 的原因。</li>
</ul>
<p>那么，到底是 MMAP 强，还是 FileChannel 强？</p>
<p>MMAP 众所周知，基于 OS 的 mmap 的内存映射技术，通过 MMU 映射文件，使随机读写文件和读写内存相似的速度。</p>
<p>那 FileChannel 呢？是零拷贝吗？很遗憾，不是。FileChannel 快，只是因为他是基于 block 的。</p>
<p>接下来，benchmark everything —— 徐妈.</p>
<h2 id="Benchmark-？"><a href="#Benchmark-？" class="headerlink" title="Benchmark ？"></a>Benchmark ？</h2><p>如何 Benchmark？ Benchmark 哪些？</p>
<p>既然是读写文件，自然就要看读写性能，这是最基本的。但，注意，通常 MQ 会使用定时刷盘，防止数据丢失，MMAP 和 FileChannel 都有 force 方法，用于将 pageCache 的数据刷到硬盘上。force 会影响性能吗？ 答案是会。影响到什么程度呢？ 不知道。每次写入的数据大小会影响性能吗，毫无疑问会，但规则是什么呢？FileOutputStream 真的一无是处吗？答案是不一定。</p>
<p>一直以来，文件调优都是艺术，因为影响性能的因素太多，首先，SSD 的出现，已经让传统基于 B+ tree 的树形结构产生了自我疑问，第二，每个文件系统的性能不同，Linux ext3 和 ext4 性能天壤之别（删除文件的性能差距在 20 倍左右）。而 Max OS 的 HFS+  系统被 Linus 称之为“有史以来最垃圾的文件系统”，幸运的是，苹果终于在 2017 年推送了 macOS High Sierra 和  iOS 10.3  系统，这个两个系统都抛弃了 HFS+，换成了性能更高的 APFS。而每个文件系统又可以设置不同的调度算法，另外，还有虚拟内存缺页中断带来的性能毛刺……. </p>
<p>（tips：良心的 RocketMQ 提供了 Linux IO 调优的脚本，这点做的不错 ：）</p>
<p>跑题了。</p>
<p>楼主写了一个小项目，用于测试 Java MappedByteBuffer &amp; FileChannel &amp; RandomAccessFile  &amp;  FileXXXputStream 的读写性能。大家也可以在自己的机器上跑跑看。</p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>CPU：intel i7 4核8线程  4.2GHz<br>内存：40GB DDR4<br>磁盘：SSD 读写 2GB/s 左右<br>JDK1.8<br>OS：Mac OS 10.13.6<br>虚拟内存： 未关闭，大小 9GB</p>
<p>测试注意点：</p>
<ol>
<li>为了防止 PageCache 缓存的影响，每次都生成一个新的文件进行读取。</li>
<li>为了测试不同数据包对性能的影响，需要使用不同大小的数据包进行多次测试。</li>
<li>force 对性能影响很大，应该单独测试。</li>
<li>使用 1GB 文件进行测试（小文件没有参考意义，大文件 mmap 无法映射）</li>
</ol>
<h2 id="纯粹读测试"><a href="#纯粹读测试" class="headerlink" title="纯粹读测试"></a>纯粹读测试</h2><p>1GB 文件：</p>
<p>测试 MappedByteBuffer &amp; FileChannel &amp; RandomAccessFile &amp; FileInputStream.</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g3c6kfhqykj317q0o6q4a.jpg"></p>
<p>从这张图里，我们看到，mmap   性能完胜，特别是在小数据量的情况下。其他的流，只有在4kb 的情况下，才开始反杀 mmap。<strong>因此，读 4kb 以下的数据，请使用 mmap。</strong></p>
<p>再放大看看 mmap 和 FileChannel 的比较：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-5a8085205bae036f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缩放图"></p>
<p>根据上图，我们看到，在写入数据包大于 4kb 以上的情况下，FileChannel 等一众非零拷贝，基本完胜 mmap，除了那个一次读 1G 文件的 BT 测试。</p>
<p><strong>因此，如果你的数据包大于 4kb，请使用 FileChannel</strong>。</p>
<h2 id="纯粹写测试"><a href="#纯粹写测试" class="headerlink" title="纯粹写测试"></a>纯粹写测试</h2><p>1GB 文件：</p>
<p>测试 MappedByteBuffer &amp; FileChannel &amp; RandomAccessFile &amp; FileInputStream.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-21b0ba80242f83e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="大图"></p>
<p>从上图，我们可以看出，mmap 性能还是一样的稳定。FileChannel 也不差，但是在 32 字节数据量的情况下，还差点意思。</p>
<p>再看缩略图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-330395fb35b08687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="写缩略图"></p>
<p>我们看到，64字节 是 FileChannel 和 mmap 性能的分水岭，从  64字节开始，FileChannel 一路反杀，直到 BT 1GB 文件稍稍输了一丢丢。</p>
<p>因此，我们建议：<strong>如果你的数据包大小在 64 字节以上，请使用 FileChannel 写入。</strong></p>
<h2 id="异步-force-测试"><a href="#异步-force-测试" class="headerlink" title="异步 force 测试"></a>异步 force 测试</h2><p>我们知道，RocketMQ 使用异步刷盘，那么异步 force 对性能有没有影响呢？benchmark everything。我们使用异步线程，每 16kb 刷盘一次，看看性能如何。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4b77af1d279f3427.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异步刷盘"></p>
<p>mmap 一直落后，且性能很差，除了在 2048 字节那里有一点点抖动，基本维持 在 4000 左右，而没有 force 的情况下，则在 1500 左右。而 FileChannel 则完全不受 force 的影响。在我的测试中，1GB 的文件，一次 force 需要 800 毫秒左右。buffer 越大，时间越多，反之则越小。</p>
<p>说个题外话，Kafka 一直不建议使用 force，大概也有这个原因。当然，Kafka 还有自己的多副本策略保证数据安全。</p>
<p><strong>这里，我们得出结论，如果你需要经常执行 force，即使是异步的，也请一定不要使用 mmap，请使用 FileChannel。</strong></p>
<h2 id="总结。"><a href="#总结。" class="headerlink" title="总结。"></a>总结。</h2><p>基于以上测试，我们得出一张图表：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-31e313b87612dde2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>假设，我们的系统的数据包在 1024 - 2048 左右，我们应该使用什么策略？</p>
<p>答：读使用 mmap，仅仅写使用 FileChannel。</p>
<p>再回过头看看 MQ 的实现者们，似乎只有 QMQ 是 这么做的。当然，RocketMQ 也提供了 FileChannel 的写选项。但默认  mmap 写加异步刷盘，应该是 broker busy 的元凶吧。</p>
<p>而 Kafka，因为默认不 force，也是使用 FileChannel 进行写入的，为什么使用 FileChannel 读呢？大概是因为消息的大小在 4kb 以上吧。</p>
<p>这样一揣测，这些 MQ 的设计似乎都非常合理。</p>
<p>最后，能不用 force 就别用 force。如果要用 force ，就请使用 FileChannel。</p>
]]></content>
      <categories>
        <category>Java 性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>几个网络相关的问题</title>
    <url>/2019/06/06/2019/06-06-io-qa/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<span id="more"></span>    

<h2 id="1-一台机器最多支持多少-tcp-连接"><a href="#1-一台机器最多支持多少-tcp-连接" class="headerlink" title="1 一台机器最多支持多少 tcp 连接"></a>1 一台机器最多支持多少 tcp 连接</h2><p>首先，一个连接的组成是 【local ip, local port, remote ip, remote port】,作为服务端 ，前两者是不变的。</p>
<p>那么一个端口，ipv4地址，2的32 次方 * 端口数（2 的 16 次方）= 2的48 次方</p>
<p>另外，还需要修改文件句柄大小。ulimit 是一个进程的句柄大小。默认 1024.</p>
<h2 id="2-连接数过多会带来什么影响"><a href="#2-连接数过多会带来什么影响" class="headerlink" title="2 连接数过多会带来什么影响"></a>2 连接数过多会带来什么影响</h2><p>连接数过多之tcp回收问题 time wait，即服务端主动关闭连接。</p>
<p>可修改 vi /etc/sysctl.conf 文件，修改 timeout，socket 回收，重用 tcp，开启 syn cookies。 4 个方式。</p>
<h2 id="3-cpu0-显示繁忙"><a href="#3-cpu0-显示繁忙" class="headerlink" title="3 cpu0 显示繁忙"></a>3 cpu0 显示繁忙</h2><p>软中断过高，而且大部分都集中在同一个CPU。</p>
<p>用软件处理，有 RPS，通过对流的 hash，负载到不同的  cpu，问题是不能够很好的让 进程的 cpu 和处理中断的  cpu 是同一个 cpu，导致 cache miss。为了解决这个问题，linux 后来的版本，有个 RFS 的方案，防止 cache miss。但是据说还是不太好用。</p>
<p>购买支持多队列的网卡硬件，可以彻底解决 软中断集中在单个 cpu0 的问题（看版本）。</p>
<p>从这个话题换个角度说：当你的网卡没有打满，cpu 满载了，除了用 pidstat 看看是不是程序问题，或者 cs 问题，还可以看看是不是 cpu0 软中断太多导致的。</p>
<h2 id="4-time-wait-和-close-wait-区别"><a href="#4-time-wait-和-close-wait-区别" class="headerlink" title="4 time wait 和 close wait 区别"></a>4 time wait 和 close wait 区别</h2><p>time wait 是主动关闭，这个是为了确保旧连接的数据对新连接的影响。通常是 2msl。而且资源会被占用。</p>
<p>解决办法，1 尽量不要主动断开连接。</p>
<p>2 另外，关闭 socket 的 linger 选项。</p>
<p>close wait 对方关闭。此时，我们需要再调一次 close 来主动关闭。</p>
<h2 id="5-写文件经历几层-cache"><a href="#5-写文件经历几层-cache" class="headerlink" title="5 写文件经历几层 cache"></a>5 写文件经历几层 cache</h2><p>普通调用：1 层，如果是 DIO，则是 0 层。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8173e2b49923ab80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="6-tcp-滑动窗口是什么"><a href="#6-tcp-滑动窗口是什么" class="headerlink" title="6 tcp 滑动窗口是什么"></a>6 tcp 滑动窗口是什么</h2><p>滑动窗口是接受数据端使用的窗口大小，用来告知发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的</p>
<h2 id="7-为什么有网卡中断"><a href="#7-为什么有网卡中断" class="headerlink" title="7 为什么有网卡中断"></a>7 为什么有网卡中断</h2><p>可以认为是“唤醒” CPU 处理网卡数据，否则网卡缓存会溢出，导致丢弃数据。</p>
<p>还有一种 DMA 的方式。</p>
<h2 id="8-bio-有什么好处，什么地方用-bio"><a href="#8-bio-有什么好处，什么地方用-bio" class="headerlink" title="8 bio 有什么好处，什么地方用 bio"></a>8 bio 有什么好处，什么地方用 bio</h2><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p>
]]></content>
      <categories>
        <category>Java 性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>递归时间复杂度 递归树 推演计算</title>
    <url>/2019/10/19/2019/1019-fuzadujisuan/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h1 id="递归时间复杂度-递归树-推演计算"><a href="#递归时间复杂度-递归树-推演计算" class="headerlink" title="递归时间复杂度 递归树 推演计算"></a>递归时间复杂度 递归树 推演计算</h1><p>递归的时间复杂度计算较为麻烦。以下我们使用归并排序的例子，对递归复杂度进行推演。</p>
<p>假设现在有一个归并排序。他的运行总时间是 <code>T（n）</code>，<br>我们通过将其分解成 2 个子任务，即 ：<code>2 * （T（n/2））+ n</code>，为什么加 <code>n</code> 呢？因为 <code>n/2</code> 只是递归计算的时间，实际还有合并的时间，在大部分递归中，不但有分解子任务的时间，还有合并子任务的时间也要计算（在递归计算中，子问题消耗的时间需要统计，合并子问题的结果所消耗的时间也要统计）。</p>
<p>现在，我们的公式是 <code>2 * （T（n/2））+ n</code>，表达的是一颗高度是 1 的递归树：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-d045b4a459b26fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如上图，我们需要把这颗递归树的 3 个节点的所有耗时都加上，最终的结果就是 <code>T(N)</code>;<br>再看上图，我们递归了 1 层，如果递归 2 层、3层呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-c086af2b67e6b7d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 2 层"></p>
<p>递归 2 层，表达式变为 <code>4 *（T（n/4）)+ 2n</code>.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-db5951fa33bbc1f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3 层"></p>
<p>递归 3 层，表达式变为 <code>8 * （T（n/8）)+ 3n</code>.</p>
<p>我们总结一下：</p>
<p>递归 2 层：<code>4（T（n/4）)+ 2n</code><br>递归 3 层：<code>8（T（n/8）)+ 3n</code><br>递归 4 层：<code>16（T（n/16）)+ 4n</code><br>······<br>递归 k 层：<code>2^k （T（n/2^k））+ kn</code></p>
<p>假设我们最终递归的结果是 1，那么：</p>
<p><code>T(n/2^k) = 1</code><br>·····反推 <code>  2^k = n</code><br>····· 那么 <code>   k = log2n</code></p>
<p>k 等于<code> log2N</code>，我们带入 k 到上面的公式：<code>2^k （T（n/2^k））+ kn</code>；</p>
<p>即 <code>n + log2n * n</code>；</p>
<p>使用大 O 表达式，去除常数，低阶，系数，递归的时间复杂度为 <code>O(nlogn)</code>;</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>关于递归树的推演，推荐观看一个视频，讲的很详细，地址：<a href="https://www.youtube.com/watch?v=bQi9BHCiusg">https://www.youtube.com/watch?v=bQi9BHCiusg</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2019/10/19/2019/1019-gb-sort/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g5jaqcvd8jj30tk0nitou.jpg" alt="image-20190731203119006"></p>
<p>分治是一种思路。</p>
<p>递归是一种技巧。</p>
<p>分治算法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归的求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>
<p>分治模式在每层递归时都有  3 个步骤：</p>
<ol>
<li>分解，分解原问题为子问题。这些子问题是原问题的规模较小的实例。</li>
<li>解决，递归的求解子问题。</li>
<li>合并。合并子问题的解为原问题的解。</li>
</ol>
<h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序完全遵循分治思想。操作如下：</p>
<ol>
<li>分解：分解待排序的 n 个元素，序列成剧透 2/n 个元素的 2 个子序列。</li>
<li>解决，使用归并排序，递归的排序 2 个子序列。</li>
<li>合并，合并两个子序列以产生已排序的答案。</li>
</ol>
<p>当待排序的序列长度为 1 时，递归开始“回升”，在这种情况下，不要做任何工作，因为长度为 1 的序列已经排好序了。</p>
<p>归并排序的关键 步骤，在于“合并”。</p>
<p>通常这个合并函数，叫做 merge。他的职责就是将  2 个有序的序列，合并成一个有序的序列。</p>
<p>如果是你，你怎么合并呢？</p>
<p><strong>思路</strong>：假设，现在有  1 个数组，被分成了 2 个有序的序列。我们可以新申请一个临时数组，将数据从最小的下标开始，依次比较，谁小，谁就放入到 临时 数组中，然后下次，下标递增，继续比较。</p>
<p>具体过程如下图：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g5jto0lecrj30ig0bfgm3.jpg" alt="image-20190801072624608"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 归并排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        sort(arr, start, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = p;</span><br><span class="line">        <span class="comment">// 这里必须 + 1, 以 q 作为分割点.</span></span><br><span class="line">        <span class="keyword">int</span> j = q + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r - i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= q &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">          	<span class="comment">// 保证排序算法稳定性</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                tmp[tmpIndex++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[tmpIndex++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = i;</span><br><span class="line">        <span class="keyword">int</span> end = q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &lt; r) &#123;</span><br><span class="line">            start = j;</span><br><span class="line">            end = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = start; k &lt;= end; k++) &#123;</span><br><span class="line">            tmp[tmpIndex++] = arr[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; tmpIndex; k++) &#123;</span><br><span class="line">            arr[p++] = tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>代码中，有 2 个函数：</p>
<p>$sort(int [] arr, int start, int end)$</p>
<p>$merge(int [] arr, int p, int q, int r)$</p>
<p>sort 函数用来分割数组，终止条件为，直到分割成只有一个元素（只有一个元素的序列，是不用排序的）。</p>
<p>merge 函数用来合并数组，例如，在递归树的最下层，一定是从 【0， 1】开始合并的，merge 函数会合并这两个下标的元素，变成有序的序列。</p>
<p>merge 函数的流程：</p>
<ol>
<li>创建 i j 下标 和 tmp 数组。</li>
<li>循环原数组，将 i 和 j 递增进行比较，并进行比较，然后把较小的值，依次放入到 tmp 数组中。</li>
<li>如果 i 或者 j 比较结束，就需要将未比较结束的，copy 到 tmp 数组中。</li>
<li>最后，将 tmp 数组的数据，copy 到原数组中。</li>
</ol>
<p>这样就完成了 归并排序 中，最为关键的合并。</p>
<p>从上面的代码中，也可以看到，最为核心的代码，就是 merge 函数。</p>
<h3 id="排序算法-三-问"><a href="#排序算法-三-问" class="headerlink" title="排序算法 三 问"></a>排序算法 三 问</h3><h4 id="1-是原地排序吗"><a href="#1-是原地排序吗" class="headerlink" title="1 是原地排序吗"></a>1 是原地排序吗</h4><p>答案，不是原地排序的。</p>
<p>在 <code>merge</code> 函数中，我们需要申请一个临时数组，将两个区间的元素逐个 copy 进临时数组中，这就不是原地的了。而 归并排序的空间复杂度，也因此比“原地排序” 的算法，要高。</p>
<p>多高呢？由于归并排序使用递归计算，每次只有一个函数在执行，同一时刻，只会申请一个临时数组，因此，如果申请的 大小 为 n 的数组，那么他的空间复杂度就是 $O(n)$.</p>
<h4 id="2-是稳定的吗"><a href="#2-是稳定的吗" class="headerlink" title="2 是稳定的吗"></a>2 是稳定的吗</h4><p>答案是稳定的（只要你实现的正确）。</p>
<p>假设两个数组中，有相同的两个元素，例如：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g5jult8acqj310e0b8aay.jpg" alt="image-20190801075855224"></p>
<p>上图中， i 和 j 的位置，元素都是5， 遇到这种情况，在算法中，我们可以先将左边的那个 5 拷贝到 tmp 数组中，然后再下次比较时，再将 右边的那个 5 ，拷贝到 tmp 数组中。</p>
<p>代码怎么写呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> （arr[i] &lt;= arr[j]）&#123;</span><br><span class="line">		tmp[index++] = arr[i++];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[j] &lt; arr[i])&#123;</span><br><span class="line">    tmp[index++] = arr[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，在 i 和 j 元素的比较中，$=$ 等于号，必不可少。如果没有等于号，那么，他将不是稳定的。 </p>
<h4 id="3-三种时间复杂度是多少"><a href="#3-三种时间复杂度是多少" class="headerlink" title="3 三种时间复杂度是多少"></a>3 三种时间复杂度是多少</h4><p>实质上，对归并排序的时间复杂度分析，就是对“分治算法’’ 的时间复杂度分析。</p>
<p>在《算法导论》 2.3.2 中，作者 告诉我们如何分析分治算法。</p>
<blockquote>
<p>当一个算法包含对其自身的递归调用时，我们往往可以用<strong>递归方程</strong>或<strong>递归式</strong>来描述其 运行时间。</p>
</blockquote>
<p>递归方程 或 递归式。</p>
<p>递归式：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g5jv59lo2bj30go03kjrk.jpg" alt="image-20190801081737393"></p>
<p>分治算法运行时间的递归式，来自其基本模式的三个步骤。</p>
<p>通过推演，我们可以知道，归并算法的时间复杂度 $O(nlogn)$ ，具体推演参见《递归时间复杂度 递归树 推演计算》。</p>
<p>另外，归并排序的时间复杂度，和原始数组是否有序没有关系，算法的最好，最坏，平均，时间复杂度都是  $O(nlogn)$ 。是一个非常稳定的排序算法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>归并排序，</p>
<p>分治算法。</p>
<p>非原地排序，空间复杂度 $O(n)$。</p>
<p>稳定性好。</p>
<p>所有情况下复杂度都为  $O(nlogn)$ ，</p>
<p>merge 函数为核心逻辑，临时数组 i j 拷贝。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Java 技术栈(Warning)</title>
    <url>/2019/10/19/2019/1019-java-stack/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h2 id="JVM-相关"><a href="#JVM-相关" class="headerlink" title="JVM 相关"></a>JVM 相关</h2><ol>
<li>运行时结构</li>
<li>GC 算法</li>
<li>JVM 调优</li>
<li>热部署、字节码</li>
</ol>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ol>
<li>数组，链表，栈，队列</li>
<li>二叉树、红黑树，完全二叉树、B+ 树</li>
<li>散列表、跳表、堆（优先级队列）</li>
<li>排序算法</li>
<li>查找和搜索</li>
<li>高级数据结构和算法</li>
</ol>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><ol>
<li>进程线程</li>
<li>内存</li>
<li>IO 磁盘，文件系统</li>
<li>CPU</li>
<li>网络</li>
</ol>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><ol>
<li>Java 内存模型</li>
<li>happen before</li>
<li>JDK 工具类、容器类，synchronize、volatile 原语</li>
<li>无锁编程</li>
</ol>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ol>
<li>netty</li>
<li>rocketmq、dubbo</li>
<li>apollo</li>
<li>redis</li>
<li>zk，eureka</li>
<li>springCloud</li>
</ol>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ol>
<li>cap、raft、zab、paxos</li>
<li>2pc，3pc，tcc、base</li>
<li>一致性 hash，负载均衡，数据分片</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>mysql </li>
<li>nosql( redis )</li>
</ol>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法要素</title>
    <url>/2019/10/19/2019/1019-sort-algorithm/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h2 id="几种排序算法"><a href="#几种排序算法" class="headerlink" title="几种排序算法"></a>几种排序算法</h2><p><img src="https://upload-images.jianshu.io/upload_images/18906978-e66e7a8550e0e069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>还有希尔排序，堆排序等。</p>
<p>当然还有其他冷门排序：猴子排序，睡眠排序，面条排序。</p>
<h2 id="如何分析一个排序算法？"><a href="#如何分析一个排序算法？" class="headerlink" title="如何分析一个排序算法？"></a>如何分析一个排序算法？</h2><h3 id="1-排序算法的执行效率——-时间复杂度要更精细"><a href="#1-排序算法的执行效率——-时间复杂度要更精细" class="headerlink" title="1. 排序算法的执行效率—— 时间复杂度要更精细"></a>1. 排序算法的执行效率—— 时间复杂度要更精细</h3><ul>
<li><code>最好情况、最坏情况、平均时间复杂度</code>，为什么要分析这么多种呢？因为数据的不同，算法的执行效果也不同。例如有点数据完全无序，有的数据接近有序。</li>
<li><code>时间复杂度的系数、常数、低阶</code>。我们知道，我们之前分析复杂度的时候，会忽略这 3 个元素，只需要知道 n 的趋势即可。但在实际的开发中，数据量可能很小，所以，之前忽略的这些常数，低阶，系数，我们也要考虑进去，这样就能进行更精确的对比。</li>
<li><code>比较次数和交换（移动）次数</code>，大部分排序算法基于比较和交换，我们分析排序算法效率 的时候，应该把比较次数和交换次数也考虑进去。</li>
</ul>
<h3 id="2-排序算法的内存消耗——-原地排序的重要性"><a href="#2-排序算法的内存消耗——-原地排序的重要性" class="headerlink" title="2. 排序算法的内存消耗—— 原地排序的重要性"></a>2. 排序算法的内存消耗—— 原地排序的重要性</h3><ul>
<li>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外，不过，针对排序算法的空间复杂度，我们通常有个 <strong>“原地排序”</strong> 的概念，表示 O1 空间复杂度——所谓原地排序算法。</li>
</ul>
<h3 id="3-排序算法的稳定性——-相等的数据前后位置不变"><a href="#3-排序算法的稳定性——-相等的数据前后位置不变" class="headerlink" title="3. 排序算法的稳定性—— 相等的数据前后位置不变"></a>3. 排序算法的稳定性—— 相等的数据前后位置不变</h3><ul>
<li>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的，针对排序算法，一个重要的指标是“稳定性”。<br>即如果待排序中的序列中存在值相同的元素，经过排序之后，相等元素之间的先后顺序不变。例子：一组数据有 时间戳属性 和 价格属性，我们需要既按照时间戳排序，又按照价格排序。我们可以先按照时间戳进行排序，然后按照价格进行排序。注意：如果价格相同，顺序不能变，否则时间戳就不对了！这就是排序算法稳定的重要性。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2019/10/19/2019/1019-insert-sort/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序，如果你打过扑克，你就会非常熟悉：当我们摸排的时候，第一张牌是 8，第二张牌如果是 7，我们会放在 8 的前面，否则会放到后面。插入排序和这个非常类似。</p>
<p>我们将数组中的元素，分成“已排序区间”和“未排序区间”。</p>
<p>刚开始的时候，已排序区间的个数是 1. 我们从  2 开始，从右往左进行比较，如果后面的较小，就进行交换，直到后面的数字比前面的数字大，就停止比较。</p>
<p>如下图所示：</p>
<p>在第四次比较中，我们将 1 这个元素，逐步移动到了最前面。</p>
<p>在第五次比较中，我们将 3 这个元素，逐步移动到了下标为 1（从 0 开始） 的这个位置。</p>
<p>…….</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g5iqv93zgfj30qm0n0dlf.jpg" alt="image-20190731090402490"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 插入排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果该数, 已经比前面的数字大了,就停止循环(因为是升序).</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; num) &#123;</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// + 1; 补偿最后 j--</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="排序算法三问"><a href="#排序算法三问" class="headerlink" title="排序算法三问"></a>排序算法三问</h2><h3 id="1-是原地排序算法吗？"><a href="#1-是原地排序算法吗？" class="headerlink" title="1. 是原地排序算法吗？"></a>1. 是原地排序算法吗？</h3><p>是的。</p>
<h3 id="2-是稳定的排序算法吗？"><a href="#2-是稳定的排序算法吗？" class="headerlink" title="2 是稳定的排序算法吗？"></a>2 是稳定的排序算法吗？</h3><p>只要代码实现时，不要把相等的元素进行调换，就是稳定的。</p>
<h3 id="2-时间复杂度是多少？"><a href="#2-时间复杂度是多少？" class="headerlink" title="2. 时间复杂度是多少？"></a>2. 时间复杂度是多少？</h3><p>最好时间复杂度，数组本身有序，啥也不干，$O(n)$.</p>
<p>最坏时间复杂度，全部逆序，$O(n^2)$.</p>
<p>平均时间复杂度，我们知道，往有序数组插入一条数据时间复杂度是 $O(n)$.，如果将整个半无序数组遍历一遍进行有序插入，那就是 $O(n^2)$.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法——冒泡排序</title>
    <url>/2019/10/19/2019/1019-sort-bb/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    


<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>大部分人学习排序的第一个算法，就是冒泡排序。    </p>
<p>简单来说，冒泡排序就是每次迭代，都会检查相邻的 2 个元素大小，如果左边比右边大，就交换顺序（升序），这样，第一轮下来，一定会把最大的那个值放到最右边。到第二轮的时候，也同样会把未排序的最大的数字，放到倒数第二的位置……..</p>
<p>第一轮排序，如下图：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g5i7nx3csyj30ex0cv769.jpg" alt="image-20190730215933710"></p>
<p>解释一下上图，左边是排序次数，一共 5 次。</p>
<p>从最下面开始冒泡，i 从 0 开始，每次比较 i 和 i + 1 的大小，如果 i 大，就把他俩进行交换，例如第一次比较中， i 比 i + 1 大，所以，在第二行，进行了交换。 同时，i 进行自增，继续重复上个过程。知道将最大的元素 9 放到最后一个格子，从而完成一轮排序。 </p>
<p>简单说，冒泡排序，每次都会找到最大的数字，然后将其放到最后的位置进行排序。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sort升序(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的代码中，我们使用 2 层循环，最内层循环比较 j 和 j + 1 的大小。从而实现上面的思路。</p>
<p>那么，代码还有优化空间吗？</p>
<p>答案是有的。</p>
<p>我们使用这样一组数据，进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，该数组基本有序。我们打印每次循环之后的数组的值，发现只要 4 次，就已经完成排序，后面的实际上就不需要继续执行了。</p>
<p>所以，如果进行优化的话，只要内部没发生调换事件，实际数组就是有序的了，就可以直接结束排序算法。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g5i7u1z40yj30ig09mt9v.jpg" alt="image-20190730220527753"></p>
<p>还可以继续优化吗？</p>
<p>我们的代码中，内循环条件每次都是 i &lt; arr.length. 需要吗？</p>
<p>答案是不需要。</p>
<p>因为，每次我们都能找到“未排序”分区中，最大的那个数字，并将其放到最右边正确的位置，所以，当每次冒泡结束，下次再循环时，最后面的那个格子，就不用再次进行比较了——因为他的位置已经是正确的。</p>
<p>所以，内层 for 循环的表达式，应该是 <code>j &lt; arr.length - i  - 1</code>;</p>
<p>结合两个优化，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sort升序(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 flag 控制是否还需要继续循环，例如当原始数据源本身就是升序的，那么，就可以在很少的冒泡次数下，完成排序，当有一次没有发生交换数据事件，表明排序已经完成，应当结束排序。</li>
<li>使用 <code>j &lt; arr.length - 1 - i</code> 进行优化，因为每次循环后，倒数第 i 个格子的数据，肯定是正确的，不需要再次进行比较，因此，可以过滤这个格子以及后面的格子。</li>
</ol>
<h2 id="日常三问"><a href="#日常三问" class="headerlink" title="日常三问"></a>日常三问</h2><h3 id="1-冒泡排序是原地排序算法吗？"><a href="#1-冒泡排序是原地排序算法吗？" class="headerlink" title="1. 冒泡排序是原地排序算法吗？"></a>1. 冒泡排序是原地排序算法吗？</h3><p>答案是的；冒泡排序在进行比较以及交换的操作中，并没有使用其他空间，空间复杂度是 1， 因此是一个原地排序算法。</p>
<h3 id="2-冒泡排序是稳定的排序算法吗？"><a href="#2-冒泡排序是稳定的排序算法吗？" class="headerlink" title="2 冒泡排序是稳定的排序算法吗？"></a>2 冒泡排序是稳定的排序算法吗？</h3><p>答案：看你的实现。</p>
<p>如果我们的比较是 <code>if（arr[j] &gt; arr[j+1]）</code>这么写的，那么就是稳定的，因为相等的两个数字，并没有进行交换，但是，如果加上了 = 号，就不是稳定的。</p>
<h3 id="2-冒泡排序的时间复杂度是多少？"><a href="#2-冒泡排序的时间复杂度是多少？" class="headerlink" title="2. 冒泡排序的时间复杂度是多少？"></a>2. 冒泡排序的时间复杂度是多少？</h3><p>时间复杂度， 3 个角度：最好，最差，平均。</p>
<p>最好，数据本身就是有序的，只要一遍，就能知道其是有序的，复杂度是 N。</p>
<p>最差，数据是逆序的，需要 n * n 次操作，复杂度是  n^2.</p>
<p>平均，之前我们知道，可以用概率论的方式，来进行平均时间复杂度的计算。还有另一种方式，就是“有序度”和“逆序度”这两个概念进行分析。</p>
<h3 id="有序度和逆序读"><a href="#有序度和逆序读" class="headerlink" title="有序度和逆序读"></a>有序度和逆序读</h3><p><strong>有序度</strong>是数组中具有<strong>有序关系</strong>的元素对的个数。 </p>
<p>例如数组 : <code>&#123;5, 1, 11, 2, 0, 6, 9, 4 &#125;</code>，具有“有序关系” 的元素有：</p>
<p>![image-20190730225029392](/Users/cxs/Library/Application Support/typora-user-images/image-20190730225029392.png)</p>
<p>可以看到，有 15 对数据是有序的。公式为<code>arr[i] &lt;= arr[j]  &amp;&amp;  i &lt; j​</code>.</p>
<p>那如果整个数组都是有序的，那有多少有序元素呢？</p>
<p>假设 5 个元素：$「1，2，3，4，5」$</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g5ohb6xizqj30d70eftc9.jpg" alt="image-20190805080645625"></p>
<p>有以上组合，公式为 <code>n(n - 1) / 2</code>.</p>
<p>数组 <code>&#123;5, 1, 11, 2, 0, 6, 9, 4 &#125;</code> 有 8 个元素，满有序度为 38 ，而实际有序度为  15，那么逆有序度为 38 - 15 = 17. 本质上，我们排序的过程，就是将逆有序的元素，变成有序的元素。即增加有序度，减少逆序度。</p>
<p>在最好情况下，有序度为 n*(n-1)/2，我们不需要任何操作。</p>
<p>在最好情况下，有序度为 0。我们要进行 n*(n-1)/2 次交换。</p>
<p>如果使用这种方式计算“平均时间复杂度”？</p>
<p>我们可以取一个数据有序度 不是很高，也不是很低的，例如 $n *\frac{ (n-1)} {4}$，来当做平均时间复杂度，可以看到，去去除低阶和系数，复杂度还是 $O(n^2)$，注意，这里只是交换操作，还有比较操作没算进去，因此，冒泡排序的时间复杂度就是  $O(n^2)$.</p>
<p>虽然这种方式不是很严格—— 相对于使用概率论。但很多时候还是挺实用的。（大话数据结构中，也是这么计算平均时间复杂度的。但如果要真正的计算的比较准确，需要对数据规律进行统计，然后使用概率进行计算）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2019/10/19/2019/1019-sort-quick/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>快排是排序算法中绕不开的关键一环，其中涉及到分治算法，二分查找等关键知识。</p>
<p>本文内容：</p>
<ol>
<li>快排原理</li>
<li>代码实现</li>
<li>分区过程图示</li>
<li>&lt;啊哈算法&gt; 中的另一种实现</li>
<li>复杂度</li>
<li>优化</li>
</ol>
<h2 id="快排原理"><a href="#快排原理" class="headerlink" title="快排原理"></a>快排原理</h2><p>快排也归并类似，也使用了分治的思想，即将原序列划分成 2 份，然后继续递归。但是他们的区别是：</p>
<p>归并的划分是简单的通过找中位下标进行，他的公式是 $mid = \frac {(low + high)}2$<br>快排的划分，是通过一个参考值，将每个数据和参考值比较，然后将划分成 2 份，左边的比参考值小，右边的比参考值大。他的公式是 ：$mid = partitin(A, low, high)$ ，通过一个 partition 函数，找到一个 mid 值。</p>
<p>在算法导论中，伪代码是这样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-977bdc264c691e02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>代码中，先使用 partition 函数，获取 mid 值，然后，将 2 个序列继续进行递归调用。</p>
<p>其中，partition 的关键函数如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-653feffa20d10ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>算法会设计两个指针 i 和 j，i 左边的数据表示已经排好序的元素，j 指针用来寻找比 参考值 x 小的 元素。如果 j 所在的元素比 x 小，就将 i 和 j 交换，并将 i 指针前进一步。最后，将 i 所在的元素和 x 进行互换，达到分区的目的。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> mid = partition(arr, low, high);</span><br><span class="line">     quickSort(arr, low, mid - <span class="number">1</span>);</span><br><span class="line">     quickSort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> x = arr[high];</span><br><span class="line">     <span class="keyword">int</span> i = low;</span><br><span class="line">     <span class="keyword">int</span> j = low;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (j &lt; high) &#123;</span><br><span class="line">         <span class="keyword">if</span> (arr[j] &lt;= x) &#123;</span><br><span class="line">             swap(arr, i++, j);</span><br><span class="line">         &#125;</span><br><span class="line">         j++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     swap(arr, i, high);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> I;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> tmp = arr[low];</span><br><span class="line">     arr[low] = arr[high];</span><br><span class="line">     arr[high] = tmp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，关键就是 parttion 函数，我们使用了 i 和 j 两个指针，每次 j 都会自增，如果 j 比 x 小，那么，就将 j 和 i 交换，同时 i 自增。目的就是让 i 左边的序列是有序的，j 和 i 之间不会存在比 x 小的元素。j 的作用是寻找比 x 下的元素，直到 j == hight。</p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p>假设我们现在有一个序列：</p>
<p>{2, 3, 1, 6, 9, 0 ,4, 8, 5}</p>
<p>排序过程是怎么样的呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-8b110bee422cb55f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>首先，参考值 x 是 5.</p>
<p>我们从最左边开始，和 x 比较。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-275c78e328732820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>左边的 2，3，1 元素，都比 5 小，直接跳过，i 和 j 指针同时进行。直到遇到 6 ，比 x 大，此时，i 停止，保证 i 左边的元素是有序的，j 继续寻找 比  x 小的元素。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-5ab7fa4df0d2e854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>j 找到了 0 这个元素，比 x 小，此时 i 还在 6 这个位置，因此，我们可以将 i 和 j 进行交换，并将 i 前进一位，使 i 左边的序列继续有序。j 继续向前扫描。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-cef36062fa6bb1e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>j 又找到了 4 个元素，比 x 小，算法重复上个步骤：将 i 和 j 交换，i 和 j 都前进一步。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-96861096b4fd95a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>现在 j 走到了尽头，此时我们需要将参考值 x 和 i 进行交换，使 x 左边比 x 小，x 右边 比 x 大，并返回 x 所在的下标。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-235a7d56ede3597a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>此时，完成了一次分区。</p>
<h2 id="lt-啊哈算法-gt-中的另一种实现"><a href="#lt-啊哈算法-gt-中的另一种实现" class="headerlink" title="&lt;啊哈算法&gt; 中的另一种实现"></a>&lt;啊哈算法&gt; 中的另一种实现</h2><p>在另一本算法普及书《啊哈算法》 中，也实现另一个快排，不过，和算法导论的有一点点区别，区别在于指针的开始阶段不同。</p>
<p>算法导论的指针，i 和 j 是从同一个方向开始的。<br>啊哈算法中的指针，i 总左边开始，j 从右边开始，两个指针相遇，就停止循环。</p>
<p>在我的电脑中进行测试，后者的性能，要比前者更好。</p>
<p>我们看看后者的分区过程是怎么样的。</p>
<p>现在我们有一个无序数组：</p>
<p>{2, 3, 1,6, 9, 0,4,8,5}</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-5d15706e3d8b5db8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>首先，参考值是 5，i 从左边开始，j 从右边开始，<strong>i 用于寻找比 pivot 大的元素，j 用于寻找比 pivot 小的元素，然后将 i 和 j 进行交换</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-4bf28bf6dac6c133.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上图中，i 为了找到 比 pivot 大的元素，走到了 6 的位置，j 为了找到比 pivot 小的元素，走到了 4 的位置，然后进行交换。然后，各自继续前进。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-af0d457b7f5a73bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>重复上次的操作，进行交换，并前进一步。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-9d8689014866e9aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>此时，i 和 j 相遇，停止循环，此时，需要将 pivot 和 i 进行交换，让 pivot 左边的比自身小，pivot 右边的，比自身大。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/18906978-f07661b4bf0c7df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>此时，完成了一次分区。</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head &gt;= tail || arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = head, j = tail, pivot = arr[tail - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; pivot) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qSort(arr, head, j);</span><br><span class="line">    qSort(arr, i, tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在我的电脑上，使用如下数据进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        arr[i] = ThreadLocalRandom.current().nextInt(<span class="number">90000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;time : &quot;</span> + (e - s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1k 万的数据，使用首尾指针，时间是 800ms 左右，使用前后指针，时间是 1100ms 左右。（归并的排序时间是 1300ms）。</p>
<p>个人认为，差距在于：前后指针，如果数据是的有序度是50%，那么 i 和 j 的指针会走 150% 次，而首尾指针则只会走100% 次。这个是常量级的时间损耗。</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>快排和归并一样，使用分治算法，但是他们时间复杂度并一样：<br>最好：$O(nlogn)$<br>最坏：$O(n^2)$<br>平均：$O(nlogn)$</p>
<p>空间复杂度，注意，虽然快排是原地排序，但是由于使用递归，递归本身就是栈，因此，递归的深度就是他的空间复杂度，而递归的深度就是 $O(logn)$，因此，他的空间复杂就是 $O(logn)$，不是 $O(1)$.</p>
<p>快排是稳定的排序算法吗？</p>
<p>答案：不是。</p>
<p>假设现在有一个序列：$6，8，7，6，3，5，9，4$</p>
<p>我们以 4 作为 pivot ，在第一次分区，进行交换后，6 和 3 的位置进行交换，此时， 两个 6 的位置就变化了，因此，快排不是稳定的排序算法。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>快排的优化，在于如何选取合适 的 pivot 。</p>
<p>为什么这么说。</p>
<p>如果快排的原始数据是接近有序的，那么，分区函数的性能将急剧下降，退化成 $O(n^2)$.</p>
<p>为什么？试想，我们每次选取的 pivot 都是最后一位，分区函数如果想找到正确的分区点，需要交换整个序列。如果想递归完成所有分区操作，则需要 n 次，而不是 logn 次。</p>
<p>而最好的状态就是，分区之后，两边的数据量是均等的。</p>
<p>那么，如何取 pivot 就很重要了。</p>
<p>通常有 2 种方式：</p>
<ol>
<li>随机数，从概率上来说，随机数，能够保证命中的概率是一致的。</li>
<li>3 个数字取中法。我们从首、尾、中，三个地方取出数字，取其中间值当做 pivot。如果数量量比较大，就需要 5 数取中，10 数取中等方法。</li>
</ol>
<p>另外，由于快排是使用递归的，因此，如果递归栈过深，可能导致堆栈溢出，因此，如果堆栈很深，可以手动模拟堆栈实现。防止堆栈溢出。归并也是同样的道理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快排的思想很优秀，使用了分治思想，原地排序。</p>
<p>但是他也有缺点。</p>
<ol>
<li>不是稳定的排序算法</li>
<li>如果数据本身有序度很高，那么，算法性能将急剧退化，需要使用优化策略处理。</li>
</ol>
<p>关于优化，很多排序函数不会仅仅只用一种算法。</p>
<p>例如：</p>
<p>在数据量很小的时候，使用归并排序，因为算法稳定，$O（n）$的空间复杂度问题也不大。</p>
<p>在数据量很大的时候，使用快排，取 pivot 时，进行优化，例如随机，3 数取中。</p>
<p>在序列元素很少时，使用插入排序，例如当递归到只有 4 个元素时，快排算法需要 12 次，而插入排序最多只需要 16 次，如果序列的有序度不那么差，插入排序会比快排性能要好。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2019/10/19/2019/1019-select-sort/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>核心思想：将数据分为 “未排序区间” 和 “已排序区间”，每次在“未排序区间”找到最小的元素，追加到已排序区间的末尾。</p>
<p>如下图所示：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g5j7unr12xj308l06f0tf.jpg"> </p>
<p>初始数组 「4，5，2，1，3」；</p>
<p>初始，未排序区间大小为 0， 从 0 开始，遍历数组，找到最小元素，放在 0 的位置。</p>
<p>第二次，从下标 1 开始，找最小的元素，放到 1 的位置。</p>
<p>…..</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 选择排序 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[index] &gt; arr[j]) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[index];</span><br><span class="line">            arr[index] = arr[i];</span><br><span class="line">            arr[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="排序三问"><a href="#排序三问" class="headerlink" title="排序三问"></a>排序三问</h2><h4 id="1-是原地排序吗"><a href="#1-是原地排序吗" class="headerlink" title="1 是原地排序吗"></a>1 是原地排序吗</h4><p>选择选择，顾名思义，就是每次选择最小的，然后追加到“已排序区间” 的末尾。没有使用其他的恐惧，所以，是原地排序算法。</p>
<h4 id="2-是稳定的排序吗"><a href="#2-是稳定的排序吗" class="headerlink" title="2 是稳定的排序吗"></a>2 是稳定的排序吗</h4><p>假设现在有一组数据 {2,3,2,4,5,1,0,7};</p>
<p>我们先将 0 和 1 放到了正确的位置，注意，第一个 2 的位置 和 第二个 2 的位置就变了，所以，就不稳定了。</p>
<p>正因为如此，选择排序，相对于冒泡和插入，显得不那么厉害了。</p>
<h4 id="3-种时间复杂度是多少？"><a href="#3-种时间复杂度是多少？" class="headerlink" title="3 种时间复杂度是多少？"></a>3 种时间复杂度是多少？</h4><p>最好时间复杂度，如果本身就是有序的，时间复杂度是 线性 On。</p>
<p>最坏时间复杂度，如果是满逆序的，时间 复杂度是指数级的，On^2.</p>
<p>平均时间复杂度，如果数据有序度为 <code>满有序度/2</code>， 时间复杂度是多少呢？我们看上面，可以知道，选择排序，每次都会找到一个最小的值，这次遍历可以认为是 On，n 次 On，就是 On^ ， 因此，他的时间复杂度是 On^2.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2019/10/19/2019/1019-sort-summary-final/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    


<p>算法复杂度：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g5pu9m2obaj30tm0hydo2.jpg" alt="image-20190806122034899"></p>
<p>快排的空间复杂度：O(logn)</p>
<p>归并的空间复杂度：O(n)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>3 种简单算法总结</title>
    <url>/2019/10/19/2019/1019-sort-summary/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h1 id="3-种简单算法总结"><a href="#3-种简单算法总结" class="headerlink" title="3 种简单算法总结"></a>3 种简单算法总结</h1><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g5j98kclgtj30tm0eg7da.jpg" alt="image-20190731193936927"></p>
<p>插入排序，在业务中，使用是最多的。其他 2 种排序，只是用来涨涨见识而已。</p>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>都分为 有序区间 和 非有序区间。</p>
<p>例如，在冒泡排序中，我们每次，都会找到最大的数字，将其放到最右边（右边已经排序好了）。</p>
<p>在插入排序中，我们每次都将 i 的值，放到对应的位置（左边已经排序好了）。</p>
<p>在选择排序中，我们每次追加的，都是最小的值，左边都是有序的。右边都是无序的。</p>
<p>他们的时间复杂度都是 On^2; 且他们都是原地排序。</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>关于稳定性，选择排序不是稳定的（当第一位的元素是重复的时候，改元素会被换到后面去）。</p>
<p>冒泡和插入都是有序的。</p>
<p>同时，在冒泡和插入的选择上，虽然时间复杂度都是 On^2, 但是，我们通常会使用插入排序，因为他的交换操作只有 一步，而冒泡有 3 步。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>线性排序</title>
    <url>/2019/10/19/2019/1019-sort-xianxing/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h1 id="线性排序"><a href="#线性排序" class="headerlink" title="线性排序"></a>线性排序</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ol>
<li>桶排序（借助快排）</li>
<li>计数排序（借助数组下标）</li>
<li>基数排序（借鉴“稳定排序”思路）</li>
</ol>
<h5 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h5><p>算法复杂度：$O(n)$</p>
<p>对数据要求苛刻。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>解释：</p>
<p>假设要按照 100w 用户的年龄进行排序。年龄设置最大 120 岁。设置 12 个桶，第一个桶里，放 0-10岁的用户，第二个桶里，放 11 -20岁的用户，依次类推。</p>
<p>遍历所有数据，将用户按照年龄放到对应的桶里。然后对每个桶，进行快速排序。</p>
<p>复杂度：</p>
<p>假设有 n 个数据，m 个桶，每个桶里是 k 个数据。</p>
<p>那么每个桶的复杂度就是 k * logk。所有桶的复杂度就是 m * k * logk。</p>
<p>因为 k = n/m，代入之后，n/m * m * logk = n * logk。</p>
<p>如果 m 接近 n，那么 k 的值就会很小，那么 logk 也就很小，所以他时间复杂度是 $O(n)$.</p>
<p>关键字：有序桶，快排。</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是桶排序的一种特殊情况。</p>
<p>假设：现在，我们要给 120 个学生的分数进行排序，分数是 0 - 100；如何在 $O(n)$ 的时间复杂度里，实现按照分数排序？</p>
<p>我们可以设计一个长度为 101 的数组，数组下标对应 0-100 分值，数组内容记录每个分值的人数即可。</p>
<p>计数排序的 “计数” 的意思是，记住每个槽位记录的是重复值的数量。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g5ptocmxigj30p108iaax.jpg" alt="image-20190806120007283"></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>如下图，有 5 行数据，每个数据由 3 个字母组成，我们可以认为是电话号码。</p>
<p>我们第一次比较这 5 行数据的最后一位，并对他们整体进行排序。</p>
<p>第二次比较这 5 行数据的第二位，并对他们 整体进行排序。</p>
<p>第三次比较这 5行数据的第一位，并对他们整体进行排序。</p>
<p>注意：基数排序，每次排序必须都是稳定的，如果不是稳定的，那么上次的排序将失去价值。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g5ptpapjwsj30ba05m74y.jpg" alt="image-20190806120104131"></p>
<p>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 $O(n)$ 了;</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>如何编写一个 SendFile 服务器和客户端</title>
    <url>/2019/10/29/2019/1029-SF/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>     


<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前讨论零拷贝的时候，我们知道，两台机器之间传输文件，最快的方式就是 send file，众所周知，在 Java 中，该技术对应的则是 FileChannel 类的 transferTo 和 transferFrom 方法。</p>
<p>在平时使用服务器的时候，比如 nginx ，tomcat ，都有 send file 的选项，利用此技术，可大大提高文件传输效能。</p>
<p>另外，可能也有人谈论 send file 的缺点，例如不能利用 gzip 压缩，不能加密。这里本文不做探讨。</p>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
<p>那么，如何使用这两个 api 实现一个 send file 服务器和客户端呢？</p>
<p>想象一下，你写的 send file 服务器利用 send file 技术，利用万兆网卡，从各个 client 端 copy 海量文件，瞬间打爆你那 1TB 的磁盘和 48核的 CPU。并且，注意：只需很小的 JVM  内存就可以实现这样一台强悍的服务器。为什么？如果你知道 send file 的原理，就会知道，使用 send file 技术时， 在用户态中，是不需要多少内存的，数据都在内核态。</p>
<p>是不是很有成就感？什么？没有？那打扰了 🤣。</p>
<p>另外，关于 send file，我们都知道，由于是直接从内核缓冲区进入到网卡驱动，我们几乎可以称之为 “零拷贝”，他的性能十分强劲。</p>
<p>但是。</p>
<p>除了这个，还有其他的吗？答案是有的，send file 利用 DMA 的方式 copy 数据，而不是利用 CPU。注意，不利用 CPU 意味着什么？意味着数据不会进入“缓存行”，进一步，不会进入缓存行，代表着缓存行不会因为这个被污染，再进一步，就是不需要维护缓存一致性。</p>
<p>还记得我们因为这个特性搞的那些关于 “伪共享” 的各种黑科技吗？是不是又学到了一点呢？😎</p>
<h1 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h1><p>作为一个纯粹的，高尚的，有趣的 sendFile 服务器或者客户端，使用场景是嵌入到某个服务中，或者某个中间件中，不需要搞成夸张的容器。我们可以借鉴一下，客户端可以做成 Jedis 那样的，如果你想搞个连接池也不是不可以，但 client 自身实例，还是单连接的。服务端可以做成 sun 的 httpServer 那种轻量的，随时启动，随时关闭。</p>
<p>同时， 支持 oneway 的高性能发送，因为，只要机器不宕机，发送到网卡就意味着发送成功，这样能大幅提高发送速度，减少客户端阻塞时间。</p>
<p>另外，也支持带有 ack 的稳定发送，即只有返回 ack 了，才能确认数据已经写到目标服务器磁盘了。</p>
<p>server 端支持海量连接，必须得是  reactor 网络模型，但我们不想在这么小的组件里用 netty，太重了，还容易和使用方有 jar 冲突。所以，我们可以利用 Java 的 selector + nio 自己实现 Reactor 模型。</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h3 id="IO-模型设计"><a href="#IO-模型设计" class="headerlink" title="IO 模型设计"></a>IO 模型设计</h3><p>设计图：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8esdrp8fhj30zr0u00u2.jpg"></p>
<p>如上图，Server 端支持海量客户端连接。</p>
<p>server 端含有 多个处理器，其中包括 accept 处理器，read 处理器 group， write 处理器 group。</p>
<p>accept 处理器将 serverSocketChannel 作为 key 注册到一个单独的 selector 上。专门用于监听 accept 事件。类似 netty 的 boss 线程。</p>
<p>当 accept 处理器成功连接了一个 socket 时，会随机将其交给一个 readProcessor（netty worker 线程？） 处理器，readProcessor 又会将其注册到 readSelector 上，当发生 read 事件时，readProcessor 将接受数据。</p>
<p>可以看到，readProcessor 可以认为是一个多路复用的线程，利用 selector 的能力，他高效的管理着多个 socket。</p>
<p>readProcessor 在读到数据后，会将其写入到磁盘中（DMA 的方式，性能炸裂）。</p>
<p>然后，如果 client 在 RPC 协议中声明“需要回复（id 不为 -1）” 时，那就将结果发送到 Reply Queue 中，反之不必。</p>
<p>当结果发送到  Reply Queue 后，writer 组中的 写线程，则会从 Queue 中拉取回复包，然后将结果按照 RPC 协议，写回到 client socket 中。</p>
<p>client socket 也会监听着 read 事件，注意：client 是不需要 select 的，因为没必要，selector 只是性能优化的一种方式——即一个线程管理海量连接，如果没有 select， 应用层无法用较低的成本处理海量连接，注意，不是不能处理，只是不能高效处理。</p>
<p>回过来，当 client socket  得到 server 的数据包，会进行解码反序列化，并唤醒阻塞在客户端的线程。从而完成一次调用。</p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>设计图：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8etjmkuejj30vv0u0wg2.jpg" alt="image-20191029093524267"></p>
<p>如上图所示。</p>
<h4 id="在-client-端："><a href="#在-client-端：" class="headerlink" title="在 client 端："></a>在 client 端：</h4><p> 每个 Client 实例，维护一个 TCP 连接。该 Client 的写入方法是线程安全的。</p>
<p>当用户并发写入时，可并发写的同时并发回复，因为写和回复是异步的（此时可能会出现，线程 A 先 send ，线程 B 后 send，但由于网络延迟，B 先返回）。</p>
<h4 id="在-server-端："><a href="#在-server-端：" class="headerlink" title="在 server 端："></a>在 server 端：</h4><p>server 端维护着一个 ServerSocketChannel 实例，该实例的作用就是接收 accep 事件，且由一个线程维护这个 accept selector 。</p>
<p>当有新的 client 连接事件时，accept selector 就将这个连接“交给“ read 线程（默认 server 有 4 个 read 线程）。</p>
<h4 id="什么是“交给”？"><a href="#什么是“交给”？" class="headerlink" title="什么是“交给”？"></a>什么是“交给”？</h4><p>注意：每个 read 线程都维护着一个单独的 selector。 4 个 read 线程，就维护了 4 个 selector。</p>
<p>当 accept 得到新的客户端连接时，先从 4 个read 线程组里 get 一个线程，然后将这个 客户端连接 作为 key 注册到这个线程所对应的 read selector 上。从而将这个 Socket “交给” read 线程。</p>
<p>而这个 read 线程则使用这个 selector 轮询事件，如果 socket 可读，那么就进行读，读完之后，利用 DMA 写进磁盘。</p>
<h1 id="RPC-协议"><a href="#RPC-协议" class="headerlink" title="RPC 协议"></a>RPC 协议</h1><h4 id="Server-RPC-回复包协议"><a href="#Server-RPC-回复包协议" class="headerlink" title="Server RPC 回复包协议"></a>Server RPC 回复包协议</h4><table>
<thead>
<tr>
<th>字段名称</th>
<th>字段长度(byte)</th>
<th>字段作用</th>
</tr>
</thead>
<tbody><tr>
<td>magic_num</td>
<td>4</td>
<td>魔数校验，fast fail</td>
</tr>
<tr>
<td>version</td>
<td>1</td>
<td>rpc 协议版本</td>
</tr>
<tr>
<td>id</td>
<td>8</td>
<td>Request id， TCP 多路复用 id</td>
</tr>
<tr>
<td>length</td>
<td>8</td>
<td>rpc 实际消息内容的长度</td>
</tr>
<tr>
<td>Content</td>
<td>length</td>
<td>rpc 实际消息内容(JSON 序列化协议)</td>
</tr>
</tbody></table>
<h4 id="Client-RPC-发送包协议"><a href="#Client-RPC-发送包协议" class="headerlink" title="Client RPC 发送包协议"></a>Client RPC 发送包协议</h4><table>
<thead>
<tr>
<th>字段名称</th>
<th>字段长度(byte)</th>
<th>字段作用</th>
</tr>
</thead>
<tbody><tr>
<td>magic_num</td>
<td>4</td>
<td>魔数校验，fast fail</td>
</tr>
<tr>
<td>id</td>
<td>8</td>
<td>Request id， TCP 多路复用 id, 默认 -1，表示不回复</td>
</tr>
<tr>
<td>nameContent</td>
<td>2</td>
<td>Request id， TCP 多路复用 id</td>
</tr>
<tr>
<td>bodyLength</td>
<td>8</td>
<td>rpc 实际消息内容的长度</td>
</tr>
<tr>
<td>nameContent</td>
<td>bodyLength</td>
<td>文件名 UTF-8 数组</td>
</tr>
</tbody></table>
<p>为什么 发送包和返回包协议不同？为了高效。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>注意：这是一个能用的，性能不错的，轻量的 SendFile 服务器实现，本地测试时， IO写盘达到  824MB/S，4c 4.2g inter i7 CPU 满载。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8exv1xxa5j30gg0bk0ux.jpg" alt="image-20191029120446781"></p>
<p>代码地址：<a href="https://github.com/stateIs0/send_file">https://github.com/stateIs0/send_file</a></p>
<p>同时，欢迎大家 star， pr，issue。我来改进。</p>
]]></content>
      <categories>
        <category>Java 性能优化</category>
        <category>my open source</category>
      </categories>
  </entry>
  <entry>
    <title>Java sendFile 底层实现</title>
    <url>/2019/10/30/2019/1030SFimpl/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>     

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java send file api 是 transferTo 方法和 transferFrom 方法。</p>
<p>注意：send file 是一个从磁盘到网卡驱动的 IO 优化。反过来，网卡到磁盘，是没有这个 IO 优化的。也就是说 transferFrom 方法并没有这种福利。</p>
<p>本文将稍稍深入，看看 Java 如何实现，注意，本文代码版本为 <code>openjdk-8u40-src-b25-10_feb_2015</code>。</p>
<h2 id="transferFrom-解析"><a href="#transferFrom-解析" class="headerlink" title="transferFrom 解析"></a>transferFrom 解析</h2><p>那么 transferFrom 底层是什么呢？简单说，就是使用了 MMAP 和 堆外内存而已。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8g3796qabj31120oodka.jpg" alt="image"></p>
<p>上面的 transferFrom 方法代码中：</p>
<p>如果是普通 FileChannel 的话，就走 mmap，否则，走堆外内存，例如我们本次使用的 SocketChannelImpl。</p>
<h5 id="transferFrom-by-mmap-细节："><a href="#transferFrom-by-mmap-细节：" class="headerlink" title="transferFrom by  mmap 细节："></a>transferFrom by  mmap 细节：</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8g3e4efmqj30u00u8ahe.jpg" alt="image"></p>
<p>简单来讲，在一个循环中，每次就是将 源文件根据 position 映射为一个 mmap，最大 8M，逐次的将数据写入的目标文件中。</p>
<h5 id="transferFrom-by-堆外内存细节："><a href="#transferFrom-by-堆外内存细节：" class="headerlink" title="transferFrom by  堆外内存细节："></a>transferFrom by  堆外内存细节：</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gcbffawpj30u0100gss.jpg" alt="image"></p>
<p>从上面的代码可知，</p>
<p>如果我们使用的是 SocketChannelImpl ，就会走堆外内存，也是在一个循环里进行写入，每次最大 8k。用完尽量进行回收，不是释放。</p>
<p>其中，获取堆外内存的方法：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gcf9j202j31jk0o2af0.jpg" alt="image"></p>
<p>这个 bufferCache  是一个 ThreadLocal， 如下图所示 ，线程安全。类 netty 内存设计。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gcfr7ad8j30tw0beabn.jpg" alt="image"></p>
<p>注意 ，这个 bufferCache  是 sun 写的一个简单版本的 基于直接内存的 Cache，是一个简单的内存池实现。内部是个数组，默认大小 16。get 方法的 key 是 size，即，如果数组中，有 capacity 超过 size ，就返回这个 buffer。</p>
<p>16 的来源是 JVM 底层实现，具体位置：IOUtil.c 140 line。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg3bnv2fj30uy0a4dh8.jpg" alt="image"></p>
<p>现在，假设这个 cache 有16 个槽位，内部现在有 14 个 ByteBuffer，此时 count 是 14。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg53h2qdj31wq0l4t9t.jpg" alt="image"></p>
<p>start 指针指向头部，执行 get 方法，此时我们从 start 开始进行遍历，找到了下标位于 i 的元素，因为他的 capacity 比给定的 size 大。我们需要拿出这个元素。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg62ia85j31wy0iw0to.jpg" alt="image"></p>
<p>此时 count 需要减去1，变成 13，同时，将头部的 start 元素移动到刚刚空出的位置。</p>
<p>注意，同时我们还需要将 start 指针放置于头部位置：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg7deu1wj31ue0jqgml.jpg" alt="image"></p>
<p>执行 <code>start = (start + 1) % 16</code>, 下次再次get 的时候，还是从头部开始。为什么这么做？为了避免无谓的遍历，当遇到空元素时，就直接 return 就好了。</p>
<p>具体参见代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer bb = buffers[i]; </span><br><span class="line"><span class="keyword">if</span> (bb == <span class="keyword">null</span>)<span class="comment">// 避免无谓循环</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>当用完这个 ByteBuf 之后，就需要进行归还————如果 cache 里还有空余空间，即 count &lt; 16。</p>
<p>如何归还？</p>
<p>有个 <code>Util.releaseTemporaryDirectBuffer(bb)</code>方法， 该方法用于归还内存，注意：如果内存池满了，就调用 free 方法进行内存释放。</p>
<p>最终调用 offerFirstTemporaryDirectBuffer 方法。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ggehker6j30z009wgmz.jpg" alt="image"></p>
<p>如果添加进缓存池失败，就 free，添加缓存池的逻辑：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ggfmpktrj31460coq4h.jpg" alt="image"></p>
<p>释放逻辑，简单来说，就是调用 unsafe 的 freeMemory 方法</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ggi2atiyj30t60b8dhb.jpg" alt="image"></p>
<p>限于篇幅，下次再说，还涉及到一些虚引用的内容。</p>
<h3 id="transferFrom-方法小结"><a href="#transferFrom-方法小结" class="headerlink" title="transferFrom 方法小结"></a>transferFrom 方法小结</h3><ol>
<li>如果是源是 FileChannelImpl 类型， 就走 mmap ，循环映射 8MB 刷进磁盘。</li>
<li>如果源是 SocketChannelImpl 类型，就走堆外内存。简单来说，就是循环放进堆外内存，每次 8kb 刷进磁盘。注意：关于这个堆外内存，是用到了缓存池子的（堆外内存池化是常用优化手段），这个池子是个数组，长度是 16，使用 ThreadLocal 提升性能，每次获取，只要目标数组比池子中的 ByteBuffer 的 capacity 小即可使用，用完就还，如果满了，就调用 unsafe 释放。</li>
</ol>
<h2 id="transferTo-解析"><a href="#transferTo-解析" class="headerlink" title="transferTo  解析"></a>transferTo  解析</h2><p>transferTo 方法很有意思，先简单说下结论：</p>
<ol>
<li>如果 OS 支持 send file（windows 不支持），就执行 system call。</li>
<li>如果 OS 不支持，就走 mmap。</li>
<li>如果 mmap 失败，就走 堆外内存。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ggz1vruzj314d0u0gui.jpg" alt="image"></p>
<p>代码如上。</p>
<p>注意：如果内核无法执行，返回 -2。在 jvm 代码中看到，apple ，linux，solaris,  还有 IBM 的 AIX 都支持 send file。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gh8oqf7gj31860pw0x0.jpg" alt="image"></p>
<p>以上代码位置：FileChannelImpl.c 156 line。</p>
<p>如何使用 mmap 写进网卡？和 transferFrom 类似，每次最大映射 8Mb 内存，刷进网卡。每次用完之后 clean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unmap</span><span class="params">(MappedByteBuffer bb)</span> </span>&#123;</span><br><span class="line">  Cleaner cl = ((DirectBuffer)bb).cleaner();</span><br><span class="line">  <span class="keyword">if</span> (cl != <span class="keyword">null</span>)</span><br><span class="line">    cl.clean();</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>



<p>如何使用直接内存？也和 transferFrom 类似，每次最大使用 8kb，循环刷进网卡。这里就补贴代码了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了 send file 的 Java 层面实现，这里总结一下，只有 transferTo 用到了 send file，而且还是有条件的，具体，本文第二部分已经给出。</p>
<p>而 transferFrom 方法则是很普通的使用 mmap 或者 堆外内存，似乎我们有可以自己实现，反而性能可能会更好，例如我们使用更大的缓存，而不必循环多次，我们可以使用更大的 mmap 映射，而不是 8Mb，每次都需要 clean 再重新 mapping。</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>Java 性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>Raft 总结思维导图</title>
    <url>/2019/11/01/2019/1101raft-xmind/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ilnfwle2j30u019ab29.jpg"></p>
<h2 id="XMind-源文件"><a href="#XMind-源文件" class="headerlink" title="XMind 源文件"></a>XMind 源文件</h2><p><a href="https://github.com/stateIs0/api/blob/master/api-source/Raft.xmind">https://github.com/stateIs0/api/blob/master/api-source/Raft.xmind</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ 线程模型分析</title>
    <url>/2019/11/13/2019/1113mqThreadModel/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RocketMQ 是个消息服务器，也是个网络服务器。</p>
<p>本文，将从网络 IO 模型，线程模型，看看 RocketMQ 是如何设计的。</p>
<h2 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h2><p>IO 模型这块其实没什么好说的，这里稍微展开一下。</p>
<p>RocketMQ 使用了 Netty 作为网络通信框架，自然而然使用了 Ractor 模型，或者说 Select 模型、Epoll 模型。即一个线程管理 N 个 Socket 的模式，此模式可管理海量连接，基本是所有网络服务器的首选。</p>
<p>在这里，我们可以确定，RocketMQ 的 Boss 线程数为 1， Worker 线程数为  CPU * 2.</p>
<p>在说线程模型之前，先看看 RocketMQ 如何设计 Server 接口的。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w3f1dv62j318o0u0k6v.jpg"></p>
<p>如上：</p>
<p>RemotingService 作为顶层接口，定义了 启动和关闭，另外还有注册 RPC 钩子，职责简单。他的两个子接口 RemotingServer 和 RemotingClient 各自增加了自己的抽象接口。</p>
<p>例如 Server 专属的 localListenPort 和 getProcessorPair ，Client 专属的 getNameServerAddressList 等。注意：两者都有 invokeSync  方法，但，参数不同，这也是因为他们自身的角色不同所影响的。</p>
<p>至于 NettyRemotingAbstract 抽象类，本人认为这只是个简单的”抽取重复代码”的“简单操作”。</p>
<p>再下面，就是具体实现类。每个类，都有内部类，都是 Netty 各种 Handler 的实现：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w3qxzke7j31z60iognl.jpg" alt="-"></p>
<p>我们关注黄色框里的东西，</p>
<p>NettyConnectManageHandler 负责处理 注册，连接，异常等事件，继承自 ChannelDuplexHandler。</p>
<p>NettyServerHandler 则是关键的业务处理类，处理真正的 Msg，继承自 SimpleChannelInboundHandler<RemotingCommand>。</p>
<p>HandshakeHandler 负责处理握手程序，这里就不解释了。</p>
<p>以上 3 个是 Server 端的 Handler。都是 NettyRemotingServer 的内部类。Client 端暂时不表。</p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>NettyServerHandler 作为处理业务的关键类，每个 worker 线程都有自己的单独实例，但该类只是做个包装或者桥接而已，作用不大， NettyRemotingServer 才是关键。</p>
<p>当 Request 进入到 Server 中，MQ 会根据 请求类型 code 找到对应的处理器，MQ 有多种处理器，如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w41z2xmoj31ry0tgad8.jpg" alt="-"></p>
<p>他们都继承自 NettyRequestProcessor 接口：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w42sgud4j30zg07qdgd.jpg" alt="-"></p>
<p>此接口只有 2 个方法，处理请求和拒绝请求，处理请求的参数是 Nettty 的 context 和自身的RemotingCommand 对象，这是个大对象：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w455pdxvj30qg0kqdhl.jpg" alt="-"></p>
<p>以上，是 RemotingCommand 的成员变量，这里说下 flag 的作用，其他就不说了。</p>
<p>flag 表示这次请求是什么类型。</p>
<p>倒数第一位，0 表示请求，1 表示返回。</p>
<p>倒数第二位，1 表示 oneWay。</p>
<p>扯远了。</p>
<p>刚刚提到 NettyRequestProcessor ，这是个处理器，在 MQ 中，每个 NettyRequestProcessor 都绑定了一个线程池，在 MQ 的抽象里，有个 Pair 对象，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T1 object1;</span><br><span class="line">    <span class="keyword">private</span> T2 object2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T1 object1, T2 object2)</span> </span>&#123; <span class="keyword">this</span>.object1 = object1; </span><br><span class="line">                                         <span class="keyword">this</span>.object2 = object2;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T1 <span class="title">getObject1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> object1;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObject1</span><span class="params">(T1 object1)</span> </span>&#123;<span class="keyword">this</span>.object1 = object1; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T2 <span class="title">getObject2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> object2;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObject2</span><span class="params">(T2 object2)</span> </span>&#123;  <span class="keyword">this</span>.object2 = object2;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同时，还有个 Hash 表，用 code 映射了 Pair。如此，就实现了：通过请求 code 找到“线程池和处理这种请求的处理器”，然后，提交一个任务到该线程池，任务中，会调用该处理器的 processRequest 方法，或 rejectRequest 方法。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w4k122i9j319a0u0qc6.jpg" alt="-"></p>
<p>上图中，为处理请求的关键步骤。执行钩子就不说了，我们知道，设计代码时，关键步骤都加钩子，便于扩展和以后加代码。</p>
<p>其中，会调用 processRequest 方法，执行具体业务，并得到返回值。然后使用 netty 的 ctx 对象，将返回值直接写回 Socket。</p>
<p>如果发生错误了，也将错误构造成消息，写回客户端。</p>
<p>注意，这里一直有个操作 就是 response.setOpaque(opaque)  ，就是设置请求 ID，这是 IO 多路复用的关键。</p>
<p>这里我们梳理一下，Netty 每次请求，都会调用 NettyRemotingServer 的 processRequestCommand 方法。</p>
<p>而 NettyRemotingServer 保存了请求 code 和 Pair&lt;处理器，线程池&gt; 的hash 映射表。</p>
<p>每次请求，根据 code 找到线程池，生成一个新任务，提交到线程池，任务里，会执行“处理器” 的processRequest 方法得到返回值，最后写回客户端。</p>
<p>MQ 为每种类型的任务，使用了不同的线程池，即线程池隔离。同时，也根据每种不同的任务类型，设置了不同的线程池参数。</p>
<p>例如：</p>
<p>Send  发送消息任务，线程池大小是1。</p>
<p>pull 拉取消息任务，线程池大小是 16 + CPU*2</p>
<p>query 查询任务，线程池大小是 8 + CPU*2；</p>
<p>当然还有其他的，这里就不枚举了，注意：大部分线程池都是多线程，只有 send 任务默认是单线程。</p>
<p>你猜是为什么呢？</p>
<p>send 操作是个写操作，最后是要上锁的，虽然锁的粒度已经足够小，但仍然是有锁的。如果是有锁的，多线程的是不划算的。这也是 RocketMQ  的设计决定的———— 只写一个 CommitLog。</p>
<p>假设，能像 Kafka 一样，同时写多个文件，是不是就可以利用多线程了呢？</p>
<p>当然，这里不是说多线程一定好，只是表达另外一种思路。如果单线程就能触发 MQ 瓶颈，多线程也没啥意义。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>千万句，汇成一幅图：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w5nvqx46j31af0u0djs.jpg" alt="-"></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ 和 Kafka 索引设计比较</title>
    <url>/2019/11/15/2019/1115/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>索引，是存储设计的关键，一个好的索引，应该能够在最短的时间里，找到你想要的数据，同时，还能尽量少的使用内存或磁盘空间。</p>
<p>今天不谈 MySQL 或者 NoSQL 这些数据库索引，谈谈相对而言较为简单的 MQ 索引。通过研究 MQ 的索引，看看他们为何如此设计，我们又有哪些借鉴之处。</p>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>RocketMQ 的数据文件属于混合存储，即，所有的 topic 数据都放在一个文件里，因此，读数据的时候，就无法做到连续读了，只能随机读，所以 RocketMQ 推荐使用大内存，利用 PageCache 预读机制把 commitlog 数据缓存起来，而混合存储的好处则是能够承受万级别的队列数量。</p>
<p>下图为阿里云某篇文章对 RocketMQ 和 kafka 进行的“不同数量 topic 对性能的影响”测试，每个 topic 都是  8 个 queue 或者 8 个 partition。文章测试结果如下：</p>
<p><img src="http://q0zlvq28b.bkt.clouddn.com/2019-11-15-014119.png"></p>
<p><img src="http://q0zlvq28b.bkt.clouddn.com/2019-11-15-014411.png" alt="-"></p>
<p>文章地址：<a href="http://jm.taobao.org/2016/04/07/kafka-vs-rocketmq-topic-amout/">http://jm.taobao.org/2016/04/07/kafka-vs-rocketmq-topic-amout/</a></p>
<p>怎么说呢？很强。</p>
<p>当然，华为云的老哥也做了一些回应：<a href="https://bbs.huaweicloud.com/blogs/113911">https://bbs.huaweicloud.com/blogs/113911</a></p>
<p>华为老哥表示 kafka 64 分区有些夸张，单机单磁盘 1000 分区还是没啥问题的（最好别超过 2000）。</p>
<p>这不是说索引的，跑偏了。回来。</p>
<p>RocketMQ 提供基于 MsgID 搜索消息的方案，即，每条消息，都有一个唯一的 ID，ID 由 broker IP + Port + CommitLog    Offset 组成，通过这两个参数，可快速定位到一条消息。注意，Kafka 是没有这个功能的，但理论上，通过 Kafka 的 offset 也是可以找到具体的消息的，下面会详细说。</p>
<p>另外 RocketMQ 有 2 种索引。</p>
<ol>
<li>消息消费索引</li>
<li>Hash 查询索引</li>
</ol>
<h4 id="消息消费索引"><a href="#消息消费索引" class="headerlink" title="消息消费索引"></a>消息消费索引</h4><p>消息消费索引，可以理解为，就是 topic 的索引数据，类似 kafka 的索引数据。如果没有这个，消费者基本就找不到消息了。这个索引里，存放着对应 topic 、对应 queue 里的消息连续 offset 集合（不像 commitLog 是混合存储的）。</p>
<p>下图为 RocketMQ 的存储设计图：</p>
<p><img src="http://q0zlvq28b.bkt.clouddn.com/2019-11-15-014426.png" alt="image-"></p>
<p>如图：消息被不停的 append 到 commitlog，然后，再构建<code>消费索引</code>，如果没有这个索引，consumer 要在 commitlog 里消费消息，那可真是太难了（慢慢遍历？）。</p>
<p><img src="http://q0zlvq28b.bkt.clouddn.com/2019-11-15-014436.png" alt="image-"></p>
<p>每个 consumerQueue 文件里存放着 3ow 个元素，每个元素 20 字节，8 字节 offset ，4 字节 size， 8 字节 tag hashcode，因此，每个文件也就 5.8MB 不到，很轻量。</p>
<h4 id="Hash-查询索引"><a href="#Hash-查询索引" class="headerlink" title="Hash 查询索引"></a>Hash 查询索引</h4><p>Hash 查询索引，主要是根据 Key 来快速查询消息，属于一种附加功能。RocketMQ 采用了 Java HashMap 的思想，实现了 Hash 索引的存储。</p>
<p>Hash 索引结果如下图：</p>
<p><img src="http://q0zlvq28b.bkt.clouddn.com/2019-11-15-014448.png"></p>
<p>这里我直接使用了 RocketMQ PDF 文档里的图，从图中可以看出，这个 Map 有 500w 个 slot，每个 slot 的链表长度为 4. 如果我们使用一个  key 进行消息查找，他的过程是这样的：先 hash key 得到 hashCode，然后对 5oow 取余，找到槽位，这个槽位大小是 4 个字节，保存了链表尾部的具体元素地址。而这个链表元素的大小是 20 个字节，保存了 key 的 hash 值，commitlog offset，时间戳，还有他下一个链表节点的地址。</p>
<p>为什么在 链表元素里保存 了 hash 值呢？为了防止 hash 值不同，但是 hash 取模后的结果相同（也就是 hash 冲突），如果冲突了，就用 hash 值比对一下。</p>
<p>那如果 hash 值相同，key 内容不同呢？RocketMQ 的做法是放在客户端过滤。</p>
<p>整体处理逻辑和 Java 的 HashMap 类似。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>鼎鼎大名的 Kafka，可以说强无敌了。今天，我们主要说说他的索引设计。</p>
<p>Kafka 每个 topic 有多个 partition ，每个 partition 有多个 segment，每个 segment 里，存储了消息的相关文件：数据文件，索引文件。</p>
<p>如下图：</p>
<p><img src="http://q0zlvq28b.bkt.clouddn.com/2019-11-15-014502.png" alt="image"></p>
<p>Kafka 不像 RocketMQ，所有数据都存在一个文件里，Kafka 每个 topic 的文件都是隔离开的，而每个 topic 又可能会有很多的 partition（看你的配置），因此，如果你的 topic 非常多，或者你的 partition 非常多的话，顺序写就会变成随机写，性能会骤降（按照 kafka 的说法，可能相差 6,000 倍），这也是我个人认为是两者比较大的区别之一。</p>
<p>Kafka 的索引文件和 数据文件绑定在一起的。这个和 RocketMQ 的 消费索引类似，Kafka 里面是逻辑 offset 映射物理 offset ，并且采用了稀疏索引的方式。然后，我们看看他们的索引设计，如下图：</p>
<p><img src="http://q0zlvq28b.bkt.clouddn.com/2019-11-15-014518.png" alt="-"></p>
<p>我们以 [3, 745] 为例进行说明，3 表示逻辑索引，即这个 partition  下的全局递增逻辑索引（当然，这个是相对偏移量，这里为了描述简单，就不区分了），745 表示这条消息的所在文件的物理 position。</p>
<p>假设，我现在是一个消费者，订阅了这个 partition 的消息，那么我将从 0 号逻辑索引开始订阅，从 *.index 开始遍历，然后找到对应的物理文件 position.</p>
<p>朋友，kafka 的这个 .index 文件和 RocketMQ 的 consumerQueue 索引，是不是很相似呢？</p>
<p>其实刚开始我一直在想，如果 Kafka 不设计索引行不行？</p>
<p>仔细想想，如果没有索引，如何定位一条消息？每次写入时，都返回一个物理 offset（同时返回 ip、partition、segment 等信息），消费者直接通过这个物理 offset 消费消息。例如 0ffset 362， offset 901 等等。</p>
<p>例如：查找 offset 901消息。通过 服务器 ip+port + topic + partition + segment + offset 901 来找，也不是不可以。但是也太不人性化了吧？</p>
<p>或者，我们直接遍历 .log 文件，从头开始消费。但如果，我不想从头开始消费呢？我想从第 18 条消息开始消费呢？因为没有 .index ，我只能慢慢遍历。</p>
<p>如果我们设计一个索引，一个 topic 设计一个递增的 offset，从 0 开始，每新增一条消息，加一。这是一个逻辑偏移量，我们让逻辑偏移量 映射 物理偏移量。消费者也从  0 开始消费，这样，就达到了某种默契。就算是第  18 条消息，我也能快速找到。</p>
<p>我们看看 kafka 自己怎么说的：</p>
<p><img src="http://q0zlvq28b.bkt.clouddn.com/2019-11-15-015214.png" alt="-"></p>
<p>意思就是：本来我们想用 guid 作为消息的 key 来映射物理 offset 的。但是，仔细一想，不太合适。缺点如下：</p>
<ol>
<li>由于每个消费者都为 broker 维护一个 ID，因此没必要用 guid 这种全局 id ，完全可以在 broker 的基础上，再做唯一 id。</li>
<li>guid 和物理 offset  的索引映射设计非常的重，耗费资源。</li>
</ol>
<p>所以，他们搞了一个基于 partition  的分区原子计数器。使用 broker ID + 分区 ID +  计数器 就可以标识一条唯一的消息。然后，用计数器映射 偏移量 offset，简直就是完美。然后，为了达到搜索效率和空间消耗的平衡，边稠密索引为稀疏索引。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好，开始总结。</p>
<p>RocketMQ 和 Kafka 的索引设计相似之处：</p>
<p>RocketMQ 的 topic 和 kafka 的 topic 类似，RocketMQ 的 queue 和 kafka 的 partition 类似，都是为了 scale out。RocketMQ 为每个 queue 设计了 consumerQueue 索引文件，每个文件大小固定 5.8MB；Kafka 为每个 partition 设计了 segment （.index + .log）。也就是说，consumerQueue 索引文件和 segment 的 .index 本质是一样的，都是为了让 consumer 快速找到消息。</p>
<p>最后，他俩的最大不同，就是：RocketMQ 是所有 topic 混合存储，目的是支持更多的 topic，而 Kafka 的 topic 是单独存储，好处是顺序读性能好，另外，根据分区做副本也比较好做。</p>
<p>不得不说，工程设计都是取舍与平衡。得根据实际场景来进行代码设计。</p>
<p>例如，现在有个小公司，想自己实现个消息队列，你会怎么设计呢?</p>
]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
  </entry>
  <entry>
    <title>2018 年终总结</title>
    <url>/2019/01/01/2019/2019-01-02-2018%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>从来没有写年终总结的习惯，但是今年想尝试写一点年终总结。算是一点点仪式感吧。</p>
<p>今天主要问自己下面几个问题</p>
<ol>
<li><p>2018 规划了什么？</p>
</li>
<li><p>2018 实际做了什么？</p>
</li>
<li><p>2018 哪些做的不好？哪些做的好？</p>
</li>
<li><p>2019 的规划</p>
</li>
</ol>
<h2 id="2018-规划了什么？"><a href="#2018-规划了什么？" class="headerlink" title="2018 规划了什么？"></a>2018 规划了什么？</h2><p>先回顾下 2018 年的目标：</p>
<p><img src="https://user-images.githubusercontent.com/24973360/50734297-1554d500-11d8-11e9-817c-e9fa2e5ab178.png" alt="image"></p>
<p>这是我 17 年最后一天立的 flag。</p>
<p>那么实现的怎么样了呢？</p>
<h2 id="2018-实际做了什么？"><a href="#2018-实际做了什么？" class="headerlink" title="2018 实际做了什么？"></a>2018 实际做了什么？</h2><p>先看 flag 有没有实现。</p>
<p>并发，JVM，Netty。</p>
<p>首先说并发，我的学习路线是先看书，熟悉 API，然后看 JUC 源码，写博客总结。关于并发的博客文章大概写了 49 篇文章。对并发编程算是有了一些自己的理解。</p>
<p>然后说 JVM，这个说实话，由于可实际操作的机会太少，只是看了几本书，包括周志明的《深入理解 Java 虚拟机》，《实战 Java 虚拟机》，《深入理解 G1》等，还有 R 大博客，笨神的博客，小狼的博客等。</p>
<p>整体上对 JVM 的理解的范围包括运行时内存布局，GC 策略，GC 算法，ClassLoader 机制，一些工具的简单使用，例如 Jmap， jstat，mat 等，还有一些简单的 GC 优化。关于 JVM 的笔记写了大概  9 篇。</p>
<p>自己对 JVM 的理解并没有深入到源码层面，虽然 debug 环境搭建好了，但是由于对 C++ 的不熟悉，有些吃力。</p>
<p>这是 2019 年需要用力的地方。</p>
<p>再说说 Netty。</p>
<p>Netty 和并发学习类似，都是先熟悉 API，再看书，看源码，和网友讨论等，写了大概 20 篇源码分析的文章。对 Netty 的线程模型和一些优化都有了些许理解，但仍谈不上精通。Netty 的坑还是很大的，而且也有一些 bug，值得深挖。</p>
<p>所以， 2019 Netty 也要再复习一下。</p>
<h2 id="2018-哪些做的好？哪些做的不好？"><a href="#2018-哪些做的好？哪些做的不好？" class="headerlink" title="2018 哪些做的好？哪些做的不好？"></a>2018 哪些做的好？哪些做的不好？</h2><p>总的来说，年初立的 flag 算完成了80% 吧，由于没有量化指标，只能这么认为了 ^_^。</p>
<h4 id="1-哪些做的不好？"><a href="#1-哪些做的不好？" class="headerlink" title="1. 哪些做的不好？"></a>1. 哪些做的不好？</h4><p>整个 2018 年也换了一份工作，也从苏州来到了杭州。换工作的经历也是比较坎坷，放弃了薪资高的，选了一份比较低的，主要还是工作内容的不同吧。这个选择有些赌博的成分在里面。</p>
<p>那段时间也参加了很多面试，包括上海，苏州，杭州等。大公司，小公司，外包等等，都面了一遍，面到最后，甚至面试官接下来要问什么，我都能感觉到.</p>
<p>面试多了，也有好处，好处就是你知道了自己的弱点，例如，面试大厂的时候，那时的自己，大型分布式的经验不是很足，仅仅接触了一个 SpringCloud 项目而已，对分布式事务，分布式存储等仅仅停留的博客文章层面。在大厂面试官面前，确实有些弱。</p>
<p>坏处则是，理论有余，实践不足，甚至让自己有一种“能应付面试，我就掌握了这门技术”的错觉。</p>
<p>同时，对 JVM 没有深入到源码级别的理解，高难度的 GC  调优也基本没有，基本是靠着看笨神的文章跪着学习的。</p>
<p>还有传统算法，例如 LeetCode 上的那些算法没有刷过，这个也让自己在面试的时候吃了一些亏。</p>
<p>由于时间所限制，自己对数据库，缓存，MQ 等中间件没有深入到源码级别去理解，也让自己在面试的时候，有点僵硬。</p>
<p>不过，虽然没有被大厂看上，但由于自己对并发，Netty，SOFA 有些了解，所以，拿小厂的 offer 还是比较容易的。而且薪资在市场价里，也还行。</p>
<h4 id="2-哪些做的好？"><a href="#2-哪些做的好？" class="headerlink" title="2. 哪些做的好？"></a>2. 哪些做的好？</h4><p>哪些做的好？ 竟然感觉还挺多的，先列一下吧。</p>
<ol>
<li>看了 SOFA RPC 的源码，为官方贡献了一篇源码分析文章，自己也写了一部分。</li>
<li>看了 SOFA Bolt 的源码， 为官方贡献了一篇源码分析文章。</li>
<li>开源了自己的 Lu-RPC 项目，虽然很简单，但是算是自己对 RPC 的理解，通过这个项目，让自己在公司的 DireWolf 项目开发中对 RPC 框架的设计又了更深刻的理解。目前也有了 78 个 star， 2019 争取上到 100， ^_^.</li>
<li>阅读了 RAFT 论文，看了 Nacos 的源码，自己实现了一个 Raft 分布式一致性算法，相较于 nacos 的 AP，自己实现的是 CP，难度更高，算是对分布式一致性有了更深刻的理解。</li>
<li>研究了 Apollo 的源码和设计，对分布式配置中心算是有了自己的理解，并且在 Apollo 的基础上做了 2 次开发。也写了 10 篇源码分析文章。</li>
<li>独自为公司开发了限流熔断系统 DireWolf，开发过程中，借鉴了 Sentinel，hystrix，concurrent-limit 等项目，实现了动态限流，多通多流量分配，自适应限流等，让自己对限流熔断的理解更深入了一些，对框架类库的设计也更深刻的理解了一些，开发过程了，借鉴了很多之前看过的源码设计，例如 SOFA， Netty，Dubbo，Hystrix，Sentinel 等等，因此，更加觉得看优秀的源码是一件非常重要的事情。</li>
<li>在工作期间，接触了 kv 相关的分布式缓存，例如 codis，redis，pika，搜狐的 CacheCloud 也看了一下，还基于 SpirngData-RedisTemplate 封装了公司内部的 Redis 客户端 —— Tedis，对  Redis 客户端有了一些了解。也接触了 Rocketmq，看了存储模块的代码。了解了一个 MQ 的核心设计。接触了阿里的 binlog 同步中间件 —— canal，hbase，es 等。但这些由于工期较紧，都没有深入到源码层面去研究。</li>
<li>工作之余阅读了 Spring 1.0 版本的框架代码，别名 interface 21，相较于现在的版本，代码量更少，阅读起来很轻松，也能更好的理解 Spring 的设计。我觉得这个代码可以多阅读几遍，Spring 对设计模式用的很多，甚至可以说过度设计（随便一说，别当真，只是想表达 Spring 的设计模式用的太多）。</li>
<li>在研究 RPC 的时候，看了毕玄大师的 McQueenRPC， 对 RPC 的理解又更深入了一点，感叹“开源世界真好”。同时，在研究 RPC 的时候，阅读了梁飞的博客文章，对框架类库设计多了一些见解，可以说，梁飞博客文章常读常新。</li>
<li>代码之外的话，自己 2 个月成功减肥了 20 斤，不过最近去重庆暴饮暴食，长了 4 斤左右了，但对于减肥，我已经有自己的一套办法了，因此无所谓。从 7 月 15 开始，每天 6 点之前起床， 12 左右睡，保持了一个比较好的生物钟。不得不说，跑步真的很重要，等到 2019 年气温回升到 20 度的时候，就恢复跑步。</li>
<li>最后，还买了一台顶配的 iMac，开发效率大增。哈哈，缺点就是太贵了。我保证用 5 年，把本钱赚回来。</li>
</ol>
<p>整体上，大概是几个部分，</p>
<ol>
<li>阅读优秀源码，尝试编写优秀代码。</li>
<li>阅读优秀文章、书籍，尝试编写优秀文章。</li>
<li>保持身体健康，以最好的身体状态写代码。</li>
</ol>
<h2 id="2019-的规划"><a href="#2019-的规划" class="headerlink" title="2019 的规划"></a>2019 的规划</h2><p>回顾完了 2018，规划下 2019 吧。</p>
<p>实际上，那天跨年，我们酒过三巡后，每个人都给自己写了 7 个愿望，希望在 2019 实现。</p>
<p>具体内容就不放出来了，从几个方面来说吧</p>
<ol>
<li>工作相关，希望新的一年，能够公司做的更好。薪资，职位都能够有所提升。这算是人之常情吧。</li>
<li>技术相关，希望自己在新的一年，在分布式领域能够有更深刻的认识，配合公司多活建设，能够一起成长。然后有一些高质量的技术输出。</li>
<li>个人相关，首先身体健康吧（戒烟，跑步，早睡早起），然后尝试解决感情问题。</li>
<li>业余生活相关，希望自己在新的一年，看些闲书啥的。拓展一下自己的思维。</li>
</ol>
<p>以上就是跨年夜立的 flag。</p>
<p>今天，结合对 2018 的回顾，重新整理一下。</p>
<p>针对 2018 做的不好的地方，要做一些改变，特别是技术相关的。</p>
<ol>
<li>Java 并发的查缺补漏。</li>
<li>JVM 的深刻理解，GC 优化</li>
<li>Netty 源码的复习</li>
<li>LeetCode 算法题的复习</li>
</ol>
<p>针对 2018 年做的好的地方，需要继续保持</p>
<ol>
<li>阅读优秀代码，阅读优秀文章和书籍</li>
<li>尝试编写优秀代码，尝试编写优秀文章</li>
<li>保持身体健康</li>
</ol>
<p>目前计划看的代码：gprc, disrupt, netty 引用的 mpsc 类库。</p>
<p>结合起来就能组成 2019 年的规划：</p>
<ol>
<li>阅读优秀代码，优秀文章，复习并发，JVM，Netty，然后写一点高质量的文章。</li>
<li>在分布式领域能做一个高难度的产品。</li>
<li>能通过工作，改善一下家人的生活。</li>
<li>保持身体健康。</li>
<li>如果可能，在 golang 和 rust 中，选取一门语言作为自己的第二语言。虽然我很喜欢用 Java，但尝试下别的语言，写一些简单应用，例如那些占用内存很少的小工具。</li>
</ol>
<p>最后，希望明年这个时候，能够达到自己的目标吧，离“而立”又近了一年，时间不多了。</p>
<p>新的一年，猫腰前行，继续战斗。虽然犹死，向死而生。 </p>
<p>EOF</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>生活的加法和减法</title>
    <url>/2019/01/01/2019/2019-01-02-%E7%94%9F%E6%B4%BB%E7%9A%84%E5%8A%A0%E6%B3%95%E5%92%8C%E5%87%8F%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>     
  
<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>每隔一段时间，我们总要对生活做一些加法和减法，就像写代码一样，隔断时间总要重构一下，因为有了新的思考从而引入新的设计，但重构不会修改原有的功能，只会进行优化，使速度更快，消耗的资源更少，更加易读，易扩展，易维护。</p>
<p>对生活一样，我们虽然是程序员，但无法完全脱离人类生活（如果可以，我愿意进入计算机的主板里，完全脱离人类生活），因此，我们总要对生活进行重构。使生活的流程更好，更”合理”。</p>
<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>对生活做减法，大家也许看过一些文章和书，我也看到过一些标题文章，但我没有点进去看，这里说说我的简单理解。</p>
<p>所谓减法，就是去除生活中那些不重要的事情，利用更多的时间去做重要的事情。那么什么是不重要的事情呢？每个人都不同，对于我来说，刷朋友圈，不重要，刷抖音，不重要，刷新闻，不重要。什么是重要的事情呢？睡眠，代码，书籍，运动，这些都是重要的，除去生命中必须的东西，睡眠，运动，那么，剩下代码和书籍很重要——对于我来说。</p>
<p>代码和书籍，这里不必太狭隘的看待为某个项目的代码和某本技术图书。而应该理解成，整个编程世界（编程语言，操作系统，网络安全等等），至于书籍，就更宽泛了，什么书籍都可以，不过尽量读一些年代较为久远的图书，你要知道，进入 21 世纪，写书的人太多了，我们必须进行筛选，而筛选者是谁呢？是时间，让时间检验一本书是否有价值。换个角度，代码也一样，去看那些古老的，仍旧在传承的代码，例如 Linux 内核。</p>
<p>回到我自己身上，我该怎么做减法？换个说法，我有什么可减的？</p>
<p>我偶尔会刷朋友圈，每天 10 分钟最多吧。我手机上目前没有安装抖音，任何新闻。并且关闭了所有的推送通知。退出了 90% 的技术群。但是，我有个爱好，就是比较喜欢电子产品，手机上，会经常逛数字尾巴这个网站，看一些网友分享自己的电子产品，这个算是自己的爱好吧。很多年以前，我就有这个爱好了，似乎很难改掉。这个每天估计会花掉半小时。</p>
<p>然后是吸烟，之前每天都要吸5-8支烟，每支烟 10 分钟，那么每天平均要花 1 个小时到抽烟上，要知道，除去每天 8 小时睡眠，1 小时吃饭，1 小时路程，1小时洗漱， 每天只剩 13 个小时，如果还要花 1 个小时在吸烟上，简直是犯罪，而且这一个小时不仅浪费时间，还损伤身体。出于理智，我在一个月前决定戒烟，目前状态还可以。</p>
<p>然后是如何合理利用时间。</p>
<p>出于职业道德，每天工作八小时是必须的，那么还剩 5 个小时，如何利用？ 我之前有一个 TODO List，只要有时间，就会去做 TODO List 里的事情。</p>
<p>但是，好像有点点小问题——不够系统，因为总会有各种诱惑性的 TODO List 插入，导致一些大块头的，系统性的，基础性的计算知识没有时间去学习，这让我有些难过。</p>
<p>我想了原因，大概可能是以下几个原因：</p>
<ul>
<li>或许是因为要学的东西太多了，</li>
<li>或许是因为学的东西是自己不感兴趣的，但是是面试要使用的。</li>
<li>或许是自己感兴趣的东西即使学习了，还是无法应用到工作中，时间久了就忘了。</li>
</ul>
<p>我依稀记得那一本书说过，学习不能贪杯，计算机世界知识庞杂，我们每个人都只可能精通其中一部分—— 假设可以达到精通的话。</p>
<p>从我们的角度，我们也不能贪杯，我们应该找自己感兴趣的，有发展潜力的。</p>
<p>一个最好的情况是：你目前所做的事情你很感兴趣，并且很有潜力，同时跳槽的目标公司很方便，你甚至都不需要做什么面试题准备，而你做的这个事情，在你当前公司也非常的重要，你甚至可以通过深入研究这个从而升职加薪。</p>
<p>但这种情况基本很少见。</p>
<p>从我的角度说，我目前的做法是，由于工作内容是变化的，如果那段时间工作内容是我感兴趣的，那么就重点研究这一块的技术，因为这是最好的状态，将你学习的东西应用到生产环境中。能够让你更深刻的掌握这门技术。</p>
<p>另一种情况，如果你现在做的项目不是你感兴趣的，例如 CRUD，接口开发，那么，我就会把业余时间用在学习自己感兴趣的，或者面试有用的（例如刷题）。这是没有办法的事情。</p>
<p>说完了怎么利用时间和做减法。再说说加法。</p>
<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>加法实际上，很容易做，随便弄点什么就是加法了，例如，本来你每天除了写代码就是看书，突然，你今天出去打球了，爬山了，那么这就是加法。所以说，做加法很简单。</p>
<p>那么，做加法该怎么做呢？一定要做有效的，有意义的加法—— 这是我个人看法。但也不排除有些文艺青年喜欢做无意义的事情，这里不在讨论范围之内。</p>
<p>如果是我要做加法，我怎么做？首先先小规模试点，看看这个事情可靠吗？有意义吗？先做几天，如果有意义，就分隔出每天那宝贵的一点时间去做这件事情，如果没有意义，明知道是错的，那么就要立刻停止。有句话怎么说来着？</p>
<p>“对的事情要坚持，错的事情要及时停止”。</p>
<p>对，很多人明知道刷抖音，刷朋友圈没有意义，但是他们就是停止不了，为什么，就是无法自控。很多人明明知道早睡早起比晚睡晚起要好得多，他们就是做不到，为什么？还是无法自控。</p>
<h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>为什么我花这么大篇幅说这个事情？</p>
<p>很多时候，我们走的太快，走的太猛，就忘记从另一个角度看自己了。我们应该时刻知道自己最需要什么，最应该做什么，什么才是永恒不变的，什么才是真正应该做的。我们应该立刻放弃那些没有意义的事情，包括那些损害身体，浪费时间的事情，这样才能成为真正的自己，才能用全力实现自己的梦想，否则，等到我们老了，面对没有实现的梦想，只能后悔莫及然而却又无能为力。你心里知道，这些恶果全都是因为你当初不能自控导致的。</p>
<p>记住，只要坚持，总有一天，你会成为自己的榜样。</p>
<p>虽生犹死，向死而生。</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>编写你的第一个 Java 版 Raft 分布式 KV 存储</title>
    <url>/2019/01/12/2019/2019-01-12-lu-raft-kv/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       本文旨在讲述如何使用 Java 语言实现基于 Raft 算法的，分布式的，KV 结构的存储项目。该项目的背景是为了深入理解 Raft 算法，从而深刻理解分布式环境下数据强一致性该如何实现；该项目的目标是：在复杂的分布式环境中，多个存储节点能够保证数据强一致性。

<p>项目地址：<a href="https://github.com/stateIs0/lu-raft-kv">https://github.com/stateIs0/lu-raft-kv</a></p>
<p>欢迎 star ：）</p>
<h2 id="什么是-Java-版-Raft-分布式-KV-存储"><a href="#什么是-Java-版-Raft-分布式-KV-存储" class="headerlink" title="什么是 Java 版 Raft 分布式 KV 存储"></a>什么是 Java 版 Raft 分布式 KV 存储</h2><p>Raft 算法大部分人都已经了解，也有很多实现，从 GitHub 上来看，似乎 Golang 语言实现的较多，比较有名的，例如 etcd。而 Java 版本的，在生产环境大规模使用的实现则较少；</p>
<p>同时，他们的设计目标大部分都是命名服务，即服务注册发现，也就是说，他们通常都是基于 AP 实现，就像 DNS，DNS 是一个命名服务，同时也不是一个强一致性的服务。</p>
<p>比较不同的是 Zookeeper，ZK 常被大家用来做命名服务，但他更多的是一个分布式服务协调者。</p>
<p>而上面的这些都不是存储服务，虽然也都可以做一些存储工作。甚至像 kafka，可以利用 ZK 实现分布式存储。</p>
<p>回到我们这边。</p>
<p>此次我们语言部分使用 Java，RPC 网络通信框架使用的是蚂蚁金服 SOFA-Bolt，底层 KV 存储使用的是 RocksDB，其中核心的 Raft 则由我们自己实现（如果不自己实现，那这个项目没有意义）。 注意，该项目将舍弃一部分性能和可用性，以追求尽可能的强一致性。</p>
<h2 id="为什么要费尽心力重复造轮子"><a href="#为什么要费尽心力重复造轮子" class="headerlink" title="为什么要费尽心力重复造轮子"></a>为什么要费尽心力重复造轮子</h2><p>小时候，我们阅读关于高可用的文章时，最后都会提到一个问题：服务挂了怎么办？</p>
<p>通常有 2 种回答：</p>
<ol>
<li>如果是无状态服务，那么毫不影响使用。</li>
<li>如果是有状态服务，可以将状态保存到一个别的地方，例如 Redis。如果 Redis 挂了怎么办？那就放到 ZK。</li>
</ol>
<p>很多中间件，都会使用 ZK 来保证状态一致，例如 codis，kafka。因为使用 ZK 能够帮我们节省大量的时间。但有的时候，中间件的用户觉得引入第三方中间件很麻烦，那么中间件开发者会尝试自己实现一致性，例如 Redis Cluster， TiDB 等。</p>
<p>而通常自己实现，都会使用 Raft 算法，那有人问，为什么不使用”更牛逼的” paxos 算法？对不起，这个有点难，至少目前开源的、生产环境大规模使用的 paxos 算法实现还没有出现，只听过 Google 或者 alibaba 在其内部实现过，具体是什么样子的，这里我们就不讨论了。</p>
<p>回到我们的话题，为什么重复造轮子？从 3 个方面来回答：</p>
<ol>
<li>有的时候 ZK 和 etcd 并不能解决我们的问题，或者像上面说的，引入其他的中间件部署起来太麻烦也太重。</li>
<li>完全处于好奇，好奇为什么 Raft 可以保证一致性（这通常可以通过汗牛充栋的文章来得到解答）？但是到底该怎么实现？</li>
<li>分布式开发的要求，作为开发分布式系统的程序员，如果能够更深刻的理解分布式系统的核心算法，那么对如何合理设计一个分布式系统将大有益处。</li>
</ol>
<p>好，有了以上 3 个原因，我们就有足够的动力来造轮子了，接下来就是如何造的问题了。</p>
<h2 id="编写前的-Raft-理论基础"><a href="#编写前的-Raft-理论基础" class="headerlink" title="编写前的 Raft 理论基础"></a>编写前的 Raft 理论基础</h2><p>任何实践都是理论先行。如果你对 Raft 理论已经非常熟悉，那么可以跳过此节，直接看实现的步骤。</p>
<p>Raft 为了算法的可理解性，将算法分成了 4 个部分。</p>
<ol>
<li>leader 选举</li>
<li>日志复制</li>
<li>成员变更</li>
<li>日志压缩</li>
</ol>
<p>同 zk 一样，leader 都是必须的，所有的写操作都是由 leader 发起，从而保证数据流向足够简单。而 leader 的选举则通过比较每个节点的逻辑时间（term）大小，以及日志下标（index）的大小。</p>
<p>刚刚说 leader 选举涉及日志下标，那么就要讲日志复制。日志复制可以说是 Raft 核心的核心，说简单点，Raft 就是为了保证多节点之间日志的一致。当日志一致，我们可以认为整个系统的状态是一致的。这个日志你可以理解成 mysql 的 binlog。</p>
<p>Raft 通过各种补丁，保证了日志复制的正确性。</p>
<p>Raft leader 节点会将客户端的请求都封装成日志，发送到各个 follower 中，如果集群中超过一半的 follower 回复成功，那么这个日志就可以被提交（commit），这个 commit 可以理解为 ACID 的 D ，即持久化。当日志被持久化到磁盘，后面的事情就好办了。</p>
<p>而第三点则是为了节点的扩展性。第四点是为了性能。相比较 leader 选举和 日志复制，不是那么的重要，可以说，如果没有成员变更和日志压缩，也可以搞出一个可用的 Raft 分布式系统，但没有 leader 选举和日志复制，是万万不能的。</p>
<p>因此，本文和本项目将重点放在 leader 选举和日志复制。</p>
<p>以上，就简单说明了 Raft 的算法，关于 Raft 算法更多的文章，请参考本人博客中的其他文章（包含官方各个版本论文和 PPT &amp; 动画 &amp; 其他博客文章），博客地址：thinkinjava.cn</p>
<h2 id="实现的步骤"><a href="#实现的步骤" class="headerlink" title="实现的步骤"></a>实现的步骤</h2><p>实现目标：基于 Raft 论文实现 Raft 核心功能，即 Leader 选举 &amp; 日志复制。</p>
<p>Raft 核心组件包括：一致性模块，RPC 通信，日志模块，状态机。</p>
<h3 id="技术选型："><a href="#技术选型：" class="headerlink" title="技术选型："></a>技术选型：</h3><ul>
<li>一致性模块，是 Raft 算法的核心实现，通过一致性模块，保证 Raft 集群节点数据的一致性。<strong>这里我们需要自己根据论文描述去实现</strong>。</li>
<li>RPC 通信，可以使用 HTTP 短连接，也可以直接使用 TCP 长连接，考虑到集群各个节点频繁通信，同时节点通常都在一个局域网内，因此我们选用 TCP 长连接。而 Java 社区长连接框架首选 Netty，这里我们选用蚂蚁金服网络通信框架 SOFA-Bolt（基于 Netty），便于快速开发。</li>
<li>日志模块，Raft 算法中，日志实现是基础，考虑到时间因素，我们选用 RocksDB 作为日志存储。</li>
<li>状态机，可以是任何实现，其实质就是将日志中的内容进行处理。可以理解为 Mysql binlog 中的具体数据。由于我们是要实现一个 KV 存储，那么可以直接使用日志模块的 RocksDB 组件。</li>
</ul>
<p>以上。我们可以看到，得益于开源世界，我们开发一个 Raft 存储，只需要编写一个“一致性模块”就行了，其他模块都有现成的轮子可以使用，真是美滋滋。</p>
<h3 id="接口设计："><a href="#接口设计：" class="headerlink" title="接口设计："></a>接口设计：</h3><p>上面我们说了 Raft 的几个核心功能，事实上，就可以理解为接口。所以我们定义以下几个接口：</p>
<ol>
<li>Consensus， 一致性模块接口</li>
<li>LogModule，日志模块接口</li>
<li>StateMachine， 状态机接口</li>
<li>RpcServer &amp; RpcClient， RPC 接口</li>
<li>Node，同时，为了聚合上面的几个接口，我们需要定义一个 Node 接口，即节点，Raft 抽象的机器节点。</li>
<li>LifeCycle， 最后，我们需要管理以上组件的生命周期，因此需要一个 LifeCycle 接口。</li>
</ol>
<p>接下来，我们需要详细定义核心接口 Consensus。我们根据论文定义了 2 个核心接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 请求投票 RPC</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 接收者实现：</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *      如果term &lt; currentTerm返回 false （5.2 节）</span></span><br><span class="line"><span class="comment">  *      如果 votedFor 为空或者就是 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">RvoteResult <span class="title">requestVote</span><span class="params">(RvoteParam param)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 附加日志(多个日志,为了提高效率) RPC</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 接收者实现：</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *    如果 term &lt; currentTerm 就返回 false （5.1 节）</span></span><br><span class="line"><span class="comment">  *    如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配，则返回 false （5.3 节）</span></span><br><span class="line"><span class="comment">  *    如果已经存在的日志条目和新的产生冲突（索引值相同但是任期号不同），删除这一条和之后所有的 （5.3 节）</span></span><br><span class="line"><span class="comment">  *    附加任何在已有的日志中不存在的条目</span></span><br><span class="line"><span class="comment">  *    如果 leaderCommit &gt; commitIndex，令 commitIndex 等于 leaderCommit 和 新日志条目索引值中较小的一个</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">AentryResult <span class="title">appendEntries</span><span class="params">(AentryParam param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>请求投票 &amp; 附加日志。也就是我们的 Raft 节点的核心功能，leader 选举和 日志复制。实现这两个接口是 Raft 的关键所在。</p>
<p>然后再看 LogModule 接口，这个自由发挥，考虑日志的特点，我定义了以下几个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(LogEntry logEntry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LogEntry <span class="title">read</span><span class="params">(Long index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeOnStartIndex</span><span class="params">(Long startIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LogEntry <span class="title">getLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Long <span class="title">getLastIndex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分别是写，读，删，最后是两个关于 Last 的接口，在 Raft 中，Last 是一个非常关键的东西，因此我这里单独定义了 2个方法，虽然看起来不是很好看 ：）</p>
<p>状态机接口，在 Raft 论文中，将数据保存到状态机，作者称之为应用，那么我们也这么命名，说白了，就是将已成功提交的日志应用到状态机中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数据应用到状态机.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 原则上,只需这一个方法(apply). 其他的方法是为了更方便的使用状态机.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> logEntry 日志中的数据.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(LogEntry logEntry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LogEntry <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getString</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setString</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delString</span><span class="params">(String... key)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个 apply 方法，就是 Raft 论文常常提及的方法，即将日志应用到状态机中，后面的几个方法，都是我为了方便获取数据设计的，可以不用在意，甚至于，这几个方法不存在也不影响 Raft 的实现，但影响 KV 存储的实现，试想：一个系统只有保存功能，没有获取功能，要你何用？。</p>
<p>RpcClient 和 RPCServer 没什么好讲的，其实就是 send 和 receive。</p>
<p>然后是 Node 接口，Node 接口也是 Raft 没有定义的，我们依靠自己的理解定义了几个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置配置文件.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setConfig</span><span class="params">(NodeConfig config)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理请求投票 RPC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">RvoteResult <span class="title">handlerRequestVote</span><span class="params">(RvoteParam param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理附加日志请求.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AentryResult <span class="title">handlerAppendEntries</span><span class="params">(AentryParam param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理客户端请求.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ClientKVAck <span class="title">handlerClientRequest</span><span class="params">(ClientKVReq request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转发给 leader 节点.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ClientKVAck <span class="title">redirect</span><span class="params">(ClientKVReq request)</span></span>;</span><br></pre></td></tr></table></figure>

<p>首先，一个 Node 肯定需要配置文件，所以有一个 setConfig 接口，<br>然后，肯定需要处理“请求投票”和“附加日志”，同时，还需要接收用户，也就是客户端的请求（不然数据从哪来？），所以有 handlerClientRequest 接口，最后，考虑到灵活性，我们让每个节点都可以接收客户端的请求，但 follower 节点并不能处理请求，所以需要重定向到 leader 节点，因此，我们需要一个重定向接口。</p>
<p>最后是生命周期接口，这里我们简单定义了 2 个，有需要的话，再另外加上组合接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure>


<p>好，基本的接口定义完了，后面就是实现了。实现才是关键。</p>
<h3 id="Leader-选举的实现"><a href="#Leader-选举的实现" class="headerlink" title="Leader 选举的实现"></a>Leader 选举的实现</h3><p>选举，其实就是一个定时器，根据 Raft 论文描述，如果超时了就需要重新选举，我们使用 Java 的定时任务线程池进行实现，实现之前，需要确定几个点：</p>
<ol>
<li>选举者必须不是 leader。</li>
<li>必须超时了才能选举，具体超时时间根据你的设计而定,注意，每个节点的超时时间不能相同，应当使用随机算法错开（Raft 关键实现），避免无谓的死锁。</li>
<li>选举者优先选举自己,将自己变成 candidate。</li>
<li>选举的第一步就是把自己的 term 加一。</li>
<li>然后像其他节点发送请求投票 RPC，请求参数参照论文，包括自身的 term，自身的 lastIndex，以及日志的 lastTerm。同时，请求投票 RPC 应该是并行请求的。</li>
<li>等待投票结果应该有超时控制，如果超时了，就不等待了。</li>
<li>最后，如果有超过半数的响应为 success，那么就需要立即变成 leader ，并发送心跳阻止其他选举。</li>
<li>如果失败了，就需要重新选举。注意，这个期间，如果有其他节点发送心跳，也需要立刻变成 follower，否则，将死循环。</li>
</ol>
<p>具体代码，可参见 <a href="https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultNode.java#L546">https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultNode.java#L546</a></p>
<p>上面说的，其实是 Leader 选举中，请求者的实现，那么接收者如何实现呢？接收者在收到“请求投票” RPC 后，需要做以下事情：</p>
<ol>
<li>注意，选举操作应该是串行的，因为涉及到状态修改，并发操作将导致数据错乱。也就是说，如果抢锁失败，应当立即返回错误。</li>
<li>首先判断对方的 term 是否小于自己，如果小于自己，直接返回失败。</li>
<li>如果当前节点没有投票给任何人，或者投的正好是对方，那么就可以比较日志的大小，反之，返回失败。</li>
<li>如果对方日志没有自己大，返回失败。反之，投票给对方，并变成 follower。变成 follower 的同时，异步的选举任务在最后从 condidate 变成 leader 之前，会判断是否是 follower，如果是 follower，就放弃成为 leader。这是一个兜底的措施。</li>
</ol>
<p>具体代码参见 <a href="https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultConsensus.java#L51">https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultConsensus.java#L51</a></p>
<p>到这里，基本就能够实现 Raft Leader 选举的逻辑。</p>
<p>注意，我们上面涉及到的 LastIndex 等参数，还没有实现，但不影响我们编写伪代码，毕竟日志复制比 leader 选举要复杂的多，我们的原则是从易到难。：）</p>
<h2 id="日志复制的实现"><a href="#日志复制的实现" class="headerlink" title="日志复制的实现"></a>日志复制的实现</h2><p>日志复制是 Raft 实现一致性的核心。</p>
<p>日志复制有 2 种形式，1种是心跳，一种是真正的日志，心跳的日志内容是空的，其他部分基本相同，也就是说，接收方在收到日志时，如果发现是空的，那么他就是心跳。</p>
<h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><p>既然是心跳，肯定就是个定时任务，和选举一样。在我们的实现中，我们每 5 秒发送一次心跳。注意点：</p>
<ol>
<li>首先自己必须是 leader 才能发送心跳。</li>
<li>必须满足 5 秒的时间间隔。</li>
<li>并发的向其他 follower 节点发送心跳。</li>
<li>心跳参数包括自身的 ID，自身的 term，以便让对方检查 term，防止网络分区导致的脑裂。</li>
<li>如果任意 follower 的返回值的 term 大于自身，说明自己分区了，那么需要变成 follower，并更新自己的 term。然后重新发起选举。</li>
</ol>
<p>具体代码查看：<a href="https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultNode.java#L695">https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultNode.java#L695</a></p>
<p>然后是心跳接收者的实现，这个就比较简单了，接收者需要做几件事情：</p>
<ol>
<li>无论成功失败首先设置返回值，也就是将自己的 term 返回给 leader。</li>
<li>判断对方的 term 是否大于自身，如果大于自身，变成 follower，防止异步的选举任务误操作。同时更新选举时间和心跳时间。</li>
<li>如果对方 term 小于自身，返回失败。不更新选举时间和心跳时间。以便触发选举。</li>
</ol>
<p>具体代码参见：<a href="https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultConsensus.java#L109">https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultConsensus.java#L109</a></p>
<h4 id="说完了心跳，再说说真正的日志附加。"><a href="#说完了心跳，再说说真正的日志附加。" class="headerlink" title="说完了心跳，再说说真正的日志附加。"></a>说完了心跳，再说说真正的日志附加。</h4><p>简单来说，当用户向 Leader 发送一个 KV 数据，那么 Leader 需要将 KV数据封装成日志，并行的发送到其他的 follower 节点，只要在指定的超时时间内，有过半几点返回成功，那么久提交（持久化）这条日志，返回客户端成功，否者返回失败。</p>
<p>因此，Leader 节点会有一个 ClientKVAck handlerClientRequest(ClientKVReq request) 接口，用于接收用户的 KV 数据，同时，会并行向其他节点复制数据，具体步骤如下：</p>
<ol>
<li>每个节点都可能会接收到客户端的请求，但只有 leader 能处理，所以如果自身不是 leader，则需要转发给 leader。</li>
<li>然后将用户的 KV 数据封装成日志结构，包括 term，index，command，预提交到本地。</li>
<li>并行的向其他节点发送数据，也就是日志复制。</li>
<li>如果在指定的时间内，过半节点返回成功，那么就提交这条日志。</li>
<li>最后，更新自己的 commitIndex，lastApplied 等信息。</li>
</ol>
<p>注意，复制不仅仅是简单的将这条日志发送到其他节点，这可能比我们想象的复杂，为了保证复杂网络环境下的一致性，Raft 保存了每个节点的成功复制过的日志的 index，即 nextIndex ，因此，如果对方之前一段时间宕机了，那么，从宕机那一刻开始，到当前这段时间的所有日志，都要发送给对方。</p>
<p>甚至于，如果对方觉得你发送的日志还是太大，那么就要递减的减小 nextIndex，复制更多的日志给对方。<strong>注意：这里是 Raft 实现分布式一致性的关键所在</strong>。</p>
<p>具体代码参见：<a href="https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultNode.java#L244">https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultNode.java#L244</a></p>
<p>再来看看日志接收者的实现步骤：</p>
<ol>
<li>和心跳一样，要先检查对方 term，如果 term 都不对，那么就没什么好说的了。</li>
<li>如果日志不匹配，那么返回 leader，告诉他，减小 nextIndex 重试。</li>
<li>如果本地存在的日志和 leader 的日志冲突了，以 leader 的为准，删除自身的。</li>
<li>最后，将日志应用到状态机，更新本地的 commitIndex，返回 leader 成功。</li>
</ol>
<p>具体代码参见：<a href="https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultConsensus.java#L109">https://github.com/stateIs0/lu-raft-kv/blob/master/lu-raft-kv/src/main/java/cn/think/in/java/impl/DefaultConsensus.java#L109</a></p>
<p>到这里，日志复制的部分就讲完了。</p>
<p>注意，实现日志复制的前提是，必须有一个正确的日志存储系统，即我们的 RocksDB，我们在 RocksDB 的基础上，使用一种机制，维护了 每个节点 的LastIndex，无论何时何地，都能够得到正确的 LastIndex，这是实现日志复制不可获取的一部分。</p>
<h2 id="验证“Leader-选举”和“日志复制”"><a href="#验证“Leader-选举”和“日志复制”" class="headerlink" title="验证“Leader 选举”和“日志复制”"></a>验证“Leader 选举”和“日志复制”</h2><p>写完了程序，如何验证是否正确呢？</p>
<p>当然是写验证程序。</p>
<h5 id="我们首先验证-“Leader-选举”。其实这个比较好测试。"><a href="#我们首先验证-“Leader-选举”。其实这个比较好测试。" class="headerlink" title="我们首先验证 “Leader 选举”。其实这个比较好测试。"></a>我们首先验证 “Leader 选举”。其实这个比较好测试。</h5><ol>
<li>在 idea 中配置 5 个 application 启动项,配置 main 类为 RaftNodeBootStrap 类, 加入 -DserverPort=8775 -DserverPort=8776 -DserverPort=8777 -DserverPort=8778 -DserverPort=8779<br>系统配置, 表示分布式环境下的 5 个机器节点.</li>
<li>依次启动 5 个 RaftNodeBootStrap 节点, 端口分别是 8775，8776， 8777, 8778, 8779.</li>
<li>观察控制台, 约 6 秒后, 会发生选举事件,此时,会产生一个 leader. 而  leader 会立刻发送心跳维持自己的地位.</li>
<li>如果leader 的端口是  8775, 使用 idea 关闭 8775 端口，模拟节点挂掉, 大约 15 秒后, 会重新开始选举, 并且会在剩余的 4 个节点中,产生一个新的 leader.  并开始发送心跳日志。</li>
</ol>
<p>然后验证 日志复制，分为 2 种情况：</p>
<h5 id="正常状态下"><a href="#正常状态下" class="headerlink" title="正常状态下"></a>正常状态下</h5><ol>
<li>在 idea 中配置 5 个 application 启动项,配置 main 类为 RaftNodeBootStrap 类, 加入 -DserverPort=8775 -DserverPort=8776 -DserverPort=8777 -DserverPort=8778 -DserverPort=8779 </li>
<li>依次启动 5 个 RaftNodeBootStrap 节点, 端口分别是 8775，8776， 8777, 8778, 8779.</li>
<li>使用客户端写入 kv 数据.</li>
<li>杀掉所有节点, 使用 junit test 读取每个 rocksDB 的值, 验证每个节点的数据是否一致.</li>
</ol>
<h5 id="非正常状态下"><a href="#非正常状态下" class="headerlink" title="非正常状态下"></a>非正常状态下</h5><ol>
<li>在 idea 中配置 5 个 application 启动项,配置 main 类为 RaftNodeBootStrap 类, 加入 -DserverPort=8775 -DserverPort=8776 -DserverPort=8777 -DserverPort=8778 -DserverPort=8779 </li>
<li>依次启动 5 个 RaftNodeBootStrap 节点, 端口分别是 8775，8776， 8777, 8778, 8779.</li>
<li>使用客户端写入 kv 数据.</li>
<li>杀掉 leader （假设是 8775）.</li>
<li>再次写入数据.</li>
<li>重启 8775.</li>
<li>关闭所有节点, 读取 RocksDB 验证数据一致性.</li>
</ol>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>本文并没有贴很多代码，如果要贴代码的话，阅读体验将不会很好，并且代码也不能说明什么，如果想看具体实现，可以到 github 上看看，顺便给个 star ：）</p>
<p>该项目 Java 代码约 2500 行，核心代码估计也就 1000 多行。你甚至可以说，这是个玩具代码，但我相信毕玄大师所说，玩具代码经过优化后，也是可以变成可在商业系统中真正健壮运行的代码（<a href="http://hellojava.info/?p=508%EF%BC%89">http://hellojava.info/?p=508）</a> ：）</p>
<p>回到我们的初衷，我们并不奢望这段代码能够运行在生产环境中，就像我的另一个项目 Lu-RPC 一样。但，经历了一次编写可正确运行的玩具代码的经历，下次再次编写工程化的代码，应该会更加容易些。这点我深有体会。</p>
<p>可以稍微展开讲一下，在写完 Lu-RPC 项目后，我就接到了开发生产环境运行的限流熔断框架任务，此时，开发 Lu-RPC 的经历让我在开发该框架时，更加的从容和自如：）</p>
<p>再回到 Raft 上面来，虽然上面的测试用例跑过了，程序也经过了我反反复复的测试，但不代表这个程序就是 100% 正确的，特别是在复杂的分布式环境下。如果你对 Raft 有兴趣，欢迎一起交流沟通 ：）</p>
<p>项目地址：<a href="https://github.com/stateIs0/lu-raft-kv">https://github.com/stateIs0/lu-raft-kv</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>my open source</category>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>扎心一问：分库分表就能无限扩容吗</title>
    <url>/2019/01/15/2019/2019-01-16-fkfb/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       像我这样的菜鸟，总会有各种疑问，刚开始是对 JDK API 的疑问，对 NIO 的疑问，对 JVM 的疑问，当工作几年后，对服务的可用性，可扩展性也有了新的疑问，什么疑问呢？其实是老生常谈的话题：服务的扩容问题。

<h2 id="正常情况下的服务演化之路"><a href="#正常情况下的服务演化之路" class="headerlink" title="正常情况下的服务演化之路"></a>正常情况下的服务演化之路</h2><p>让我们从最初开始。</p>
<ol>
<li>单体应用<br>每个创业公司基本都是从类似  SSM 和 SSH 这种架构起来的，没什么好讲的，基本每个程序员都经历过。</li>
<li>RPC 应用<br>当业务越来越大，我们需要对服务进行水平扩容，扩容很简单，只要保证服务是无状态的就可以了，如下图：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-32cb3108687e3d25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>当业务又越来越大，我们的服务关系错综复杂，同时，有很多服务访问都是不需要连接 DB 的，只需要连接缓存即可，那么就可以做成分离的，减少 DB 宝贵的连接。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-fb09a89bc8478b7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我相信大部分公司都是在这个阶段。Dubbo 就是为了解决这个问题而生的。</p>
<ol start="3">
<li>分库分表</li>
</ol>
<p>如果你的公司产品很受欢迎，业务继续高速发展，数据越来越多，SQL 操作越来越慢，那么数据库就会成为瓶颈，那么你肯定会想到分库分表，不论通过 ID hash 或者 range 的方式都可以。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b3f9721f866736c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这下应该没问题了吧。任凭你用户再多，并发再高，我只要无限扩容数据库，无限扩容应用，就可以了。</p>
<p>这也是本文的标题，分库分表就能解决无限扩容吗？</p>
<p>实际上，像上面的架构，并不能解决。</p>
<p>其实，这个问题和 RPC 的问题有点类似：数据库连接过多！！！</p>
<p>通常，我们的 RPC 应用由于是使用中间件进行访问数据库，应用实际上是不知道到底要访问哪个数据库的，访问数据库的规则由中间件决定，例如 sharding JDBC。这就导致，这个应用必须和所有的数据库连接，就像我们上面的架构图一样，一个 RPC 应用需要和 3 个 mysql 连接，如果是 30 个 RPC 应用，每个 RPC 的数据库连接池大小是8 ，每个 mysql 需要维护 240 个连接，我们知道，mysql 默认连接数是 100，最大连接数是 16384，也就是说，假设每个应用的连接池大小是 8 ，超过 2048 个应用就无法再继续连接了，也就无法继续扩容了。注意，由于每个物理库有很多逻辑库，再加上微服务运动如火如荼， 2048 并没有看起来那么大。</p>
<p>也许你说，我可以通过前面加一个 proxy 来解决连接数的问题，实际上，代理的性能也会成为问题，为什么？代理的连接数也是不能超过 16384 的，如果并发超过  16384，变成 163840，那么 proxy 也解决不了问题。</p>
<p>怎么办？让我们再看看上面的架构图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a7770de852d71082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们发现，问题是出在“每个 RPC 应用都要连所有的库”，导致扩容应用的同时，每个数据库连接数就要增加。<strong>就算增加数据库，也不能解决连接数的问题。</strong></p>
<p>那怎么办呢？</p>
<h2 id="单元化"><a href="#单元化" class="headerlink" title="单元化"></a>单元化</h2><p>单元化，听起来高大上，通常在一些 XXX 大会上，分享“关于两地三中心”，“三地五中心”，“异地多活”等等牛逼的名词的时候，单元化也会一起出现。</p>
<p>这里我们不讨论那么牛逼的，就只说“数据库连接数过多” 的问题。</p>
<p>实际上，思路很简单：我们不让应用连接所有的数据库就可以了。</p>
<p>假设我们根据 range 分成了 10 个库，现在有 10 个应用，我们让每个应用只连一个库，当应用增多变成 20个，数据库的连接不够用了，我们就将 10 个库分成 20 个库，这样，无论你应用扩容到多少个，都可以解决数据库连接数过多的问题。</p>
<p>注意：做这件事的前提是：你必须保证，访问你这个应用的 request 请求的数据库一定是在这个应用的。s</p>
<p>换个说法，当用户从 DNS 那里进来的时候，就知道自己要去那个应用了，所以，规则在 DNS 之前就定好了，虽然这有点夸张，但肯定在进应用之前就知道要去哪个库了。</p>
<p>所以，这通常需要一个规则，例如通过用户 ID hash，由配置中心广播 hash 规则。这样，所有的组件都能保持一致的规则，从而正确的访问到数据库。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-36a572bcc18170f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单元化"></p>
<p>到这里，我们终于解决了无限扩容的问题。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文从单体应用开始，逐步讲述了一个正常后台的演进历程，知道了分库分表并不能解决“无限扩容” 的问题，只有单元化才能解决这问题。而单元化则带来更多的复杂性。但是好处不言而喻。</p>
<p>单元化带来的更多的思路。</p>
<p>有了单元化，解决了无限扩容的问题，但是我们还没有考虑单点的问题，即服务的可用性。要知道，我们这里的数据库都是单点的。</p>
<p>这就是另一个话题 —— 异地多活。限于篇幅，下次再聊。</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>最易懂的数据库异地多活方案</title>
    <url>/2019/02/15/2019/2019-02-16-yddh/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       随着业务发展越来越快，数据量越来越多，用户也越来越多，业务出现故障的几率也越来越大，而可用性是衡量一个系统的关键指标，application 由于是无状态的，可用性很好保证，当一个应用挂掉，直接切到另一个即可，最关键的是数据库的高可用，则是最复杂的。

<p>今天我们将尝试探讨数据库的异地多活高可用。注意，我们讨论的都是超大数据量（50TB 级别）的数据库。</p>
<h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>直接上分布式数据库，目前市面上常见的有  3 种，TiDB，阿里云 POLARDB，亚马逊 Aurora。</p>
<p>虽然 TiDB 可以将数据 sharding 到各个城市，但由于各个城市的物理距离导致的网络消耗，查询的效率可想而知（或许可以通过 Hash 的方式解决？）。 POLARDB 和 Aurora 是相同的思路，计算节点是分布式的，存储使用共享存储，带来的问题还是单机房问题。</p>
<p>因此，分布式数据库解决的还是超大数据的存储和单机房的 HA，一旦跨越城市，目前还没有看到好的方案。</p>
<h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>在 <a href="http://thinkinjava.cn/2019/01/fkfb">扎心一问：分库分表就能无限扩容吗</a> 文章中，我们提到了单元化。单元化说白了，就是先分库分表，然后，将数据库划分为固定的几个单元，使固定的业务进入固定的单元，这样，就不会出现每个业务都需要连接所有的数据库 —— 从而减小连接数。</p>
<p>在单元化的基础上，我们可以实现异地多活。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d2b4a4b52dc2246a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解释一下上图：<br>我们将 数据分成了 3 个数据库，同时，我们有3个城市的机房，红色表示为写节点，每个 shard 库最好只保证只有一个地方写，尽量避免双写的问题。 另外，杭州机房作为主机房。</p>
<p>上海机房的 shard 1 库在写入数据后，会同步到杭州主节点，北京机房的 shard 3 节点在写入数据后，也会同步到杭州主节点，杭州机房的 shard 2  写入数据后，也会同步到上海机房和北京机房。</p>
<p>其中，非红色数据库都是备库或读库。</p>
<p>我们假设，上海机房断电。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a0d70c352f4919ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>此时，杭州机房将会接管 shard 1 库，变成写入节点。</p>
<p>我们再假设，杭州机房断电。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-44e0332f15eeb4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>杭州机房断电后，上海机房将会接管 shard 2 节点，同时，将 shard 2 节点的数据同步到北京机房，仍然保证可用性。</p>
<p>注意，这里为什么是上海机房的 shard 2 接管，而不是北京机房的 shard 2 接管呢？实际上，我是随便写的，在生产环境中，如果有超过 2 个副本，那么就需要使用 Raft 这种一致性协议来决策到底由谁来接管，这里为了简单，就写上海了。</p>
<p>我们观察到，其中，同步是核心，注意，使用 mysql 自带的同步是不可靠的，通常会自行开发一个稳定的，HA 的高可用复制系统，称之为 DRC，即数据复制中心，主要处理多城市或多机房的数据复制。</p>
<p>其中，阿里云已经有商业版的 DRC ，即 DTS，支持数据同步，数据订阅，数据迁移。而其底层则是 otter + canal，已经开源，不过比较简陋，想上生产环境的话，还需要二次开发和优化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单的讨论了数据库的异地多活的方案，我们认为，在单元化的方案中，同步是核心，稳定的同步是保证数据一致的关键，而这，在单个机房中，只需要通过简单的 RPC 即可解决，但在跨机房，跨城市的网络中，就显得尤为复杂。</p>
<p>那么，如何打造一个高可用，低延迟，可靠的一致性，高吞吐的同步系统呢? </p>
<p>且听下次分享。</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Canal 源码走读</title>
    <url>/2019/02/25/2019/2019-02-26-canal-read/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span> 

<h2 id="Canal-源码走读"><a href="#Canal-源码走读" class="headerlink" title="Canal 源码走读"></a>Canal 源码走读</h2><p>canal 是什么？ 引用一下官方回答：</p>
<blockquote>
<p>阿里巴巴mysql数据库binlog的增量订阅&amp;消费组件</p>
</blockquote>
<p>canal 能做什么？</p>
<p>基于日志增量订阅&amp;消费支持的业务：</p>
<ol>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>多级索引 (卖家和买家各自分库索引)</li>
<li>search build</li>
<li>业务cache刷新</li>
<li>价格变化等重要业务消息</li>
</ol>
<p>比如 LZ 目前就使用 canal 实现数据实时复制，搜索引擎数据构建等功能。既然要使用，就好好的研究一下。</p>
<p>时间有限，一起来简单看看。</p>
<h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>关于 canla 的工作原理，我就不展开了，有兴趣的可以看看官方文档，或者这个 <a href="https://docs.google.com/presentation/d/1MkszUPYRDkfVPz9IqOT1LLT5d9tuwde_WC8GZvjaDRg/edit#slide=id.p16">ppt</a>.</p>
<p>说白了， canal 就是伪装成 mysql 的 slave，dump binlog，解析 binlog，然后传递给应用程序，总体还是蛮简单的。</p>
<p>好，我们来看看 canal 的代码架构。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/26/16928ee404944aa1?w=1240&h=400&f=png&s=53129"></p>
<p>我们看到，canal server 内部由几个模块组成， 最外部的是 Server，该 Server 接收 Canal Client 请求，并返回 Client 数据。一个 Server 就是一个 JVM。每个 Server 内部由多个 CanalInstance，每个 CanalInstance 其实就是我们设置的 destination，通常是一个数据库。</p>
<p>每个 CanalInstance 内部由 5 个模块，分别是 parser 解析，sink 过滤，store 存储，metaManager 元数据管理，Alarm 报警。</p>
<p>这 5 个模块是干嘛的呢？</p>
<p>简单说一下：</p>
<p>当 Canal Server 启动后，会根据配置启动 N 个 CanalInstance， 每个 CanalInstance 都会使用 socket 连接 mysql，dump binlog，然后将数据交给 parser 解析，sink 过滤，store 存储，当 client 连接时，会从 zk 上读取该 client 的信息，而  metaManager 元数据管理就是管理 zk（当然有多种实现，比如存储在文件中） 信息的，如果发生错误了，就调用 Alarm 发送报警信息（你可以接入自己公司的监控系统），目前是打印日志。</p>
<h2 id="Canal-启动流程"><a href="#Canal-启动流程" class="headerlink" title="Canal 启动流程"></a>Canal 启动流程</h2><p>canal 代码量目前有 6 万多行，去除 2 个 ProtocolBuffer 生成类大概 1.7 万行，也还有 4.3 万行，代码还是不少的。</p>
<p>启动过程也比较绕。这里我简单画了一个流程图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/26/16928ee796f049fe?w=991&h=565&f=png&s=70082"></p>
<p>解释一下这个图：</p>
<p>canal 脚本从 CanalLauncher main 方法启动，然后调用 CanalController 的 start 方法，CanalController 调用 InstanceConfigMonitor 的 start 方法，最后调用 canal 关键组件 CanalServerWithEmbedded 的 start 方法。</p>
<p>在 Canal 内部， 有 CanalServerWithEmbedded 和 CanalServerWithNetty，前者是没有 Server 端口的，是一个无端口的代理。后者是基于 Netty 实现的服务器，在 channelRead 方法中，会调用 CanalServerWithEmbedded 的相关方法。</p>
<p> CanalServerWithEmbedded 是单例的， 内部会有多个 CanalInstance， 他有多个实现，独立版本中使用的是 CanalInstanceWithSpring 版本，基于 Spring 管理组件的生命周期。</p>
<p> 每个 CanalInstance 内部有 5 个组件，也就是上面说的几个组件，他们会分别启动。</p>
<p> 其中，比较关键的是 parser，sink，store。</p>
<p> CanalEventParser 启动后，会启动一个叫做  parseThread 线程，不停的循环。主要是：构造与 mysql 的连接，然后启动心跳线程，然后开始 dump binlog。</p>
<p> dump 出来的 binlog 通过 disruptor 无锁队列发布，内部由 3 个消费者按照顺序消费 binlog，处理完之后，交给了 sink 模块。</p>
<p> 然后是 sink，这个比较简单，就不说了。sink 处理完之后，交给了 store 模块。</p>
<p> store 模式是一个类似 RingBuffer 的循环数组，存储着从 mysql dump 出来的数据，client 也是从这里获取数据的。该数组维护着 3 个指针，get，put， ack。</p>
<p> 这里比较奇怪的是，为什么不使用责任链模式够组装组件？</p>
<h2 id="Canal-数据流向"><a href="#Canal-数据流向" class="headerlink" title="Canal 数据流向"></a>Canal 数据流向</h2><p> 看了启动流程，再来看看 canal 内部运行的数据流向是什么样子的。我这里简单画了一个图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/26/1692903e4a9abaa1?w=823&h=697&f=png&s=65726"></p>
<p>独立版本的 Canal 使用 Netty 暴露端口，使用自己构造的 SessionHandler 处理 TCP 请求，SessionHandler 将请求交给 CanalServerWithEmbedded 来处理。</p>
<p>我们看 CanalServerWithEmbedded 的一些方法，例如 subscribe，get，ack 等，都是和 client 对应的方法，也就是说，CanalServerWithEmbedded 是和 client 打交道的一个类。</p>
<p>CanalServerWithEmbedded 内部管理所有的 CanalInstance，通过 Client 的信息，找到 Client 订阅的 CanalInstance，然后调用 CanalInstance 内部的 Store 模块，也就是那个 RingBuffer 的 get 方法，获取 RingBuffer 的数据。</p>
<p>从 Myslq 的角度看，MysqlConnection 从 Myslq dump 数据，交给 parser 解析，parser 解析完，交给 sink，sink 处理完，交给 store 保存，等待 client 前来获取。</p>
<p> 看完了数据流向，如果对哪里有什么疑问，就可以看看哪个模块对应的代码是什么，直接看是看就好了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 花了点时间看了看 Canal 的代码，总体上还是非常好的，只是有些地方有点疑问，例如 parser，sink，store 为什么不使用过滤器模式。</p>
<p> Client 和 CanalServerWithEmbedded 为什么不使用 RPC 的方式交互，这样更简单明了。</p>
<p> 代码里回调方法太多太长，影响阅读。</p>
<p> 但总体瑕不掩瑜，值得一读。</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>Java 中间件</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 三大知识点——索引、锁、事务</title>
    <url>/2019/03/16/2019/2019-03-16-mysql/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ### 1. 索引
索引，类似书籍的目录，可以根据目录的某个页码立即找到对应的内容。

<p>索引的优点：1. 天生排序。2. 快速查找。<br>索引的缺点：1. 占用空间。2. 降低更新表的速度。</p>
<p>注意点：小表使用全表扫描更快，中大表才使用索引。超级大表索引基本无效。</p>
<p>索引从实现上说，分成 2 种：聚集索引和辅助索引（也叫二级索引或者非聚集索引）</p>
<p>从功能上说，分为 6 种：普通索引，唯一索引，主键索引，复合索引，外键索引，全文索引。</p>
<p>详细说说 6 种索引：</p>
<p>1、普通索引：最基本的索引，没有任何约束。<br>2、唯一索引：与普通索引类似，但具有唯一性约束。<br>3、主键索引：<strong>特殊的唯一索引，不允许有空值</strong>。<br>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。<br>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。<br>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎（ES，Solr）。</p>
<ul>
<li><code>注意：主键就是唯一索引，但是唯一索引不一定是主键，唯一索引可以为空，但是空值只能有一个，主键不能为空。</code></li>
</ul>
<p>另外，InnoDB 通过主键聚簇数据，如果没有定义主键且没有定义聚集索引， MySql 会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个 6 字节的主键作为聚簇索引，用户不能查看或访问。</p>
<p>简单点说：</p>
<ol>
<li>设置主键时，会自动生成一个唯一索引，如果<strong>之前</strong>没有聚集索引，那么主键就是聚集索引。</li>
<li>没有设置主键时，会选择一个不为空的唯一索引作为聚集索引，如果还没有，那就生成一个隐式的 6 字节的索引。</li>
</ol>
<p>MySql 将数据按照页来存储，默认一页为 16kb，当你在查询时，不会只加载某一条数据，而是将这个数据所在的页都加载到 pageCache 中，这个其实和 OS 的就近访问原理类似。</p>
<p>MySql 的索引使用 B+  树结构。在说 B+ 树之前，先说说 B 树，B 树是一个多路平衡查找树，相较于普通的二叉树，不会发生极度不平衡的状况，同时也是多路的。</p>
<p>B 树的特点是：他会将数据也保存在非页子节点。</p>
<p>看图可知：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3c0198590f08aca9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自网络"></p>
<p>而这个特点会导致非页子节点不能存储大量的索引。</p>
<p>而 B+ Tree 就是针对这个对 B tree 做了优化。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-44f67d0d44470b51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自网络"></p>
<p>我们看到，B+ Tree 将所有的 data 数据都保存到了叶子节点中，非也子节点只保存索引和指针。</p>
<p>我们假设一个非页子节点是 16kb，每个索引，即主键是 bigint，即 8b，指针为 8b。那么每页能存储大约 1000 个索引（16kb/ 8b + 8b）.</p>
<p>而一颗 3 层的 B+树能够存储多少索引呢？如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b0874a8acbdee195.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>大约能够存储 10 亿个索引。通常 B+ 树的高度在 2-4 层，由于 MySql 在运行时，根节点是常驻内存的，因此每次查找只需要大约 2 -3 次 IO。可以说，B+ 树的设计，就是根据机械磁盘的特性来进行设计的。</p>
<p>知道了索引的设计，我们能够知道另外一些信息：</p>
<ol>
<li>MySql 的主键不能太大，如果使用 UUID 这种，将会浪费 B+ 树的非叶子节点。</li>
<li>MySql 的主键最好是自增的，如果使用 UUID 这种，每次插入都会调整  B+树，从而导致页分裂，严重影响性能。</li>
</ol>
<p>那么，如果项目中使用了分库分表，我们通常都会需要一个主键进行 sharding，那怎么办呢？在实现上，我们可以保留自增主键，而逻辑主键用来作为唯一索引即可。</p>
<h3 id="2-锁机制"><a href="#2-锁机制" class="headerlink" title="2. 锁机制"></a>2. 锁机制</h3><p>关于 Mysql 的锁，各种概念就会喷涌而出，事实上，锁有好几种维度，我们来解释一下。</p>
<h5 id="1-类型维度"><a href="#1-类型维度" class="headerlink" title="1. 类型维度"></a>1. 类型维度</h5><ul>
<li><p>共享锁（读锁 / S 锁）</p>
</li>
<li><p>排它锁（写锁 / X 锁）</p>
<p>  类型细分：</p>
<ul>
<li>意向共享锁</li>
<li>意向排他（互斥）锁</li>
</ul>
</li>
<li><p>悲观锁（使用锁，即 for update）</p>
</li>
<li><p>乐观锁（使用版本号字段，类似 CAS 机制，即用户自己控制。缺点：并发很高的时候，多了很多无用的重试）</p>
</li>
</ul>
<h5 id="2-锁的粒度（粒度维度）"><a href="#2-锁的粒度（粒度维度）" class="headerlink" title="2. 锁的粒度（粒度维度）"></a>2. 锁的粒度（粒度维度）</h5><ul>
<li>表锁</li>
<li>页锁（Mysql BerkeleyDB 引擎）</li>
<li>行锁（InnoDB）</li>
</ul>
<h5 id="3-锁的算法（算法维度）"><a href="#3-锁的算法（算法维度）" class="headerlink" title="3. 锁的算法（算法维度）"></a>3. 锁的算法（算法维度）</h5><ul>
<li>Record Lock（单行记录）</li>
<li>Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）</li>
<li>Next-Key Lock（Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身， MySql 防止幻读，就是使用此锁实现）</li>
</ul>
<h5 id="4-默认的读操作，上锁吗？"><a href="#4-默认的读操作，上锁吗？" class="headerlink" title="4. 默认的读操作，上锁吗？"></a>4. 默认的读操作，上锁吗？</h5><ul>
<li>默认是 MVCC 机制（“一致性非锁定读”）保证 RR 级别的隔离正确性，是不上锁的。</li>
</ul>
<p>可以选择手动上锁：select xxxx for update (排他锁); select xxxx lock in share mode(共享锁)，称之为“一致性锁定读”。</p>
<p>使用锁之后，就能在 RR 级别下，避免幻读。当然，默认的 MVCC 读，也能避免幻读。</p>
<p>既然 RR 能够防止幻读，那么，SERIALIZABLE 有啥用呢？</p>
<p>防止丢失更新。例如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-33cd8f28d4539270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这个时候，我们必须使用 SERIALIZABLE 级别进行串行读取。</p>
<p>最后，行锁的实现原理就是锁住聚集索引，如果你查询的时候，没有正确地击中索引，MySql 优化器将会抛弃行锁，使用表锁。</p>
<h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h3><p>事务是数据库永恒不变的话题， ACID：原子性，一致性，隔离性，持久性。</p>
<p>四个特性，最重要的就是一致性。而<strong>一致性</strong>由原子性，隔离性，持久性来保证。</p>
<ul>
<li>原子性由 Undo log 保证。Undo Log 会保存每次变更之前的记录，从而在发生错误时进行回滚。</li>
<li>隔离性由 MVCC 和 Lock 保证。这个后面说。</li>
<li>持久性由  Redo Log 保证。每次真正修改数据之前，都会将记录写到 Redo Log 中，只有  Redo Log 写入成功，才会真正的写入到 B+ 树中，如果提交之前断电，就可以通过 Redo Log 恢复记录。</li>
</ul>
<p>然后再说隔离性。</p>
<p>隔离级别：</p>
<ol>
<li>未提交读（RU）</li>
<li>已提交读（RC）</li>
<li>可重复读（RR）</li>
<li>串行化（serializable）</li>
</ol>
<p>每个级别都会解决不同的问题，通常是3 个问题：脏读，不可重复读，幻读。一张经典的图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-74511fa0e3e26bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里有个注意点，关于幻读，在数据库规范里，RR 级别会导致幻读，但是，由于 Mysql 的优化，MySql 的 RR 级别不会导致幻读：在使用默认的 select 时，MySql 使用 MVCC 机制保证不会幻读；你也可以使用锁，在使用锁时，例如 for update（X 锁），lock in share mode（S 锁），MySql 会使用 Next-Key Lock 来保证不会发生幻读。前者称为快照读，后者称为当前读。</p>
<p>原理剖析：</p>
<ul>
<li>RU 发生脏读的原因：RU 原理是对每个更新语句的行记录进行加锁，而不是对整个事务进行加锁，所以会发生脏读。而 RC 和 RR 会对整个事务加锁。</li>
<li>RC 不能重复读的原因：RC 每次执行 SQL  语句都会生成一个新的 Read View，每次读到的都是不同的。而 RR 的事务从始至终都是使用同一个 Read View。</li>
<li>RR 不会发生幻读的原因： 上面说过了。</li>
</ul>
<p>那 RR 和 Serializble 有什么区别呢？答：丢失更新。本文关于锁的部分已经提到。</p>
<p>MVCC 介绍：全称多版本并发控制。</p>
<p>innoDB 每个聚集索引都有 4 个隐藏字段，分别是主键（RowID），最近更改的事务 ID（MVCC 核心），Undo Log 的指针（隔离核心），索引删除标记（当删除时，不会立即删除，而是打标记，然后异步删除）；</p>
<p>本质上，MVCC 就是用 Undo Log 链表实现。</p>
<p>MVCC 的实现方式：事务以排它锁的方式修改原始数据，把修改前的数据存放于 Undo Log，通过回滚指针与数据关联，如果修改成功，什么都不做，如果修改失败，则恢复 Undo Log 中的数据。</p>
<p>多说一句，通常我们认为  MVCC 是类似乐观锁的方式，即使用版本号，而实际上，innoDB 不是这么实现的。当然，这不影响我们使用 MySql。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/XwC9n2Ik_DrfY-ERd99wqA">https://mp.weixin.qq.com/s/XwC9n2Ik_DrfY-ERd99wqA</a></p>
<p><a href="https://mp.weixin.qq.com/s/V9nuZ-TNSI_avMVbCd1T7Q">https://mp.weixin.qq.com/s/V9nuZ-TNSI_avMVbCd1T7Q</a></p>
<p><a href="https://www.imooc.com/article/17290">https://www.imooc.com/article/17290</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>软件架构概念</title>
    <url>/2019/04/13/2019/2019-04-13-architecture/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       “你对架构这个词怎么理解？”

<p>emm …..</p>
<p>实际上，软件架构分成 2 派。</p>
<h2 id="1-软件架构的派别"><a href="#1-软件架构的派别" class="headerlink" title="1 软件架构的派别"></a>1 软件架构的派别</h2><ol>
<li>组成派<br>组成派的定义非常简洁。<br>定义：软件系统的架构将系统描述为计算组件及组件之间的交互。</li>
</ol>
<p>剖析定义：<br>a. 该架构关注架构实践中的客体——软件，以软件本身为描述对象。<br>b. 分析了软件的组成，即软件由承担不同任务的组件组成，这些组件通过相关交互，完成更高层次的计算。</p>
<ol start="2">
<li>决策派<br>决策派的定义相对于组成派的定义，要繁杂很多。但核心思想非常明确：<strong>软件架构是在一些重要方面所做出的决策的集合</strong>。</li>
</ol>
<p>定义（软件架构包含了关于以下问题的重要决策）：</p>
<ul>
<li>软件系统的组织</li>
<li>选择成为系统的结构元素和他们之间的接口，以及当这些元素相互协作时所体现的行为。</li>
<li>如何组合这些元素，使他们逐渐合并成更大的子系统。</li>
<li>用于指导这个系统的架构风格：这些元素以及它们的接口、协作和组合。</li>
<li>软件架构并不仅仅注重软件本身的结构和行为，还注重其他特性：使用、功能性、性能、弹性、重用、可理解性、经济和技术的限制及权衡，以及美学等。</li>
</ul>
<h2 id="2-组成派、决策派-概念解析"><a href="#2-组成派、决策派-概念解析" class="headerlink" title="2 组成派、决策派 概念解析"></a>2 组成派、决策派 概念解析</h2><h4 id="组成派："><a href="#组成派：" class="headerlink" title="组成派："></a>组成派：</h4><blockquote>
<p>架构设计是分与合的艺术。</p>
</blockquote>
<p>架构 = 组件 + 交互。</p>
<p>我们举例 MVC 架构：<br> V 创建 C，C 根据用户交互调用 M 的相关服务，而 M 将自身的改变通知 V，V 通过交互读取 M 的信息以更新自身。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ed69ac67a783f613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组成派"></p>
<h4 id="决策派"><a href="#决策派" class="headerlink" title="决策派"></a>决策派</h4><p>架构属于设计，但设计不一定属于架构。架构设计的决策，将对整体质量、并行开发、适应变化等方面有着重大影响，例如：</p>
<ul>
<li>模块如何划分</li>
<li>每个模块的职责如何</li>
<li>每个模块的接口如何定义</li>
<li>模块间采用何种交互机制</li>
<li>开发技术如何选型</li>
<li>如何满足约束和质量属性的需求</li>
<li>如何适应可能发生的变化</li>
</ul>
<p>这里假设我们设计一个 C/S 系统，会有一个决策树：</p>
<ol>
<li>决定采用 C/S 架构，包含 Client 和 Server</li>
<li>决定将 Server 分成 3 层</li>
<li>决定将 Server 的引擎层划分成  N 个模块</li>
<li>决定  …..</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-840efd4559ebbd28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="决策派"></p>
<p>可以看出，决策，就是一步步递归，将大任务，通过一个个合理的决策，划分成一个个小任务。是不是类似 fork join 呢？</p>
<p>另外，从上面也可以看出，不是只有大系统才有架构，小的模块，小的系统也有架构。因此，在平时编写代码时，即使自己负责的系统很小，也要关心，设计好他的架构。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是组成派，还是决策派，在架构设计中，我们都会涉及，只是站的角度不同罢了，前者站在软件的角度，后者站在决策人的角度。<br>例如：<br>当我们决定对模块如何进行划分的时候，这个时候，是决策派。<br>当我们设计模块边界的时候，是组成派。<br>当我们对模块之间的交互接口进行设计的时候，就是组成派。<br>当我们考虑易用性，代码美学，灵活性的时候，是决策派。<br>……</p>
<p>最后，管他什么派，只是角度不同罢了，好的架构，我认为是这样的：模块边界清晰，依赖合理，弹性灵活，性能优越，易于理解。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>软件架构设计——温昱</p>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>软件架构视图介绍</title>
    <url>/2019/04/13/2019/2019-04-13-architecture2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       > 有角度就有空间。多视图方法背后的核心思想有些类似：从不同角度，规划“分割”与“交互”。

<h2 id="1-软件架构为谁设计？"><a href="#1-软件架构为谁设计？" class="headerlink" title="1 软件架构为谁设计？"></a>1 软件架构为谁设计？</h2><p>什么是软件架构？不同的角色有不同的看法。</p>
<p>程序员：软件架构就是决定编写哪些类，使用哪些库和框架。<br>程序经理：软件架构就是模块的划分和接口的定义。<br>系统分析员：软件架构就是业务领域对象的关系建模。<br>配置管理员：软件架构就是开发出来的以及编译过后的软件到底是个啥结构。<br>DBA：软件架构规定了持久化数据库的结构，其他一切只不过是对数据的操作而已。<br>运维：软件架构规定了软件部署到硬件的策略。<br>用户：软件架构应该是将系统划分为一个个功能子系统。</p>
<p>以上，就是从不同的视角得到的不同的软件架构视图。而架构师需要为不同社众的需求而设计。</p>
<p>架构视图的本质是“分而治之”，能帮助架构师从不同角度设计，特别是面对复杂系统时，“分而治之”的设计是必须的。</p>
<h2 id="2-如何设计？"><a href="#2-如何设计？" class="headerlink" title="2 如何设计？"></a>2 如何设计？</h2><p>1 为用户设计。<br>为什么开发一个软件？因为要给用户使用，或者辅助用户完成工作，或者为用户提供娱乐等等。</p>
<p>用户要功能，也要质量，缺一不可。</p>
<p>架构师必须牢记：为用户而设计。</p>
<p>同时，诸如性能，易用性等软件质量属性，并不像“软件功能”那样直接帮助用户达到特定目标，但也非常重要。例如，如果你开发一个查询余额功能，查询一次需要一分钟，虽然能得到结果，但用户肯定无法接受。</p>
<p>因此，架构师必须牢记：为用户设计的同时，不仅要满足用户要求的功能，也要达到用户期望的质量。</p>
<p>2 为客户而设计</p>
<p>很多时候，用户 不等于 客户。</p>
<p>例如，开发一个商场收银系统，很明显，客户是商场老板，用户是商场收银员。</p>
<p>架构师需要为客户而设计：充分考虑客户的业务目标、上线时间的需求，预算限制，以及集成需要等，还要特别关注客户所在领域的业务规则和业务限制。</p>
<p>例如：如果客户是一家小型超市，那么就不应该使用那种需要昂贵的设备和搞性能中间件的架构方案。</p>
<p>3 为开发者设计</p>
<p>开发流程中，一般先研究需求，再设计架构，然后交给开发人员编程……作为架构，不仅要为“上游”的需求而设计，还要为“下游” 的开发人员而设计。</p>
<p>例如，性能是软件运行期间的重要属性，也是重要的的质量属性，最关心性能的人其实是客户；</p>
<p>程序员最关心什么？可扩展性。可扩展性也是软件开发期间的重要质量属性。</p>
<p>不只是可扩展性，还有可重用性，可移植性，易理解性，易测试性等，都是开发人员关心的。</p>
<p>架构师必须牢记：为了使开发流程更顺畅，必须为开发者设计。</p>
<p>4 为管理人员设计</p>
<p>软件越来越复杂，单兵作战已经很少了，取而代之的是团队开发，而团队开发反过来又导致软件开发更加复杂，因此，现在不仅仅是软件复杂的问题，还有管理复杂的问题。</p>
<p>开发人员之间的依赖，源自他们负责的程序之间的依赖，要理清并管理好协作，就应该搞清楚系统一级“模块 + 交互”的设计，搞清楚架构。可见，架构是开发管理的核心基础。</p>
<p>就软件项目管理而言，软件架构应当起到应有的作用：<strong>为项目经理指定项目计划、管理项目分工和考核进度等提供依据。</strong></p>
<p>一方面：软件架构应该从大局着手，就技术方面的重大问题作出决策，构造一个由粗粒度模块组成的解决方案，从而把不同模块分配给不同的小组分别开发。<br>另一方面：软件架构应当规定各个模块如何交互的机制和接口，在开发小组之间，起到“沟通桥梁”和“合作契约” 的作用。</p>
<p>5 小结</p>
<p>架构师在设计架构时，应该要考虑到不同的角色，使<code>架构</code>满足<code>包含了关于如何构建软件的一些最重要的设计决策</code>的定义。</p>
<p>如下图：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-0f5c13f1bdbeafc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="3-什么是架构视图"><a href="#3-什么是架构视图" class="headerlink" title="3 什么是架构视图"></a>3 什么是架构视图</h2><p>为什么提供多个架构视图？</p>
<ul>
<li>架构要涵盖的内容和决策太多了，超过了人脑“一撮而就” 的能力范围，因此采用“ 分而治之” 的办法从不同视角分别设计。</li>
<li>同时，也为了软件架构的理解，交流和归档提供了方便。</li>
</ul>
<p>在多种架构视图中，最常用的是逻辑架构视图和物理架构视图。</p>
<p>1 什么是逻辑架构视图？</p>
<p>软件的逻辑架构视图，规定了软件系统由哪些逻辑元素组成，以及这些逻辑元素之间关系。</p>
<p>软件逻辑架构的核心任务，是比较全面的识别模块，规划接口，并基于此进一步明确模块之间的使用关系和使用机制。通常，一个软件的 UML 类图，就是他的逻辑架构。</p>
<p>2 什么是物理架构视图？</p>
<p>说白了，就是由哪些物理元素组成，以及这些物理元素是如何交互的。</p>
<p>物理架构可以反映出软件系统动态运行时的组织情况，通常物理元素就是进程、线程、类的实例对象等，而进程之间的调度，线程同步，进程/线程通信等，则进一步反映出物理架构的动态行为。</p>
<p>3 如何设计一个 逻辑视图 + 物理视图 的软件架构？</p>
<p>架构设计，将会指导后续的详细设计和编程，而详细设计和编程，这会贯彻和利用这些设计：</p>
<p>a 首先设计逻辑架构，体现为，层、功能子模块和模块等的划分决策，有了模块划分，比如产生协作，逻辑接口还要规定这些模块之间如何进行交互，因此还要设计交互接口。</p>
<p>b 所谓交互，指不同模块之间的沟通和通信，一般有几种方式：方法调用、RPC 远程调用，消息机制。</p>
<p>c 物理架构，关注软件在运行时期的情况，物理架构规定了软件系统如何利用进程和线程完成期望的并发处理，进程线程这些主动单元会调用哪些被动单元，消息直接的交互如何处理等等。这些设计，将会为后续编程实现提供基础。</p>
<p>具体过程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f0345619635eae07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="4-架构设计流程实战"><a href="#4-架构设计流程实战" class="headerlink" title="4 架构设计流程实战"></a>4 架构设计流程实战</h2><p>设计技巧：<br>先有需求，再有用例，通过分而治之和迭代式设计，设计第一版本的逻辑视图，有了逻辑视图，再设计第一版本的物理视图，再根据第一版本的物理视图设计 第二版本的逻辑视图</p>
<p>1 用例设计（需求设计）<br>2 逻辑架构设计版本 1<br>3 物理架构设计版本 1<br>4 逻辑结构设计版本 2<br>5 物理架构设计版本 2<br>6 逻辑架构设计版本 n…..<br>7 逻辑架构设计版本 n…..</p>
<p>假设我们现在有个需求：设计一个邮件代理服务器，并且提供后台管理功能。</p>
<p>根据上面的流程, 先来个用例图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-83bd9d72542eb456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>逻辑视图 版本 1</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-bdc992a557e2fefc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>物理视图 版本 1</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6e9f6c151bf81332.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>逻辑视图 版本 2</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-54fe023f7230725a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>物理视图 版本 2 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-996543cc9dd4370e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>到这里，我们就基本完成了一个 逻辑视图 + 物理视图的 架构设计。</p>
<p>我们通过分而治之，迭代式设计的方式，让逻辑架构设计和物理架构设计交替进行，不断验证，促进设计优化，从而完成架构设计。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>软件架构设计——温昱</p>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ 发送消息（一条消息从发送到存储的过程）</title>
    <url>/2019/05/08/2019/2019-05-09-rmq-sendmsg/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       
目录:
* 前言
* quickStart
* 单刀直入
* Remoting 模块发送消息实现
* 如何处理返回值
* Broker Server 处理消息流程

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RocketMQ 目前在国内应该是比较流行的 MQ 了，楼主目前也在使用中，今天借着本文，理理 RocketMQ 发送一条消息到存储一条消息的过程。</p>
<p>注意：本文主线是发送到存储，因此，阅读源码时，其他和这条线相关度不高的代码，会酌情阅读。另外，本文的目的是为了看清一条消息是如何被发出且被存储的，代码中，关于 MQ 文件系统的优化，设计等，并不会花很多篇幅介绍。</p>
<h2 id="quickStart"><a href="#quickStart" class="headerlink" title="quickStart"></a>quickStart</h2><p>来自官方源码 example 的一段发送代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ProducerGroupName&quot;</span>);</span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;OrderID188&quot;</span>, <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>

<h2 id="单刀直入"><a href="#单刀直入" class="headerlink" title="单刀直入"></a>单刀直入</h2><p>我们直接看看 send 方法。</p>
<p>send 方法会设置一个默认的 timeout， 3 秒。<br>默认使用 SYNC 模式，另外有 Async 和 OneWay 模式。<br>我们需要处理方法签名中的 Client 端的异常，网络异常，Broker 端的异常，线程中断异常。</p>
<p>DefaultMQProducerImpl # sendDefaultImpl 方法就是发送的主要逻辑。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2uotxd3rbj30ig0hcdgf.jpg"></p>
<p>这端代码里，有个有趣的地方，可以提一下，关于更新故障时间的策略，RMQ 有一个类 MQFaultStrategy，用来处理 MQ 错误，然后对 MQ Server 进行服务降级。</p>
<p>对照图:</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2uoza9kz9j30c2068a9x.jpg"></p>
<p>这个策略具体内容：如果发送一条消息在 550 毫秒以内，那么就不用降级，如果 550 毫秒以外，就进行容错降级（熔断）30 秒，以此类推。<br>再看 DefaultMQProducerImpl # sendKernelImpl 发送到内核的方法实现。</p>
<p>先找到 broker 的地址。尝试压缩大于 4M 的消息（批量消息不压缩）。执行各种钩子。构造 Request 对象（存放数据），Context 上下文对象（存放调用上下文）。</p>
<p>这里会设置一个消息生成时间，即 bornTimestamp。后面使用消息轨迹的时候，可以查看。</p>
<p>最后，如果是 SYNC 模式，就调用 MQClientAPIImpl 来发送消息，这一层还是在 Client 模块里，在这一层，会设置更详细的消息细节，构造命令对象。最后调用 remotingClient # invokeSync 发送消息。</p>
<p>注意，在 MQClientAPIImpl # sendMessage 这一层，会给命令对象设置一个 CmdCode，叫 SEND_MESSAGE，这个东西就是一个和 Broker 的契约，Broker 会根据这个 Code 进行不同的策略。另外，如果这里用 RPC 的方式，例如，使用一个接口的抽象方法，然后 Broker 对抽象方法进行 RPC 调用，这样可不可以呢？</p>
<p>最后，看看 remotingClient # invokeSync 是如何实现的。</p>
<h2 id="Remoting-模块发送消息实现"><a href="#Remoting-模块发送消息实现" class="headerlink" title="Remoting 模块发送消息实现"></a>Remoting 模块发送消息实现</h2><p>invokeSync 方法首先执行  RPCBefore 钩子，类似 Spring 的各种 Bean 扩展组件，然后就是对超时进行判断。可以看到，每个方法几乎都有对超时的判断，超时判断和超时处理在分布式场景非常重要。</p>
<p>然后根据 addr 找到对应的 Socket Channel。然后执行 invokeSyncImpl 方法。</p>
<p>这里其实和其他大部分的 RPC 框架都是类似的了，生产一个永远自增的 Request ID，创建一个 Feature 对象，和这个 ID 绑定，方便 Netty 返回数据对这个 ID 对应的线程进行唤醒。<br>然后调用 Netty 的 writeAndFlush 方法，将数据写进 Socket，同时添加一个监听器，如果发送失败，唤醒当前线程。</p>
<p>发送完毕之后，当前线程进行等待，使用 CountDownLatch.wait 方法实现，当 Netty 返回数据时，使用 CountDownLatch.countDown 进行唤醒，然后返回从 Broker 写入的结果，可能成功，也可能失败，需要到上层（Client 层）解析，网络层只负责网络的事情。</p>
<p>我们知道， Netty 会使用 Handler 处理出去的数据和返回的数据，我们看看 Client 端 Netty 有哪些 Handler.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bootstrap handler = <span class="keyword">this</span>.bootstrap.group(<span class="keyword">this</span>.eventLoopGroupWorker).channel(NioSocketChannel.class)</span><br><span class="line">            .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">            .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">false</span>)</span><br><span class="line">            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, nettyClientConfig.getConnectTimeoutMillis())</span><br><span class="line">            .option(ChannelOption.SO_SNDBUF, nettyClientConfig.getClientSocketSndBufSize())</span><br><span class="line">            .option(ChannelOption.SO_RCVBUF, nettyClientConfig.getClientSocketRcvBufSize())</span><br><span class="line">            .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="keyword">if</span> (nettyClientConfig.isUseTLS()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> != sslContext) &#123;</span><br><span class="line">                            pipeline.addFirst(defaultEventExecutorGroup, <span class="string">&quot;sslHandler&quot;</span>, sslContext.newHandler(ch.alloc()));</span><br><span class="line">                            log.info(<span class="string">&quot;Prepend SSL handler&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            log.warn(<span class="string">&quot;Connections are insecure as SSLContext is null!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pipeline.addLast(</span><br><span class="line">                        defaultEventExecutorGroup,</span><br><span class="line">                        <span class="keyword">new</span> NettyEncoder(),</span><br><span class="line">                        <span class="keyword">new</span> NettyDecoder(),</span><br><span class="line">                        <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, nettyClientConfig.getClientChannelMaxIdleTimeSeconds()),</span><br><span class="line">                        <span class="keyword">new</span> NettyConnectManageHandler(),</span><br><span class="line">                        <span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>


<p>我们看到，这里使用了一个 Encoder，Decoder，空闲处理器，连接管理器，ClientHandler。</p>
<p>XXCoder 就是对 Cmd 对象进行序列化和反序列化的。这里的空闲使用的读写最大空闲时间为 120s，超过这个，就会触发空闲事件。RMQ 就会关闭 Channel 连接。而针对空闲事件进行处理的就是连接管理器了。</p>
<p>连接管理器处理空闲、Close、Connect、异常等事件，使用监听器模式，不同的监听器对不同的事件进行处理。另外，这里也许可以借鉴 EventBus，每个事件可以设置多个监听器。</p>
<h2 id="如何处理返回值"><a href="#如何处理返回值" class="headerlink" title="如何处理返回值"></a>如何处理返回值</h2><p>我们看了 RMQ 中 Netty 的设计，再看看返回值处理就简单了，NettyClientHandler 会在 channelRead0 方法处理 Netty Server 的返回值。对应 RMQ，则是 processMessageReceived 方法。该方法很简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessageReceived</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RemotingCommand cmd = msg;</span><br><span class="line">        <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> REQUEST_COMMAND:</span><br><span class="line">                    processRequestCommand(ctx, cmd);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RESPONSE_COMMAND:</span><br><span class="line">                    processResponseCommand(ctx, cmd);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>

<p>其实，这是一个模板方法，固定算法，由子类实现，分为 Request 实现和 Response 实现。我们看看 Response 实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResponseCommand</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> opaque = cmd.getOpaque();</span><br><span class="line">        <span class="comment">// 找到 Response .</span></span><br><span class="line">        <span class="keyword">final</span> ResponseFuture responseFuture = responseTable.get(opaque);</span><br><span class="line">        <span class="keyword">if</span> (responseFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">            responseFuture.setResponseCommand(cmd);</span><br><span class="line"></span><br><span class="line">            responseTable.remove(opaque);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (responseFuture.getInvokeCallback() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                executeInvokeCallback(responseFuture);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 返回结果</span></span><br><span class="line">                responseFuture.putResponse(cmd);</span><br><span class="line">                responseFuture.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;receive response, but not matched any request, &quot;</span> + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));</span><br><span class="line">            log.warn(cmd.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里，通过 cmd 对象的 Request ID 找到 Feature,执行 responseFuture.putResponse，设置返回值，唤醒阻塞等待的发送线程。这里还有一个 release 调用，这个和异步发送有关，默认最大同时 65535 个异步请求，具体就不展开了。</p>
<p>好，到这里，唤醒阻塞的发送线程，返回数据，客户端层面的发送就结束了，我们小结一下。根据模块层次，我们记录一下 sendMessage 的过程：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2urdndmakj30la0e7mxe.jpg"></p>
<p>层次还是比较清晰的。</p>
<p>我们再来看看 Server 端如何处理一条消息的。</p>
<h2 id="Broker-Server-处理消息流程"><a href="#Broker-Server-处理消息流程" class="headerlink" title="Broker Server 处理消息流程"></a>Broker Server 处理消息流程</h2><p>从哪里入手呢？</p>
<p>我们上面看源码，看到有个 SEND_MESSAGE Code，是 Client 和  Broker Server 的一个约定代码，我们看看这个代码在哪里用的。</p>
<p>在 broker 模块的 BrokerController 类中，有个 registerProcessor 方法，会将 SEND_MESSAGE Code 和一个 SendMessageProcessor 对象绑定。</p>
<p>这一步我们停一下，再去看看 netty Server 端的 Handler。</p>
<p>NettyRemotingServer 是处理 Request 的类，他的 ServerBootstrap 会在 pipeline 中添加一个 NettyServerHandler 处理器，这个处理器的 channelRead0 方法会调用 NettyRemotingServer 的父类 processMessageReceived 方法。</p>
<p>这个方法会从 processorTable 里，根据 Cmd Code，也就是 SEND_MESSAGE 获取对应的 Processor， Processor 由 2 部分组成，一部分是处理数据的对象，一部分是这个对象所对应的线程池。用于异步处理逻辑，防止阻塞 Netty IO 线程。</p>
<p>关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doBeforeRpcHooks(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), cmd);</span><br><span class="line"><span class="keyword">final</span> RemotingCommand response = pair.getObject1().processRequest(ctx, cmd);<span class="comment">// 处理.</span></span><br><span class="line">doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), cmd, response);</span><br></pre></td></tr></table></figure>

<p>前后都是执行一些钩子，例如 ACL 啥的。</p>
<p>这里我们小结一下，RMQ 会有一个 BrokerController 类，会注册 Code 和 Processor 的绑定关系，BrokerController 也会把这些绑定，注册到 Netty Server 中，当 Netty Server 从 Socket 收到 Cmd 对象，根据 Cmd 对象的 Code，就可以找到对应 Processor 类，对数据进行处理。</p>
<p>中间是处理 Request 请求的。这个 processRequest 方法，有很多的实现，如下图，我们主要看 SendMessageProcessor 的实现。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2urptryj8j31qs0eujsv.jpg"></p>
<p>SendMessageProcessor # sendMessage 是处理消息的主要逻辑。</p>
<p>关键代码：<br>putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);</p>
<p>消息存储引擎，这里我们看 DefaultMessageStore 的 putMessage 实现。</p>
<p>首先一堆校验。注意，其中有一个地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;<span class="comment">// 检查 mmp 忙不忙.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 RMQ 写数据是王 PageCache 里面写的，因此，如果写的慢，就是 PageCache 忙，这里忙的标准是，如果锁文件的时间，超过了 1 秒，那就是忙。</p>
<p>最后调用 PutMessageResult result = this.commitLog.putMessage(msg) 写数据。</p>
<p>如果耗时超过 500 毫秒，就会打印日志。这样我们排查问题的时候，可以看看 storeStats 的日志。</p>
<p>看看 commitLog 的 putMessage 方法实现。</p>
<p>先拿到最新的 MappedFile 文件，MappedFile 文件的命名是用 offset 命名的，一个文件默认 1gb，这个大小和 mmp 的机制有关，通常不能过大。</p>
<p>然后上锁，这段代码是可以说整个 RMQ Server 的热点区域，</p>
<p>这里上锁会记录上锁的时间，方便前面做 PageCache Busy 的判断。</p>
<p>写入代码：</p>
<p>result = mappedFile.appendMessage(msg, this.appendMessageCallback)</p>
<p>写完之后，释放锁，如果超过 500 毫秒，打印 cost time 日志。</p>
<p>统计。</p>
<p>处理刷盘和slave 同步，这里看刷盘策略和同步策略，是 SYNC 还是 ASYNC。</p>
<p>经过我的测试，同步刷盘和异步刷盘的性能差距是 10 倍。<br>而 Slave 的数据同步，如果用 SYNC 模式，tps 最高也就 2000 多一丢度，为什么？内网，两台机器 ping 一下都要 0.2 毫秒，一秒最多 5000 次，再加上处理逻辑， 2000 已经到顶了，网络成了瓶颈。</p>
<p>如果用全异步的话，我的 4c8g 的机器，单机 tps 最高能  2 万多。美滋滋。</p>
<p>跑题了。</p>
<p>我们看看  mappedFile.appendMessage 方法的实现。</p>
<p>一路追踪，有个关键逻辑， 在 appendMessagesInner 里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">    ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">    byteBuffer.position(currentPos);</span><br><span class="line">    AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">        <span class="comment">// 写数据到 缓存</span></span><br><span class="line">        result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">        result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">    <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>代码中，使用了 mappedFile 从 Linux 映射的 MMap buffer，对数据进行写入。我们看看 doAppend 方法。</p>
<p>我们可以看到，一条消息有太多的内容：<br>总长度、魔数、CRC 校验、队列 ID、各种 flag、存储时间，物理 offset、存储 IP、时间戳、扩展属性等等。</p>
<p>最终，这条消息会被写入到 MMap 中。</p>
<p>那什么时候刷盘呢？</p>
<p>如果是 SYNC 模式，执行 CommitLog 的 handleDiskFlush 的方法时，就会立刻刷盘并等待刷盘结果。<br>如果是 ASYNC 模式，执行  CommitLog 的 handleDiskFlush 的方法时，会通知异步线程进行刷盘，但不等待结果。</p>
<p>另外，如果没有新数据，则为 500ms 执行一次刷盘策略。</p>
<p>简单说下异步刷盘：</p>
<ol>
<li>默认刷盘 4 页，Linux 一页是  4kb 数据，4页就是 16kb。</li>
<li>如果写的数据减去已经刷的数据，剩下的数据大于等于 4 页，就执行刷盘.</li>
<li>执行 mappedByteBuffer.force() 或者 fileChannel.force(false);</li>
</ol>
<p>我们这里小结一下，看看 RMQ Server 处理处理一条消息的：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2uukmxvzej30o50g0dg0.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>来张大图总结一下。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2uv1yq5hpj30ot0nxt97.jpg"></p>
<p>篇幅有限，下篇再一起看看 RMQ 如何消费消息。</p>
]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
  </entry>
  <entry>
    <title>重庆跨年</title>
    <url>/2018/12/31/2019/2019-01-01-%E9%87%8D%E5%BA%86%E8%B7%A8%E5%B9%B4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>2018 即将过去，去了一趟重庆 “了结” 了 2018. 迎战 2019.</p>
<h2 id="行程规划"><a href="#行程规划" class="headerlink" title="行程规划"></a>行程规划</h2><p>2018-12.29 早上7点飞机从杭州出发，中午 10 点到重庆。</p>
<p>2019-1.1 晚上 8点 45 从重庆出发，23 点半到杭州萧山机场。</p>
<p>很明显，跨了个年。</p>
<h2 id="第一天-12-29"><a href="#第一天-12-29" class="headerlink" title="第一天 12-29"></a>第一天 12-29</h2><p>早上4点半就起床，坐昨天晚上预约的出租车到了萧山机场，花了150，相比回来做机场大巴才65，有点肉疼。</p>
<p>10 点多到了重庆，用高德打车去酒店，很快，就有一个重庆师傅接单，高德打车很方便，并发使用多个司机端，例如同程，曹操，首汽等等，比单纯用滴滴快很多。</p>
<p>酒店在洪崖洞附近，离解放碑很近，离机场大概 20 公里。</p>
<p>从机场到酒店的路上，和司机师傅侃了一路，算是从当地人口中了解了一丢丢重庆，从车窗外望去，感觉重庆的楼普遍都很高，似乎没见到 6 层的“低层”住宅，基本都是高层建筑，大概是因为重庆山多，盖房子的地基不多，因此需要最大化的利用地基。甚至路上还看到了 20 年前的20多层的高层。</p>
<p>到酒店后，由于酒店名字从英文变成中文（2个月前定的酒店），差点没找到，😅 [汗]。我们的房间在 24 层，侧着身子可以看到一点点嘉陵江。</p>
<p>放下行李后， 差不多 11 点多，外面下着小雨，不过看天气预报，未来几天是多云天气，还好不下雨，不然就僵住了。</p>
<p>虽然下着小雨，依然挡不住我们的热情。</p>
<p>看了一下地图，准备去离这里比较近的“洪崖洞”—— 传说洪崖洞的夜景类似千与千寻。然后询问酒店工作人员怎么走，酒店工作人员告知，电梯走到 22 楼，然后出大门，径直走就能到洪崖洞了。。。。。</p>
<p>什么？22 楼下去，就直接到洪崖洞了？</p>
<p>难道洪崖洞在 22 楼？其实来重庆之前，就听说重庆是 3D 魔幻城市。只不过这次切切实实的体验了一把 3D 魔幻。</p>
<p>雨不是很大，我们走了大概 20 分钟，就到了洪崖洞，吃了碗酸辣粉，逛了洪崖洞里面的一些店。也到外面的瀑布前拍了照片。整体感觉一般般。其实，洪崖洞最美的还是晚上，当灯光亮起，确实有一些“千与千寻”的味道。</p>
<p>看了看时间，时间还很早，离开洪崖洞，来到了解放碑 —— 重庆跨年的核心地带，只不过此时没几个人。</p>
<p>然后来到了著名的八一美食街，有很多重庆的特色美食，不像其他的一些旅游景点，都是一些连锁小吃，毫无特色。</p>
<p>点了一份小汤圆，一份鸡爪，几串烤串，加上之前吃的酸辣粉，真的很撑了。然后开始逛解放碑的苹果直营店，里面全是小孩子，拿着 iPhone 在打王者，工作人员也不阻拦，很友好。试了一下全新的 iPad Pro，真的很强大，就是太贵了，虽然很强大，但还是替代不了笔记本。</p>
<p>逛的差不多到 5 点，另几个朋友就都陆陆续续到了，约好 6 点半去吃火锅。</p>
<p>火锅店选在解放碑附近，叫洞府老火锅，我们一行七个人，坐在三楼，点了2 个红汤火锅，整体感觉还没有连锁店好吃，例如小龙侃这种。不过，主要还是吃个氛围。</p>
<p>边吃火锅，边喝啤酒，边吹牛，感觉甚是不错，甚至还有点上头的感觉。哈哈。</p>
<p>喝完酒，由于去过一次洪崖洞，便做起了导游，带大家去逛逛晚上的洪崖洞，果然，风景确实很美，特别是站在嘉陵江边，看着灯火阑珊的房子，有些伤感。</p>
<p>看完洪崖洞，拍完照，就各自回家了，此时已经 10 点了，步行回到旅馆，大概 20 分钟。</p>
<h2 id="第二天-12-30"><a href="#第二天-12-30" class="headerlink" title="第二天 12-30"></a>第二天 12-30</h2><p>今天原本准备租一辆 7 座的车子自驾游，但由于各种原因，最后还是选择用脚步丈量重庆，整个路线依次为解放碑，朝天门，长江缆车，磁器口，轻轨穿楼，吃晚饭。</p>
<p>看的出来，今天去的地方挺多的，解放碑就是简单的过了一下，朝天门也没啥，就是不太好找，问路问了一路，然后吃个面，准备做长江索道，不得不说，索道真的一点意思都没有，大概也就是一点纪念意义了吧，在没有长江大桥之前，重庆人民都是通过索道过江的。</p>
<p>虽然买的往返长江索道票，但我们没有回去，而是直接打车去了磁器口，磁器口是个古镇，离市区20公里左右，叫了一辆滴滴，车牌和注册的竟然不一样。不过问题不大。</p>
<p>磁器口和其他地方的古镇都类似，已经去的太多了，麻木了，没什么好说的。</p>
<p>然后做地铁看轻轨穿楼，这个应该是今天最美的风景了，轻轨沿着江边飞驰，正好是晚上，江上的游轮亮起灯光，江边的建筑群也亮起灯光，很美。轻轨穿楼其实在重庆市很普遍的事情，因为，整个重庆的地势不平，只是正巧李子坝这个站被拍到抖音并且火了。虽然，轻轨穿楼应该在外面新建的观景台上看比较好，不过，由于赶着回去吃饭，就直接在里面看了。</p>
<p>一行七人一致认为 5 块钱的轻轨穿楼是今天最美的风景，大概也和晚上坐的有关。</p>
<p>坐地铁到了解放碑之后，准备吃饭，由于昨天晚上的火锅和今天中午的面条，导致大家的胃都不是很舒服，于是去了一家清淡的港式茶餐厅，点了 4 份粥。养养胃，准备明天再战，因为明天就跨年了。</p>
<h2 id="第三天-12-31"><a href="#第三天-12-31" class="headerlink" title="第三天 12-31"></a>第三天 12-31</h2><p>今天是 2018 最后一天，如何合理的安排这一天非常关键。重庆市区的基本都玩过了，解放碑，朝天门，洪崖洞，长江索道，磁器口，轻轨穿楼等等。</p>
<p>于是我们把眼光放到了郊区，他们在抖音上看到重庆有个著名的高空旅游景点，非常刺激，于是定了青旅准备跟团，然后晚上回到解放碑跨年，听起来就很棒。哈哈。</p>
<p>早上 6 点多，大家就在解放碑附近集合了，做 2 小时的大巴到郊区，不得不说，山路崎岖。</p>
<p>由于昨天下过雪，虽然路边的雪已经被景区工作人员人工扫除，但山顶的雪还若隐若现，伴随着山顶的风力发电设备，看起来很美。</p>
<p>颠颠簸簸终于到了景区，由于是12-31，人没有想象的多，我们先吃了 60 一人的自助餐，非常难吃。吃完就准备开始玩了，由于大家的兴趣不同，可玩的东西有很多，于是都分开来玩了。</p>
<p>我们先玩了高空索道，就是从这个山头滑到另一个山头。我基本是闭着眼睛过去的。然后看了寒冰洞， 名字很霸气，但实际上，没什么可看的。</p>
<p>过了寒冰洞，来到了玻璃吊桥，第一次走这种桥，有点慌。</p>
<p>然后来到了高空刺激项目，21 米的悬崖秋千，我当然没坐，看着都吓人。</p>
<p>走了世界第一长的空中悬廊，实在是吓人。不过有的人一点都不怕，很是奇怪。然后大家站在空中玻璃长廊上找无人机拍了一段视频，看起来很帅气，适合发朋友圈。哈哈。</p>
<p>拍完视频，我们又去玩了冰雪王国，就是一个室内的冰雪项目，租了大羽绒服，由于是第一次见识，玩的很开心。</p>
<p>然后又坐了旋转木马，开了碰碰车，这些都感觉很一般了，没什么好说的。</p>
<p>玩到下午 5 点钟左右，开始准备回家了，因为赶着回去跨年，而且小腿爬山爬的，真的很酸了。</p>
<p>距离市区 4 公里左右的时候，大巴车就把我们放了下来，说是今天跨年，警察已经把进入市区的道路封起来了，只能做公交车或者步行。</p>
<p>下了大巴之后，我们看路边的元旦灯光布置的很漂亮，于是就选择一起走到解放碑。途径长江大桥的时候，拍了几张照片，很漂亮。哈哈。路上有很多卖灯饰的，用来跨年的时候耍，我们每个人都买了一两个。烘托一下过年的气氛。</p>
<p>走了大概半小时，到了解放碑，已经有很多人了，虽然才 9点半。而我们也还都没有吃饭，于是决定先吃饭喝酒，吃到 11：30 的时候，再到广场跨年。</p>
<p>所有饭店人满为患，我们找了一家非常一般般的酸菜鱼之类的店，开始吃了起来，我甚至喝了几瓶啤酒，大家一起回顾昨天，畅想明天，每个人都给 2019 年定下了一些目标，希望都能够实现吧。</p>
<p>吃的差不多了，也到了 11点半了，结账走出来，发现商场已经没有人了，全部都到广场去了，不对，不是广场，应该是围绕解放碑附近的所有道路，对，所有道路全都站满了人，大概有几万人，看到这么多人，我有点慌，生怕发生踩踏事件，全程紧紧抱住警察搭建的脚手架栏杆。实际上，警察也非常紧张，刚过零点，警察就催促了年轻人赶紧回家。哈哈。</p>
<p>本来还想在零点发个视频什么的，结果一点信号都没有，应该是人太多了，信号不够用。</p>
<p>到了零点，所有人倒计时 54321，放掉手上的气球，拍照。第一次经历这种跨年，有点点意思，哈哈。不过，以后再也不敢来解放碑跨年了，人太多，吓人，还有很多人挤来挤去，很烦。重庆政府胆子也很大，听说很多其他的城市都在避免这种大量人群的跨年活动。那天晚上，政府也临时找了很多大爷大妈穿着绿色荧光衣服维护秩序，等跨年一结束，立马发现金。</p>
<p>跨年结束，我们就各自回家了。对着天空大喊一声：2018 再见，2019 我来了。</p>
<h2 id="第四天-01-01"><a href="#第四天-01-01" class="headerlink" title="第四天 01-01"></a>第四天 01-01</h2><p>今天是重庆之旅的最后一天，晚上 8点40的飞机就要回到杭州。而几个小伙伴中，有 2 个小伙伴也去了成都，剩下的人自己安排了。</p>
<p>我们昨天经历了景区的爬上爬下和跨年疯狂，一觉睡到 9 点半，吃个鸭血粉丝汤当早饭（重庆人早上好像都是吃酸辣粉的），然后来到了皇冠大扶梯，听说是亚洲第一长的扶梯，93年就建造了，单程票 2 元，来回一共  4 元。</p>
<p>怎么说，看看就行了，但也没什么惊奇，就是长。一个超长的扶梯。</p>
<p>看完扶梯后，我们准备吃中饭，由于到重庆还没有正经吃一顿好火锅（第一天吃的洞府老火锅贼鸡儿难吃），于是找了一家火锅，作为在重庆的最后一顿饭，还真的不错，地址在七星岗，名字叫 “晓山城火锅”，离解放碑 1 公里，他家的毛肚和腰片非常的好吃，而且还很便宜。这一顿火锅，让我觉得这次重庆之旅没有白来 ^_^。</p>
<p>吃完火锅，就准备逛逛解放碑（对，又逛解放碑），因为实在没啥好玩的了。准备 4 点多出发，从酒店到机场。时间也快到了，大家就各自收拾行李了。</p>
<p>我们回到酒店拿了行李箱，就坐 6 号线转 10 号线到 T3 航站楼。6号线人真的很多，10 号线人倒是不多。扛着行李箱背着笔记本电脑真的很累，如果再让我选择一次，我一定选择打车。到了机场，就开始安检啥的，很顺利。</p>
<p>8点 40 的飞机一到，我们就离开重庆了。</p>
<p>为期 4 天的重庆之旅也就结束了。</p>
<p>11 点 30 到杭州后，坐机场大巴到武林路，然后打车回到住处，也很方便。只是明早还要上班，不能好好睡一觉。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>今年的跨年总的来说，还是比较有意思的，很有仪式感，过去那么多年，我都是当做很平常的一天来度过的，例如去年，我就在办公室写代码，看书，今年尝试了一些不一样的东西。哈哈。</p>
<p>仪式感归仪式感，2019 已经到来，还是那句话：虽生犹死，向死而生。把每一天当做生命的最后一天度过，去完成自己想要完成的事情。加油。</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ 异常分析 [TIMEOUT_CLEAN_QUEUE]broker Busy, Start Flow Control for a Whil</title>
    <url>/2019/05/08/2019/2019-05-09-rmq-busy-exp/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       现象:

<p>在对 RMQ 做集群压测时，偶现 [TIMEOUT_CLEAN_QUEUE]broker busy, start flow control for a whil 异常，对系统正确率有一定影响，所以决定一探究竟。</p>
<h2 id="全局搜索代码"><a href="#全局搜索代码" class="headerlink" title="全局搜索代码"></a>全局搜索代码</h2><p>首先，clone 了一波代码，全局搜了一下，在 BrokerFastFailure 这个类里的 cleanExpiredRequestInQueue 方法看到了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanExpiredRequestInQueue</span><span class="params">(<span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; blockingQueue, <span class="keyword">final</span> <span class="keyword">long</span> maxWaitTimeMillsInQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!blockingQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable runnable = blockingQueue.peek();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == runnable) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> RequestTask rt = castRunnable(runnable);</span><br><span class="line">                <span class="keyword">if</span> (rt == <span class="keyword">null</span> || rt.isStopRun()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> behind = System.currentTimeMillis() - rt.getCreateTimestamp();</span><br><span class="line">                <span class="keyword">if</span> (behind &gt;= maxWaitTimeMillsInQueue) &#123;<span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (blockingQueue.remove(runnable)) &#123;</span><br><span class="line">                        rt.setStopRun(<span class="keyword">true</span>);</span><br><span class="line">                        rt.returnResponse(RemotingSysResponseCode.SYSTEM_BUSY, String.format(<span class="string">&quot;[TIMEOUT_CLEAN_QUEUE]broker busy, start flow control for a while, period in queue: %sms, size of queue: %d&quot;</span>, behind, blockingQueue.size()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑：</p>
<ol>
<li>如果当前时间减去这个请求的创建时间 &gt; 配置的最大等待时间。就删除掉这个请求，并抛出这个异常。在调用 returnResponse 方法时，会直接调用 netty 的 writeAndFlush 方法写回数据。</li>
</ol>
<p>而这个方法会被 4 个地方调用：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-dae38fa7de6ea22f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>楼主在每个调用后面设置了默认值：<br>发送时：最大 200ms<br>pull 消息时： 最大 5 秒<br>心跳： 31 秒<br>事务： 3 秒。</p>
<p>而我们的系统都是在 send 消息时，报错的，看来，是队列里请求等待超过 200 毫秒了。</p>
<p>再回头看看 cleanExpiredRequest 这个方法。</p>
<p>这个方法被一个 10ms 间隔的定时任务执行的。因此，最多也就超过 210 毫秒，就会抛异常。而这个方法还有另外一个逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">this</span>.brokerController.getMessageStore().isOSPageCacheBusy()) &#123;<span class="comment">// 如果写不进去.</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getSendThreadPoolQueue().isEmpty()) &#123;</span><br><span class="line">                   <span class="keyword">final</span> Runnable runnable = <span class="keyword">this</span>.brokerController.getSendThreadPoolQueue().poll(<span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">null</span> == runnable) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> RequestTask rt = castRunnable(runnable);</span><br><span class="line">                   rt.returnResponse(RemotingSysResponseCode.SYSTEM_BUSY, String.format(<span class="string">&quot;[PCBUSY_CLEAN_QUEUE]broker busy, start flow control for a while, period in queue: %sms, size of queue: %d&quot;</span>, System.currentTimeMillis() - rt.getCreateTimestamp(), <span class="keyword">this</span>.brokerController.getSendThreadPoolQueue().size()));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>如果操作系统 PageCache 很忙，也抛出 PCBUSY 异常，忙的意思是：往 MQ 文件里写是需要一把锁的，如果上次上锁的时间截止到现在，超过了 1 秒，就表示忙，就不等了，就抛出异常。</p>
<p>明显，200ms 的队列排队超时，更容易被触发。</p>
<p>那有没有可能，把这个队列对应的线程池搞的大一点呢？</p>
<p>我们看看源码：<br>sendThreadPoolQueueCapacity = 10000;<br>sendMessageThreadPoolNums = 1；</p>
<p>发现这个队列的大小是 10000。线程池的大小是 1（max 和 core 都是 1）.</p>
<p>为什么是1？</p>
<p>注释是这么说的：</p>
<blockquote>
<p> thread numbers for send message thread pool, since spin lock will be used by default since 4.0.x, the default value is 1.</p>
</blockquote>
<p>意思是，4.0.x 版本后使用自旋锁，所以默认值是1.</p>
<p>这个锁说的是 PutMessageLock，在 RMQ 里，有 2 种实现：</p>
<ol>
<li>PutMessageSpinLock 自旋锁。</li>
<li>PutMessageReentrantLock JDK 非公平重入锁。</li>
</ol>
<p>默认使用自旋锁，但是，自旋锁适合在并发低的时候使用，说白了就是乐观锁，乐观锁适合并发低的时候使用，悲观锁适合在并发高的时候使用。</p>
<p>为什么使用一个线程？因为多个线程没有效果，往 PageCache 里写数据是上锁的，最耗时的就在这部分，开启多个线程在这里抢锁是没有意义的。而且，在高并发下，多个线程自旋抢锁，CPU 可能会爆炸。</p>
<p>那用重入锁呢？大部分时候，MQ 的压力都没那么大，使用自旋锁，能够减少 CPU 上下文切换，提高性能。这是一个权衡。如果你把线程池搞了多个 线程，那就使用重入锁吧。但多线程确实没意义。</p>
<p>所以，线程池这部分，我们最好不要修改，也就是说，你即使增加线程数，也解决不了这个问题。另外，如果不是 1，在使用绝对顺序消息时，是无法保证消息的顺序的。相当于多个线程处理一个队列的消息，顺序一定会错乱。这个千万要注意。</p>
<p>根本的原因还是 PageCache 刷盘的时候，会有毛刺，超时超过 200ms，就会偶发这种现象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下：<br>这个错误是因为请求在队列里待的太久了，如果是 send 请求，就是 200 多毫秒。因此，会被 Server 端认为这是过期的请求。</p>
<p>相关参数：</p>
<ol>
<li><p>waitTimeMillsInSendQueue 这个最有效，默认值是 200，可稍微改的大一点。例如 250，300，切不可过大，过大会导致积压过多请求，而且大部分都是无效的。更会引起后面的请求都无效。</p>
</li>
<li><p>sendMessageThreadPoolNums 发送消息处理线程数，可以改的大一点，但治标不治本。</p>
</li>
<li><p>brokerFastFailureEnable 这个参数用于控制是否进行扫描，就是每 10ms 执行 cleanExpiredRequest 那个定时任务，可以修改为 false，但不建议这么做。</p>
</li>
</ol>
<p>最后，这个错误的根本原因猜测是因为操作系统 IO 抖动，因为看到网上很多 tps 很低，也会出现这个情况。具体还需要详细的测试和排查。</p>
<p>通常，大家会使用重试策略，解决这个异常，但是可能会引起消息重复，所以，如果对消息重复敏感，做幂等是必须的。</p>
<p>如果 CPU 和 磁盘负载很高，出现这种问题就很正常了，建议增加 Broker 服务器，分担压力。</p>
]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
  </entry>
  <entry>
    <title>如何独立思考？这里有一份全指南(转载)</title>
    <url>/2019/05/26/2019/2019-05-27-dulisikao/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<blockquote>
<p>本文是一篇转载文章, 个人很喜欢这篇文章, 因为担心原链接失效, 这里保留一份.<br>原文链接: <a href="https://mp.weixin.qq.com/s/aViJrzywwGkGdN6PTtBfJA">https://mp.weixin.qq.com/s/aViJrzywwGkGdN6PTtBfJA</a></p>
</blockquote>
<p>知乎上有一个问题，叫做：为什么我们要独立思考？</p>
<p>排名第一的回答，是凤凰前主笔王路写的，很有意思。他说：</p>
<p>因为别人告诉我们要独立思考。</p>
<p>这个回答非常妙，也非常反讽，有一种「第22条军规」式的黑色幽默：你要证明你是疯子才能退役；但如果你能证明你是疯子，你就一定不是疯子，因为疯子不会这样做。</p>
<p>这个回答显然很荒诞，但我相信它讲出了许多人的心声：大家都说独立思考好，但究竟为什么要独立思考呢？不独立思考又会怎么样呢？</p>
<p>我想从反面来聊聊：为什么我们会缺乏独立思考的能力？</p>
<hr>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>不妨做一个小测试：给你两个词，「马」和「狼」，你会分别联想到什么？</p>
<p>前者是不是一些比较正面的词汇，比如骏马、奔驰、勇敢；后者是不是一些偏负面的词汇，比如豺狼、凶恶、狼狈为奸？</p>
<p>为什么会这样呢？因为我们从小受到的教育，就是这样告诉我们的：蝴蝶会传播花粉，所以它是益虫；麻雀会吃掉庄稼，所以它是害虫。牛和马能为我们提供劳动力，所以它们是善良正义的，是「好」的；豺狼、狐狸会袭击人类，糟蹋庄稼，所以它们是凶狠狡诈的，是「坏」的。</p>
<p>因此，在各种文学体裁中，这些形象以及它们相关联的喻义，就这么固化了下来。</p>
<p>注意上述文字「所以」之后的部分 —— 我们是如何能给这些动物下定义，判定它们是好是坏的？</p>
<p>显然，是站在人类的立场上去看待。对人类有利的，就是好的；对人类不利的，就是坏的。</p>
<p>但实际上呢？动物根本无所谓「好坏」，这些只不过是它们的自然天性。</p>
<p>用传播学的话来说，「牛马能提供劳动力」就是「事实判断」，「所以牛和马是好的」就是「价值判断」。豺狼和狐狸也一样。「会袭击家畜」是事实判断，「所以它们是坏的」则是价值判断。</p>
<p>熟悉传播学的朋友，一定知道一条基本原则：<strong>对于任何事情，我们要尽量关注事实判断，而非价值判断</strong>。因为事实判断是确凿的，能够达成共识；而价值判断是依赖于视角和立场的，可以有多种解读。</p>
<p>但是在生活中，很多时候是相反的：我们接收到的信息，往往被有意无意地模糊了两者的局限，被预设了立场，然后打包、封装起来，喂给我们。</p>
<p>为什么我们会缺乏独立思考能力？这就是很重要的一点：因为构成我们思维的信息，从源头开始就是有偏差的。</p>
<p>我们一直生活在偏见和立场的灌输之下。</p>
<p>久而久之，我们就会习惯戴着有色眼镜去看待事物。</p>
<p>这样做是不是一定不好呢？当然不是。生活中，我们经常会给人贴标签，用刻板印象去评判别人。比如「东北人性格豪爽」「广东人什么都吃」「英国人都是gay」……本质也是一样的。</p>
<p>很多时候，这能帮助我们节省认知资源，提高决策和思考的效率。</p>
<p>但要注意：这只是一种走捷径的取巧方式。如果你一直用这样的思维去看待事物、作出思考，那多少会显得有点「头脑简单」。</p>
<p>那么，这会有什么后果呢？</p>
<p>如同我在 你的深度思考能力，是如何一步步被毁掉的？中所说的：社会永远呈现金字塔结构。为了稳定大众，减少可能发生的麻烦，使社会阶层更牢固，让下层「头脑简单」，就是最好的策略。</p>
<p>最好大家都老老实实上班挣钱，累了就用娱乐发泄情绪，挣了钱就通过消费再散出去，每个人都变成机器，只看得到短期利益，想着怎么挣更多的钱，过上「更好的」生活，没有精力和时间去思考。</p>
<p>我们越来越依赖于别人告诉我们答案，指引我们方向，告诉我们应该用什么方式去生活。</p>
<p>所以，如果你问我「独立思考有什么用？」我会告诉你：</p>
<p>它没什么用。但如果你不想被别人牵着鼻子走，真正面对自己的内心，你就有必要培养独立思考的习惯和能力。</p>
<p>说了这么多，如何才能培养独立思考能力呢？</p>
<p>我把独立思考分成三个层次。</p>
<p>第一个层次，是「内在」。也就是构成我们内心价值观、认知框架的质料，亦即我们认知世界的方式。</p>
<p>第二个层次，是「信息」。也就是我们跟外界交互、获取信息的方式。</p>
<p>第三个层次，是「群体」。也就是我们的身份认同和社会性。</p>
<p>下面详述。</p>
<ol>
<li>内在层次</li>
</ol>
<p>我们是如何认知和思考世界的？</p>
<p>本质上，我们对世界的认知，是先通过观察，获得一个个孤立的命题，再通过「逻辑」，将这些命题组合起来，得出有价值的结论 —— 这就是一个思考过程。</p>
<p>举个简单的例子：</p>
<p>LPhone 10 今天做活动，打 7 折，只要 4200！赶紧去买！</p>
<p>这个思考过程的背后是什么呢？</p>
<p>1）LPhone 10 原价 6000；</p>
<p>2）LPhone 10 今天做活动，只要4200，能省钱；</p>
<p>3）我喜欢 LPhone 10；</p>
<p>4）省钱对我是有利的；</p>
<p>5）所以，我要赶紧去买。</p>
<p>在这个过程中，有些是观察到的信息（1和2），有些是我们心中固有的信念（3和4），通过用归纳和演绎法进行组合，从而得出结论（5）。</p>
<p>这个思路很合理，没有任何问题。</p>
<p>但很多时候，事情并没有这么简单。我们的「信念」，会受到预设立场的影响，从而干扰我们对信息的解读，导出有偏差的结论。</p>
<p>比如：特朗普大选的时候，偶尔会在推特上发一些惊人之语。对于这些言论，反对派们会认为「这说明他智力低下、头脑简单」；但对于同样的内容，支持者则会认为：这是他故意为之，目的是为了吸引注意力，为竞选造势。</p>
<p>为什么对同一个内容，双方会有不同的解读呢？原因就是，他们内在的「信念」不同，导致对同样的信息产生不同的理解。</p>
<p>2009 年有过一个相似的实验：当一名脱口秀主持人用讽刺的语气模仿共和党口吻时，民主党支持者会觉得「他在嘲讽共和党」，而共和党支持者会认为「他在借玩笑表露真实想法」。</p>
<p>这种现象，就称为「动机性推理」（Motivated Reasoning）：</p>
<p>我们的推理和思考过程，并不能客观反映事物本身，而是被我们固有的信念所误导，得出了「我们想要的结论」。</p>
<p>这是独立思考的大敌。</p>
<p>那么，动机性推理的机制是什么呢？它通常包含三个要素：</p>
<p>1）Emotion Bias：情绪偏见。也就是「预设立场」。</p>
<p>2）Confirmation Bias：证实偏见。</p>
<p>3）Rationalization：合理化。</p>
<p>我们每天都会通过各种方式，摄入海量信息，而这些信息绝大部分都带着偏见和立场。于是，它们就会累积在我们的心智中，形成我们「先入为主」的观点。</p>
<p>久而久之，大脑就会上当，以为这些观点是我们的真实想法 —— 这就是「预设立场」。</p>
<p>在这个前提下，当我们接触到其他材料时，会怎么样呢？我们会更倾向于接受和相信「正面证据」，也就是支持我们固有观点的证据。</p>
<p>譬如，2008 年大选期间，Orgnet 做过一项调查，结果显示：那些支持奥巴马的人，更喜欢购买赞扬奥巴马的书籍；反之，反对奥巴马的人，更愿意购买指责奥巴马的书籍。</p>
<p>这就叫做「证实偏见」。它非常自然，无处不在，却同时也是令我们走上极端的罪魁祸首。</p>
<p>最后，当我们不得已接触到「反面证据」时，会怎么做呢？心理学家说：我们会将其「合理化」，用各种理由来解释它，给它一个合理的原因。</p>
<p>举个例子：当你用 4200 块买了 LPhone 10，突然，你一个朋友跑过来对你说，他在别的渠道只用了 3000 块就买到了，你会是什么心态？我想，多半会闪过这个念头 —— 「你买的一定是假货」吧？</p>
<p>为什么会出现动机性推理呢？本质上，是因为对认知失调（Cognitive dissonance）的修正。</p>
<p>我们天生希望我们是对的，不希望看到我们错了。出于这一点，当信念和外在信息出现偏差时，我们会倾向于「曲解」它，来维持我们信念的稳定。这才能让我们感到安全。</p>
<p>那么，如何克服动机性推理呢？</p>
<p>就是我强调过多次的：时时刻刻站在自己的对立面，思考：如果我错了，会怎么样？ </p>
<p>我把它称为「对立思维」。</p>
<p>平时不妨多做做这样的练习：阅读、聊天时，看到跟自己抵牾的观点，先不急着反驳和嘲讽，而是停下来，静静思考一下：</p>
<p>我是如何得出这个观点的？是别人告诉我，还是我自己推理出来的？</p>
<p>如果我错了，会怎么样？</p>
<p>不考虑对错，对方的观点，有没有合理和可取之处？</p>
<p>你会发现，你所笃信的东西，其实很多时候，未必能站得住脚。</p>
<p>你会开始产生怀疑，质疑以前被灌输的信息，甚至感到无所适从。</p>
<p>不要怕，这就是独立思考的开始。</p>
<ol start="2">
<li>信息层次</li>
</ol>
<p>第一个层次是关乎内心深处，对世界的理解和认知。</p>
<p>第二个层次，则是关乎信息的交互，亦即我们如何接收信息。</p>
<p>先举一个简单的例子，大家思考下面这句话，有没有任何问题：</p>
<p>中国的教育事业发展还很落后，所以我们需要不断提高在教育上的投入。</p>
<p>看起来很自然，很合理，对不对？</p>
<p>但事实上，前半句是一个客观现象的描述，我们叫做「事实陈述」；后半句是一种行动的倡导，我们叫做「规范陈述」。</p>
<p>从事实陈述推出规范陈述，实际上，是需要打一个问号的：提高教育投入真的能改善教育事业吗？教育事业落后主要是因为投入不够吗？提高教育投入有可行性吗？诸如此类。</p>
<p>这个观念，在哲学上叫做「休谟问题」：我们是否能从「是」推出「应该」？（What is to what ought to be）</p>
<p>很多时候，这两者的内涵是完全不同的，但是在日常生活中，它们却被广泛地、有意无意地混淆了。因为一样东西好，所以我们要倡导它；一样东西不好，所以我们要提高它。等等。</p>
<p>很少有人会去思考：这里面的逻辑关系真的成立吗？我们真的能无需怀疑地接受吗？</p>
<p>发现了吗？这一点，跟一开始的「事实判断」到「价值判断」，非常类似 —— 它们的确也是一致的。</p>
<p>事实到价值：「是什么」，能否推出「好」「坏」？这是需要打一个问号的。因为好坏需要视不同角度而定，背后往往有非常复杂的因素。</p>
<p>事实到规范：「是什么」，能否推出「应该」？这同样需要审问和质疑。很多时候，这往往会将复杂问题简单化，被作者有意引导向他的立场和倾向。</p>
<p>举个非常简单的例子：如果前面的「教育」一例，你下意识接受了，那么稍微进一步：「中国的教育事业发展很落后，所以我们要全盘学习西方的模式」是不是看上去也很合理？</p>
<p>这就是一个陷阱。这里，需要论证非常多的东西，排除其他各种情况和可能性，才能使后半句成立。</p>
<p>但是，如果把这句话放在文章里，不经意地出现，我敢保证，绝大多数人都不会注意到，而是下意识地扫视、阅读、接收 —— 这时，它已经被你所摄入了。</p>
<p>所以，在接受信息时，如何做到独立思考？这就需要在脑海中保持一个筛子，时时刻刻把信息筛一遍，确认无误的，再接受；存疑的，放在一边。</p>
<p>那么，除了刚才讲过的休谟问题，我们还可以用什么标准，来打造这个「信息筛」呢？</p>
<p>第一点是「情绪」。</p>
<p>我们的大脑有两个系统，分别是负责情绪处理的边缘系统，以及负责理性的新皮层。</p>
<p>这两个系统是相互颉颃的。也就是说，当边缘系统活跃时，新皮层就会被抑制。我们可能就会在情绪的操控下，盲从、盲信，作出冲动的决策和判断。</p>
<p>所以，如果你在阅读文章时，觉察到情绪的起伏，那么就要小心了：很有可能，作者正是通过这一点，来影响和干预你的判断。</p>
<p>常见的情绪干预手法有哪些呢？</p>
<p>感情色彩强烈的词汇；</p>
<p>高代入感的经历和故事；</p>
<p>细节描绘和镜头特写；</p>
<p>煽动性强的断言、反问、呼吁和感叹；</p>
<p>……</p>
<p>注意：不是说它们不好 —— 这些都是正常的写作技法。但是在擅长的人手里，可以轻易地通过灵活组合和运用，来实现对你潜移默化的影响，让你被引导、操控而毫不自知。</p>
<p>所以，当你接收信息时，不妨同步在脑海里屏蔽掉这些感情色彩，只留下信息的内核和主干，再问自己：我可以如何理解这些信息？以此来达到对信息的「筛查」。</p>
<p>思考是一件很累的事情，尤其是时刻保持大脑的运转。但只有这样，才能确保不被外界所操纵。</p>
<p>另一点则是「观点」。</p>
<p>我在之前的文章中反复强调过：要警惕「观点输出」。</p>
<p>为什么呢？因为观点输出没法给你提供任何价值。它只会不断让你产生「我学到了东西」「我的理解没有错」的感受，不断地沉溺在这种对神经的刺激和新鲜感中。</p>
<p>简而言之，它只会告诉你「是什么」，不会告诉你「为什么」和「怎么做」 —— 后者需要非常复杂的逻辑和思考加工。</p>
<p>这就是观点输出的问题：它往往是媚俗的 —— 亦即挑你喜欢、能对你产生刺激的话讲，并且轻描淡写，落不到实处。</p>
<p>最常见的观点输出是什么呢？简单归因。亦即把一个复杂的现象，用简单的话概括出来。比如：</p>
<p>为什么他会成功？是因为他自律。</p>
<p>为什么他会成功？是因为他善于抓住时机。</p>
<p>为什么他会成功？是因为他行动力强。</p>
<p>……</p>
<p>这些观点对吗？没有错。但有价值吗？基本没有。</p>
<p>这就是大多数文章的写法：一个观点，加几个故事，再一个观点，再几个故事……最后提炼总结一下：为了……你要……；只有……才能……。</p>
<p>所以，综合以上这几点，不妨试一试：</p>
<p>在阅读文章、接受信息时，不要按照作者原本的思路和框架走，而是把信息拆开来，用自己的「信息筛」筛一遍，最大限度地避免被作者所引导。</p>
<p>这样，才能提高独立思考能力。</p>
<ol start="3">
<li>群体层次</li>
</ol>
<p>除了认知的偏误会影响我们，外界的信息会影响我们，你所生存和交互的群体，也会通过种种方式，对我们施加干预。</p>
<p>大量的心理学实验都证实了这一点：群体对个体有着惊人的影响力。我们自以为独立作出决策，其实可能都是受到群体框架的操纵。</p>
<p>随便举几个例子：</p>
<p>所罗门·阿希的阿希从众实验证明：哪怕是一道非常简单的题目，当其他所有人都给出了错误答案时，参与者也会被他们所影响，把自己的答案由对改错。</p>
<p>米尔格拉姆实验证明：即使平时循规蹈矩的良好市民，在权威者的压力之下，也可能作出非常残酷的行为。</p>
<p>最负盛名的斯坦福监狱实验则证明：哪怕是斯坦福大学的学生，只要适应了「监狱看守」的身份，也会不自觉地投入进去，对犯人作出伤害和虐待。</p>
<p>这就是社会心理学主要关注的议题。</p>
<p>很多时候，我们以为自己在独立思考，其实也许只是在「扮演」着我们的角色而已。</p>
<p>我们身在任何一个圈子里，都会被赋予一种身份认同 —— 无论这个圈子是实体的、还是虚拟的，是广阔的，还是小众的。</p>
<p>这种身份认同会塑造我们，影响我们，规范我们，让我们朝着「一致」去行动。</p>
<p>这就是「圈子效应」。</p>
<p>对内寻求一致 —— 作出共同的行为，增强彼此间的归属感、身份认同和联结；对外寻求差异 —— 通过营造「不同」，跟其他人拉开差距，从而获得「我们比你们强」的优越感。</p>
<p>无论你是否意识到，你所处的群体，都在不知不觉、潜移默化地干预着你。</p>
<p>一个例子就是时尚。齐美尔有一段话，讲时尚，非常透彻。</p>
<p>他说：时尚是一种特定的模仿机制。一方面，模仿满足了成员的群体归属感，使成员感觉到前进的道路上并不孤独；另一方面，模仿减少了成员的责任感和羞耻感，获得一种安全感。因为个体在跟随时尚的过程中不需要为自己的品味与行为负责。</p>
<p>这就是鲍德里亚所说的「消费社会」。我们追逐消费，追逐潮流，并不是因为我们「想要」，而是因为我们相信，我们消费了，就能成为那样的人。</p>
<p>这就是一种群体力量的操控。</p>
<p>那么，如何避免被群体所影响呢？</p>
<p>唯一的方法是：不断反思自己的内心，问清楚「我想要什么」。时时刻刻弄清楚，我的想法、观念、欲望，是真的来源于自己的内心，还是来源于群体、环境，和「他们」？</p>
<p>以我为主，为我所用。明确「我想要什么」，让一切来帮助你、成就你，而不是被融入环境。</p>
<p>在湍急的河流上前行，唯有内心的声音，能够为我们导航。</p>
<p>最后，简单聊聊「深度思考」「独立思考」「批判性思考」这三个概念的差异。</p>
<p>在我的体系中，深度思考，是一种生活态度，亦即追求理性认识事物、探寻事物本质的观念。处于最高的层级。</p>
<p>独立思考，强调不受操控，独立地作出决策和判断。它是深度思考的一部分。</p>
<p>批判性思考，强调对信息进行审视、质疑，而不是下意识地接收。它属于独立思考的一部分。</p>
<p>亦即 深度思考 &gt; 独立思考 &gt; 批判性思考。</p>
<p>希望这篇文章，能帮你理清一些疑惑。</p>
<p>在独立思考的道路上，一起同行。</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>如何防范&quot;影响力&quot;</title>
    <url>/2019/05/26/2019/2019-05-27-yingxiangli/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h3 id="0-关键字"><a href="#0-关键字" class="headerlink" title="0 关键字"></a>0 关键字</h3><ul>
<li>对比</li>
<li>互惠</li>
<li>相互退让</li>
<li>承诺和一致</li>
<li>社会认同</li>
<li>喜好</li>
<li>权威</li>
<li>短缺</li>
</ul>
<h3 id="1-对比"><a href="#1-对比" class="headerlink" title="1 对比"></a>1 对比</h3><p>常用技巧：</p>
<ol>
<li>先说坏消息，再说好消息。</li>
<li>先报高价格，再报低价格。</li>
</ol>
<h3 id="2-互惠"><a href="#2-互惠" class="headerlink" title="2 互惠"></a>2 互惠</h3><p>原理（人类收了别人好处，要去报答别人的负债感）</p>
<ol>
<li>超市免费试用</li>
<li>中国人拜年、份子钱、不愿意欠人情等。</li>
<li>有些人经常会拒绝别人的帮助，其实是为了避免以后帮助对方。</li>
<li>给开发提新需求时，先买饮料给开发</li>
</ol>
<h3 id="3-相互退让"><a href="#3-相互退让" class="headerlink" title="3 相互退让"></a>3 相互退让</h3><p>场景：</p>
<ol>
<li>砍价。商家故意将价格说的很高，然后说给你点面子，抹掉零头，此时，我们通常会觉得对方主动让步了，就会相应的也做出让步。</li>
</ol>
<h3 id="4-承诺和一致"><a href="#4-承诺和一致" class="headerlink" title="4 承诺和一致"></a>4 承诺和一致</h3><p>例子：</p>
<ol>
<li>老婆让老公写保证书</li>
<li>销售让客户同意接见自己</li>
<li>商人亏本也要做第一笔生意（为了获取信任）</li>
<li>让孩子把承诺的东西写下来</li>
<li>在公司公开夸奖同事，那么他下次也会继续做这件事</li>
<li>仪式感（复杂的入党仪式，名企的复杂面试流程）让人们觉得承诺会有效。同时，人们更加珍惜他们努力奋斗得到的东西（所以有那么多仪式）。</li>
</ol>
<h3 id="5-社会认同"><a href="#5-社会认同" class="headerlink" title="5 社会认同"></a>5 社会认同</h3><p>例子：</p>
<ol>
<li>社会跟风现象，例如前几年跟风买 iPhone（他们都说好！）。</li>
<li>新闻里的围观群众眼睁睁看着受害者被打死。</li>
</ol>
<p>总之：当人们对外界情况不熟悉或者没有把握的时候，就需要从外界寻找认同。这个时候，社会认同原理的效力最大。</p>
<h3 id="6-喜好"><a href="#6-喜好" class="headerlink" title="6 喜好"></a>6 喜好</h3><p>例子：</p>
<ol>
<li>人们喜欢长得好看的人（肯尼迪当总统）</li>
<li>和自己相似</li>
<li>别人称赞自己</li>
<li>熟悉感</li>
<li>爱屋及乌</li>
</ol>
<h3 id="7-权威"><a href="#7-权威" class="headerlink" title="7 权威"></a>7 权威</h3><p>原理：即使是具有独立思考的人，也会为了服从权威的命令而做出一些完全丧失理智的事情来 。<br>例子：</p>
<ol>
<li>头衔（某某大学的教授，某某公司的前高管）</li>
<li>衣着（科技工作者的白大衣，军队的军服）</li>
<li>外部标志（豪车，奢侈品衣服）</li>
</ol>
<h3 id="8-短缺"><a href="#8-短缺" class="headerlink" title="8 短缺"></a>8 短缺</h3><p>原理：机会越少，价值就越高。（物依稀为贵）</p>
<ol>
<li>人们总是向往得不到的东西（得不到的永远在骚动）</li>
<li>人们总喜欢吃禁果（亚当夏娃、情侣出轨）</li>
<li>独家消息（记者们总是喜欢说 独家消息）</li>
<li>数目稀少，截止 xxx 日期，秒杀，抢购….. 是不是很熟悉</li>
<li>当东西从充足变成稀缺时，人们更加害怕失去，例如抢盐。</li>
<li>当某种东西，必须通过竞争才能得到，我们就会更像得到，例如拍卖竞拍。</li>
</ol>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h2><p>要想免于陷入这些陷阱，就需要时刻具备独立思考能力。</p>
<p>为什么要独立思考呢？</p>
<p>“因为别人让我们独立思考。”</p>
<p>当然这是抖机灵的回答。很明显，之所以要独立思考，是因为 “影响力”太多，如果不能独立思考，就不能真正理智的认识到是非对错。虽然我们不能做到 100% 的分辨是非对错，但我们应该尽自己所能，去分辨真正的是非对错，并知行合一。</p>
<p>关于独立思考,这里有一篇个人认为不错的文章: <a href="https://36kr.com/p/5134906">https://36kr.com/p/5134906</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>零拷贝</title>
    <url>/2019/06/01/2019/2019-06-01-zero_copy/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>零拷贝这三个字，一直是服务器网络编程的关键字，任何性能优化都离不开。在 Java 程序员的世界，常用的零拷贝有 mmap 和 sendFile。那么，他们在 OS 里，到底是怎么样的一个的设计？本文将简单聊聊 mmap 和 sendFile 这两个零拷贝。</p>
<h2 id="传统数据读写的劣势"><a href="#传统数据读写的劣势" class="headerlink" title="传统数据读写的劣势"></a>传统数据读写的劣势</h2><p>初学 Java 时，我们在学习 IO 和 网络编程时，会使用以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure>

<p>我们会调用 read 方法读取 index.html 的内容—— 变成字节数组，然后调用 write 方法，将 index.html 字节流写到 socket 中，那么，我们调用这两个方法，在 OS 底层发生了什么呢？我这里借鉴了一张其他文字的图片，尝试解释这个过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-174b8d9cc6119e67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传统 io 操作"></p>
<p>上图中，上半部分表示用户态和内核态的上下文切换。下半部分表示数据复制操作。下面说说他们的步骤：</p>
<ol>
<li><p> read 调用导致用户态到内核态的一次变化，同时，第一次复制开始：DMA（Direct Memory Access，直接内存存取，即不使用 CPU 拷贝数据到内存，而是 DMA 引擎传输数据到内存，用于解放 CPU） 引擎从磁盘读取 index.html 文件，并将数据放入到内核缓冲区。</p>
</li>
<li><p>发生第二次数据拷贝，即：将内核缓冲区的数据拷贝到用户缓冲区，同时，发生了一次用内核态到用户态的上下文切换。</p>
</li>
<li><p>发生第三次数据拷贝，我们调用 write 方法，系统将用户缓冲区的数据拷贝到 Socket 缓冲区。此时，又发生了一次用户态到内核态的上下文切换。</p>
</li>
<li><p>第四次拷贝，数据异步的从 Socket 缓冲区，使用 DMA  引擎拷贝到网络协议引擎。这一段，不需要进行上下文切换。</p>
</li>
<li><p>write 方法返回，再次从内核态切换到用户态。</p>
</li>
</ol>
<p>如你所见，复制拷贝操作太多了。如何优化这些流程？</p>
<h2 id="mmap-优化"><a href="#mmap-优化" class="headerlink" title="mmap 优化"></a>mmap 优化</h2><p>mmap 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户控件的拷贝次数。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c5ea00b78e1b93fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mmap 流程"></p>
<p>如上图，user buffer 和 kernel buffer 共享 index.html。如果你想把硬盘的 index.html 传输到网络中，再也不用拷贝到用户空间，再从用户空间拷贝到 Socket 缓冲区。</p>
<p>现在，你只需要从内核缓冲区拷贝到 Socket 缓冲区即可，这将减少一次内存拷贝（从 4 次变成了 3 次），但不减少上下文切换次数。</p>
<h2 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h2><p>那么，我们还能继续优化吗？ Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-695904d24edc2fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="snedFile 2.1 版本"></p>
<p>如上图，我们进行 sendFile 系统调用时，数据被 DMA 引擎从文件复制到内核缓冲区，然后调用，然后掉一共 write 方法时，从内核缓冲区进入到 Socket，这时，是没有上下文切换的，因为在一个用户空间。</p>
<p>最后，数据从 Socket 缓冲区进入到协议栈。</p>
<p>此时，数据经过了 3 次拷贝，3 次上下文切换。</p>
<p>那么，还能不能再继续优化呢？ 例如直接从内核缓冲区拷贝到网络协议栈？</p>
<p>实际上，Linux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 Socket buffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-00c3e47936ecea25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" sendFile 在 2.4 版本的再一次优化"></p>
<p>现在，index.html 要从文件进入到网络协议栈，只需 2 次拷贝：第一次使用 DMA  引擎从文件拷贝到内核缓冲区，第二次从内核缓冲区将数据拷贝到网络协议栈；内核缓存区只会拷贝一些 offset 和 length 信息到 SocketBuffer，基本无消耗。</p>
<p>等一下，不是说零拷贝吗？为什么还是要 2 次拷贝？</p>
<p>答：首先我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 kernel buffer 有一份数据，sendFile 2.1 版本实际上有 2 份数据，算不上零拷贝）。例如我们刚开始的例子，内核缓存区和 Socket 缓冲区的数据就是重复的。</p>
<p>而零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的  CPU 缓存伪共享以及无 CPU 校验和计算。</p>
<p>再稍微讲讲 mmap 和 sendFile 的区别。</p>
<ol>
<li>mmap 适合小数据量读写，sendFile 适合大文件传输。</li>
<li>mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。</li>
<li>sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。</li>
</ol>
<p>在这个选择上：rocketMQ 在消费消息时，使用了 mmap。kafka 使用了 sendFile。</p>
<h2 id="Java-世界的例子"><a href="#Java-世界的例子" class="headerlink" title="Java 世界的例子"></a>Java 世界的例子</h2><p>kafka 在客户端和 broker 进行数据传输时，会使用 transferTo 和 transferFrom 方法，即对应 Linux 的 sendFile。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-702a0577fcf0f78a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kafka "></p>
<p>tomcat 内部在进行文件拷贝的时候，也会使用 transferto 方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4334d181982acbf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tomcat"></p>
<p>tomcat 在处理一下心跳保活时，也会调用该 sendFile 方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4cd8bde5a9db4630.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在 pulsar 项目中，下载文件时，也会使用 sendFile。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6d950980cf16017d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pulsar"></p>
<p>所以，如果你需要优化网络传输的性能，或者文件读写的速度，请尽量使用零拷贝。他不仅能较少复制拷贝次数，还能较少上下文切换，缓存行污染。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.linuxjournal.com/article/6345">Zero Copy I: User-Mode Perspective</a></p>
<p><a href="https://developer.ibm.com/articles/j-zerocopy/">Efficient data transfer through zero copy</a></p>
<p><a href="http://www.sxt.cn/ueditor/php/upload/file/20170901/1504248466272324.pdf">RocketMQ 开发指南</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>Java 性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>一种单机支持 JavaWeb 容器万级并发的设想</title>
    <url>/2019/06/02/2019/2019-06-02-aysnc-io/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>    



<p>当前的大部分 Java web 容器基于 Bio 线程模型，例如常见的 tomcat ，默认 200 线程，即 200 连接。由此带来的问题是，如果想提高并发，或者提高资源利用率，就得加大线程数。</p>
<p>如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d02bb44f8ed552e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>于是出现了类 Netty 的 Reactor 线程模型。同时，Java 官方也设计了 Servlet 3 异步 API，可以通过返回类 Feature 的方式，实现异步编程。在某些情况下，也可以实现万级别并发。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-cbf68357e9235038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet 3 "></p>
<p>但是，为什么 Java 社区的异步编程无法推广开来？究其原因，数据库是罪魁祸首，再往上看，其实是 JDBC 的锅，JDBC 定义了一套阻塞式的数据库 IO 通信模型。这导致每次请求，线程都阻塞在等待  DB 结果。进而导致，服务器资源无法充分利用。</p>
<p>有没有一种办法，让 Java web 应用的整个链路都是非阻塞的呢？</p>
<p>答：有。</p>
<p>异步编程是提高生产力的关键。下图是我们今天假设的模型：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-13a4d7d0978cc7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新的设想模型"></p>
<p>其实非常简单。</p>
<p>我们让 tomcat 支持 Servlet 3 异步编程模型，接口返回 feature 即可，这个功能其实有很多web 容器都实现了。关键的是，我们让 DB 客户端和服务器都支持异步编程模型。让 DB 像 netty 复用 IO 连接，业务线程只需要将 SQL 交个 数据库 client 即可返回 feature，然后释放当前线程（再也不用阻塞，这是关键），等 DB 操作结果返回时，只需通知这个 feature 即可。这将极大的提高线程的利用率，不夸张的说，只需 8 条线程，就足以承受万级别的并发。</p>
<p>整个的调用流程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-00b1e88a29ad8745.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新的调用流程设想"></p>
<p>我们看到，当一个 http 请求过来，整个流程是无阻塞的，不用等待 数据库 返回结果，业务只需添加回调即可，当数据库结果返回时，自动触发回调。</p>
<p>当然，这只是我的一个小设想，Mysql 要重写连接器，我估计是太难了。但是，那些新一代的数据库，是否能够把连接器设计成支持异步、支持多路复用的呢？这样，web 应用的客户端，就能够把整个链路设计成异步的，这将节约很多资源，提高生产力。</p>
<p>希望那一天快点到来。</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>Java 性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>远程工作阅读学习笔记</title>
    <url>/2020/02/26/2020/0226/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>     

<p>原文链接<br>黄东旭 : <a href="https://www.infoq.cn/article/3zMtchlVWg7EfIfg9jjo">PingCAP 的 5 年远程办公实践</a></p>
<p>左耳朵耗子：<a href="https://www.infoq.cn/article/fVAkBmhfwVaQ7868BT3g">疫情下的远程办公，聊聊我的经验和实践</a></p>
<p>PingCAP 架构师 siddontang ： <a href="https://github.com/siddontang/blog/blob/master/2016/my-remote-work.md">一年多远程工作带给我的感悟</a></p>
<h2 id="1-管理哲学"><a href="#1-管理哲学" class="headerlink" title="1 管理哲学"></a>1 管理哲学</h2><p>到底是要“监督”还是“自驱”？如果是后者的话，则需要一个强大的愿景作为驱动.</p>
<h2 id="2-细节"><a href="#2-细节" class="headerlink" title="2 细节"></a>2 细节</h2><p>1 <strong>分享</strong>：每周让每个人分享自己的工作感悟和心得，然后发精心挑选的奖品；</p>
<p>2 <strong>目标和管理</strong>：</p>
<ul>
<li>OKR</li>
<li>计划指定和执行跟踪</li>
</ul>
<h3 id="OKR："><a href="#OKR：" class="headerlink" title="OKR："></a>OKR：</h3><p>相比较 KPI 来说：<br>1 更强调由团队成员共同指定目标，容易达成共识，且目标导向一致；<br>2 能让团队成员知道自己工作内容在整个大局的意义，这样，能促进人与人的协作，让团队具有整体性<br>3 透明，每个人都能看到其他人的 OKR，知道其他人在做什么</p>
<h3 id="计划指定和执行跟踪"><a href="#计划指定和执行跟踪" class="headerlink" title="计划指定和执行跟踪"></a>计划指定和执行跟踪</h3><p>每个具体的项目计划需要透明，每个负责人都为自己的项目建立一个全局的大盘，也可以称为地图。<br>地图上有【资源的链接、负责人、风险点、进度】，这个对于管理者来说，至关重要；</p>
<h2 id="3-工具"><a href="#3-工具" class="headerlink" title="3 工具"></a>3 工具</h2><ul>
<li>GitHub 代码托管</li>
<li>Zoom 在线会议</li>
<li>Slack 即时通讯（电话）</li>
<li>企业微信</li>
<li>在线文档</li>
<li>邮件日历</li>
<li>wiki Confluence（内部文档）</li>
<li>Jira bug 跟踪</li>
<li>Trello 看板，记录重要客户和事件备忘</li>
<li>Jenkins CI</li>
</ul>
<p>例子：如果开发一个小功能</p>
<ol>
<li>使用在线文档草拟描述，并分享同事</li>
<li>文档沟通定稿，同步 wiki 和 gitHub</li>
<li>拆分子项目，通过 Jira 分配，完成后提交到 Github</li>
<li>持续集成</li>
</ol>
<p>注意点：工具，不仅仅是使用现成的，工程师也可以开发工具来提升效率；能交给机器做的，就尽量不要让人来做，自动化是至关重要的；</p>
<h2 id="4-远程最大的挑战：沟通"><a href="#4-远程最大的挑战：沟通" class="headerlink" title="4 远程最大的挑战：沟通"></a>4 远程最大的挑战：沟通</h2><ol>
<li>沟通必不可少，沟通的品质决定了做事情的本质；</li>
</ol>
<p>远程的状态下，沟通会更多，更细致，并不会变少；只是形式不再是面对面的会议；</p>
<p><strong>沟通最重要的意义：信息拉平</strong></p>
<p>大白话：大家都互相知道自己该干嘛，团队正在干嘛以及该干嘛；</p>
<p>要做到这点，还是需要<strong>透明；</strong></p>
<p>即使在远程，<strong>会议</strong>仍然是<strong>信息拉平</strong>的重要方式。Zoom 视频会议工具很优秀；</p>
<p>会议分2种：</p>
<ul>
<li>例会（通常以周为单位，管理者可以知道方向是否正确，进度是否正常）</li>
<li>具体业务的沟通会</li>
</ul>
<p>注意：</p>
<ul>
<li>例会上，管理者不要轻易做决策，应当会后思考后，再进行决策；</li>
<li>善用日历，让别人可见，目的是信息拉平</li>
<li>会议前发议程，会议后发笔记，并记录 wiki；</li>
<li>少开大会，长会，两个 pizza 原则（两张 pizz 就能喂饱团队）</li>
</ul>
<p>团队周报和个人周报，都记录在 wiki 里，并且标注索引；</p>
<h2 id="5-远程办公的自我管理"><a href="#5-远程办公的自我管理" class="headerlink" title="5 远程办公的自我管理"></a>5 远程办公的自我管理</h2><p>家里或者咖啡厅</p>
<p>需要克服孤独感，需要自律精神，克服倦怠感；使用个人时间管理工具，例如番茄钟，日历等工具；</p>
<p>作为管理者，任务要拆解的足够细，在前期，需要和远程同事，反复确认是否达成一致；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>自驱为主</li>
<li>OKR 制定计划，透明，公开</li>
<li>地图跟踪任务，周报总结任务，例会调整任务</li>
<li>沟通是重点：使用工具进行沟通，例如电话，视频会议，在线文档（文档驱动很重要）</li>
<li>人：能独当一面的人、沟通能力要强、能自我管理和自驱动</li>
</ol>
<p>到底是花时间“教育不好的人”，还是“花时间精力找更好的人” ？ 当然是后者。</p>
<p>制度的建立，要基于好人更多的原则来制定。</p>
<h2 id="一个普通员工的一天"><a href="#一个普通员工的一天" class="headerlink" title="一个普通员工的一天"></a>一个普通员工的一天</h2><ol>
<li>看下 OKR 上自己的任务，再看看地图上的大盘，看看别人做了啥，自己到哪一步了；</li>
<li>根据项目进度和 leader 的分配，开始做今天的任务，用小番茄定个任务；</li>
<li>如果遇到困难，可以和同事或者 leader 沟通；</li>
<li>每天结束，更新自己在地图上的进度，写上今天的计划，优先级、问题，总结摘要；</li>
<li>每周的周报，工作心得和感悟</li>
</ol>
]]></content>
      <categories>
        <category>工作效率</category>
      </categories>
  </entry>
  <entry>
    <title>MOSN 动态路由的使用</title>
    <url>/2021/11/25/2021/mosn-dynamic-metadata/</url>
    <content><![CDATA[<p>在使用 MOSN 进行路由时，默认的路由策略可能无法满足你的需求，例如，当你的服务集群里，有多个版本时，就需要更复杂的路由逻辑。通常 proxy 在处理此类问题时，都会使用 subsets 的方案。</p>
<p>关于此功能更详细的介绍，可参考 envoy 的 <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/subsets">文档</a>.</p>
<p>下面介绍如何在 MOSN 中，使用 subset 来动态路由分组。</p>
<h2 id="1-设置-host-的-subSet-key-和-MetaData"><a href="#1-设置-host-的-subSet-key-和-MetaData" class="headerlink" title="1 设置 host 的 subSet key 和  MetaData"></a>1 设置 host 的 subSet key 和  MetaData</h2><p><img src="/img/2021/11/mdm/20211125103921.jpg" alt="img"></p>
<p>上面的红框标记哪些 key 需要匹配。</p>
<p>下面的红框，标记 key 匹配的值是啥。</p>
<p>当 key 匹配的值存在，那么，就能够路由到这个 host 上。</p>
<p>ps: 上面的代码意思是基于 eureka 的数据，进行动态更新。</p>
<h2 id="2-BeforeRoute-请求级别元数据"><a href="#2-BeforeRoute-请求级别元数据" class="headerlink" title="2 BeforeRoute 请求级别元数据"></a>2 BeforeRoute 请求级别元数据</h2><p><img src="/img/2021/11/mdm/20211125103943.jpg" alt="img"></p>
<p>创建一个自己的 StreamFilter。在 StreamFilter 路由前，设置请求级别元数据。我们这里创建的是 eurekaRPCGroupFilter。</p>
<h2 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h2><p><img src="/img/2021/11/mdm/20211125103953.jpg" alt="img"></p>
<p>当执行 choose host 时，subsetLoadBalancer.findSubset 函数会根据当前请求的元数据，从 subSetLoadbalancer 里找出匹配的 host List。</p>
<h2 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4 扩展"></a>4 扩展</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>如果想做更复杂的路由，例如分组里指定机器调用；</p>
<p>1 请求时, 可在 header 里，指定 ip，并在 varRouterMeta 里设置这个 ip。</p>
<p>2 host 配置，可在 metadata 里，配置 ip kv，例如 ip：192.168.2.3；</p>
<p>如下图:</p>
<p><img src="/img/2021/11/mdm/20211125104007.jpg" alt="img"></p>
<p>这样，就能匹配到指定机器了。</p>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>再例如，单个 host 存在于多个分组，而请求时，只能指定一个分组。如下图：</p>
<p><img src="/img/2021/11/mdm/20211125104018.jpg" alt="img"></p>
<p>我们现在有 2 台机器，共 3 个分组，AAA，BBB，CCC。每个机器都包含 AAA 分组。</p>
<p>现在有 3 个请求，每个请求都是不同的分组，此时，我们该如何配置 元数据呢？</p>
<p>首先，本质上，给机器加分组，其实就是打标。我们将元数据想象成 tag 列表即可。</p>
<p><img src="/img/2021/11/mdm/20211125104029.jpg" alt="img"></p>
<p>上面的代码，展示了：我们将多个分组标签，转换成 MOSN 可以认识的元数据 kv，每个标签对应一个固定的 value <code>true</code>（<code>为什么设置为 true 呢？value 自身其实在 MOSN 的 subsetLB 中是有含义的，即最终根据请中携带的 metadata 的值去匹配 cluster 中满足条件的 subset host entry。由于这个例子只使用了 key 自身做分组，所有的 value 都保持一样，所以本质上任何值都是可以的</code>）。同时注意，这些 key，都要保存到 SubsetSelectors 中，否则，MOSN 无法识别。</p>
<p>每次调用时，我们在 filter 里，从 header 里面取出分组标签，然后设置进“上下文变量”中。例如：</p>
<p><img src="/img/2021/11/mdm/20211125104038.jpg" alt="img"></p>
<p>这样，我们就能够完成更加复杂的分组路由。</p>
<h2 id="5-再谈-MetaData"><a href="#5-再谈-MetaData" class="headerlink" title="5 再谈 MetaData"></a>5 再谈 MetaData</h2><p>事实上, 我们不仅可以在 请求级别(varRouterMeta)设置元数据对 host 进行匹配, 也可以在路由信息中,配置元数据. 如下图:</p>
<p><img src="/img/2021/11/mdm/888.jpg"></p>
<p>上图中,左边是 host 配置,右边是 router 配置. </p>
<p>这个路由配置的意思是,当请求者的 header 里指定了 name 和 value, 且其值匹配这个路由值 service 和 service.green, 那么该请求就被路由到了这个 cluster_subset 集群中,然后, 这个集群可能有多个机器, 那么需要这个机器的元数据和路由配置的元数据相同.<br>必须都是 subset:green, 才能匹配上这个 Host;</p>
<p>另外, 如果路由配置中配置 MetaData, 请求级别也配置了 MetaData, 那么, MOSN 会将 2 个元数据进行合并, 来和 Host 进行匹配. 这个逻辑在 <code>pkg/proxy/downstream.go:1497</code> 代码中有体现.</p>
<h2 id="6-如何动态选择-Cluster？"><a href="#6-如何动态选择-Cluster？" class="headerlink" title="6 如何动态选择 Cluster？"></a>6 如何动态选择 Cluster？</h2><p>上面提到的是如何选择 cluster 里面的分组，其实动态路由，还包含如何动态选择 cluster 的场景。cluster 和 subset 的关系如下图：</p>
<p><img src="/img/2021/11/mdm/20211127163435.jpg"></p>
<p>正常情况下，如果我们的路由逻辑很简单，例如根据 header 里的某个名字，找到对应的 cluster，代码或者配置就是这么写的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router := v2.Router&#123;</span><br><span class="line">    <span class="comment">// header 匹配</span></span><br><span class="line">    RouterConfig: v2.RouterConfig&#123;</span><br><span class="line">        Match: v2.RouterMatch&#123;</span><br><span class="line">            Headers: []v2.HeaderMatcher&#123;</span><br><span class="line">                <span class="comment">// 这个 header 匹配, 就转发到 app.Name cluster.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Name:  <span class="string">&quot;X-service-id&quot;</span>,</span><br><span class="line">                    Value: strings.ToLower(app.Name),</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// cluster 名称匹配.</span></span><br><span class="line">        Route: v2.RouteAction&#123;</span><br><span class="line">            RouterActionConfig: v2.RouterActionConfig&#123;</span><br><span class="line">                ClusterName: app.Name,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">r.VirtualHosts[<span class="number">0</span>].Routers = <span class="built_in">append</span>(r.VirtualHosts[<span class="number">0</span>].Routers, router)</span><br></pre></td></tr></table></figure>
<p>上面代码的意思是如果 header 里有 X-service-id 这个 kv，那么就能找到下面 RouteAction 对应的 Cluster 了。</p>
<p>那如果是更复杂的逻辑呢？比如随机找一个 Cluster？</p>
<p>此时，通过配置已经无法解决这个需求，因为这其中涉及到了计算逻辑。</p>
<p>MOSN 通过动态配置可以支持该需求。如下图配置：</p>
<p><img src="/img/2021/11/mdm/11111122.png"></p>
<p>我们设置了一个 “cluster_variable”: “My-ClusterVariable” 的 KV 配置。</p>
<p>同时，我们还需要在 StreamFilter 中，利用变量机制，设置 key 为 “My-ClusterVariable” 的 value，这个 value 就是计算出来的 Cluster 名称。</p>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先注册这个 key 到变量表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	variable.Register(variable.NewStringVariable(<span class="string">&quot;My-ClusterVariable&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, variable.DefaultStringSetter, <span class="number">0</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clusterMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *MyFilter)</span> <span class="title">OnReceive</span><span class="params">(ctx context.Context, headers api.HeaderMap, buf buffer.IoBuffer, trailers api.HeaderMap)</span> <span class="title">api</span>.<span class="title">StreamFilterStatus</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(clusterMap)</span><br><span class="line">    <span class="comment">// 随机找一个 Cluster</span></span><br><span class="line">	cluster := clusterMap[rand.Intn(l)]</span><br><span class="line">    <span class="comment">// 设置到上下文变量中。这个 key 必须和配置文件中保持一致。</span></span><br><span class="line">	variable.SetString(ctx, <span class="string">&quot;My-ClusterVariable&quot;</span>, cluster)</span><br><span class="line">	<span class="keyword">return</span> api.StreamFilterContinue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示了如何基于变量机制动态的找到 Cluster，这种机制在面对复杂路由逻辑的场景时，能够解决你的问题。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p>尝试用一张图来解释 MOSN 路由和 Cluster 的关系。大部分情况下，我们用 json 配置就能解决我们的路由问题。<br>如果路由逻辑较为复杂，可以使用 Stream Filter + varRouterMeta 、Stream Filter  +  cluster_variable 等方式，来进行动态路由。</p>
<p><img src="/img/2021/11/mdm/20211127183927.jpg"></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>mosn,service mesh</category>
      </categories>
      <tags>
        <tag>service mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul 2.1.5 设计分析</title>
    <url>/2021/11/25/2021/zuul/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/Netflix/zuul">https://github.com/Netflix/zuul</a></p>
<p>zuul 是 SpringCloud 家族老兵，使用 Java 微服务大部分都在使用 zuul 作为网关。既然他如此重要，那么我们就来分析一下。本文分析的是 zuul 2.1.5版本。</p>
<h2 id="调用链路"><a href="#调用链路" class="headerlink" title="调用链路"></a>调用链路</h2><p>首先，我们知道，zuul 基于 Netty，Netty 是异步网络框架。我们从调用链路出发，分析下 Zuul 的调用链路是如何串起来的。</p>
<p>首先看官方介绍：</p>
<p><img src="/img/2021/11/zuul/1111.jpg" alt="image"></p>
<p>既然是基于 Netty 的，我们首先看 ChannelInboundHandler，Zuul 的 ChannelInboundHandler 名为 ClientRequestReceiver，用于接收 Http 请求。</p>
<p>然后，ClientRequestReceiver 会将请求交给 Zuul 的过滤器链，也就是我们经常编写的 Zuul 业务逻辑。Zuul 将整个过滤器链编织成一个 ZuulFilterChainHandler，作为 ClientRequestReceiver 的下一个 Handler。最后，当过滤器处理好逻辑并得到后端返回值，将 Response 交给 ClientResponseWriter，该类会将 Response 写回给客户端。代码如下：</p>
<p><img src="/img/2021/11/zuul/20211125181702.jpg"></p>
<p>好，我们知道了 Zuul 基于 Netty 是如何控制调用的，那么，我们再来看看，Zuul 是如何编织过滤器链的。代码就在 com.netflix.zuul.netty.server.BaseZuulChannelInitializer#addZuulFilterChainHandler 方法中。</p>
<p><img src="/img/2021/11/zuul/222.jpg"></p>
<p>从上面的截图，可以看到，Zuul 先是构造了 Response Filter Chain，然后再构造 Endpoint Chain，最后构造 Request Chain，形成了一张链表，并将起封装，添加到 Netty 的 pipeline 中。</p>
<p>Request Chain 作为头，Response Chain 作为尾，当 Response Chain 执行完之后，则会调用 ClientResponseWriter，将返回值写回 Http Client。</p>
<p>这里需要提一下 Endpoint Chain 概念，首先， Zuul 作为网关，核心职责是转发请求，而 endpoint 就是目标服务器，zuul 会将请求先经过 Request Chain，然后交给 Endpoint Chain，Endpoint Chain 则会请求后端服务器，拿到返回值，然后将返回值交给 Response Chain。</p>
<p>那么 Zuul 是如何请求后端服务的呢？</p>
<p>我们看 ZuulEndPointRunner 这个类，他是 Endpoint Chain 的标准实现。filter 方法是关键。</p>
<p><img src="/img/2021/11/zuul/333.jpg"></p>
<p>我们看到，这里有2个红框，第一个是获取过滤器，然后，执行过滤器逻辑，得到结果。从 getEndpoint 方法看，通常我们会得到 ProxyEndpoint 过滤器，他继承自 SyncZuulFilter。分支逻辑暂时不讲。</p>
<p>当得到 ProxyEndpoint 后，则会执行 apply 方法。</p>
<p><img src="/img/2021/11/zuul/aaa.jpg"></p>
<p>proxyRequestToOrigin 方法，背后是 Netty 客户端请求后端服务。该方法会先连接后端服务，然后在回调中，将 Request 内容发送给后端服务。注意，发送之前，会将 此客户端的异步接收类 OriginResponseReceiver 添加到 pipeline 中，用于处理后端返回值。OriginResponseReceiver 得到返回值后，则会调用 ProxyEndpoint 的 responseFromOrigin 方法，该方法，则会将返回值交给 Response Chain。Response Chain 处理完之后，再交给 ClientResponseWriter，完成一次完整的调用。</p>
<p>整个调用图如下：<br><img src="/img/2021/11/zuul/444.jpg"></p>
<p>上图展示了一次请求的整个过程。</p>
<p><code>我们继续讨论下一个问题：Zuul 如何识别请求，并将其正确的转发的目标服务器？</code></p>
<p>假设，zuul ip port 为172.3.3.3:8080，后端服务为 172.2.2.2:8888，服务名为 userService，zuul</p>
<p>如何将请求转发到 172.2.2.2:8888？</p>
<p>首先需要定义规则，我们将服务名作为标识，通过服务名去 Eureka 找到服务地址，然后再进行调用。标识放在哪里？我们可以放在 URL 里面，比如 172.3.3.3:8080/userService/getUser 这个 url ，实际是请求的 172.2.2.2:8888/getUser 这个服务。当然，也可以将服务名放在 header 里。看自己的实现。</p>
<p>当 Zuul 拿到标识，则会请求 Eureka，拿到 ip 地址，构造一个 Netty 客户端，即 ProxyEndpoint 的 NettyOrigin 属性。当调用 connectToOrigin 方法后，会返回一个 Netty 的 promise，ProxyEndpoint 会将自己的调用逻辑放在回调中，即，NettyOrigin connect 成功后，ProxyEndpoint 会发送数据给后端服务器。</p>
<p>我们查看 com.netflix.zuul.netty.connectionpool.DefaultClientChannelManager#acquire 方法，该方法，会先调用 Server chosenServer = loadBalancer.chooseServer(key)， 得到一个服务器ip port。然后得到一个 PerServerConnectionPool，</p>
<p>该类的 tryMakingNewConnection 方法，会构造一个 Netty 客户端。</p>
<p><img src="/img/2021/11/zuul/bbb.jpg"></p>
<p>至此，我们已经知道了 Zuul 整个的调用链路是如何实现的。</p>
<h2 id="异步分析"><a href="#异步分析" class="headerlink" title="异步分析"></a>异步分析</h2><p>Zuul 是如何基于 Netty 实现异步的呢？</p>
<p>首先入口 Handler 是 ClientRequestReceiver，当 ClientRequestReceiver 拿到请求后，会将 Request 交过过滤器链，而 Zuul 的过滤器是支持异步的。基于 RxJava 加入了 applyAsync 方法。</p>
<p>ProxyEndpoint 在请求后端服务时，也是异步的，ProxyEndpoint 的 apply 方法里，将自己的业务逻辑，放到了 zuul 客户端的回调里，这是基于 Netty 实现的。</p>
<p>流程图如下：</p>
<p><img src="/img/2021/11/zuul/ccc.jpg"></p>
<p>可以看到，Netty IO 线程，基本没有等待，从流量进来之后，要么在执行 Request chain 逻辑，要么在构建 Netty Client，没有任何等待 IO 的过程，当 Endpoint 在请求后端服务时，IO 线程是空闲的。而当后端返回时，会触发 Netty 客户端的回调，进而触发 Zuul Response 过滤器链，最后写回 ClientResponseWriter。</p>
<p>有个问题，异步返回时，是如何找到 ClientResponseWriter 的呢？Zuul 的实现方式是，将 ChannelHandlerContext 保存到 Session 里（_netty_server_channel_handler_context），当异步返回时，则会继续调用这个 ChannelHandlerContext 后面的 Handler 的 channelRead 方法。</p>
<p>Zuul 的 worker EventLoop grop 名为 Salamander-ClientToZuulWorker；</p>
<p>在构造请求 后端服务的 Netty 客户端时，也是使用的该 EventLoop。如下图：</p>
<p><img src="/img/2021/11/zuul/ddd.jpg"></p>
<p>可以看到，处理请求 和 处理返回值的，是同一个线程。为什么不为每个 Netty Client 设计一个 Eventloop group 呢？我的理解是代价太大了，网关会 连接成千上万个后端，如果每个 Netty Client 都配置一个 Group，那服务器估计要爆炸。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>开源 Zuul 2（Netflix 技术博客）</p>
<p><a href="https://netflixtechblog.com/open-sourcing-zuul-2-82ea476cb2b3">https://netflixtechblog.com/open-sourcing-zuul-2-82ea476cb2b3</a></p>
<p>Zuul 2：Netflix 的异步、非阻塞系统之旅（Netflix 技术博客）</p>
<p><a href="https://netflixtechblog.com/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c">https://netflixtechblog.com/zuul-2-the-netflix-journey-to-asynchronous-non-blocking-systems-45947377fb5c</a></p>
]]></content>
      <categories>
        <category>zuul</category>
      </categories>
      <tags>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Canal 设计可扩展、高可用 Binlog 同步集群</title>
    <url>/2021/11/15/2021/drc/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<p>binlog 同步组件，canal 使用是比较广泛的，canal 逻辑架构如图：</p>
<p><img src="/img/2021/11/drc/111111.jpg"></p>
<p>部署架构如图：</p>
<p><img src="/img/2021/11/drc/2222.jpg"></p>
<p>canal 基于主从模式，任务都运行在 master 中，client 从 master 拉取数据。在使用 canal server 的过程中，我们遇到了一些问题，例如扩展性不足，默认情况下，当任务流量变多变大时，单机无法支持大流量，要么增加主从集群，要么增加机器配置。</p>
<p>相关讨论：<a href="https://github.com/alibaba/canal/issues/147">https://github.com/alibaba/canal/issues/147</a></p>
<p>增加主从集群的问题：slave 机器很浪费。官方建议手动修改 running 配置，将 instance 平均分散。这样可以避免机器浪费。手工操作，不太友好，当流量突然变大时，无法应对。另外，操作麻烦，需要将任务从 a 集群迁移到 b 集群。</p>
<p>增加机器配置的问题：需要重启机器，重启前，需要转移任务到其他的机器，升级成功后，再手动转移回来（通过修改 zk</p>
<p>running 配置）这个对线上操作，不太友好。如果是临时流量，那就更危险了。</p>
<p>部署不太友好，基于 ECS 的部署方式很麻烦，不符合目前 k8s 动态扩缩容的设计。</p>
<p>不支持全量同步 + 增量同步，限流等逻辑。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>基于以上问题，我们想设计出一种支持以下特性的架构。</p>
<p>canal 任务可自动均匀分散在集群中，且集群机器互为主备。此需求解决大量任务运行+资源浪费+ 手动操作风险</p>
<p>该架构支持 k8s 集群，可快速扩容，升配。此需求解决大流量问题。</p>
<p>能够将指定的 canal 任务移动到指定机器。（虽然大部分任务流量不大，但需要考虑部分任务流量很大，需要单独高性能机器）</p>
<p>支持限流，暂停等操作。</p>
<p><img src="/img/2021/11/drc/333.jpg"></p>
<p>如上图所示，我们定义了几个角色：</p>
<p>Manager，表示这个集群的管理者，用于调度 worker，并接收 worker 心跳</p>
<p>worker，用于执行 task 任务</p>
<p>task，包含 canal Server，canal client，binlog handler，能够连接 MySQL 服务器，拉取 binlog，并交给 binlog handler 处理，例如直接插入目标 MySQL，投递 Kafka，RocketMQ ，ES 等等。</p>
<h3 id="高可用？"><a href="#高可用？" class="headerlink" title="高可用？"></a>高可用？</h3><p>如何保证高可用？</p>
<p>当一个 worker 挂掉了，manager 收不到心跳，会将这个 worker 上任务，转移到其他的 worker 上（manager 会有一个 30s 间隔的定时任务扫描心跳），注意：task 有状态，状态保存在 Zookeeper 上。worker 宕机后，manager 会在其他的 worker 上启动 task，此时 task 会从 Zookeeper 上读取状态，这块逻辑和 canal 自身几乎相同。</p>
<h3 id="扩展性？"><a href="#扩展性？" class="headerlink" title="扩展性？"></a>扩展性？</h3><p>当任务较多时，基于 k8s 基础之上，可立刻扩容机器，新机器会向 manager 发送心跳，manager 收到心跳后，则会将其他 worker 的任务，转移部分到新的 worker 上。</p>
<p>升配时，可先启动高配置 worker，manager 会将任务转移到高配置 worker，然后，k8s 系统会自动销毁低配置机器。此时，系统逻辑会回到高可用系统中。</p>
<h3 id="部署？"><a href="#部署？" class="headerlink" title="部署？"></a>部署？</h3><p>worker 和 manager 本身基于 springCloud，无状态，可快速扩展。</p>
<h3 id="增量-全量？"><a href="#增量-全量？" class="headerlink" title="增量 + 全量？"></a>增量 + 全量？</h3><p>manager 系统已经实现该逻辑，当全量任务同步前，会先开启增量任务并暂时保存，然后开启全量任务，当全量任务结束时，会自动触发增量数据回放，回放结束后，则会回到纯增量逻辑</p>
<h3 id="指定部署"><a href="#指定部署" class="headerlink" title="指定部署"></a>指定部署</h3><p>指定将某个任务部署到指定机器，这个比较简单，manager 系统支持将指定任务名，分配到指定 ip 启动。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/img/2021/11/drc/aaa.jpg"></p>
<p>上图显示了我们的系统，首页中，显示 worker 节点 8 个。task 35 个，qps 241， 下面的 running worker list 显示了 worker 工作详情（QPS，task 数量），每个worker 的 task 数量基本相同，但也支持手动调节。</p>
<p><img src="/img/2021/11/drc/bbb.jpg"></p>
<p>上图显示了 manager 支持自动重新负载所有 task。目的是让所有 task 均匀分布在运行的 worker 上。</p>
<p>下面的手动，显示了可以将某个指定 task 转移到指定 机器 上。</p>
<p><img src="/img/2021/11/drc/ccc.jpg"></p>
<p>上图显示了如何创建一个任务。</p>
<p><img src="/img/2021/11/drc/ddd.jpg"></p>
<p>上图显示了任务列表，可配置 QPS 进行限流，可早操作界面停止子任务。</p>
<p>目前，我司大部分同步任务，包括全量任务，增量任务，全量+增量任务，基本都使用该系统。业务场景包括，同步 MySQL 到 ES，数据库迁移，数据库同步，全链路压测影子库数据同步等。效果很好。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢 canal 团队提供优秀的产品，使我们在 canal 基础上，开发了该系统。</p>
]]></content>
      <categories>
        <category>Canal</category>
      </categories>
  </entry>
  <entry>
    <title>第一篇简书</title>
    <url>/2017/01/03/2017/2017-01-03-%E7%AC%AC%E4%B8%80%E7%AF%87%E7%AE%80%E4%B9%A6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       #第一篇简书,用于测试 Markdown

<p><em><code>开通了好几个博客,用于测试哪个好用.</code></em></p>
<blockquote>
<p>WeakHashMap 是怎么工作的？</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">WeakHashMap 的工作与正常的 <span class="keyword">HashMap</span> 类似，但是使用弱引用作为 <span class="built_in">key</span>.</span><br><span class="line">意思就是当 <span class="built_in">key</span> 对象没有任何引用时，<span class="built_in">key</span>/value 将会被回收。</span><br></pre></td></tr></table></figure>



<ul>
<li>保洁阿姨来教室打扫卫生了,我也应该睡觉了,==下午再战.</li>
</ul>
<ul>
<li>修改</li>
</ul>
<p><strong>Java 代码</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">  public static void main(String<span class="literal">[]</span> args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread()</span> &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.is<span class="constructor">Interrupted()</span>) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Interrupted&quot;</span>);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.is<span class="constructor">Interrupted()</span>);</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">2000</span>);</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           <span class="comment">// 此处由于中断而抛出异常会清除中断标记，因此重新设置中断标记</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.is<span class="constructor">Interrupted()</span>);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Interrupted when sleep&quot;</span>);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.interrupt<span class="literal">()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.is<span class="constructor">Interrupted()</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start<span class="literal">()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line">    t1.interrupt<span class="literal">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>5年程序员</title>
    <url>/2017/01/04/2017/2017-01-04-5%E5%B9%B4%E7%A8%8B%E5%BA%8F%E5%91%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在csdn看到一篇文章,5年钻研,终于变成技术大牛.总结了一下.

<p>1)只往一个方向去攻克,立志成为那个方向的专家—也就是Java</p>
<p>2)坚持,因为你知道,总有一天你将不在这样.</p>
<p>3)不要去怀疑现有的语言,在后端的领域,Java不会过时,就算过时也不会在你学会之前过时.</p>
<p>4)那个人称自己5年花了6000个小时,我觉得我可以乘以2. </p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>关于野生程序员</title>
    <url>/2017/01/15/2017/2017-01-15-%E5%85%B3%E4%BA%8E%E9%87%8E%E7%94%9F%E7%A8%8B%E5%BA%8F%E5%91%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       刚在简书上看了一篇文章，讲的是一个少年18岁放弃了读书，去学习了编程，还挺感慨的，以为这个世界上又要多一个程序员了，峰回路转，他又去复读了，好吧，总是难以挣脱命运的。

<p>既然励志做一个程序员，为什么要把时间浪费在根本在编程用不到的课程上面呢，有7年的学习时间，为什么不将这些时间全部用在学习编程上呢，如果真的热爱它，无论发生什么都不会妥协的吧，还是罗老师说的好：只有偏执狂才能生存。</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA-的介绍和下载和使用</title>
    <url>/2017/02/14/2017/2017-02-14-IDEA-%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%B8%8B%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       #IDEA 的介绍和下载和使用

<p>关于Java的ide工具，eclipse人尽皆知，对于Java社区的贡献也是不可限量，而另一个工具，idea也是大名鼎鼎，最早的时候在《Java编程思想》就听说是世界上最具创新的的ide，也在网上看见很多大牛在使用，那炫酷的黑色界面令人神往。但是还是没有机会使用。我以前是经常使用eclipse的，虽然写不了插件，但是使用上还是很熟悉的，但是进了新公司，为了配合同事，开始使用idea，下面我来说说我的入坑之路吧！</p>
<p>首先需要下载IDEA。对于我们这些苦逼程序员来说，价格还是很割肉的，所以，我们低调的使用破解版，我下载的是Mac版的，如果需要可以留下邮箱。<br>当然网上也是有很多的。</p>
<p>IDEA有社区版和旗舰版，社区版是免费的，但是功能也是阉割的，比如据我所知，社区版就是不能创建Java web项目的（可以使用Javaweb项目），而旗舰版功能无比强大，下图就是旗舰上上可以创建的项目，比eclipse强多了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c29612ae66eba2d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="idea旗舰版强大的功能"></p>
<p>具体的使用教程，网上有很多，我也不重新写了<br>以下是网址：<br><a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/about-this-tutorial.html">http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/about-this-tutorial.html</a><br>写得很详细，我也经常看一看。</p>
<p>关于使用方面的问题，反正我第一件事情就是修改主题，那黑色的主题实在是太诱人，主要参考的文章都不是很清楚，可能是因为我的是16版，而idea的界面都已经改了。那么我就自己截图给大家看看在哪里改：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7b6d1ced92fd0003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首先这样"></p>
<p>然后这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e68a73b69bdddb4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意观察，因为我省略了一步"></p>
<p>如果觉得这个不好看，有一个专门的网站是有免费的主题下载的，你可以下载成jar包，然后倒入到idea中。</p>
<p>不过经过我的使用，还是这个比较经典好看。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>一次故障排查过程</title>
    <url>/2019/02/18/2019/2019-02-19-ycgzpcgc/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       上周晚上，某环境 ES 出现阻塞， 运行缓慢。于是开始排查问题的过程。

<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>思路：现象是阻塞，通常是 CPU 彪高，导致业务线程分配不到 CPU 时间片，或者内存吃紧，频繁 GC 导致的 STW。登录到目标服务器，由于 ES 的用户不是 LZ，因此找运维要了 root 权限，登录到服务器。sudo -i 切到 root，使用 <code>ps -ef | grep Elasticsearch </code>找到该用户，然后 <code>su - es</code> 切到 <code>es</code> 用户（不切是无法处理 es 用户的 Java 进程的，例如打印 jstack 日志）。<br>top 查看服务器状态，发现 pid 4335 进程的 CPU 占用达到 180%，查看 CPU 核数：cat /proc/cpuinfo| grep “processor”| wc -l， 核数为 4，根据经验，通常是 C2 编译器，或者 GC 线程，最后是业务代码导致。因此需要定位该线程。使用 <code>top -Hp 4335</code>，得到线程号 <code>30785</code>，使用 <code>printf &quot;%x&quot;</code> 得到 16 进制数字 <code>7841</code>，方便在 <code>jstack </code>日志查找线程。使用 <code>jstack -l 4335 &gt; jstacklog.txt</code> 打印日志，然后找线程，<code>vim jstacklog.txt</code>, 开始查找，<code>gg，/7841，enter，n</code>， 找到 <code>&quot;Concurrent Mark-Sweep GC Thread&quot; os_prio=0 tid=0x00007fd380063800 nid=0x7841 runnable </code>这个 CMS GC 线程，看来是内存不够了。 使用 jps -l 找到 es 启动类名称，然后使用 ps aux | grep Elasticsearch 找到启动详细信息，发现启动配置为 -Xmx2g -Xms2g, -XX:CMSInitiatingOccupancyFraction=50 ，这里为了防止串行 FGC，让 CMS 在 old 区达到 50% 时就开始 GC，所以 CMS 非常繁忙。为了验证此问题，使用 jstat -gcutil 4335 1000 查看 gc 状态，发现 fgc 频繁(5 秒一次)，ygc 正常（3 秒一次） ，这里说一下，CMS 的 fgc 此时和我们想象的不一样，CMS GC 只工作在老年代，每次 GC 会对 FGC 次数加 2，一次是 init mark，一次是 remark，这两个阶段会影响暂停应用，其他的清理阶段是并行清理的，对业务线程无影响，所以，当使用 CMS GC ，如果 jstat 看到 FGC 次数很多，不用在意。但当 CMS 出现 concurrent mode failure（CMS GC 的速度赶不上对象晋升到 old 区的速度），则会使用备用收集器 Serial，开始串行 GC，此时将会彻底 STW。 因此，这个 ES 将 CMS 的阈值调的很低，就是为了防止出现 concurrent mode failure。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>原因已经找出，由于 CMS GC 频繁，导致 CPU 彪高，ES 查询速度变慢，最后业务阻塞。</p>
<h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><p>但是为什么频繁 CMS 呢？肯定是内存不够，为什么不够呢？ 通常是通过 <code>dump </code>内存文件查看，但是注意，jmap 和 jcmd dump 文件时，会导致 fgc，线上需要注意，我这里由于不是业务高峰，使用 jmap -dump:format=b,file=/tmp/dump.hprof 3445 , 导出该文件到 tmp 目录，方便从跳板机上下载。</p>
<p>从跳板机下载文件，权限不够，使用 <code>sudo chown -R username dump.hprof </code>修改权限，然后下载。</p>
<p>LZ 使用的是 mac，使用 mat（Mac 的 mat 有 bug，需要替换一个 jar 包，具体自行搜索） 开始分析，发现内存中有 1个多 g 的 indexService 对象（600 多），即 ES 的索引对象，通过和 ES 同学的沟通，确实发现有 600 多索引，有很多都是国企索引，通常一台 ES 差不多配置 100-200 索引，大量索引引起更新，频繁更新索引对象。</p>
<p>最后，将ES 内存升级到 4g，<code>-XX:CMSInitiatingOccupancyFraction</code> 修改为75，减少 CMS GC。删除 ES 无效索引。问题解决。</p>
<p>后期为了检验结果，使用 jvisualvm 连上服务器 Java 进程： 登录到目标服务器，创建文件 <code>jstatd.all.policy</code>，文件内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grant codebase <span class="string">&quot;file:$&#123;java.home&#125;/../lib/tools.jar&quot;</span> &#123;</span><br><span class="line">   permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行 <code>jstatd -J-Djava.security.policy=jstatd.all.policy -p 1222 &amp; </code>, 启动 jstatd 后台服务，方便 <code>jvisualvm</code> 连接到这台服务器的 Java 进程。找到本机 Java 目录下的 VisualVM ,连接上目标 ip 和 1222 端口服务，安装 GC 插件，查看 GC 状态。</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
  </entry>
  <entry>
    <title>UML-类图总结图（建议保存）</title>
    <url>/2017/05/06/2017/2017-05-06-UML-%E7%B1%BB%E5%9B%BE%E6%80%BB%E7%BB%93%E5%9B%BE%EF%BC%88%E5%BB%BA%E8%AE%AE%E4%BF%9D%E5%AD%98%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ![uml.png](https://upload-images.jianshu.io/upload_images/4236553-7032e37b92f11457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



<p>继承和实现就不说了，稍微说说其他的：</p>
<ol>
<li>依赖：指的是两个类之间的必须关系，比如 “人” 依赖 “手” 和 “脚”，这是<strong>必须</strong>的。</li>
<li>关联：一般用于你中有我，我中有你的关系，又或者，一对多或者一对一或者多对多的关系。</li>
<li>组合：类似依赖，但是，是一对多的关系。比如 鸟 需要 2 只翅膀。</li>
<li>聚合：可以想象成一个管理者管理很多相同的类。比如大雁数组管理大雁，那么，雁群就聚合和很多大雁。</li>
</ol>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>对于技术的一点思考</title>
    <url>/2017/06/08/2017/2017-06-08-%E5%AF%B9%E4%BA%8E%E6%8A%80%E6%9C%AF%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       来到新公司，公司主营业务是ar图书app，分后台管理和api接口两个服务端，api接口使用的是springboot + mybatis，后台管理使用的是springmvc + mybatis，看来mybatis 还是比更hibernate更令人接受，hibernate的强大功能不是每一个人都能熟练掌握的，而mybatis的灵活和轻量正式互联网公司所需要的。

<p>以前做的也是spirngboot的小项目，那时候boss说，我们使用springboot是为了以后上微服务，但是直到我走了还是没有微服务，现在，这家公司的架构师很厉害，将我们app所有的业务进行拆分，分成一个个小的springboot，每个服务之间使用新浪的motan rpc框架进行远端调用。不知道这算不算微服务?</p>
<p>后天管理使用的是jsp，说实话，我对jsp是抵制的，我不喜欢前端，我认为以后的趋势就是前后端高度分离，而不是什么所谓的全栈，我最恨的就是全栈这个词了，真正的误导程序员，认真看一下周围，那些牛人哪一个不是在专属领域有所建树，而不是东会一点，西会一点。狗屁用都没有。</p>
<p>我也认为现在的安卓和ios会被js取代，不过也无妨啊，反正客户端永远都在变。</p>
<p>关于代码质量，我看见有人用蹩脚的英文写着自己都看不懂的注释，让人啼笑皆非。注释的意义就是用来解释复杂的晦涩的代码，用半吊子英文意义何在呢？<br>架构师要求我们使用的统一的格式化模板，使用统一的注释模板，使用checkstyle检查代码，使用findbug 静态检查代码，这些在之前我都是没有接触到的，确实方便了很多。加上idea自带的检查，一些低级的错误得以避免。<br>我们的架构师使用的eclipse，而我们这些年轻人在我的诱惑下全都换上了idea，虽然idea不及宇宙第一的vs，但是还是比eclipse好用多了，eclipse的无故报错我早就受不了了，我猜想架构师应该是习惯了使用eclipse了吧。</p>
<p>在以前，我们的项目中使用搜索查询的时候，总是使用like，而like不仅效率低，而且可能会发生死锁的状况，架构师亲自上手使用solr搜索引擎，反正我是看不懂的。当然还是要花时间去学习的，我想，在这家公司我一定能学会不少东西吧。</p>
<p>在多数据库的情况下，我们使用的分库策略是根据域名，使用spring的动态数据源进行切换，以前说读写分离很高大上，看起来也没什么，重要的如何保持一致性和事务。</p>
<p>在后台管理的安全方面，我们使用shiro框架，shiro使用tomcat的过滤器执行用户session的过滤，其实我也还没怎么弄明白他的机制。</p>
<p>好了，接下来的半年我要攻击spring 技术内幕这本书，更加的去了解spring，还有mybatis，这两个框架一定要熟悉的不能再熟悉。<br>我还要弄懂shiro。<br>我还要弄懂数据库的高级特性。<br>我还要对设计模式有更深入的认识，其实对框架的理解就是建立在设计模式上的，如果看不懂设计模式，根本不会明白作者为什么那么设计框架，就在我稍稍研究的过滤器就是使用的责任链模式，但如果对责任链模式毫不知情，那么就无法理解过滤器的原理。<br>我还要对java4大高级特性有更深入的认识。这些都是java的基础。<br>另外，工作难免会设计js和css，这些也都是要去学习的，虽然不需要像java那样花大时间去学习，但总也要懂点。</p>
<p>看着上面给自己列的列表。压力很大啊，但我就是喜欢这样不断的钻研，不断的突破自己。<br>接下来的笔记都会写在有道云笔记里，到时候会修订后一起发出来。<br>就用这把我最爱的hhkb来完成下半年的任务吧。</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>宇宙第二IDE——使用IDEA快捷键阅读源码</title>
    <url>/2017/08/04/2017/2017-08-04-%E5%AE%87%E5%AE%99%E7%AC%AC%E4%BA%8CIDE%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ctrl + e 查看最近打开的文件
caps + tab 同样也是查看最近打开的文件
ctrl + {  返回上一步编辑获取鼠标停留的位置
ctrl + } 返回下一步编辑获取鼠标停留的位置

<p>阅读源码最重要的几个功能：<br>1：查看某方法被哪些地方调用：ctrl + g<br>2：查看某方法的调用树：Ctrl+Alt+H<br>3：查看某个类被某些地方调用（不包括实现的接口）：ctrl + T<br>4：查看某个类的继承树：show diagram 能够看到这个类的继承的图，很清晰<br>5：查看某个类的被继承树： F4<br>6：查看某个类的方法和属性，或者包含的父类属性：点击左上角的structure查看。</p>
<p>还有一些小功能：比如正常使用的ctrl + v ,只能看到你上一次粘贴的，而使用ctro + shift + v 就能看到一个粘贴板，可以多重选择。</p>
<p>还有一些缩写，方便使用<br>1：psvm        public static void main(String[] args){}<br>2：sout          System.out.println();<br>3：souf          System.out.printf();<br>4：serr          System.err.println();<br>5：psf            public static final<br>6：psfi           public static final int<br>7：psfs          public static final String</p>
<p>抽取一段代码重构：<br>alt + shift + m</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>详解Spirng-目标方法参数-Reader和@RequestBody在Spring中如何抉择</title>
    <url>/2017/08/04/2017/2017-08-04-%E8%AF%A6%E8%A7%A3Spirng-%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-Reader%E5%92%8C@RequestBody%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8A%89%E6%8B%A9/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       首先，我们都知道在使用spring框架的时候，无论是springmvc还是springboot，都可以在Controller层使用一些参数来取得我们想要的目的。

<p>首先我们debug，进入最核心的方法中，发现核心方法就是ServletInvocableHandlerMethod类中的invokeAndHandle方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法入口和结束的地方就是ServletInvocableHandlerMethod.invokeAndHandle()方法中</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, </span></span></span><br><span class="line"><span class="params"><span class="function">          ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  此处进入项目代码</span></span><br><span class="line"> Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line"><span class="comment">// 此处接受项目代码返回值</span></span><br><span class="line"> setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">   mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.responseReason)) &#123;</span><br><span class="line">  mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">    returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   logger.trace(getReturnValueHandlingErrorMessage(<span class="string">&quot;Error handling return value&quot;</span>, returnValue), ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">重点看invokeForRequest：</span><br><span class="line">调用Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"></span><br><span class="line">核心代码：InvocableHandlerMethod.getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,  Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,</span><br><span class="line">  Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 获取所有的参数</span></span><br><span class="line"> MethodParameter[] parameters = getMethodParameters();</span><br><span class="line"><span class="comment">// 创建数组</span></span><br><span class="line"> Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line"><span class="comment">// 遍历参数</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line"><span class="comment">// 得到具体参数</span></span><br><span class="line">  MethodParameter parameter = parameters[i];</span><br><span class="line"></span><br><span class="line">  parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">  GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());</span><br><span class="line">  args[i] = resolveProvidedArgument(parameter, providedArgs);</span><br><span class="line">  <span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 注意，此处是核心，进入此方法，则改变返回的到底之什么值</span></span><br><span class="line">    args[i] = <span class="keyword">this</span>.argumentResolvers.resolveArgument(</span><br><span class="line">      parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">     logger.debug(getArgumentResolutionErrorMessage(<span class="string">&quot;Error resolving argument&quot;</span>, i), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">   String msg = getArgumentResolutionErrorMessage(<span class="string">&quot;No suitable resolver for argument&quot;</span>, i);</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####调用HandlerMethodArgumentResolverComposite.resolveArgument（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">  NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 此处很重要，会返回不同的子类，不同的子类调用下面的方法有不同的实现</span></span><br><span class="line"> HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);</span><br><span class="line"> <span class="keyword">if</span> (resolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown parameter type [&quot;</span> + parameter.getParameterType().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####然后调用resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory)；根据不同的resolver对象返回不同的值。这就是spring的抉择。应该算是状态模式吧。<br>那我们看看每次返回的具体子类是什么：<br>// Reader的方法参数的实现类是@ServletRequestMethodArgumentResolver<br>// @RequestBody注解的实现是@RequestResponseBodyMethodProcessor<br>// Map参数的实现类是@HandlerMethodArgumentResolverComposite</p>
<p>然后他们调用各自的resolveArgument(parameter, mavContainer, webRequest, binderFactory)方法<br>去实现自己的逻辑去解析。从而返回不同的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find a registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125; that supports the given method parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 此方法决定返回什么值</span></span><br><span class="line"> HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line"> <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (HandlerMethodArgumentResolver methodArgumentResolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Testing if argument resolver [&quot;</span> + methodArgumentResolver + <span class="string">&quot;] supports [&quot;</span> +</span><br><span class="line">      parameter.getGenericParameterType() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 就是根据这个，是否支持某参数来确定resolver的返回的子类</span></span><br><span class="line">   <span class="keyword">if</span> (methodArgumentResolver.supportsParameter(parameter)) &#123;</span><br><span class="line">    result = methodArgumentResolver;</span><br><span class="line">    <span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#####下面的方法返回了Reader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">  NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"> Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line"> <span class="keyword">if</span> (WebRequest.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">  <span class="keyword">return</span> webRequest;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"> <span class="keyword">if</span> (ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">  Object nativeRequest = webRequest.getNativeRequest(paramType);</span><br><span class="line">  <span class="keyword">if</span> (nativeRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">     <span class="string">&quot;Current request is not of type [&quot;</span> + paramType.getName() + <span class="string">&quot;]: &quot;</span> + request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nativeRequest;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (HttpSession.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">  <span class="keyword">return</span> request.getSession();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (HttpMethod.class == paramType) &#123;</span><br><span class="line">  <span class="keyword">return</span> ((ServletWebRequest) webRequest).getHttpMethod();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (Principal.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">  <span class="keyword">return</span> request.getUserPrincipal();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (Locale.class == paramType) &#123;</span><br><span class="line">  <span class="keyword">return</span> RequestContextUtils.getLocale(request);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (TimeZone.class == paramType) &#123;</span><br><span class="line">  TimeZone timeZone = RequestContextUtils.getTimeZone(request);</span><br><span class="line">  <span class="keyword">return</span> (timeZone != <span class="keyword">null</span> ? timeZone : TimeZone.getDefault());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;java.time.ZoneId&quot;</span>.equals(paramType.getName())) &#123;</span><br><span class="line">  <span class="keyword">return</span> ZoneIdResolver.resolveZoneId(request);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (InputStream.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">  <span class="keyword">return</span> request.getInputStream();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (Reader.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line"><span class="comment">// 返回了Reader</span></span><br><span class="line">  <span class="keyword">return</span> request.getReader();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// should never happen...</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">    <span class="string">&quot;Unknown parameter type: &quot;</span> + paramType + <span class="string">&quot; in method: &quot;</span> + parameter.getMethod());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>######此方法返回了Json对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">  NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"> parameter = parameter.nestedIfOptional();</span><br><span class="line"><span class="comment">// 就是下面的方法，层层调用，最后使用ObjectMapper解析了字符串，变成了@RequestBody中的对象</span></span><br><span class="line"> Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line"> String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line"> WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line"> <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">  validateIfApplicable(binder, parameter);</span><br><span class="line">  <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们重写了解析了json的类，重写了<span class="number">240</span>行的代码，方便我们解析参数</span><br><span class="line"><span class="keyword">package</span> org.springframework.http.converter.json;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">  JavaType javaType = getJavaType(type, contextClass);</span><br><span class="line">  <span class="keyword">return</span> readJavaType(javaType, inputMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readJavaType</span><span class="params">(JavaType javaType, HttpInputMessage inputMessage)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputMessage <span class="keyword">instanceof</span> MappingJacksonInputMessage) &#123;</span><br><span class="line">      Class&lt;?&gt; deserializationView = ((MappingJacksonInputMessage) inputMessage).getDeserializationView();</span><br><span class="line">      <span class="keyword">if</span> (deserializationView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.objectMapper.readerWithView(deserializationView).forType(javaType).</span><br><span class="line">            readValue(inputMessage.getBody());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在这里修改源码</span></span><br><span class="line">    InputStream inputStream = inputMessage.getBody();</span><br><span class="line">    String body = FileCopyUtils.copyToString(<span class="keyword">new</span> InputStreamReader(inputStream,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    body = mxr(body);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.objectMapper.readValue(body, javaType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">&quot;Could not read document: &quot;</span> + ex.getMessage(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这篇文章以代码居多，通过对spring如何修改参数的设置，我们可以在他的逻辑里定义自己想要的逻辑，比如修改参数。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>CPU</title>
    <url>/2017/10/08/2017/2017-10-08-CPU/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       1. 传统cpu只有控制器和运算器，而现代cpu异常复杂，含有浮点运算器，cache等。

<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><blockquote>
<p>由程序计算器，指令寄存器，指令译码器，时序产生器和操作控制器组成，他是发布命令的“决策机构”，即完成协调和指挥整个计算机系统的操作。控制器的主要功能有：</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 从内存中取出一条指令，并指出下一条指令在内存中的位置。</span><br><span class="line"><span class="number">2</span>. 对指令进行译码和测试，并产生相应的操作控制信号，以便启动规定的动作。比如一次内存读<span class="regexp">/写操作，一个算术逻辑运算操作，或一个输入/</span>输出操作。</span><br><span class="line"><span class="number">3</span>.指挥并控制cpu。内存和输入/输出设备之间数据流动的操作。</span><br></pre></td></tr></table></figure>

<h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><blockquote>
<p>有算数逻辑单元（ALU），累加寄存器，数据缓存寄存器和状态添加寄存器组成，他是数据加工处理部件，相对控制器而言，运算器接受控制器的命令而进行动作。即运算器锁进行的全部操作都是由控制器的控制信号来指挥的。所以它是执行部件。运算器由两个主要功能：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.执行所有的算术运算。</span><br><span class="line">2.执行所有的逻辑运算，并进行逻辑测试，入零值测试或两个值的比较。通常，一个算术操作产生一个运算结果，而一个逻辑操作则产生一个判决。</span><br></pre></td></tr></table></figure>

<h2 id="cpu中的主要寄存器"><a href="#cpu中的主要寄存器" class="headerlink" title="cpu中的主要寄存器"></a>cpu中的主要寄存器</h2><ol start="0">
<li><p>数据缓冲寄存器</p>
<blockquote>
<p> 数据缓冲寄存器用来暂时存放有内存储器读出的一条指令或一个数据字；反之，当向内存存入一条指令或一个数据字时，也暂时将它们存放在数据缓冲寄存器中。缓冲寄存器的作用是：（1）作为CPU和内存。外部设备之间信息传送的中转站；（2）补偿CPU和内存，外围设备之间在操作速度上的差别；（3）在单累加器结构的运算器中，数据缓冲寄存器还可兼做为操作数寄存器。</p>
</blockquote>
</li>
<li><p>指令寄存器（IR）</p>
<blockquote>
<p>用来保存当前正在执行的一条指令。为了执行任何给定的指令，必须对操作码进行测试，以便识别锁要求的操作。一个叫做<strong>指令译码器</strong>的部件就是做这项工作的。指令寄存器中操作码字段的树人初就是治理你译码器的输入。</p>
</blockquote>
</li>
<li><p>程序计数器（PC）</p>
<blockquote>
<p>为了保证程序能够连续地执行下去，cpu必须具有某些手段来确定下一条指令的地址。所以又称为<strong>指令计数器</strong>。</p>
</blockquote>
</li>
<li><p>地址寄存器（AR）</p>
<blockquote>
<p>用来保存当前cpu所访问的内存单元的地址。</p>
</blockquote>
</li>
<li><p>累加寄存器AC </p>
<blockquote>
<p>通常简称为累加器，他是一个通用寄存器。其功能市：当运算器的算数逻辑单元（ALU）执行算数或逻辑运算时，现将一个操作数暂时存放在AC中,再从内存中取出另一操作数，然后同AC的内容相加，所得的结果送回AC中，而AC中原有的内容随机被破坏。</p>
</blockquote>
</li>
<li><p>状态条件寄存器（PSW）</p>
<blockquote>
<p>保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容，入运算结果进位标志(C),运算结果溢出标志（V), 运算结果为零标志（Z)，运算结果为负标志（N)，等等。这些标志位通常分别有1位触发器保存。</p>
</blockquote>
</li>
</ol>
<h4 id="操作控制器与时序产生器"><a href="#操作控制器与时序产生器" class="headerlink" title="操作控制器与时序产生器"></a>操作控制器与时序产生器</h4><p>由上可知，CPU的6类主要寄存器，每一个完成一种特定的功能。然而信息怎样才能在各寄存器之间传送呢？也就是说，数据的流动是由什么部件控制的呢？<strong>通常把许多寄存器之间传送信息的通路，成为数据通路。信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，都要加以控制。在各寄存器之间建立数据通路的任务，是由称为操作控制器的部件来完成的。</strong>操作控制器可分为时序逻辑型，存储逻辑型，时序逻辑与存储逻辑结合型三种，第一种称为<strong>硬布线控制器</strong>，他是采用时序逻辑技术来实现的；第二种称为<strong>微程序控制器</strong>，他是采用存储逻辑来实现的，第三种是前两种方式的组合。</p>
<p>操作控制器产生的控制信号必须定时，还必须有时序产生器，。因为计算机高速的进行工作，每一个动作的时间是非常严格的，不能有任何差错。时序产生器的作用就是对各种操作实施时间上的控制。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>IO管理和磁盘调度</title>
    <url>/2017/10/08/2017/2017-10-08-IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       #### I/O管理和磁盘调度

<p>I/O 也许是操作系统设计中欧最复杂的工作。因为村子这大量的设备，而且这些设备有许多应用，所以很难开发出一种通用一致的解决方案。</p>
<p>计算机系统和外界的接口是I/O体系结构。设计这个结构的目的在于提供一个控制与外界交互的系统方法，同时提供给操作系统其所需的有效管理I/O的信息。</p>
<p>I/O函数可以分成若干层，底层处理接近于物理功能，高层则用逻辑方法处理IO。这样，硬件参数的改变不必改变大多数的IO软件。</p>
<p>IO的关键方面在于缓冲的使用由IO设备来控制，而不是由应用进程控制。缓冲消除了计算机系统的内部速度和IO设备的速度之间的差异。同时，缓冲的使用将应用进程的地址空间和实际IO传输分离开，这允许操作系统在执行其内存管理函数时有更多的灵活性。</p>
<p>磁盘IO对于整个系统的性能有很大的影响。相应的，这个领域比其他领域需要更多的研究和设计方面的努力。两种广泛使用的改善磁盘I/O性能的方法是磁盘调度和磁盘cache。</p>
<p>任何时候，对于同一磁盘，有可能存在一个IO请求队列。磁盘调度的目标是在满足请求的同时，最小化机器寻道时间，由此改善性能。</p>
<p>磁盘cache是主存中的缓冲区，其中磁盘和主存其他部分之间作为磁盘块的一个caceh，因为局部性，磁盘cache的使用会减少主存和磁盘之中IO传输的块数。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Think-in-Java-读后感</title>
    <url>/2017/10/08/2017/2017-10-08-Think-In-Java-%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       这几天在对Think In Java 进行最后的冲锋，终于在今晚完成了第一次通读Think In Java的目标（除去GUI）。
但是却感到更加的痛苦了，原本想看完了为了补充可能会遗漏的知识，看完之后才发现，原来自己知道的才是遗留的。知道的太少了，看到毕玄，R大，小狼，假笨，康德等等大神，我觉得自己就是一傻逼，连openJdk都不知道，一直以为Java都是开源的，为什么以为是开源的？我们不是每天都能看到jdk中的源码吗？这不就是开源吗？

<p>开个毛！</p>
<p>那只是供你使用的api，而真正的底层语言实现代码都是有版权的，我们可能只能从所谓的openjdk中看到一些native方法的c代码和虚拟机包括编译器，反编译器c++的源码。可是我都没学过c和c++， 看样子还需要学习些语法。想要在并发这个领域有所成就，那必须要研究那些线程相关的native的c代码，否则是不会知道真正的底层实现。还需要更加熟悉字节码。</p>
<p>接下来还是要继续阅读Java核心思想卷1，一定要把基础打牢固，才能在后面的路上走得更远，磨刀不误砍柴工。<br>还有计算机组成原理。tcpIp协议。目前就是这些，剩下的操作系统和编译原理慢慢补。</p>
<p>决定要把Think In Java 和 Java 核心技术 ，还有并发编程实战，虚拟机，等这些书混着看，这样就能举一反三了。</p>
<p>还要一些博客。这几天把网上的大牛都关注了一波，涨了不少的姿势。也让自己更加的有动力了。加油加油。</p>
<p>还有一点烦心的事情，就是macbookpro 每次启动idea中的main方法的时候都好慢好卡，不知道是硬件问题还是像网上说的idea太吃显卡了。不过还是喜欢在mac下编程，不喜欢在window下编程。好烦windows。</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>中央处理器</title>
    <url>/2017/10/08/2017/2017-10-08-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       #### 中央处理器

<p>CPU 是计算机的中央处理部件，具有指令控制，操作控制，时间控制，数据加工等基本功能。</p>
<p>早起的cpu有运算器和控制器两大部分组成。随着高密度继承电路技术的发展，当今的cpu新片编程运算器，cache和控制器三大部分，其中还包括浮点运算器，存储管理部件等，cpu中至少要有如下六类寄存器：指令寄存器，程序计数器，地址寄存器，缓冲寄存器，通用寄存器，状态条件寄存器。</p>
<p>CPU从存储器取出一条指令并执行这条指令的时间和称为指令周期。由于各种指令的操作功能不同，各种指令的指令周期是不尽相同的。划分指令周期，是设计操作控制器的重要依据。</p>
<p>时序信号产生器提供CPU周期（也称机器周期）所需的时序信号。操作控制器利用这些时序信号进行定时，有条不紊的取出一条指令并执行这些指令</p>
<p>微程序设计技术是利用软件方法设计操作控制器的一门技术，具有规整性，灵活性，可维护性等一系列有点，因而在计算机设计中得到了广泛应用，并取代了早起采用的硬布线控制器设计技术。但是随着VLSI技术的发展和对机器速度的要求，硬布线逻辑设计思想又得到了重视。硬布线控制器的基本思想是：某一微操作控制信号是指令操作码译码输出，时序信号和状态条件信号的逻辑函数，即用布尔代数写出逻辑表达式，如何用门电路，触发器等器件实现。</p>
<p>不论是微型机还是巨型机，并行处理技术以成为计算机技术发展的主流，并行处理技术科贯穿与信息加工的各个步骤和阶段，概括起来，主要有三种形式：1时间并行 2空间并行 3时间并行+空间并行.</p>
<p>流水CPU是以时间并行性为原理构造的处理器，是一种非常经济而实用的并行技术。目前的高性能微处理器几乎无一例外的使用了流水技术。流水技术中主要问题是资源相关，数据相关和控制相关，为此需要采取相应的技术对策，才能保证流水线畅通而不断流。</p>
<p>RISC CPU是继承CISC的成功技术，并在客服CISC机器缺点的基础上发展起来的。RISC机器的三个基本要素是：1.一个有限的简单指令集。2.CPU配备大量的通用寄存器。3.强调指令流水线的优化，注意：RISC机器一定是流水CPU，但流水CPU不一定是RISC机器。如奔腾CPU是流水CPU，但奔腾级是CISC机器。</p>
<p>多媒体CPU是带有MMX技术的处理器，MMX是一种多媒体扩展结构技术，特别适合于图像数据处理，极大地提高了计算机在多媒体和通信应用方面的功能。多媒体CPU以新一代奔腾CPU为代表，开始采用单指令流多数据流的新型结构。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2017/10/08/2017/2017-10-08-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ### 内存管理

<h4 id="内存管理的要求"><a href="#内存管理的要求" class="headerlink" title="内存管理的要求"></a>内存管理的要求</h4><p>在研究各种内存管理的机制和技术时，一定要牢记内存管理所必须满足的要求：</p>
<ol>
<li>重定位<blockquote>
<p>指的是处理机硬件和操作系统软件必须能将程序代码中地址映射为程序在内存中实际的物理地址。</p>
</blockquote>
</li>
<li>保护<blockquote>
<p>每个进程必须内保护以免受到其他进程的干扰，未经允许进程不能对其他进程的存储区进行读写操作</p>
</blockquote>
</li>
<li>共享<blockquote>
<p>协同工作的多个进程需要共享同一数据结构。</p>
</blockquote>
</li>
<li>逻辑组织<blockquote>
<p>计算机系统中的内存组织形式是包含字或字节序列的线性或一维地址空间。</p>
</blockquote>
</li>
<li>物理组织<blockquote>
<p>计算机的存储器至少分2个层次：主存和辅助存储器。</p>
</blockquote>
</li>
</ol>
<h4 id="程序的加载"><a href="#程序的加载" class="headerlink" title="程序的加载"></a>程序的加载</h4><p><strong>任何操作系统的核心人物是将程序调入到主存中执行。</strong> 在多数现代多道程序系统中，完成这个人物涉及到一个名为<code>虚拟存储器</code>的复杂调度方案，而虚拟存储器又是建立在两个基本技术基础之上的：分段和分页。还要一种更为基本的技术：分区。</p>
<table>
<thead>
<tr>
<th>header 1</th>
<th>header 2</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>固定分区</td>
<td>在系统生成时，内存分为若干个分区。等于或小于分区大小的进程可以调入内存</td>
<td>易于实现，开销少</td>
<td>存在内存碎片</td>
</tr>
<tr>
<td>动态分区</td>
<td>动态建立分区，所以分区大小与进程大小相同</td>
<td>无内存碎片，内存利用率较高</td>
<td>由于要进行压缩，处理机利用率不高</td>
</tr>
<tr>
<td>简单分页</td>
<td>主存分为大小相同的帧，每个进程分为同样大小的页，通过将进程中所有页调入内存空闲页，将进程调入内存，这些内存中的页可不连接</td>
<td>无外部碎片</td>
<td>少量的内部碎片</td>
</tr>
<tr>
<td>简单分段</td>
<td>每个进程分为若干个段，通过将进程所有的段调入内存，将进程调入内存，这些内存中的段可不连续</td>
<td>无内部碎片</td>
<td>需要压缩</td>
</tr>
<tr>
<td>虚拟内存分页</td>
<td>除了不需将近所有页都调入内存外，其余与分页相同，不在内存中的页当需要时自动调入</td>
<td>无外部碎片，可容纳更多进程，虚拟内存空间大</td>
<td>复杂的内存，管理导致开销大</td>
</tr>
<tr>
<td>虚拟内存分段</td>
<td>除了不需将进程所有段调入内存外其余与分段相同，不在内存中的段当需要时自动调入</td>
<td>无内部碎片，可容纳更多进程，虚拟内存空间大，支持保护和功效共享</td>
<td>复杂的内存，管理导致开销大</td>
</tr>
</tbody></table>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>分页就是将内存分成多个同样大小的存储区，每个进程页分成同样大小的页，较小的进程需要较少的页，较大的进程需要较多的页，进程在调入内存时，所有的进程页放入内存中空闲页，并建立页表。这种方法解决了分区方案中所固有的许多问题。</p>
<h4 id="局部性和虚拟内存"><a href="#局部性和虚拟内存" class="headerlink" title="局部性和虚拟内存"></a>局部性和虚拟内存</h4><p>颠簸：处理器把大部分时间花在调入调出近的片段上而不是执行用户的指令上</p>
<p>本质上，OS都是根据最近的历史来预测在较近的将来最不可能用到的那些片段。</p>
<p>局部性原理指的是：一个进程的程序和数据访问都有聚集成群的倾向。因此，关于在一个短的时间内，只需要进程的几个片段的假设是合理的，同样，页可以智能的预测在较短的将来会用到哪些片段。从而可以避免颠簸。</p>
<p>而局部性原理意味着虚拟内存是可行的。可行且有效的虚拟内存需要两个部件。一个是支持分页或/和分段的硬件。另一个是OS必须包括相应的软件，这些软件能管理主存和辅助存储器之间页和/ 和段的移动。</p>
<h3 id="操作系统软件"><a href="#操作系统软件" class="headerlink" title="操作系统软件"></a>操作系统软件</h3><p>操作系统的内存管理部分的设计取决于对下面几个方面的选择：</p>
<ol>
<li>是否运用虚拟存储技术。</li>
<li>运用分页，分段还是组合使用</li>
<li>内存管理的不同方面使用什么样的算法。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>为了有效使用处理机和I/O设备，在主存中保留尽可能多的进程显然是有益的。另外，让程序员不受大小的约束也是可取的，其基本技术是分页和分段。</p>
<p>达到上面两点的方法是使用虚拟内存。在虚拟内存，所有引用的地址都是逻辑地址，在执行时转换为物理地址。使用虚拟内存可以让进程存放于主存的任何位置并可以不时改变。虚拟内存还可以让程序分为一些片段，在执行时，这些片段不需要连续的存放于主存中，甚至不需要进程的所有片段都在主存中。</p>
<p>可以提供虚拟内存的基本方法是：分段和分页。运用分页，每一个进程被分成相对较小的，大小固定的页，分段则可以使用大小可变的片段。当然也可以在一个内存管理的设计中组合使用分段和分页技术。</p>
<p>虚拟内存管理需要硬件和软件的支持，处理机可以提供硬件支持，这种支持包括虚拟地址到物理地址的动态转换，当所引用的页或段不在主存中时产生一个中断。这个中断可以激活OS中的内存管理软件。</p>
<p>和OS对内存管理相关的几个设计问题是：</p>
<ol>
<li>装入策略。进程的页可以根据请求调入或使用预分页，后者可以同时调入一些页，成批的执行输入动作。</li>
<li>分配策略。在纯分段的系统中，将要调入主存的段必须能适合主存的空闲空间。</li>
<li>替换策略。当内存被占满时，必须决定哪一个页或哪些页被替换掉。</li>
<li>常驻集管理。当一个进程替换时，OS必须决定分配多大的主存给他。它可以在进程创建时静态分配，也可动态分配。</li>
<li>清除策略。修改过的进程可以在替换时写出，或使用预清除策略。后者成批或成蔟的执行输出动作。</li>
<li>加载控制。这是在任一给定时间，决定主存中驻留多少进程。</li>
</ol>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>处理机调度</title>
    <url>/2017/10/08/2017/2017-10-08-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><p>对于进程的执行，操作系统必须做出三个决定：长程调度，中程调度以及短程调度。</p>
<p>对于短程调度的设计可面向用户，也可面向系统。用户主要关心响应时间，而系统关系吞吐量和处理机利用率。</p>
<p>短程调度的算法有：先来先服务（FCFS)，时间片轮转法，最短进程优先，最短剩余时间优先，最高响应比优先，多级反馈队列等。调度算法的选择取决于期望的性能及实际应用。</p>
<p>在多处理机系统中。处理机可共享内存，各调度算法的性能差别不大。</p>
<p>实时进程和任务要与外部事件交互，要满足一定的时限，实时操作系统就是要处理实时进程，关键在于满足时限。</p>
<p>============================================</p>
<p>在一个多道程序系统中，主存同时存在多个进程。每个进程在两种状态之间转换：要么占用处理机，要么等待I/O执行或等等待其他事件发生。处理机忙于执行一个进程而其他进程只有等待。</p>
<p>调度室多道程序的关键。事实上，有4种类型的调度。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>长程调度</td>
<td>决定增加与执行的进程池</td>
</tr>
<tr>
<td>中程调度</td>
<td>决定增加部分或全部位于主存内的进程数</td>
</tr>
<tr>
<td>短程调度</td>
<td>决定哪个就绪进程被处理机执行</td>
</tr>
<tr>
<td>I/O调度</td>
<td>决定哪个进程完成的I/O请求被可用I/O设备处理</td>
</tr>
</tbody></table>
<p>处理机调度的目的是使处理机在满足系统要求的响应时间，吞吐量和处理机利用率的前提下及时的运行进程。在许多系统中，调度被分成三种：长程，短程和中程调度。</p>
<p>当产生一个新进程时，就执行长程调度，将新进程加到一组活动进中，中程调度室替换工的一部分，他将一个新进程的部分或全部调入内存以便执行。短程调度真正决定哪一个就绪进程将在下次执行。</p>
<p>由于调度决定了哪些进程将等待哪些进程被执行，所以它直接影响到系统的执行效率。从根本上讲，<strong>调度就是要使队列延迟最小，并优化系统的执行效率</strong>。</p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p>短程调度的主要目标是以使系统性能得到优化的方法来分配处理机时间。调度算法需要从各个方面来考虑。</p>
<p>调度标准有以下几个方面：</p>
<ol>
<li>响应时间</li>
<li>轮转时间，期限</li>
<li>预测性</li>
<li>吞吐量，处理机利用率</li>
<li>公平性，优先权，资源平衡。</li>
</ol>
<h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><p>分为2类：</p>
<ol>
<li>非抢占式。在这种情况下，只要进程处于运行态，他就一直执行直到终止或I/O阻塞或请求其他的OS服务。</li>
<li>抢占式。OS中断当前运行进程，将其便成就绪状态。抢占式的决定可以在到达一个新进程，将则色进程变为就绪状态的中断发生时，或时钟中断期间进行。</li>
</ol>
<p>抢占策略比非抢占的开销要大，但他哥所有进程提供了更好的服务。因为他防止了一个进程独占处理机时间过长。另外他可以通过有效的现场切换机制（尽量使用硬件）和一个大的主存以容纳多的程序来降低其开销。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>外围设备</title>
    <url>/2017/10/08/2017/2017-10-08-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h4 id="外围设备"><a href="#外围设备" class="headerlink" title="外围设备"></a>外围设备</h4><p>各种外围设备的数据传输速率相差很大。如果保证主机与外围设备在时间上同步，则设计外围设备的定时问题。</p>
<p>在计算机系统中，CPU对外围设备的管理有一下五种方式：1.程序查询方式；2.程序中断方式；3.直接存储访问（DMA）方式；4.通道方式；5.外围处理机（PPU）方式；其中第一种对CPU的资源浪费最大，而第五种使CPU得效率得到最大发挥，但是需要更多的硬件支持。</p>
<p>程序中断方式是各类计算机中广泛使用的一种数据交换方式。当某一外设的数据准备就绪后，他“主动”向CPU发送请求信号，CPU响应中断请求后，暂停运行主程序，自动转移到该设备的中断服务子程序，为该设备进行服务，结束时放回主程序。中断处理过程可以嵌套进行，优先级高的设备可以中断优先级低的中断服务程序。为此，需要有响应的中断优先级仲裁，中断向量产生和中断控制逻辑等硬件支持。</p>
<p>DMA技术的出现，<strong>使得外围设备可以通过DMA控制器直接访问内存</strong>，与此同时，CPU可以继续程序。DMA方式采用以下三种方法：1.停止CPU访问；2周期挪用；3.DMA与CPU交替访问。DMA控制器按其组成结构，分为选择性和多路型两类。选择型控制器在物理上可以连接多个设备，而在逻辑上只允许一个设备，适合于连接高速设备。多路型控制器不仅在屋里上而且在逻辑上可以连接多个设备，适合于连接慢速设备。</p>
<p>通道是一个特殊功能的处理器。他有自己的指令和程序专门负责数据输入输出的传输控制，从而使CPU将“传输控制”的功能下放给通道，CPU只负责“数据处理”功能。这样，通道与CPU分时使用内存，实现了CPU内部的数据处理与I/O设备的平行工作。通道有三种类型；1.选择通道，物理上可以连接多个设备，但在某一时间段内只选择一个设备工作，适用于连接磁盘一类高速外围设备，信息以成组方式高速传输。 2.<strong>数组多路通道</strong>，保留了选择通道高速传送数据的优点，又充分利用了控制性操作的时间间隔为其他设备服务，使通道效率充分得到发挥。3.字节多路通道，与数组多路通道相同处在于，他们是多路通道，在一段时间内交替执行多个设备的通道程序，使这些设备同时工作。不同处在于，数组多路通道只允许一个设备进行传输型操作，数据传送单位是数据块；字节多路通道可允许每个设备进行传输性操作，数据传送单位是字节。</p>
<p>标准化是建立开放式系统的基础，CPU，系统总线，I/O总线及标准接口技术近年来取得了重大进步。其中并行I/O接口SCSI与串行I/O接口IEEE1394是两个最具权威性和发展前景的标准接口技术。</p>
<p>SCSI 是系统级接口，是处于主适配器和智能设备控制器之间的并行I/O接口，改进的SCSI可允许连接1-15台不同类型的高速外围设备。SCSI的不足处在于硬件较昂贵，并需要通用设备程序和各类设备的驱动程序模块的支持。</p>
<p>IEEE 1394 是串行I/O接口。与SCSI并行I/O接口相比，它具有更高的数据传输速率和数据传送的实时性，具有更小的体积和连接的方便性，IEEE 1394的一个重大特点是，各被连接的设备的关系是平等的，不同PC介入也能自成系统。因此IEEE 1394 已成为Intel，Microsoft等公司联手制定的PC 98系统设计指南的新标准。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>将Springboot部署到windows服务器上做成服务</title>
    <url>/2017/10/01/2017/2017-10-01-%E5%B0%86springboot%E9%83%A8%E7%BD%B2%E5%88%B0windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%81%9A%E6%88%90%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在java web开发中，我们使用的是极其方便的springboot，他本身就包含了tomcat，所以，我们不用像从前开发springmvc一样 要先将应用部署到tomcat中，然后启动tomcat才能进行调试程序。 现在，我们只需要启动Application这个类就能轻易的进行调试。 这种方式在liunx服务器上部署没有什么不妥，也是非常的方便。 但是在windows上，就不一样了。 按照正常的启动，我们必须开启命令行窗口，否则应用会随着的命令行窗口的关闭而关闭。这实在是太危险了，稍不注 意就会关闭程序。所以我们的方案是将调试极其方便的springboot在windows上也能够极其方便的部署和维护。即将 springboot做成window服务。 而解决这个问题的办法就是使用一个守护进程来维护程序。 目前通用的解决方案是3个：

<ol>
<li><p>使用Apache 的Wrapper 来维护我们的程序，但不足之处是：收费、64位版本需要购买Licence。放在5年前，或许不用 担忧是否需要64位JVM，但如今，32位仅1.5G的堆内存略显不足。</p>
</li>
<li><p>使用Apache Commons Daemon，tomcat win安装版用的就是他。tomcat.exe 的图标和他一模一样，但使用不方便。 </p>
</li>
<li><p>也就是我们使用的方案，直接使用tomcat。将tomcat做成windows的服务是那么的简单，只需要使用一行命令即可。 步骤如下： </p>
<ol>
<li>首先下载tomcat。解压。 </li>
<li>稍稍修改我们的springboot程序</li>
</ol>
<ul>
<li>首先将我们的pom .xml文件的打包方式变成war，jar包是不能够在tomcat中运行的，也不方便 在部署时候修改一些配置。</li>
<li> 新增一个类，在于Appliation.java 也就是我们的程序启动类同级的地方新增一个类，继承 SpringBootServletInitializer这个类，并重写configure方法。使返回值指向我们的Application类。 这样我们对程序的修改就完成了。 </li>
</ul>
</li>
<li><p>使用maven将我们的程序打包，并且复制到我们刚刚下载的tomcat的webapps的目录下，删除其  他所有的目录和文件，只保留我们的war包。</p>
</li>
<li><p>修改tomcat中conf目录下的server.xml文件，将端口修改成我们需要的端口，有一个要注意的地方      就是在修改端口的时候，如果机器上有多个tomcat，不能有重复的端口，特别是Host标签和connector 标签中的端口不能重 复。</p>
</li>
<li><p>将tomcat注册到windows服务中。步骤： 将TOMCAT注册成系统服务的好处，就是方便维护，在服务器重启的时候，系统会自动启动系统服务，而不必手动 操作，这就为我们在项目维护时省下不少麻烦。</p>
</li>
</ol>
<p>在项目维护期间有很多客户只要一有问题，就电话招呼，而且是一召唤就得立马出现，如果手上运维的项目比较多 的话，那就会很蛋疼了。将TOMCAT注册成系统服务可以减少很多这样的麻烦，直接叫客户自己重启服务器就OK 了。</p>
<p>注册方法： 1. 在DOS命令行模式下，cd到tomcat的bin目录下。 2.在tomcat的bin目录下可以看到有一个service.bat的批处理文件，这个文件就是为我们将tomcat注册成系统服务所 用。有兴趣的可以打开看看批处理文件里面的内容。 3.执行命令service.bat  install  服务名   后面的服务名可以随便取，别跟系统已有的服务名冲突就行。服务名会出现 在服务列表中，方便区分。</p>
<p>如果成功可以看到以下提示信息：</p>
<blockquote>
<p>The Service ‘服务名 服务名’  has been installed 如果不需要这个服务了，也可以用简单的命令将其去除就OK 了 前面步骤如上，执行命令：service.bat uninstall 服务名 移除成功的提示信息： The Service ‘服务名’ has been removed。</p>
</blockquote>
<p>6 ：修改日志路径，导入到我们制定的路径。</p>
<p> 7 ：最后我们在windows的服务列表中就能看到我们的服务了。点击启动就好了。<br>最后，我们知道tomcat容器中的应用都是要加后缀的，而我们的springboot是不加后缀的，当我们使用的jmeter的测试用 例都需要加上项目前缀，就很疼了。那怎么解决呢？ 我们只需要编辑tomcat 中的conf 目录下的server.xml 文件，在host标签中加入一行代码：</p>
 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;Context <span class="attribute">path</span>=<span class="string">&quot;&quot;</span> <span class="attribute">docBase</span>=<span class="string">&quot;/ccppg-service&quot;</span> <span class="attribute">debug</span>=<span class="string">&quot;0&quot;</span> <span class="attribute">reloadable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>path 代表的是访问的路径，docBase对应的是webapps目录的项目相对路径。reloadable=”true” 表示自动重载class文件。 这样，我们重启服务器，就不需要加项目前缀了。注意：如果你的项目里含有需要将文件上传到服务器或者保存到服务器的插件或逻辑，对这个标签必须谨慎对待，这里就是你文件上传的路径。</p>
<p>到此，我们就完成了让springboot发挥他最大的优点：<strong>方便调试</strong>。也能够在windows中方便的维护我们的程序。不必担心一 不小心关闭了命令行导致的事故，也可以让什么都不懂的人开启或关闭服务。节约了我们的时间。</p>
<p>现在，我们已经将程序部署到服务器上，外网页能通过ip来访问我们了，但是不够友好，我们需要使用域名映射我们的 ip，即访问域名时就转发到我们的ip，不需记住难记的数字。</p>
<p>首先我们申请域名，然后在dns服务商处映射我们的ip地址，映射指定的端口，比如80端口，然后再服务器中使用nginx根 据特定的二级域名转发到我们指定的端口用应。</p>
<p>还有一个就是我们测试的数据库和正式的数据库是不一样的，我们必须修改应用的数据源地址为正式地址，否则一定报 错。我们将测试服务器上的sql文件导出，然后在正式服务器上创建新的数据库，导入我们的sql文件，这样，数据库就建 好了。</p>
<p>现在，一个完整的java web 应用就部署成功了。并且能够方便的管理和维护。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>存储系统</title>
    <url>/2017/10/08/2017/2017-10-08-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h4><p>计算机对存储器的要求是容量大，速度快，成本低。为了解决这三方面的矛盾，计算机采用多级存储体系结构，即cache，主存和外存。cpu能直接发你给我内存（cache， 主存），但不能直接访问外存。存储器的技术指标有存储容量，存取时间，存储周期，存储器带宽。</p>
<p>广泛使用的SRAM和DRAM都是半导体随机读写存储器，前者速度比后者快，按集成度不如后者高。二者的有点是体积小，可靠性高，价格低廉，缺点是断电后不能保存信息。只读存储器和闪速存储器正好弥补了SRAM和DRAM的缺点，即使断电后也能保存原先使用的数据，特别是闪速存储器能提供高性能，低功耗，高可靠性以及瞬时启动能力，因而有可能使现有的存储器体系结构发生重大变化。</p>
<p>双端口存储器和多模块交叉存储器属于并行存储器结构。前者采用空间并行技术，后者采用时间并行技术。</p>
<p><strong>相联存储器不是按地址而是按内容访问的存储器，在cache中用来存放地址表，在虚拟存储器中用来存放段表，页表和快表。在这两种应用中，都需要快速查找。</strong></p>
<p>cache是一种告诉缓存存储器，是为了解决CPU和内存之间速度不匹配而采用的一项重要的硬件技术，并且发展为多节cache体系，指令cache和数据cache分设体系。要求cache的命中率接近于1.主存于cache的地址映射有全相连，直接，组相连三种方式。其中组相连方式是前两者的折中方案，适度的兼顾了两者的优点又尽量避免其缺点，从灵活性，命中率，硬件投资来说较为理想，因而得到普遍采用。</p>
<p>虚拟存储器指的是主存-外存层次，它给用户提供了一个比实际主存空间大得多的虚拟地址空间。因此虚拟存储器只是一个容量非常大的存储器分逻辑模型，不是任何实际的物理存储器，按照主存-外存层次的信息传送单位不同，虚拟存储器有页式，段式，段页式三类。</p>
<p>多个用户共享主存时，系统应提供存储保护。通常采用的方法存储区域保护和访问方式保护，并用硬件来实现。有些机器中提供特权指令来实现某种保护。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>总线系统</title>
    <url>/2017/10/08/2017/2017-10-08-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h4><p>总线是构成计算机系统的互联机构，是多个系统部件之间进行数据传送的公共通道，并在争用资源的基础上进行工作。</p>
<p>总线有物理特性，功能特性，电器特性，机械特性，一次必须标准化。微型计算机系统的标准总线从ISA总线（16位，带宽8MB/s）发展到EISA总线（32位，带宽33.3MB/s)和VESA总线（32位，带宽132MB/s），又进一步发展到PCI总线（64位，带宽264MB/s).衡量总线性能的重要指标是总线带宽，它定义为总线本身所能达到的最高传输速率。</p>
<p>当代流行的标准总线追求与结构，CPU，技术无关的开发标准。其总线内部结构包含：1.数据传送总线（由地址线，数据线，控制线组成）；2.仲裁总线；3.中断和同步总线；4公用线（电源，地线，时钟，复位等信号线）。</p>
<p>计算机系统中，根据应用条件和硬件资源不同，信息的传输方式可采用：1.并行传送。2.串行传送。3.复用传送。</p>
<p>各种外围设备必须通过“接口”与总线相连。接口是指CPU，主存，外围设备之间通过总线进行连接的逻辑部件。接口部件在它动态连接的两个功能部件间起着缓存器和转换器的作用，以便实现彼此之间的信息传递。</p>
<p>总线仲裁是总线系统的核心问题之一。为了解决多个主设备同时竞争总线控制权的问题，必须具有总线仲裁部件。它通过采用优先级策略或公平策略，选择其中一个主设备作为总线的下一次主方，接管总线控制权。</p>
<p>按照总线仲裁电路的位置不同，总线仲裁分为集中式和分布式仲裁。集中式仲裁方式必有一个中央仲裁器，它受理所有功能模块的总线请求，按优先原则或公平原则进行排队，然后仅给一个功能模块发出授权信号。分布式仲裁不需要中央仲裁器，每个功能模块都有自己的仲裁号和仲裁器。通过分配优先级仲裁号，每个仲裁器将仲裁总线上得到的仲裁号与自己的仲裁号进行比较，从而获得总线控制权。</p>
<p>总线定时是总线的又一核心问题之一。为了同步主方，从方的操作，必须制定定时协议。通常采用同步定时与异步定时两种方式。在同步定时协议中，事件出现在总线上的时刻有总线时钟信号来确定，总线周期的长度是固定的。在异步定时协议中，后一事件出现在总线上的时刻取决于迁一事件的出现，即建立在应答式或互锁机制基础上，不需要同意的公共时钟信号。在异步定时中，总线周期的长度是可变的。</p>
<p>当代的总线标准大都能支持以下数据传送模式：1.读/写操作；2.块传送操作。3.写后读，读修改写操作；4.广播。广集操作。</p>
<p>PCI 总线是当前流行的总线，是一个高带宽且与处理器无关的标准总线，又是至关重要的层次总线。它采用同步定时协议和集中式仲裁策略，并具有自动配置能力。PCI适合于低成本的小系统，因此在微机系统中得到了广泛的应用。</p>
<p>正在发展的Futurebus+总线是迄今为止最复杂的总线标准，能支持64位地址空间，64位，128位，256位数据传输，为下一代的多处理机系统提供了一个稳定的平台。它可以满足各类高性能系统的需求，因此适合于高成本的较大规模计算机系统。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>指令系统</title>
    <url>/2017/10/08/2017/2017-10-08-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><p>一台计算机中所有机器指令的集合，称之为这台计算机的指令系统。指令系统是表征一台计算机性能的重要因素，他的格式与功能不仅直接影响到机器的硬件结构，而且也影响到系统软件。</p>
<p>指令格式是指令字用二进制表示的结构形式，通常由操作码字段和地址码字段组成。操作码字段表征指令的操作特性与功能，而地址码字段只是操作数的地址。目前多采用二地址，单地址，零地址混合方式的指令格式。指令字长度分为：单字长，半字长，双字长三种形式。高档微型机中目前多采用32位长度的单字长形式（2017年都是64位的了）。</p>
<p>形成指令地址的方式，称为指令寻址方式。有顺序寻址和跳跃寻址两种，由指令计数器来跟踪。</p>
<p>形成操作数地址的方式，称为数据寻址方式。操作数可放在专用寄存器，通用寄存器，内存和指令中。数据寻址方式有隐含寻址，立即寻址，直接寻址，简介寻址，结存器寻址，寄存器间接寻址，相对寻址，基值寻址，变址寻址，块寻址，段寻址等多种。按操作数的物理位置不同，有RR型和RS型。前者比后者执行的速度快。</p>
<p>堆栈是一种特殊的数据寻址方式，采用”先进后出”原理。按结构不同，分为寄存器堆栈和存储器堆栈。</p>
<p>不同机器有不同的指令系统。一个较完善的指令系统应当包含数据传送类指令，算术运算类指令，逻辑运算类指令，程序控制类指令，I/O类指令，字符串类型指令，系统控制类指令。</p>
<p>RISC指令系统是CISC指令系统的改进，他的最大特点是：1.指令条数少；2.指令长度固定，指令格式和寻址方式种类少；3.只有取数/存数指令访问存储器，其余指令的操作均在寄存器直接进行。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统的并发</title>
    <url>/2017/10/08/2017/2017-10-08-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>现代操作系统的中心问题是多道程序，多进程和分布式式进程，并发是这些问题的基础，同时也是操作系统设计的基础，当多个进程并发执行时，无论是在多处理机系统还是在单处理机系统中都会出现进程间协同的问题。</p>
<p>并发进程可通过多种方式相互作用，互相透明的进程要为使用资源展开竞争。这些资源包括处理机时间，I/O设备的访问权等。当共享某一对象时，进程就间接地觉察到对方的存在，例如共享一块内存或一个文件，进程也可直接认识对方并通过交换信息进行协同，在这些相互作用中的主要问题是互斥和死锁。</p>
<p>对于并发进程，互斥一个必要的条件，在任一时期，只能有一个进程可以访问某一给定的资源或执行某一给定的函数，互斥可用来解决一些冲突，例如竞争资源。也可用于进程同步以使他们能协同工作。例如生产者/消费者模型，一个进程向缓冲区添加数据，另一些进程则从缓冲区取走数据。</p>
<p>现在已有了不少解决互斥问题的算法，其中最著名的是Dekker算法，软件方法开销较大，错误较多，第二种方法是使用特殊的机器指令支持互斥，这种方法虽然减小了开支，但仍有不足，因为它用到了<strong>忙等待</strong>。</p>
<p>另一种解决互斥的方法是在操作系统内部提供支持，两个最常用的技术是信号量好消息传递，信号量和消息传递能方便地实现互斥，而消息传递还可用于进程间通信。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是由于进程间相互竞争系统资源或通信而引起的一种阻塞现象。如果操作系统不采取特别的措施这种阻塞将永远存在。例如可以杀死一个或多个进程或强迫他们撤回。死锁可能涉及到可重用资源和消耗性资源，消耗性资源在被进程占用时即消失，例如消息和I/O缓冲区的信息。可重用资源是不因使用而受到破坏的资源，例如I/O通道和存储器。</p>
<p>处理死锁的方法通常有3种：死锁预防，死锁 检测和死锁避免。死锁预防通过破坏产生死锁的是哪个必要条件而保证不会出现死锁。在操作系统随时满足资源请求时就要用到死锁检测。操邹系统检测到死锁并采取措施消除死锁。死锁避免是通过对资源请求是否有可能导致死锁的分析来消除死锁的可能性。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>概论</title>
    <url>/2017/10/08/2017/2017-10-08-%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="计算机组成原理概论"><a href="#计算机组成原理概论" class="headerlink" title="计算机组成原理概论"></a>计算机组成原理概论</h3><p>习惯上所称的“电子计算机”是指现在广泛引用的电子数字计算机，它分为专用计算机和通用计算机两大类。专用和通用是根据计算机的效率，速度，价格，运行的经济性和适应性来划分的。通用计算机又分为巨型机，大型机，中型机，小型机，微型机，单片机六类，其结构复杂性，性能，价格依次递减。</p>
<p>计算机的生命力在于他的广泛应用，应用的范围几乎涉及人类社会的所有领域。归纳下来，在科学计算，自动控制，测量与测试，信息处理，教育卫生，家用电器，人工智能等领域中的应用成就最为突出。</p>
<p>计算机的硬件是由有形的电子器件等构成的，它包括运算器，存储器，控制器，适配器，输入输出设备。传统上将运算器和控制器称为cpu，而将cpu和存储器称为主机。存储程序并按地址顺序执行，这是冯*诺依曼计算机的工作原理。也是计算机自动化工作的关键。</p>
<p>计算机的软件是计算机系统结构的重要组成部分，也是计算机不同于一般电子设备的本质所在。计算机软件一般分为系统程序和应用程序两大类。系统程序用来简化程序设计，简化使用方法。提高计算机的使用效率，发挥和扩大计算机的功能和用途，它包括：1. 各种服务型程序。2. 操作系统。 3. 语言类程序，4. 数据库管理系统。应用程序是针对某一应用课题领域开发的软件。</p>
<p>计算机系统是一个由硬件，软件组成的多级层次结构，它通常由微程序级，一般机器级，操作系统级，汇编语言级，高级语言级组成，每一级都能进行程序设计，且得到下面各级的支持。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>文件管理</title>
    <url>/2017/10/08/2017/2017-10-08-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>一个文件管理系统是一组系统软件，通过文件的使用为用户和应用提供服务，包括文件存取，目录维护和存取控制。文件管理系统可以看成一个系统服务，它本身由操作系统提供服务，而不是操作系统的一部分。但是，任何系统中，至少有一部分文件管理功能有操作系统提供。</p>
<p>文件是记录的集合，访问记录的方法决定记录的逻辑结构，而且在某种程度上决定记录在磁盘上的物理组织。如果一个文件主要是整体处理，那么顺序文件结构是最简单，最合适的。若干既需要顺序访问，也需要对一个文件随机访问，则一个索引顺序文件可以提供很高的性能。如果对文件是随机访问，那么索引文件或堆文件是最合适的。</p>
<p>无论选用哪种文件结构，都需要一个目录服务，以让文件组织成分层形式。这个结构对用户跟踪文件是十分有用的，对于文件管理系统为用户提供访问控制或其他访问也是有用的。</p>
<p>文件记录，即使是定长的，通常也不和物理磁盘块的尺寸相同。相应的，需要一些分块策略，复杂度，性能，和空间的使用决定使用的分块策略。</p>
<p>任何文件管理方法的一个关键功能是管理磁盘空间。其中包括了分配磁盘块给文件的策略。文件的分配使用了许多种方法和数据结构。另外，还需要对磁盘上没有使用的磁盘进行管理。其中主要维护含有空闲新的磁盘分配表。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>编码-隐匿在计算机软硬件背后的秘密</title>
    <url>/2017/10/08/2017/2017-10-08-%E7%BC%96%E7%A0%81-%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       #### 编码-隐匿在计算机软硬件背后的秘密

<p>storage和memory有何区别？<br>storage类似于文件柜，memory类似于书桌。</p>
<p>层次化体系结构，这种结构的底层是晶体管。</p>
<p>编码指的是：一种用来在机器与人之间传递信息的方式。换句话说：编码就是交流。</p>
<p>人类语言就是编码。</p>
<p>各种类型的编码也用于计算机里来存储和传递数字，声音，音乐，图片和电影，计算机不能直接处理人类的编码，用为计算机无法通过采用与人类的眼睛，耳朵，嘴巴，和手指完全相同的方式来接受人类发出的信息。</p>
<p>重要的是：2个不同的组合或事物，只要经过适当的组合，就可以表示所有类型的信息。</p>
<p>摩尔斯码也被称为二进制码。</p>
<p>3电子+3质子+3中子 = 1锂原子<br>一个水分子 = 2氢原子 + 一个痒原子</p>
<p>一个原子钟电子的数目一般情况下与质子数目相同，但是在某些情况下，电子可能从原子钟脱离，这就是电流产生的原因。</p>
<p>当质子和电子在相同的数目的条件下共存时== 和谐稳定。<br>但如果失衡，则试图自我修复。</p>
<p>静电火花是电子运动造成的。</p>
<p>水管中流水的量（相当于电流）正比；<br>水管中的水压(相当于电压) 反比；<br>水管的纤细程度（相当于电阻）反比；</p>
<p>二进制码与电气电路之间的这种相似性很重要。</p>
<p>数字是我们平常所能接触的一种最抽象的编码。<br>逻辑门电路和开关的集合。<br>数学界的布尔代数。</p>
<p>只有当两个开关都闭合，称为“与”<br>任何一个开关闭合，称为“或”</p>
<p>即布尔表达式在电路中的实现。</p>
<p>这就是逻辑门（logic gates），需配合继电器。</p>
<p>继电器对于电报系统的工作是至关重要的。在长距离情况下，链接电报站的电线具有很高的电阻，需要将的变得很微弱的信号增强再发射出去，继电器就是通过电磁铁控制开关来实现这一目的的。</p>
<p>缓冲器，反向器，4种基本逻辑门。</p>
<p>加法计算似乎就是计算机要做的唯一工作。</p>
<p>2进制的进位与逻辑门中“与门”一致。</p>
<p>计算机已不再使用继电器了，使用过真空管，现在是晶体管。</p>
<p>蜂鸣器。震荡器。<br>触发器可以保持信息“记住信息”；</p>
<p>RAM：随机访问存储器也被称为“易失性（voliatile）”,存储器，不能断电，一日断电，金属片将弹回原位。</p>
<p>总线（bus）：运算器+控制器+IO+存储器。</p>
<p>总线就是各种数字信号的集合。<br>4类信号：</p>
<ol>
<li>地址信号：有处理器产生，通常用来对RAM进行寻址操作，也可以对其他设备寻址。</li>
<li>数据输出信号，有处理器产生，用来写入到RAM或其他设备（OUtput）</li>
<li>数据输入信号：由计算机其他部分提供，由处理器读取，输入信号一般由RAM提供。</li>
<li>控制信号：多种多样。</li>
</ol>
<blockquote>
<p>总线还可以供电。</p>
</blockquote>
<p>PC 启动时，从特定地址执行代码000h，Intel 8080</p>
<p>文件系统（MS):文件分配表</p>
<p>从理论上讲，应用程序并不能直接访问计算机硬件，须通过OS的接口（除了BIOS），还有处理视频的任务。</p>
<p>浮点运算非常重要：</p>
<ol>
<li>直接使用机器码指令。</li>
<li>增加协处理器，即FPU。</li>
</ol>
<p>C的指针本质是数字化描述的内存地址。<br>也被称为高级汇编语言。<br>Lisp 非冯*诺依曼体系语言。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算器和运算器</title>
    <url>/2017/10/08/2017/2017-10-08-%E8%AE%A1%E7%AE%97%E5%99%A8%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       #### 运算方法和运算器

<p>一个定点数由符号位和数值域两部分组成。按小数点位置不同，定点数有纯小数和纯整数两种表示方法。</p>
<p>按IEEE754 标准，一个浮点数由符号位S，阶码E，尾数M 三个域组成。其中接码E的值等于指数的真值e加上一个固定偏移值。</p>
<p>为了使计算机能直接处理十进制形式的数据，采用两种表示形式：1.字符串形式，主要用于在非数值计算的领域；2. 压缩的十进制数串形式，用于直接完成十进制数的算术运算。</p>
<p>数的真值编程机器码时有4种表示方法：原码表示法，反码表示法，补码表示法，移码表示法。其中移码主要用于表示浮点数的接码E，以利于比较两个指数的大小和对阶操作。</p>
<p>字符信息术语符号数据，是处理非数值领域的问题。国际上采用的字符系统是7单位的ASCII码。</p>
<p>直接使用西文标准键盘输入汉字，进行处理，并显示打印汉字，是一项重大成就。为此要解决汉字的输入编码，汉字内码，字模码的三种不同用途的编码。</p>
<p>为运算器构造的简单性，运算方法中算术运算通常采用补码，剪发，原码乘除法或补码乘除法。为了运算器的高速性和控制的简单性，采用了先行进位，阵列乘除法，流水线等并行计数措施。</p>
<p>定点运算器和浮点运算器的结构复杂程度有所不同。早起微型机中浮点运算器放在cpu芯片外，随着高密度集成电路的发展，现已移至CPU内部。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2017/10/08/2017/2017-10-08-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ### 计算机的组成
- 存储器 `相当于纸一样的具有记忆功能的设备`
- 控制器 `能够自动控制整个计算过程`
- 运算器 `相当于算盘`
- 适配器---> 输入设备，输出设备


<ul>
<li><p>运算器：</p>
<blockquote>
<p>人们习惯10进制的运算，但2进制实现简单，可以<br>使用逻辑门来实现各种运算。运算器的长度一般是8位，16位，32位，64位，但位数越长，所需的电子器件就越多。</p>
</blockquote>
</li>
<li><p>存储器</p>
<blockquote>
<p>目前采用半导体触发器开当担此任务。通常，在存储器中保存一个数的16个触发器称为一个<strong>存储单元</strong>，存储器是由许多存储单元组成的。每个存储单元都有编号，称为<strong>地址</strong>。但是半导体容量有限，32位字长cpu只支持4G内存，64位支持128G内存，而且不能断电，因此需要外存储器，比如磁盘，这叫外存储器，而相应的半导体存储器就称为内存储器。简称内存。</p>
</blockquote>
</li>
<li><p>控制器</p>
<blockquote>
<p>控制器是计算机中发号施令的部件，计算机中为了顺利运算，也必须事先把程序和数据按地址安排到存储器里去，注意，程序中的指令通常是按顺序执行，因此这些指令是顺序放在存储器里。<br>每条指令应当明确的告诉控制器，从存储器的哪个单元取数，并进行何种操作。这样一来，可知指令的内容由2部分组成。即<strong>操作的性质和操作数的地址</strong>，前者称为<strong>操作码</strong>，后者称为<strong>地址码</strong>。指令数码化以后，就可以和数据一样放入存储器，存储器的任何位置既可以存放数据也可以存放指令，不过一般是将指令和数据分开存放。将指令序列存放在存储器中称为<strong>存储程序</strong>，而控制器一句存储的程序来控制全机协调的完成计算任务叫做<strong>程序控制</strong>，存储程序并按地址顺序执行。这就是冯*诺依曼计算机的设计思想。也是机器自动化工作的关键。</p>
</blockquote>
</li>
</ul>
<blockquote>
<h4 id="控制器的基本任务"><a href="#控制器的基本任务" class="headerlink" title="控制器的基本任务"></a>控制器的基本任务</h4><p>控制器的基本任务，就是按照计算程序所排的指令序列，先从存储器取出一条指令放到控制器中，该指令的操作码有<strong>译码器</strong>进行分析判别，然后根据指令性质，执行这条指令，进行相应的操作。接着从存储器取出第二条指令，再执行者第二条指令，以此类推。通常把取指令的一段时间叫做<strong>取指周期</strong>，再把执行指令的一段时间叫做<strong>执行周期</strong>。因此。控制器反复交替地处在取指周期和执行周期之中。在早期的计算机术语中，通常把运算器好控制器合在一起成为<strong>中央处理器</strong>。简称CUP。而降CPU和存储器合在一起成为<strong>主机</strong>。</p>
</blockquote>
<blockquote>
<h4 id="指令流和数据流"><a href="#指令流和数据流" class="headerlink" title="指令流和数据流"></a>指令流和数据流</h4><p>当cpu向存储器取出信息时，不能存取单个的位，是用字节，一个“字节”有8位二进制信息组成，而一个“字”则至少由一个以上的字节组成。通常把组成一个字的二级制位数叫做<strong>字长</strong>，例如微型机的字长至少可以8位，而大型机的字长可以达到64位。由于计算机使用的信息既有指令又有数据，所以计算机既可以代表指令，也可以代表数据。如果某字代表要处理的数据，则成为数据字；如果某字为一条指令，则称为指令字。控制器完成可以分开哪些是指令字，哪些是数据字。一般来讲，取指周期中从内存读出的信息流是指令流，它流向<strong>控制器</strong>；而再执行周期中从内存读出的信息流是数据流。它由内存流向<strong>运算器</strong>。</p>
</blockquote>
<ul>
<li><p>总线</p>
<blockquote>
<p>系统总线是构成计算机系统的骨架，是过个系统部件之间进行数据传送的公共通路。借助系统总线，计算机在各系统部件之间实现传送地址，数据和控制信息的操作。</p>
</blockquote>
</li>
<li><p>适配器和输入输出设备</p>
<blockquote>
<p>计算机的输入/输出设备通常称为外围设备。这些外围设备有高速的也有低速的。有机电结构的。也有全电子式的。由于种类繁多且速度各异，因为他们不是直接地同高速工作的主机相连接，而是通过<strong>适配器</strong>部件与主机相联系。适配器的作用相当于一个转换器。它可以保证外围设备用计算机系统特性要求的形式发送或接受信息。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>进程</title>
    <url>/2017/10/08/2017/2017-10-08-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       #### 进程

<p><strong>进程是操作系统的核心</strong></p>
<p>进程由以下三部分组成：</p>
<ol>
<li>一个可执行的程序。</li>
<li>该程序所需的相关数据（变量，工作空间，缓冲区）</li>
<li>该程序的执行上下文（context）。</li>
</ol>
<p>上下文是必不可少的。所有操作系统用来管理进程和处理器执行进程的信息都包括在执行上下文中。这个上下文包括寄存器的内容，进程的优先级以及进程是否等待I/O事件的完成。</p>
<h5 id="操作系统设计和层次结构"><a href="#操作系统设计和层次结构" class="headerlink" title="操作系统设计和层次结构"></a>操作系统设计和层次结构</h5><table>
<thead>
<tr>
<th>层名字</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>13 外壳</td>
<td>用户程序设计环境</td>
</tr>
<tr>
<td>12 用户进程</td>
<td>用户进程</td>
</tr>
<tr>
<td>11 目录</td>
<td>目录</td>
</tr>
<tr>
<td>10 设备</td>
<td>外设，打印机，显示器等</td>
</tr>
<tr>
<td>9 文件系统</td>
<td>文件</td>
</tr>
<tr>
<td>8 通信</td>
<td>管道</td>
</tr>
<tr>
<td>7 虚拟存储器</td>
<td>段，页</td>
</tr>
<tr>
<td>6 局部辅存</td>
<td>数据块，设备通道</td>
</tr>
<tr>
<td>5 进程原语</td>
<td>进程原语，信号量，就绪队列</td>
</tr>
<tr>
<td>4 中断</td>
<td>中断处理程序</td>
</tr>
<tr>
<td>3 过程</td>
<td>过程，调用栈，显示</td>
</tr>
<tr>
<td>2 指令集</td>
<td>演算栈，微程序解释器</td>
</tr>
<tr>
<td>1 电子线路</td>
<td>寄存器，逻辑门，总线等</td>
</tr>
</tbody></table>
<p>第一层：由电路组成，其中的对象是寄存器，村粗单元和逻辑门，对这些对象的操作是一些动作如清除寄存器或读取内存单元等。</p>
<p>第二层：是处理器的指令集，这一层的操作是那些机器语言指令集所允许的一些指令，入ADD，SUBTRACT,LOAD,STORE等。</p>
<p>第三层：这一层加入过程概念，包括调用返回操作。</p>
<p>第四层：中断时处理器保存当前内容并调用中断处理程序。</p>
<p>这四层并不是操作系统的一部分，但他们组成了处理器硬件，然而，操作系统中的一些元素，如中断处理程序，已在这一层出现。</p>
<p>第五层：进程作为程序的执行在本层出现。w为了支持多进程，对操作系统而言基本的要求包括要有挂起和重新执行进程的能力。这就要求保存寄存器和值以便从一个进程切换到另一个进程。</p>
<p>第六层：处理计算机的辅存，这一层的主要功能有读/写扇区，进行定位，以及传输数据块。第六层依靠第五层的调度操作。</p>
<p>第七层：为进程创建逻辑空间。真一层将虚拟空间组织成块，并在主，辅存之间调度，当一个所需块不在主存中时，本层将逻辑地要求第六层传输。</p>
<p>第八层：处理进程间的信息和消息通信。其最有利的工具之一就是管道（pipe）。管道是进程间数据流的一个逻辑通道，它也可用来将外部设备和文件同进程连起来。</p>
<p>第九层：支持长期存储文件。</p>
<p>第十层：利用标准接口，提供对外部设备的访问。</p>
<p>第十一层：负责保存系统资源和对象的外部和内部定义间的联系。外部定义是应用程序和用户可以使用的名字。内部定义是能够被操作系统底层部分用来控制一个对象的地址或其他指示符。</p>
<p>第十二层：这一层支持所有管理进程所必须的信息，这包括进程虚拟地址空间，与该进程由相互作用的进程和对象表列，创建该进程时传递的参数等。</p>
<p>第十三层：在操作系统同用户间提供一个界面。他被成为“外壳（shell）”，这是因为他将用户和操作系统具体实现分开并使操作系统就像一个功能的集合。这个外壳接受用户命令，解释后根据需要创建并控制进程。</p>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p>有2种进程状态模型：</p>
<ol>
<li>每个进程只有2种状态：运行，非运行。</li>
<li>有一个进程队列，操作系统从这个对列中分派任务。</li>
</ol>
<h5 id="进程的产生和终止"><a href="#进程的产生和终止" class="headerlink" title="进程的产生和终止"></a>进程的产生和终止</h5><p>当有一个新进程要加入当钱进程队列时，操作系统产生一个控制进程的数据结构，并且为该进程分配地址空间，这样，新进程就产生了。</p>
<p>通常有4种事件会导致产生新的进程：</p>
<ol>
<li>新批处理任务</li>
<li>交互式登录</li>
<li>OS产生以提供服务</li>
<li>由已存在进程产生。</li>
</ol>
<p>进程的终止：</p>
<ol>
<li>正常结束</li>
<li>超时限制</li>
<li>内存不足</li>
<li>超界（进程试图对不允许接近的区域进行操作）</li>
<li>保护错误（例如对只读文件进行写操作）</li>
<li>算术错误（例如除以零）</li>
<li>超越时限（进程等待时间超过了某事件发生的制定时间）</li>
<li>I/O失败</li>
<li>非法指令</li>
<li>特权指令（进程试图执行一个保留给OS使用的指令）</li>
<li>错误使用数据(数据类型出错或数据为初始化)</li>
<li>操作员或OS干预</li>
<li>父进程终止</li>
<li>父进程需要（父进程拥有终止所有子孙进程的权利）</li>
</ol>
<p>现代操作系统中最基本的组件就是进程。操作系统的重要功能就是创建，管理和终止进程。当进程处于活动状态时，操作系统必须保证每一进程都分到处理器执行时间，还要协调他们的活动，管理冲突请求，并分配系统资源给这些进程。要履行其进程管理职能，操作系统还必须维持对每一进程的描述。每个进程是由一个进程映像来表示的，它包括进程执行的地址空间和一个进程控制块。后者包含了操作系统管理该进程所需的全部信息，包括其目前的状态，分配给他的资源，优先级及其他有关数据。</p>
<p>在进程生命周期中，他会在很多状态之间移动。这些状态中最重要的是就绪，运行和阻塞。就绪进程是指目前并未执行但一旦得到操作系统调度就准备运行的进程。运行进程是指当前正被处理器执行的进程。在多处理其系统中，可有不止一个进程处于该状态。阻塞进程是等待某件事完成（比如I/O操作）的进程。</p>
<p>运行进程可能被中断或执行操作系统的访管而终止，所谓中断是指发生在进程之外并可被处理器所识别的事件。在这两种情况下，处理器都将执行切换操作，将控制转交给操作系统例程。在完成所需工作后，曹组系统可能恢复被终止的进程或切换到另一进程。</p>
<p>一些操作系统区分了进程和线程的概念，前者与资源的拥有有关，而后者与程序的执行有关。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2017/10/27/2017/2017-10-27-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       > 首先有一个收银台小程序：
商场会有促销活动，包括打折，买200减100，买500送积分之类的很多
那么就会用到很多的if else 判断。


<p>那么如何消除if else 判断呢？<br>可能有人想到了使用简单工厂模式。是的，这样确实能够解决if 判断。但是如果后期的更改，我们是不是就要修改工厂类呢？岂不是很麻烦？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CashSuper csuper = CashFactory.createCashAccept(......</span><br><span class="line">csuper.getResult(......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/4236553-48368f2224a37d03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如果使用策略模式呢？<br>首先我们定义一个父类现金收费抽象类，让各种促销类继承他，然后创建一个Context类，在这个类中维护一个Strategy的引用。并且创建一个参数为Strategy类型的构造方法，然后创建一个方法，根据具体的Strategy对象执行对应的方法。</p>
<p>这样，我们在客户端的代码就是这样的了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CashContext csuper = <span class="keyword">new</span> CashContext(......</span><br><span class="line">csuper.getResult(......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码和工厂模式的代码的区别就是，客户端只看到了一个类，而工厂模式看到了两个类，也就是说，代码的耦合度降低了。<br>实际上我们只是在工厂类中维护了一个Strategy引用，并添加了一个根据策略引用执行特定的方法。然后改一下名字，就变成了策略模式。</p>
<p>那么我们有没有解决最初的工厂中if else过多导致的后期扩展的维护难题呢？没有。<br>我们只是在工厂模式的基础上，学习了另一种设计模式：策略模式，这个在简化一些if else中还是有作用的，在客户端最起码没有了大量的if 判断，减少了代码的坏味道。</p>
<p>总的来说，策略模式封装了变化，也就是封装了算法。应用场景就是大量的if判断，请一定使用策略模式，否则代码以后的维护就是个大问题。<br>使用策略简单工厂模式就能大大的优化代码，让代码具有可复用，易于维护，可扩展，灵活性高。耦合度低。</p>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>深入解析单例模式的七种实现</title>
    <url>/2017/10/23/2017/2017-10-23-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ### 什么是单例模式
什么是单例模式呢？ 我们引用一下维基百科：
> **单例模式**，也叫**单子模式**，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。还有就是我们经常使用的servlet就是单例多线程的。使用单例能够节省很多内存。




<h3 id="如何实现单例模式呢？"><a href="#如何实现单例模式呢？" class="headerlink" title="如何实现单例模式呢？"></a>如何实现单例模式呢？</h3><p>我们引用一下维基百科：</p>
<blockquote>
<p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>
</blockquote>
<p>好了，我们知道了单例模式的定义和如何使用单例的描述，接下来，就引用Linux Torvalds 的话：</p>
<blockquote>
<p>Talk is cheap. Show me the code</p>
</blockquote>
<p>让我们来看看单例模式的7种实现方式</p>
<h3 id="单例模式的七种实现"><a href="#单例模式的七种实现" class="headerlink" title="单例模式的七种实现"></a>单例模式的七种实现</h3><h4 id="第一种：懒汉式加载"><a href="#第一种：懒汉式加载" class="headerlink" title="第一种：懒汉式加载"></a>第一种：懒汉式加载</h4><blockquote>
<p>懒汉式加载：最简单的单例模式：2步，1.把自己的构造方法设置为私有的，不让别人访问你的实例，2.提供一个static方法给别人获取你的实例.</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9b0136eedf9370aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="懒汉式加载版本单例模式"></p>
<p>我们可以看到，这是一个简单的获取单例的一个类，首先我们定义一个静态实例 single, 如何将构造方法变成私有的。并且给外界一个静态获取实例的方法。如果对象不是null，就直接返回实例，从而保证实例。也可以保证不浪费内存。这是我们的第一个实现单例模式的例子。很简单。但是有问题，我们后面再讲。</p>
<h4 id="第二种：饿汉式加载"><a href="#第二种：饿汉式加载" class="headerlink" title="第二种：饿汉式加载"></a>第二种：饿汉式加载</h4><p><img src="http://upload-images.jianshu.io/upload_images/4236553-9f89075a7b82369e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="饿汉式加载版本单例模式"></p>
<p>我们看到第二种单例模式，代码量比第一个少了很多，而为什么叫饿汉式呢？我们看代码，我们定义了一个静态的final的实例，并且直接new了一个对象，这样就会导致Single2 类在加载字节码到虚拟机的时候就会实例化这个实例，当你调用getInstance方法的时候，就会直接返回，不必做任何判断，这样做的好处是代码量明显减少了，坏处是，在你没有使用该单例的时候，该单例却被加载了，如果该单例很大的话，将会浪费很多的内存。</p>
<h4 id="我们停下来思考一下"><a href="#我们停下来思考一下" class="headerlink" title="我们停下来思考一下"></a>我们停下来思考一下</h4><blockquote>
<p>我们如何选择这两种实现方式呢？如果你的项目对性能没有要求，那么请直接使用饿汉式方法实现单例模式，既简单又方便。但是，大部分程序员都是有追求的，岂能不追求性能。那么我们看第一种方式，就是懒汉式，我们刚刚说过，懒汉式既保证了单例，又保证了性能。但是，他真的能保证单例吗？可以确定的是：在单线程模式下，毫无问题，但在复杂的多线程模式下，会怎么样呢？show me code .</p>
</blockquote>
<h4 id="测试用例：我们测试一下"><a href="#测试用例：我们测试一下" class="headerlink" title="测试用例：我们测试一下"></a>测试用例：我们测试一下<img src="http://upload-images.jianshu.io/upload_images/4236553-351a3e3c6963a581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试用例"></h4><p>我们分析一下上面的代码，首先，我们验证的是什么呢？我们想验证多线程下获取懒汉式单例会不会出现错误。也就是出现一个以上的单例，我们如何做呢？首先我们定义一个Set对实例进行去重，然后创建1000个线程（Windows每个进程最多1000个线程，Linux每个进程最多2000个线程），每个线程都去获取实例，并添加到set中，实际上，我们应该使用Collections.synchronizedSet(set)获取一个线程安全的set，但是，这里为了方便，就直接使用HashSet了，然后main线程等待10秒，让1000个线程尽量都执行完毕。最后循环打印set的内容。在某些情况下，会出现2个实例，注意，是某些情况下，一定要多测试几次。下面是我们测试的结果：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-e2b42838c00a003f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试结果"></p>
<h4 id="我们停下来思考一下："><a href="#我们停下来思考一下：" class="headerlink" title="我们停下来思考一下："></a>我们停下来思考一下：</h4><blockquote>
<p>我们通过测试用例发现：高并发情况下，我们的懒加载确实存在bug。为什么会这样呢？我们假设第一个线程进入getInstance方法，判断实例为null，准备进入if块内执行实例化，这时线程突然让出时间片，第二个线程也进入方法，判断实例也为null，并且进入if块执行实例化，第一个线程唤醒也进入if块进行实例化。这时就会出现2个实例。所以出现了bug。So,  我们想要性能（避免上面说的消耗不需要的内存），又要线程安全。那我们该怎么办呢？有点经验的同学心里肯定有数了。show me code.</p>
</blockquote>
<h4 id="第三种方式：synchronized-同步式"><a href="#第三种方式：synchronized-同步式" class="headerlink" title="第三种方式：synchronized 同步式"></a>第三种方式：synchronized 同步式</h4><p><img src="http://upload-images.jianshu.io/upload_images/4236553-24b82915096f1b12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="59{(V}0%M`G546FRI`F4(_9.png"></p>
<p>这是我们的第三种方式，我们分析一下代码，我们可以看到，我们仅仅是在第一种懒汉式中加入了一个关键字，synchronized, 使用synchronized保证线程同步，保证同时只有一个进程进入此方法。从而保证并发安全。但是这样做完美吗？我们思考一下我们的代码：我们使用synchronized关键字，相当于每个想要进入该方法的获取实例的线程都要阻塞排队，我们仔细思考一下：需要吗？当实例已经初始化之后，我们还需要做同步控制吗？这对性能的影响是巨大的。是的，我们只需要在实例第一次初始化的时候同步就足够了。我们继续优化。</p>
<h4 id="第四种方式：双重检验锁："><a href="#第四种方式：双重检验锁：" class="headerlink" title="第四种方式：双重检验锁："></a>第四种方式：双重检验锁：</h4><p><img src="http://upload-images.jianshu.io/upload_images/4236553-06cb03b28bbab925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双重检验锁"></p>
<p>我们继续分析一下代码：首先看getInstance方法，我们在方法声明上去除了synchronized关键字，多线程进入方法内部，判断是否为null，如果为null，多个线程同时进入if块内，此时，我们是用Single4 Class对象同步一段方法。保证只有一个线程进入该方法。并且判断是否为null，如果为null，就进行初始化。我们想象一下，如果第一个线程进入进入同步块，发现该实例为null，于是进入if块实例化，第二个线程进入同步内则发现实例已经不是null，直接就返回 了，从而保证了并发安全。那么这个和第三种方式又什么区别呢？第三种方式的缺陷是：每个线程每次进入该方法都需要被同步，成本巨大。而第四种方式呢？每个线程最多只有在第一次的时候才会进入同步块，也就是说，只要实例被初始化了，那么之后进入该方法的线程就不必进入同步块了。就解决并发下线程安全和性能的平衡。虽然第一次还是会被阻塞。但相比较于第三种，已经好多了。</p>
<p>我们还对一个东西感兴趣，就是修饰变量的volatile关键字，为什么要用volatile关键字呢？这是个有趣的问题。我们好好分析一下：<br>首先我们看，Java虚拟机初始化一个对象都干了些什么？总的来说，3件事情：</p>
<ol>
<li>在堆空间分配内存</li>
<li>执行构造方法进行初始化</li>
<li>将对象指向内存中分配的内存空间，也就是地址</li>
</ol>
<p>但是由于当我们编译的时候，编译器在生成汇编代码的时候会对流程进行优化（这里涉及到happen-before原则和Java内存模型和CPU流水线执行的知识，就不展开讲了），优化的结果式有可能式123顺序执行，也有可能式132执行，但是，如果是按照132的顺序执行，走到第三步（还没到第二步）的时候，这时突然另一个线程来访问，走到if(single4 == null)块，会发现single4已经不是null了，就直接返回了，但是此时对象还没有完成初始化，如果另一个线程对实例的某些需要初始化的参数进行操作，就有可能报错。使用volatile关键字，能够告诉编译器不要对代码进行重排序的优化。就不会出现这种问题了。</p>
<p>我们看到，小小的单例模式被我们弄得很复杂。但这就是一个程序员的追求，追求最好的性能，追求最好的代码。</p>
<p>那还有没有别的更好的办法呢？这个代码也太多了，代码可读性也不好。而且线程第一次进入还会阻塞，还能更完美吗？</p>
<h4 id="第五种方式：既要懒汉式加载，又要线程安全：静态内部类。"><a href="#第五种方式：既要懒汉式加载，又要线程安全：静态内部类。" class="headerlink" title="第五种方式：既要懒汉式加载，又要线程安全：静态内部类。"></a>第五种方式：既要懒汉式加载，又要线程安全：静态内部类。</h4><p><img src="http://upload-images.jianshu.io/upload_images/4236553-88803130799bbb49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们来分析一下代码：相比较饿汉式（也就是第二种），我们增加了一个内部类，内部类中有一个外部类的实例，并且已经初始化了。我们回忆一下饿汉式有什么问题，饿汉式的问题是：<strong>在你没有使用该单例的时候，该单例却被加载了，如果该单例很大的话，将会浪费很多的内存</strong>.但是，我们现在引入了内部类的方式，虚拟机的机制是，如果你没有访问一个类，那么是不会载入该类进入虚拟机的。当我们使用外部类的时候其他属性的时候，是不会浪费内存载入内部类中的单例的。从而也就保证了并发安全和防止内存浪费。<br>但是，这样就能完美了吗？</p>
<h4 id="第六种方式：反射和反序列化破坏单例"><a href="#第六种方式：反射和反序列化破坏单例" class="headerlink" title="第六种方式：反射和反序列化破坏单例"></a>第六种方式：反射和反序列化破坏单例</h4><p><img src="http://upload-images.jianshu.io/upload_images/4236553-f8234e90cc1c70f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们知道Java的反射几乎是什么事情都能做，管你什么私有的公有的。都能破坏。我们是没有还手之力的。精心编写的代码就被破坏了，而反序列化也很厉害，但是稍微还有点办法遏制。什么办法呢？重写readResolve方法。show me code。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a5872df52befd602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看到：我们重写了readResolve方法，在该方法中直接返回了我们的内部类实例。重写readResolve() 方法，防止反序列化破坏单例机制，这是因为：反序列化的机制在反序列化的时候，会判断如果实现了serializable或者externalizable接口的类中包含readResolve方法的话，会直接调用readResolve方法来获取实例。这样我们就制止了反序列化破坏我们的单例模式。那反射呢？我们有办法吗？</p>
<h4 id="第七种方式：最后一招，使用枚举"><a href="#第七种方式：最后一招，使用枚举" class="headerlink" title="第七种方式：最后一招，使用枚举"></a>第七种方式：最后一招，使用枚举</h4><p><img src="http://upload-images.jianshu.io/upload_images/4236553-0ce6b37a73e195f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>为什么使用枚举可以呢？枚举类型反编译之后可以看到实际上是一个继承自Enum的类。所以本质还是一个类。 因为枚举的特点，你只会有一个实例。我们看一下反编译的枚举类。<br><img src="http://upload-images.jianshu.io/upload_images/4236553-0d78d3e6793bd512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反编译的class字节码"></p>
<p>我们看到，我们的hello包下的Single7枚举继承了java.lang.Enum&lt;&gt; 类。事实上就是一个类，但是我们这样就能防止反射破坏我们辛苦写的单例模式了。因为枚举的特点，而他也能保证单例。堪称完美！！！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回到开始，我们引用了一些维基百科的话，我们再看看维基百科关于并发是怎么说的：</p>
<blockquote>
<p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率).</p>
</blockquote>
<p>我们看到维基百科还是靠谱的。告诉了我们可以使用互斥锁来防止并发出现的问题。</p>
<p>而单例模式带来了什么好处呢？</p>
<ol>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ol>
<p>小小的一个单例模式也是如此的复杂，耗费了我们很多的精力去写，去读一篇文章。可是，这就是我们的乐趣。任何一段小小的代码，我们都要精益求精。总有一天，我们会写出千万人用的优良代码。加油！！</p>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2017/11/05/2017/2017-11-05-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ##### 定义：
> 状态模式（State），当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。

<hr>
<p>一个方法过长就是代码的坏味道。这个类或者这个方法违背类“单一职责原则”。</p>
<p>状态模式主要解决的是当控制一个对象状态转换的体检表达式过于复杂的时的情况，把状态的判断逻辑转移到不同的状态的一系列类当中，可以把复杂的判断逻辑化。当然，如果这个判断很简单，那就没必要用“状态模式”了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-51bc48ea81a5a152.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看到UML类图中，context类中维护者一个State的引用，也就是说，我们使用context类就可以控制State的具体实现的变化。<br>而具体实现类中有着传递一个Context的饮用的方法。实际上是将Context 这个对象一致传递下去。</p>
<p>状态模式的好处是：将与特定的状态相关的行为局部化，并且将不同状态的行为分割开来。<br>也就是将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreaeState中，所以通过定义新的子类可以很容易地增加新的状态和转换。</p>
<p>说白了，这样做的目的就是为零消除庞大的条件分枝语句，大的分支判断会使得他们那一修改和扩展。就像我们门最早说的刻板印刷一样，任何改动和变化都是致命的，状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。</p>
<p>使用场景：</p>
<blockquote>
<p>当一个对象的行为取决于他的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。而状态模式也是消灭if else 的利器</p>
</blockquote>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2017/11/11/2017/2017-11-11-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       #### 观察者模式也叫发布-订阅模式，即Publish/Subscirbe,

<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><blockquote>
<p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象再状态发生改变时，会通知所有观察真对象，使他们能够自动更新自己。</p>
</blockquote>
<p>其实这个模式其实是最常用的。</p>
<p>我想起了上段时间做的一个物联网项目，用的是MQTT协议，也是基于发布订阅模式的。当时对观察者模式不了解，所以弄了好久才明白。废话不多说。开始吧。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c7aa73e4c66395ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看一看上面的UML类图，先看接口Subject，译为‘主题’，在观察者模式中，担任通知者的角色，即通知接口。我们在看看Oberver接口，译为 ‘观察者’，就是被观察者。下面分别是实现他们的子类。我们看ConcresteSubject这个类，在他的属性中，有Observers属性，是个集合，即Observer集合，存储过个被观察者的对象。并且有两个方法，一个是增加被观察者方法，一个是删除观察者方法，一个是通知所有观察者方法。</p>
<p>我们再看ConcreaeObserver类，是一个被观察者的具体实现类，其中有一个update方法，其功能就是在通知者调用notify方法的时候，其实执行的就是他的update方法。</p>
<p>总体就是：通知者和观察者是聚合的关系，也即是‘弱’的拥有关系。每个实现Subject类的子类中都有Observer接口的饮用，用于存储被观察者，方便管理。</p>
<p>从发布订阅这个词来解说的话，就是：被观察者订阅了通知者的主题，当通知者发布主题时，就调用notify方法告诉所有订阅的被观察者。</p>
<p>观察者模式的应用场景：</p>
<p>当一个对象的改变需要改变其他对象的时候。补充一下，而且他不知道具体有多少对象待改变时，应该考虑用观察者模式。</p>
<p>当一个抽象模式有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使他们各自独立地改变和复用。</p>
<h6 id="总的来讲"><a href="#总的来讲" class="headerlink" title="总的来讲:"></a>总的来讲:</h6><blockquote>
<p>观察者模式所做的工作其实就是在解除耦合，让耦合的双方都依赖于抽象，二不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>迁移微服务框架-SpringCloud-事后总结</title>
    <url>/2017/11/12/2017/2017-11-12-%E8%BF%81%E7%A7%BB%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6-SpringCloud-%E4%BA%8B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ##### 我们这次主要讲4件事:
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 什么是微服务? 什么是 springcloud?</span><br><span class="line"><span class="bullet">2.</span> 我们为什么使用 SpringCloud?</span><br><span class="line"><span class="bullet">3.</span> 如何使用 SpringCloud? 如何 Quick Start?</span><br><span class="line"><span class="bullet">4.</span> 迁移过程中,老代码使用 springcloud 需要注意哪些坑?</span><br></pre></td></tr></table></figure>



<h2 id="1-什么是微服务-什么是-springcloud"><a href="#1-什么是微服务-什么是-springcloud" class="headerlink" title="1. 什么是微服务? 什么是 springcloud?"></a>1. 什么是微服务? 什么是 springcloud?</h2><p>引用维基百科:</p>
<blockquote>
<p>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c51d1eec7a2a246a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h5 id="微服务架构的一些通用特性"><a href="#微服务架构的一些通用特性" class="headerlink" title="微服务架构的一些通用特性"></a>微服务架构的一些通用特性</h5><ol>
<li>通过服务实现应用的组件化:微服务架构中将组件定义为可被独立替换和升级的软件单元，在应用架构设计中通过将整体应用切分成可独立部署及升级的微服务方式进行组件化设计。</li>
<li>围绕业务能力组织服务(Organizedaround Business Capabilities)：微服务架构采取以业务能力为出发点组织服务的策略，因此微服务团队的组织结构必须是跨功能的（如：既管应用，也管数据库）、强搭配的DevOps开发运维一体化团队，通常这些团队不会太大（如：亚马逊的“Two pizzateam”- 不超过12人）.</li>
<li>产品而非项目模式：传统的应用模式是一个团队以项目模式开发完整的应用，开发完成后就交付给运维团队负责维护；微服务架构则倡导一个团队应该如开发产品般负责一个“微服务”完整的生命周期，倡导“谁开发，谁运营”的开发运维一体化方法.</li>
<li>智能端点与管道扁平化：微服务架构主张将组件间通讯的相关业务逻辑/智能放在组件端点侧而非放在通讯组件中，<strong>通讯机制或组件应该尽量简单及松耦合</strong>。<em>RESTful HTTP协议</em>和仅提供消息路由功能的轻量级异步机制是微服务架构中最常用的通讯机制。</li>
<li>“去中心化”治理:微服务架构则鼓励使用合适的工具完成各自的任务，每个微服务可以考虑选用最佳工具完成(如不同的编程语言).</li>
<li>“去中心化”数据管理:微服务架构倡导采用多样性持久化的方法，让每个微服务管理其自有数据库，并允许不同微服务采用不同的数据持久化技术.</li>
<li>基础设施自动化:云化及自动化部署等技术极大地降低了微服务构建、部署和运维的难度，通过应用持续集成和持续交付等方法有助于达到加速推出市场的目的.</li>
<li>故障处理设计:微服务架构所带来的一个后果是必须考虑每个服务的失败容错机制。因此，微服务非常重视建立架构及业务相关指标的实时监控和日志机制.</li>
<li>演进式的设计:微服务应用更注重<strong>快速更新</strong>，因此系统的计会随时间不断变化及演进。微服务的设计受业务功能的生命周期等因素影响。如某应用是整体式应用，但逐渐朝微应用架构方向演进，整体式应用仍是核心，但新功能将使用应用所提供的API构建。再如在某微服务应用中，可替代性模块化设计的基本原则，在实施后发现某两个微服务经常必须同时更新，则这很可能意味着应将其合并为一个微服务.</li>
</ol>
<p>更多微服务内容请移步:<a href="https://www.ibm.com/developerworks/community/blogs/3302cc3b-074e-44da-90b1-5055f1dc0d9c/entry/%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84_%E4%B8%80_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1?lang=en">IBM developerWorks 中文社区:解析微服务架构</a></p>
<h5 id="什么是-springcloud"><a href="#什么是-springcloud" class="headerlink" title="什么是 springcloud?"></a>什么是 springcloud?</h5><blockquote>
<p> Spring Cloud是伴随着微服务的概念诞生的.基于 SpringBoot. </p>
</blockquote>
<h5 id="和-SpringCloud-密切相关的Netflix是一家什么公司"><a href="#和-SpringCloud-密切相关的Netflix是一家什么公司" class="headerlink" title="和 SpringCloud 密切相关的Netflix是一家什么公司?"></a>和 SpringCloud 密切相关的Netflix是一家什么公司?</h5><blockquote>
<p>Netflix是世界上最大的在线影片租赁提供商，向它的670万名顾客提供超过85，000部DVD电影的租赁服务，而且能向顾客提供4000多部影片或者电视剧的在线观看服务。公司的成功源自于能够提供超大数量的DVD，而且能够让顾客快速方便的挑选影片，同时免费递送。Netflix已经连续五次被评为顾客最满意的网站.</p>
</blockquote>
<h5 id="为什么-Netflix-要做-SpringCould-Netflix-和-SpringCloud-的前世今生"><a href="#为什么-Netflix-要做-SpringCould-Netflix-和-SpringCloud-的前世今生" class="headerlink" title="为什么 Netflix 要做 SpringCould?  Netflix 和 SpringCloud 的前世今生."></a>为什么 Netflix 要做 SpringCould?  Netflix 和 SpringCloud 的前世今生.</h5><p>1、首先，Netflix是一家做视频的网站，可以这么说该网站上的美剧应该是最火的。</p>
<p>2、Netflix是一家没有CTO的公司，正是这样的组织架构能使产品与技术无缝的沟通，从而能快速迭代出更优秀的产品。在当时软件敏捷开发中，Netflix的更新速度不亚于当年的微信后台变更，虽然微信比Netflix迟发展，但是当年微信的灰度发布和敏捷开发应该算是业界最猛的。</p>
<p>3、Netflix由于做视频的原因，访问量非常的大，从而促使其技术快速的发展在背后支撑着，也正是如此，Netflix开始把整体的系统往微服务上迁移。</p>
<p>4、Netflix的微服务做的不是最早的，但是确是最大规模的在生产级别微服务的尝试。也正是这种大规模的生产级别尝试，在服务器运维上依托AWS云。当然AWS云同样受益于Netflix的大规模业务不断的壮大。</p>
<p>5、Netflix的微服务大规模的应用，在技术上毫无保留的把一整套微服务架构核心技术栈开源了出来，叫做Netflix OSS，也正是如此，在技术上依靠开源社区的力量不断的壮大。</p>
<p>6、Spring Cloud是构建微服务的核心，而Spring Cloud是基于Spring Boot来开发的。</p>
<p>7、Pivotal在Netflix开源的一整套核心技术产品线的同时，做了一系列的封装，就变成了Spring Cloud；虽然Spring Cloud到现在为止不只有Netflix提供的方案可以集成，还有很多方案，但Netflix是最成熟的。</p>
<h5 id="SpringCloud-有哪些牛逼的功能"><a href="#SpringCloud-有哪些牛逼的功能" class="headerlink" title="SpringCloud 有哪些牛逼的功能?"></a>SpringCloud 有哪些牛逼的功能?</h5><p>SpringCloud 号称拥有五虎将(即最常用的五个功能). 哪五虎将?</p>
<ol>
<li>Eureka 云端服务注册与发现.</li>
<li>Zuul 动态路由, 服务网关.</li>
<li>Hystrix 断路器.容灾管理工具.</li>
<li>Spring Cloud Config 云端配置中心.</li>
<li>Load Balance 负载均衡.</li>
</ol>
<p>还有一些其他的功能, 比如事件总线, 配置管理 API, 轮询框架, Consul 可与 Docker 无缝集成, Sleuth 日志收集工具包, Data Flow 大数据操作工具, Security 安全工具包, Zookeeper 操作 ZK 的工具包, Stream 数据流操作开发包, 封装了 Redis, Rabbit, Kafka. Ribbon 负载均衡, Feign 声明式的 HTTP 客户端, Task 提供计划任务管理,任务调度框架, Cluster 提供 Leadership 选举, 类似 Zookeeper 选举. Starters  为 SpringCloud 提供开箱即用的依赖管理.</p>
<h2 id="2-我们为什么使用-SpringCloud"><a href="#2-我们为什么使用-SpringCloud" class="headerlink" title="2. 我们为什么使用 SpringCloud?"></a>2. 我们为什么使用 SpringCloud?</h2><p>让我们先来看看传统IT架构面临的一些问题：</p>
<ol>
<li>使用传统的整体式架构应用开发系统，如CRM、ERP等大型应用，随着新需求的不断增加，企业更新和修复大型整体式应用变得越来越困难；</li>
<li>随着移动互联网的发展，企业被迫将其应用迁移至现代化UI界面架构以便能兼容移动设备，这要求企业能实现应用功能的<strong>快速上线</strong>；</li>
</ol>
<h5 id="我们为什么要使用-SpringCloud"><a href="#我们为什么要使用-SpringCloud" class="headerlink" title="我们为什么要使用 SpringCloud ?"></a>我们为什么要使用 SpringCloud ?</h5><ol>
<li><p>现有的框架为多个 SpringBoot 的框架, 最明显的一个问题就是, 重复代码太多, 直接导致的问题就是修改一处, 其余地方都要修改, 代码难以维护. 比如一个User 这张表,可能每个 SpringBoot 都需要 User 表的查询功能, 但是除了 User 模块, 其余模块也要创建 User 相关的类和配置文件,一旦 User 表字段更改, 所有相关模块都要更改, 令人恐惧.<br>用 SpringCloud 能解决这个问题吗?<br>能. 只需要 User 开放一个 关于 User 表的查询接口, 其他模块调用此接口,就能实现之前的功能. 避免了大量的重复代码. 提高了代码的可维护性.</p>
</li>
<li><p>第二个问题就是应用扩展问题,  只要企业快速发展, 所有的后端都不可避免的要实施分布式, 将一个大的服务拆分为一个个小服务, 保证系统的快速迭代和快速扩展. A 应用故障不会导致 B 应用也故障. 现有的框架无法支持横向扩展和快速迭代, 之前的架构成为我们的痛点。<br>用 SpringCloud 能解决这个问题吗?<br>SpringCloud 为分布式和微服务而生, 拆分巨型应用, 使得每个模块都独立, 根据业务拆分服务, 也可根据业务的改变合并服务, SpringCloud 支持集群部署异常简单, 且自带软负载均衡, 配合 Zuul 网关实现服务认证, 安全过滤等功能. SpringCloud 自带的断路器能够很好的容灾, 当某个服务不通时, 不会影响整个服务导致雪崩性的效应. 并且如果某个服务需要迭代, 其余模块可丝毫不受影响. 更改架构后能承受更高的并发和用户量。</p>
</li>
<li><p>第三个问题是原有的代码无法支持分库分表，原有的表全部都再一个库种，业务高度耦合，难以维护，为了践行微服务“去中心化”数据管理的理念，每个服务管理其自有数据库，我们必须将表根据业务进行分割，以应对后期分库。</p>
</li>
<li><p>原有架构不清晰，水平扩展和快速迭代没有成熟和现行的技术方案，使用成熟的 SpringCloud 方案可以减少项目风险，提高应对风险的能力和应对业务快速变化的要求。</p>
</li>
</ol>
<h2 id="3-如何使用-SpringCloud-如何-Quick-Start"><a href="#3-如何使用-SpringCloud-如何-Quick-Start" class="headerlink" title="3. 如何使用 SpringCloud? 如何 Quick Start?"></a>3. 如何使用 SpringCloud? 如何 Quick Start?</h2><p>快速开始已经有很多文章.<br><a href="http://blog.csdn.net/forezp/article/details/70148833">[史上最简单的 SpringCloud 教程 | 终章]—–SpringCloud 终极入门</a></p>
<h2 id="4-老代码使用-springcloud-需要注意哪些坑"><a href="#4-老代码使用-springcloud-需要注意哪些坑" class="headerlink" title="4. 老代码使用 springcloud 需要注意哪些坑?"></a>4. 老代码使用 springcloud 需要注意哪些坑?</h2><h5 id="目前我们重构老代码的主要方向是"><a href="#目前我们重构老代码的主要方向是" class="headerlink" title="目前我们重构老代码的主要方向是:"></a>目前我们重构老代码的主要方向是:</h5><ol>
<li>抽取重复代码变成对外的 Restful 接口供其他模块调用.</li>
<li>根据数据库进一步合理拆分业务, 为以后的拆分数据库做铺垫.</li>
<li>隔离业务和 Restful 接口模块和实体类模块, 以便所有模块依赖公有代码.</li>
<li>避免递归调用和多层调用, 尽量提供方就是提供方, 消费方就是消费方. 减少深层次调用,  方便排错.</li>
<li>模块与模块之间的通信和协作通过消息队列. 减少耦合.</li>
<li>对所有模块依赖的公有代码进行 Scan, 以方便后面的重构.</li>
</ol>
<h5 id="遇到了哪些问题呢"><a href="#遇到了哪些问题呢" class="headerlink" title="遇到了哪些问题呢?"></a>遇到了哪些问题呢?</h5><ol>
<li>我们使用了 SpringCloud 的 Feign Http 客户端, 作为消费方. Feign 请求提供方接口时根据需要传参数, 可以使用<code>@RequestParam()</code>注解, 也可以使用<code>@PathVariable </code>路径传参. 也可以使用<code>@RequestBody</code>注解传对象，关于这三个注解的用法,需要注意一下他们的用法和坑点.</li>
</ol>
<hr>
<ul>
<li><code>@RequestParam</code>用法<br><img src="http://upload-images.jianshu.io/upload_images/4236553-1eed0896f1edfafb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@RequestParam用法"></li>
</ul>
<p><code>@RequestParam</code>配合 GET 请求注解用于标注普通类型的参数, 比如8个基本类型和他们的包装类或者 String 类型. 也可用使用在 Map 上, 例如<code>fun(@RequestParam (&quot;map&quot;)Map&lt;K,V&gt; map)</code>, 也可以使用在 Date 类型上, 例如 <code>fun(@RequestParam(&quot;date&quot;) Date date)</code>,<code>注意</code>, 只要有参数, 且参数是基本类型或者是包装类型和 String 类型, <code>必须</code>使用该注解配合 GET 请求. 否则肯定报错. </p>
<hr>
<ul>
<li><code>@PathVariable()</code> 用法<br><img src="http://upload-images.jianshu.io/upload_images/4236553-58670f7bb0568aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@PathVariable()"></li>
</ul>
<p>该注解用于配合路径中的占位符使用, <code>注意</code>: 该注解必须在子类上也写上注解, 也就是说, 服务提供方的 API 接口 如果使用了该注解, 那么实现该接口的子类必须在参数前加上此注解, 这三个注解都不支持继承，因为Spring 是不能识别该注解应该作用于哪个参数, 如果不写, 就会得到 Null 值, 导致错误. 那么 <code>@RequestParam</code> 需要写吗? 答案是不需要写的, 因为<code>@RequestParam</code>是 url 传参, Spring 支持将参数名称映射到参数上给定的参数上. 因此, 使用该注解时需要<code>注意</code>的是: 必须在子类中加入该注解. 还有, 该注解不能传类似版本号的数字(如:1.2.1), 会导致 http 解析时去掉最后的小数点. 建议使用 URL中的<code>www.google.com?name=tom</code> 传参.</p>
<hr>
<p><code>@RequestBody</code>用法<br><img src="http://upload-images.jianshu.io/upload_images/4236553-400c6ec97cd05470.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@RequestBody用法"></p>
<p>如果参数很多, 难道我们要一个一个参数写上去吗? 不需要, 我们可以使用<code>@RequestBody</code> 注解配合 POST 请求, 将多个参数封装成一个对象, 当然 <code>@RerquestParam</code> 注解配合 GET 加上 Map 参数也可以, 但是不建议使用 Map 作为参数, Map 会出现很多问题, 我们稍后再讲. 回到我们的<code>@RequestBody</code> 注解的用法上面来, <code>注意</code>: 这个注解也必须在子类上声明, 否则参数无法映射. 因为 Spring 映射时找的是子类, 而该注解的作用是: 解析Body 里的内容变成 JSON, 然后映射到参数中, 如果不写, Spring 将不知道如何映射. 因为 Spirng 也是支持用流获取参数的. 并且该注解也是 Swagger 文档框架的基础. <code>注意</code>, 一个方法中只能有一个<code>@RequestBody</code>注解. <code>注意</code>: 该注解要求 Http 消息头中包含: Content-Type:Application/json.</p>
<hr>
<p>总结一下上面关于三个注解的内容.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 实现类除<span class="meta">@RequestParam</span>（如果参数是map则需要加） 不需要加注解，其余都要加注解;</span><br><span class="line"><span class="number">2.</span> map 可以用get传也可以用post传;</span><br><span class="line"><span class="number">3.</span> get 请求不能有一个或多个复杂对象（顶多用一个map代替多个参数）;</span><br><span class="line"><span class="number">4.</span> post 请求有且只能有一个复杂对象，必须使用<span class="meta">@RequestBody</span> 注解;</span><br><span class="line"><span class="number">5.</span> set 类型使用post 请求 + <span class="meta">@RequestBody</span> 注解;</span><br><span class="line"><span class="number">6.</span> 不能使用数组，包装类型也不行，可用List代替：get请求+<span class="meta">@RequestParam</span>, Post请求中的</span><br><span class="line">   <span class="meta">@RequestBody</span>,jackSon工具无法解析数组，因为数组没有类型信息.而get请求框架会自动参数隐射;</span><br><span class="line"><span class="number">7.</span> Date 类型 使用post + <span class="meta">@RequestBody</span>或者，使用 get + <span class="meta">@RequestParam</span>;</span><br><span class="line"><span class="number">8.</span> 注解必须搭配使用，GetMapping + <span class="meta">@RequestParam</span>, <span class="meta">@PostMapping</span> + <span class="meta">@RequestBody</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>还有一个坑点, 就是上面说的 Map 参数, 因为我们主要重构的是关于 Mapper 方法, 也就是数据库操作, 而这之前为了方便传参数, 使用了大量的 Map 作为参数的方法, 并且 Value 的泛型为 Object 类型, 这个时候问题就出现了, 如果之前 Map 中有个键值对是<code>data=new Date()</code>, 在 xml 配置文件中则是<code>create_date &lt;= #&#123;date&#125;</code>, 原本这样写是没有任何问题的. 但是一旦把 Map 作为网络调用的参数, 当你把 Date 类型传过去的时候, 而 Value 的泛型又是 Objece, 那么那边接受到的就是 Long 类型的时间戳, 在 xml 文件中就会出现<code>create_date &lt;= 1213244343432</code>, 很明显, 就会溢出报错. 所以, 我们后期都将做了特殊处理, 类似下面这样:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">  Long date = (Long)map.get(<span class="string">&quot;date&quot;</span>);</span><br><span class="line">  <span class="comment">// 将Long 类型转换成 Date 类型</span></span><br><span class="line">  map.put(<span class="string">&quot;date&quot;</span>, <span class="keyword">new</span> Date(date));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>所以, 以后遇到需要传递 Date 类型的时候, 尽量不要使用 Map, 如果使用 Map, Value 的泛型也尽量不要写 Object. </p>
<p>3 . 还有一个问题就是分页插件的问题, 我们使用的 pageHelper 的开源分页插件, 原理是在当前线程中放入一个 ThreadLocal 的 Page 对象, 当调用动态代理了 mybatis 的方法时, 经过代理对象 invoke 方法时会触发继承了 Mybatis 拦截器的分页插件, 分页插件会从 ThreadLocal 中取出分页对象, 进行分页. 执行结束后会删除该 Page 对象.<br>那么我们发生一个什么故障呢? 原有的分页是这样写的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getPageUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 该方法进行分页, 构造一个 Page 对象, 将 Page 对象作为 ThreadLocal </span></span><br><span class="line">  <span class="comment">// 放入当前线程</span></span><br><span class="line">  PageHelper.start(page, rows);</span><br><span class="line">  <span class="comment">// 执行查询 SQL</span></span><br><span class="line">  userMapper.select(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码之前写是没有任何问题的, 但是, 由于 UserMapper 被抽取出来成为公共部分代码. 所以这个地方被重构成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getPageUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 该方法进行分页, 构造一个 Page 对象, 将 Page 对象作为 ThreadLocal </span></span><br><span class="line">  <span class="comment">// 放入当前线程</span></span><br><span class="line">  PageHelper.start(page, rows);</span><br><span class="line">  <span class="comment">// 注意: 这里变成了网络调用, 执行 SQL 的线程已经在另一个虚拟机中.</span></span><br><span class="line">  userClient.select(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, <code>userMapper</code> 变成了<code> userClient</code>, 原有的 SQL 变成了网络调用. 那么这个时候会发生什么事情呢? <code> PageHelper.start(page, rows);</code> 放入线程的 <code>Page</code> 对象将不会被消费, 也不会被删除, 因为当前线程根本不会执行 <code>Mybatis</code> 的方法, 更不会进入拦截器, 而容器使用的是线程池, 当该方法结束后, 携带着<code> Page</code> 对象的线程会随机分配一个任务执行 <code>SQL</code>, 如果该 <code>SQL</code> 不支持分页, 但是分页插件发现该线程中含有 <code>Page</code> 对象, 就会强行分页, 导致错误, 而这个错误很难排查. 所以, 当使用<code> PageHelper.start(page, rows);</code>方法后, 在本任务执行结束之前一定要在本虚拟机中跟一条 <code>SQL</code> , 也就是跟一个<code> Mybatis</code> 的方法. 否则将会影响其他线程中 <code>SQL</code> 的执行. 导致报错.</p>
<ol start="4">
<li><p>还有就是, 重构后, 实体类的全限定名都变化了, 如果使用缓存,或者是任何依赖序列化的中间件, 都会因为类名不对导致无法反序列化为新实体类而报错.<br>所以应该在保证安全的情况下, 将缓存清空.</p>
</li>
<li><p>关于断路器的使用, 断路器的作用是, 如果 <code>Feign</code> 调用失败, 并且重试多次失败（我的测试是5秒之内连续10次失败之后）， 就会触发断路器, 也就是我们重写的方法, 刚开始, 我们直接在断路器中返回了默认值, 比如如果是对象就返回 null, 如果是容器就返回空, 如果是基本类型就返回默认值, 但是, 仔细一想不对, 如果业务代码将 null 和默认值作为逻辑判断怎么办, 实际上, 网络调用失败返回 <code>null</code> 和调用成功返回 <code>null</code> 是不同的. 因此, 我们将触发断路器方法中的内容改为了抛出异常. 避免影响老代码的逻辑, 可以在新代码的使用中, 针对断路器如何返回值做出新的约定. 防止断路器和业务返回内容混淆.  断路器什么时候会恢复调用呢？答案是5秒之后断路器会变成半开闭的状态，如果有服务请求，就会尝试调用一次，如果成功则关闭断路器，如果失败，则开启断路器。5秒之后就又变成了半开闭的状态。</p>
</li>
<li><p>还有一个坑点就是: 如何传递<code> Header</code>, , 我们需要的网络调用中传递 <code>Header</code> , 而我们现有的 <code>Header </code>都是存放在 <code>ThreadLocal</code> 中的, 难道我们要写一个 <code>Feign</code> 的配置类, 并在每个配置类上加上一个<code>@Header</code>的注解? 或者我们要将 <code>Header</code> 放在参数中传递吗? 答案是不必的. 我们只需要拦截 <code>Http Request</code> , 在 <code>Http</code> 请求前加入我们需要的 <code>Header</code>. 而这就引出了第七个问题。</p>
</li>
</ol>
<ol start="7">
<li>SpringCloud Feign 和断路器为了服务的高可用和应用健壮性， 提供了二种<code>隔离策略</code>： <code>线程池隔离</code>和<code>信号量隔离</code>，<blockquote>
<p>简单说一下什么是<code>线程池隔离</code>， SpringCloud将服务调用的主线程和 Feign 调用的Http请求分开存放在不同的线程池， 为什么要这么做呢？试想一下如果不分开存放， 当主线程调用时超时，那么 tomcat 就会阻塞大量线程，影响整个服务，但，如果使用<code>线程池隔离</code>， Feign 请求会开辟新的线程，就算超时也不影响整体应用的，更不影响tomcat 线程池中的线程，保证了容器的安全。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>再说一下什么是<code>信号量隔离</code>， 信号量就是系统设置的并发请求数，如果设置的信号量为10， 那么该服务接口的请求并发数就为10， 超过10就进行服务降级，忽略请求。信号量隔离是使用tomcat中的主线程进行服务请求，因此，不能算是隔离，只能算是限流，限制请求的数量，即使目标服务不通，也不会拖垮整个 tomcat 中的服务。如果请求的服务速度很快，并发很高，并且提供方服务稳定。那么使用<code>信号量</code>是合算的。因为不会有线程的上下文切换。否则使用<code>线程池隔离</code>比较合算。</p>
</blockquote>
<blockquote>
<p>那么对于我们来说，<code>隔离策略</code>带给我们什么影响呢？ 第6点的时候我们说，我们需要将Header传递， 而Header放在ThreadLocal 中，所以，<code>线程池隔离</code>的策略难以无缝支持ThreadLocal 中的Header。 除非特殊配置或者写在参数中，但这需要修改大量代码，我们想使用切面的方式将Header 透明的传递。<code>信号量隔离</code>策略和适合我们，既能保证服务的稳定性，也能保证服务中Header的传递。所以我们选择了<code>信号量隔离</code>。</p>
</blockquote>
<ol start="8">
<li><p>由于分布式调用出错调试较为复杂, 因此, 以前返回客户端只是<code>服务端错误</code>, 现在使用<code>@ExceptionHandler(HystrixRuntimeException.class)</code> 注解, 细化每个异常, 用以返回不同的错误信息, 方便排错. </p>
</li>
<li><p>测试用例在之前貌似不怎么重要, 因为一个 debug 可以一路调通, 但分布式的可能需要跨越多层调用, 因此, 单元测试就显得很重要, 能将错误慢慢分割. 从而更加快速精准的定位异常原因, 因此, 重构后增加了大量的测试用例, 用以排错.</p>
</li>
<li><p>统一配置类, 使用<code>@ComponentScans()</code>注解扫描一个共同的配置模块, 方便重构和配置.否则, 大量的配置类将不同统一配置, 我们将疲于奔命.</p>
</li>
<li><p>SpringCloud Feign 客户端第一次远程调用可能会失败， 原因是由于Spring 是懒加载的， 调用Feign需要加载很多类，需要一些时间，  而Feign 默认超时一秒就会认为服务调用失败， 抛出异常。 因此我们测试时只需要关注第二次调用即可。 </p>
</li>
</ol>
<hr>
<hr>
<h3 id="总结：至此，我们知道了什么？"><a href="#总结：至此，我们知道了什么？" class="headerlink" title="总结：至此，我们知道了什么？"></a>总结：至此，我们知道了什么？</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 什么是微服务? 什么是 springcloud?</span><br><span class="line"><span class="bullet">2.</span> 我们为什么使用 SpringCloud?</span><br><span class="line"><span class="bullet">3.</span> 如何使用 SpringCloud? 如何 Quick Start?</span><br><span class="line"><span class="bullet">4.</span> 迁移过程中,老代码使用 springcloud 需要注意哪些坑?</span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat（一）源码环境搭建和-How-Tomcat-Works-源码</title>
    <url>/2017/11/17/2017/2017-11-17-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat%EF%BC%88%E4%B8%80%EF%BC%89%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C-How-Tomcat-works-%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       为了了解 tomcat 的原理, 楼主费劲心思, 从图书馆借来了绝版的<<How Tomcat Works>>, 下载了该书中的实例源码, 由于该书已经很老了, 讲的 tomcat4 和 tomcat5 中的知识, 于是楼主又下载了 tomcat7 的源码, 重新编译. 反正各种曲折, 不过, 最终也弄好了. 并且, 楼主已经将源码都上传到 gitHub 上了, 现在只需简单 clone, 就能运行代码了. 再也不用到处找 jar 包, 使用 ant 编译了.


<p>下面是楼主的两个源码的 github 地址:</p>
<ol>
<li>tomcat7 源码地址:<a href="https://github.com/stateIs0/Tomcat-Source-Code">https://github.com/stateIs0/Tomcat-Source-Code</a></li>
<li>How Tomcat Works 示例源码 地址:<a href="https://github.com/stateIs0/HowTomcatWorks">https://github.com/stateIs0/HowTomcatWorks</a></li>
</ol>
<p>clone 下来之后只需简单配置开发环境就可 debug. 只要熟悉自己的开发工具(eclipse 或者 IDEA), 都可在数分钟内直接启动运行.<br>欢迎 star!!  如果有什么问题请留言.</p>
<p>尽情享受源码吧!!! good luck!!</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat-(二)-从宏观上理解-Tomcat-组件及架构</title>
    <url>/2017/11/18/2017/2017-11-18-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat-(%E4%BA%8C)-%E4%BB%8E%E5%AE%8F%E8%A7%82%E4%B8%8A%E7%90%86%E8%A7%A3-Tomcat-%E7%BB%84%E4%BB%B6%E5%8F%8A%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       这是我们自编译源码以来第一次总结 tomcat, 虽然不知从何说起, 但这笔不能停下来, 看了很多的文章和源码, 脑子里从最初的混混沌沌到现在的稍有头绪, 楼主想说, 不容易.

<p>tomcat 异常复杂, 组件巨多. 我认为, 作为初学者, 我们不能直接进入源码, 过多的实现细节会掩盖抽象概念, 容易一叶障目不见泰山. 我个人认为&lt;<How Tomcat Works>&gt;这本书写的很好, 而我也想和这本书的角度一样, 尽力(注意:是尽力)去描述我所理解的 tomcat. </p>
<p>而我学习tomcat 的路线是:</p>
<ol>
<li>宏观上理解 tomcat 组件及架构设计.</li>
<li>从一个简单的例子来理解tomcat的底层设计, 到底是怎么做的.</li>
<li>从 tomcat 的各个组件各个击破, 理解每个组件的设计.</li>
<li>从2条路线去 debug, 验证之前的理论是否正确, 并深刻理解代码. 第一条路线是启动过程. 第二条路线是一个 http 请求到 Servlet 的 service() 方法的过程.</li>
<li>总结 tomcat 的设计.</li>
</ol>
<p>大概是这个样子, 所以按照我们的研究路线, 大概会有5到6篇文章来详细讲述.</p>
<p>我们的文章会配上源码, 所以, 如果同学们没有下载源码, 可以去楼主关于 tomcat 的第一篇文章去下载源码, 最好将2份源码都下载, 因为我们会将2分源码混合的分析.</p>
<p>so, 这是第一篇(虽然标题是二). </p>
<h5 id="这篇文章我们主要讲什么"><a href="#这篇文章我们主要讲什么" class="headerlink" title="这篇文章我们主要讲什么?"></a>这篇文章我们主要讲什么?</h5><h6 id="1-什么是-tomcat"><a href="#1-什么是-tomcat" class="headerlink" title="1. 什么是 tomcat?"></a>1. 什么是 tomcat?</h6><pre><code>  1. tomcat 的历史
  2. 和 tomcat 高度相关的 Servlet 是什么?是如何工作的?
</code></pre>
<h6 id="2-tomcat-是如何设计的-有哪些所谓的组件"><a href="#2-tomcat-是如何设计的-有哪些所谓的组件" class="headerlink" title="2. tomcat 是如何设计的? 有哪些所谓的组件?"></a>2. tomcat 是如何设计的? 有哪些所谓的组件?</h6><pre><code>  1.  tomcat 源码目录的解释
  2.  tomcat 整体框架的层次结构和架构图
  3. 分析每个组件, 包括 Connector, Container, Component
  4. 从接口和类的角度(UML 类图)看架构.
</code></pre>
<h6 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h6><hr>
<h2 id="什么是-tomcat"><a href="#什么是-tomcat" class="headerlink" title="什么是 tomcat ?"></a>什么是 tomcat ?</h2><p>我们还是引用一下维基百科:</p>
<blockquote>
<p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对<a href="https://zh.wikipedia.org/wiki/Servlet">Servlet</a>和<a href="https://zh.wikipedia.org/wiki/JavaServer_Page">JavaServer Page</a>（<a href="https://zh.wikipedia.org/wiki/JSP">JSP</a>）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a><a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，它也可以被视作一个单独的<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8">Web服务器</a>。但是，不能将Tomcat和<a href="https://zh.wikipedia.org/wiki/Apache_HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8">Apache HTTP服务器</a>混淆，<a href="https://zh.wikipedia.org/wiki/Apache_HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8">Apache HTTP服务器</a>是一个用C语言实现的HTTP<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8">Web服务器</a>；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p>
</blockquote>
<h5 id="简而言之-tomcat-是一个接受-http-请求并解析-http-请求并反馈客户端的一个应用程序"><a href="#简而言之-tomcat-是一个接受-http-请求并解析-http-请求并反馈客户端的一个应用程序" class="headerlink" title="简而言之: tomcat 是一个接受 http 请求并解析 http 请求并反馈客户端的一个应用程序."></a>简而言之: tomcat 是一个接受 http 请求并解析 http 请求并反馈客户端的一个应用程序.</h5><p>tomcat 可以说是 sun Servlet 的一个官方参考实现, 因为 tomcat 刚开始就是 sun 开发的,后来捐献给了 apache 基金会.</p>
<p>在我们理解 tomcat 之前, 我们得了解一下tomcat 所实现的 Servlet 是什么东东? </p>
<p>那要从互联网大潮兴起开始讲起, 我们知道, 网页不止有静态的还有动态的, 而在刚开始的时候, 常见的实现动态网页的技术就是 CGI, 但是作为 Java 的发明人, SUN|肯定要搞一个超级大风头, 让整个世界一下子认识了 Java, 不过很快悲催的发现 Applet 其实用途不大, 眼看着互联网开始流行, 一定要搭上千载难逢的快车啊.</p>
<p>于是, Servlet 就诞生了, Servlet 其实就是 SUN 为了让 Java 能实现动态的可交互的网页, 从而进入 web 编程的领域而定义的一套标准. </p>
<p>这套标准是这么说的: 你想用 Java 开发动态网页, 可以定义一个自己的” Servlet”, 但一定要实现我的 HTTPServlet 接口, 然后重载 doGet(), doPost()方法. 用户从流浪器 GET 的时候, 调用 doGet 方法, 从流浪器向服务器发送表单数据的时候, 调用 doPost 方法, 如果你想访问用户从浏览器传递过来的参数, 用 HttpServletRequest 对象就好了, 里面有 getParameter, getQueryString 方法, 如果你处理完了, 想向浏览器返回数据, 用 HttpServletResponse 对象调用 getPrintWriter 方法就可以输出数据了. </p>
<p>如果你想实现一个购物车, 需要 session, 很简单, 从 HttpServletRequest 调用 getSession 方法就可以了.</p>
<h3 id="那么…-Servlet-是如何工作的"><a href="#那么…-Servlet-是如何工作的" class="headerlink" title="那么….. Servlet 是如何工作的"></a>那么….. Servlet 是如何工作的</h3><p>servlet 是一个复杂的系统, 但是他有三个基本任务, 对每个请求, servlet 容器会为其完成以下3个操作:</p>
<ol>
<li>创建一个 Request 对象, 用可能会在调用的 Servlet 中使用到的信息填充该 Request 对象, 如参数, 头, cookie, 查询字符串, URI 等, Request 对象是 javax.servlet.ServletRequest 接口或 javax.servlet.ServletRequest 接口的一个实例.</li>
<li>创建一个调用 Servlet 的 Response 对象, 用来向 Web 客户端发送响应. response 对象是 javax.servlet.http.ServletResponse 接口或 javax.servlet.ServletResponse 接口的一个实例;</li>
<li>调用 Servlet 的 service 方法, 将 request 对象和 response 对象作为参数传入, Servlet 从 request 对象中读取信息, 并通过 response 对象发送响应信息.</li>
</ol>
<p>你写了一个” Servlet”, 接下来要运行, 你就发现没法通过 java 直接运行了, 你需要一个能够运行 Servlet 的容器, 这个容器 Sun 最早实现了一个, 叫 Java Web Server, 1999年捐给了 Apache Software foundation, 就改名叫 Tomcat. 这就是 Tomcat 的由来.</p>
<p>所以, Tomcat 就是一个 Servlet 容器, 能接收用户从浏览器发来的请求, 然后转发给 Servlet 处理, 把处理完的响应数据发回浏览器.</p>
<p>但是 Servlet 输出 Html, 还是采用了老的 CGI 方式 , 是一句一句输出, 所以,编写和修改 html 非常不方便, 于是, Java Server Pages(JSP) 就来救急了, JSP 并没有增加任何本质上不能用 Servlet 实现的功能, 实际上 JSP 在运行之前, 需要先编译成 Servlet, 然后才执行的. </p>
<p>但是, 在 JSP 中编写静态 HTML 更加方便, 不必再用 println 语句来输出每一行HTML 代码, 更重要的是, 借助内容和外观的分离,页面制作中不同性质的任务可以方便的分开: 比如, 有页面设计者进行 HTML 设计, 同时流出供 Java 程序插入动态内容的空间. </p>
<p>Tomcat 能运行 Servlet, 当然能运行 JSP 了.</p>
<p>既然是 Web 服务器, tomcat 除了能运行 Servlet 和 JSP 之外, 也能像 Apache/nginx 一样, 支持静态 html, 图片, 文档的访问, 只是性能差一点,在实际的应用中, 一般是 Apache/nginx 作为负载均衡服务器和静态资源服务器放在最前端, 后面是 tomcat 组成的集群.</p>
<p>如果用户请求的是静态资源, nginx 直接搞定, 如果是动态资源(如xxx.jsp), nginx 就会按照一定的算法转发的某个 tomcat 上, 达到负载均衡的目的.</p>
<hr>
<h2 id="Tomcat-是如何设计的-有哪些所谓的组件"><a href="#Tomcat-是如何设计的-有哪些所谓的组件" class="headerlink" title="Tomcat 是如何设计的? 有哪些所谓的组件?"></a>Tomcat 是如何设计的? 有哪些所谓的组件?</h2><p>tomcat 的主体是 Catalina, catalina 是一个成熟的软件, 设计和开发的十分优雅, 功能结构也是模块化的. 我们之前说 <code>Servlet 是如何工作的?</code>中提到了 Servlet 容器的任务, 基于这些任务可以将 Catalina 划分为两个模块: <strong>连接器(connector)和容器(container)</strong>.</p>
<p><strong>注意</strong>: 连接器和 Servlet 容器是一对多的关系.</p>
<p>连接器负责将一个请求与容器相关联, 他的工作为它接收到的每个 http 请求创建一个 Request 对象和一个 Response 对象, 然后, 他将处理过程交给容器.  容器从连接器中接收到 Request 对象和 Response 对象, 并负责调用相应的 service 方法.</p>
<p>但是请记住, 上面所描述的处理过程只是 Catalina 容器处理请求的的整个过程的一小部分, 犹如冰山的一角, 在容器中还包括很多其他的事情要做, 例如, 在容器调用相应的 Servlet 的 service 方法之前, 他必须先载入该 Servlet 类, 对用户进行身份验证(如果有必要的话), 为用户更新会话信息等, 因此, 当你发现容器使用了很多不同的模块来处理这些事情时, 请不要它惊讶, 例如, <strong>管理器模块</strong>用来处理用户会话信息, <strong>类载入器模块</strong>用来载入所需的 Servlet 类.</p>
<h6 id="那么我们来看看-Tomcat-源码的目录结构和每个目录是起什么作用的"><a href="#那么我们来看看-Tomcat-源码的目录结构和每个目录是起什么作用的" class="headerlink" title="那么我们来看看 Tomcat 源码的目录结构和每个目录是起什么作用的:"></a>那么我们来看看 Tomcat 源码的目录结构和每个目录是起什么作用的:</h6><p><img src="http://upload-images.jianshu.io/upload_images/4236553-a657a0b26724dad2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dir"></p>
<hr>
<h4 id="Tomcat-整体的框架层次：4个层次-其中-Connector-和-Container-是最重要的"><a href="#Tomcat-整体的框架层次：4个层次-其中-Connector-和-Container-是最重要的" class="headerlink" title="Tomcat 整体的框架层次：4个层次, 其中 Connector 和 Container 是最重要的."></a>Tomcat 整体的框架层次：4个层次, 其中 Connector 和 Container 是最重要的.</h4><ol>
<li>Server 和 Service</li>
<li>Connector<ul>
<li>HTTP</li>
<li>AJP (apache 私有协议，用于tomcat和apache静态服务器通信)</li>
</ul>
</li>
<li>Container<ul>
<li>Engine</li>
<li>Host</li>
<li>Context</li>
<li>Wrapper</li>
</ul>
</li>
<li>Component<ul>
<li>Manager （管理器）</li>
<li>logger （日志管理）</li>
<li>loader （载入器）</li>
<li>pipeline (管道)</li>
<li>valve （管道中的阀）</li>
</ul>
</li>
</ol>
<h5 id="下面我们来看一张有名的关于-tomcat-的结构图"><a href="#下面我们来看一张有名的关于-tomcat-的结构图" class="headerlink" title="下面我们来看一张有名的关于 tomcat 的结构图:"></a>下面我们来看一张有名的关于 tomcat 的结构图:</h5><p><img src="http://upload-images.jianshu.io/upload_images/4236553-29ffff1d2e70ceee.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tomcat 结构图"></p>
<p><strong>注意</strong>: <em>Server</em>是整个Tomcat组件的容器，包含一个或多个Service。 <em>Service</em>：Service是包含Connector和Container的集合，Service用适当的Connector接收用户的请求，再发给相应的Container来处理。</p>
<blockquote>
<p>从这张图中可以看到，Tomcat的核心组件就两个Connector和Container（后面还有详细说明），多个Connector+一个Container构成一个Service，Service就是对外提供服务的组件，有了Service组件Tomcat就可以对外提供服务了，但是光有服务还不行，还得有环境让你提供服务才行，所以最外层的Server就为Service提供了生存的土壤。那么这些个组件到底是干嘛用的呢？Connector是一个连接器，主要负责接收请求并把请求交给Container，Container就是一个容器，主要装的是具体处理请求的组件。Service主要是为了关联Container与Connector，一个单独的Container或者一个单独的Connector都不能完整处理一个请求，只有两个结合在一起才能完成一个请求的处理。Server这是负责管理Service集合，从图中我们看到一个Tomcat可以提供多种服务，那么这些Serice就是由Server来管理的，具体的工作包括：对外提供一个接口访问Service，对内维护Service集合，维护Service集合又包括管理Service的生命周期、寻找一个请求的Service、结束一个Service等</p>
</blockquote>
<hr>
<h4 id="Connector-组件"><a href="#Connector-组件" class="headerlink" title="Connector 组件:"></a>Connector 组件:</h4><blockquote>
<p>Tomcat都是在容器里面处理问题的， 而容器又到哪里去取得输入信息呢？ Connector就是专干这个的。 他会把从socket传递过来的数据， 封装成Request, 传递给容器来处理。 通常我们会用到两种Connector,一种叫http connectoer， 用来传递http需求的。 另一种叫AJP， 在我们整合apache与tomcat工作的时候，apache与tomcat之间就是通过这个协议来互动的。 （说到apache与tomcat的整合工作， 通常我们的目的是为了让apache 获取静态资源， 而让tomcat来解析动态的jsp或者servlet。）</p>
</blockquote>
<p>总的来说，Connector就是解析Http或Ajp请求的。</p>
<hr>
<h4 id="Container-组件"><a href="#Container-组件" class="headerlink" title="Container 组件:"></a>Container 组件:</h4><p>我们刚刚看到, 容器从大到小分别是 Engine, Host, Context, Wrapper, 从左到右每个容器都是一对多关系, 也就是说, Engine 容器可以有多个 Host 容器, Host 容器可以有多个 Context 容器. Context 容器可以有多个 Wrapper 容器.<br>我们来看看每个组件的解释:</p>
<ol>
<li>Container：可以理解为处理某类型请求的容器，处理的方式一般为把处理请求的处理器包装为Valve(阀门)对象，并按一定顺序放入类型为Pipeline(管道)的管道里。Container有多种子类型：Engine、Host、Context和Wrapper，这几种子类型Container依次包含，处理不同粒度的请求。另外Container里包含一些基础服务，如Loader、Manager和Realm。</li>
<li>Engine：Engine包含Host和Context，接到请求后仍给相应的Host在相应的Context里处理。</li>
<li>Host：就是我们所理解的虚拟主机。</li>
<li>Context：就是我们所部属的具体Web应用的上下文，每个请求都在是相应的上下文里处理的。</li>
<li>Wrapper：Wrapper是针对每个Servlet的Container，每个Servlet都有相应的Wrapper来管理。 可以看出Server、Service、Connector、Container、Engine、Host、Context和Wrapper这些核心组件的作用范围是逐层递减，并逐层包含。 下面就是些被Container所用的基础组件：<ul>
<li>Loader：是被Container用来载入各种所需的Class。</li>
<li>Manager：是被Container用来管理Session池。</li>
<li>Realm：是用来处理安全里授权与认证。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="Component-组件"><a href="#Component-组件" class="headerlink" title="Component 组件:"></a>Component 组件:</h4><p>需求被传递到了容器里面， 在合适的时候， 会传递给下一个容器处理。而容器里面又盛装着各种各样的组件， 我们可以理解为提供各种各样的增值服务。比如:</p>
<ol>
<li><p>manager: 当一个容器里面装了manager组件后，这个容器就支持session管理了， 事实上在tomcat里面的session管理, 就是靠的在context里面装的manager component. </p>
</li>
<li><p>logger: 当一个容器里面装了logger组件后， 这个容器里所发生的事情， 就被该组件记录下来, 我们通常会在logs/ 这个目录下看见catalina_log.time.txt 以及localhost.time.txt和localhost_examples_log.time.txt。 这就是因为我们分别为：engin, host以及context(examples)这三个容器安装了logger组件， 这也是默认安装， 又叫做标配 .</p>
</li>
<li><p>loader: loader这个组件通常只会给我们的context容器使用，loader是用来启动context以及管理这个context的classloader用的。</p>
</li>
<li><p>pipline: pipeline是这样一个东西，使用的责任链模式.  当一个容器决定了要把从上级传递过来的需求交给子容器的时候， 他就把这个需求放进容器的管道(pipeline)里面去。 而需求傻呼呼得在管道里面流动的时候， 就会被管道里面的各个阀门拦截下来。 比如管道里面放了两个阀门。 第一个阀门叫做“access_allow_vavle”， 也就是说需求流过来的时候，它会看这个需求是哪个IP过来的， 如果这个IP已经在黑名单里面了，sure, 杀！ 第二个阀门叫做“defaul_access_valve”它会做例行的检查， 如果通过的话，OK， 把需求传递给当前容器的子容器。 就是通过这种方式， 需求就在各个容器里面传递，流动， 最后抵达目的地的了。</p>
</li>
<li><p>valve: 就是上面所说的阀门。</p>
</li>
</ol>
<p>Tomcat里面大概就是这么些东西， 我们可以简单地这么理解tomcat的框架，它是一种自上而下， 容器里又包含子容器的这样一种结构。</p>
<h2 id="换个角度再来看看-Tomcat-的总体架构"><a href="#换个角度再来看看-Tomcat-的总体架构" class="headerlink" title="换个角度再来看看 Tomcat 的总体架构:"></a>换个角度再来看看 Tomcat 的总体架构:</h2><ul>
<li>面向组件架构</li>
<li>基于JMX</li>
<li>事件侦听</li>
</ul>
<ol>
<li><strong>面向组件架构</strong> tomcat代码看似很庞大，但从结构上看却很清晰和简单，它主要由一堆组件组成，如Server、Service、Connector等，并基于JMX管理这些组件，另外实现以上接口的组件也实现了代表生存期的接口Lifecycle，使其组件履行固定的生存期，在其整个生存期的过程中通过事件侦听LifecycleEvent实现扩展。Tomcat的核心类图如下所示:<br><img src="http://upload-images.jianshu.io/upload_images/4236553-648b485b5b7bdf06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="核心类图"></li>
</ol>
<p>上面我们已经对每个类的功能进行了一些描述.包括 Catalina 类和 Server 类的作用, Service 类是如何关联 Connector 和 Container 的. 还有各个容器是上面关系. 包括容器中数据是如何从从管道( pipeline) 中传递, 还有一些组件, 比如类载入器, 管理器, 安全主体( realm);</p>
<ol start="2">
<li>基于JMX Tomcat会为每个组件进行注册过程，通过Registry管理起来，而Registry是基于JMX来实现的，因此在看组件的init和start过程实际上就是初始化MBean和触发MBean的start方法，会大量看到形如： Registry.getRegistry(null, null).invoke(mbeans, “init”, false); Registry.getRegistry(null, null).invoke(mbeans, “start”, false); 这样的代码，这实际上就是通过JMX管理各种组件的行为和生命期。</li>
</ol>
<p>那么, 什么是 JMX 呢?</p>
<blockquote>
<p>JMX 即 Java Management Extensions(JMX 规范), 是用来对 tomcat 进行管理的. tomcat 中的实现是 commons modeler 库, Catalina 使用这个库来见哈编写托管 Bean 的工作. 托管 Bean 就是用来管理 Catalina 中其他对象的 Bean. </p>
</blockquote>
<ol start="3">
<li>事件侦听(观察者模式/事件驱动) 各个组件在其生命期中会有各种各样行为，而这些行为都有触发相应的事件，Tomcat就是通过侦听这些时间达到对这些行为进行扩展的目的。在看组件的init和start过程中会看到大量如： lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);这样的代码，这就是对某一类型事件的触发，如果你想在其中加入自己的行为，就只用注册相应类型的事件即可。</li>
</ol>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h3><p> 我们已经从宏观上详细分析了 Tomcat 的架构和组件等一些抽象的概念, 可能大家还比较懵逼, 因为我们完全是纸上谈兵, 没有真刀真枪实战源码, 所以, 接下来, 让我们带着我们准备好的源码一起撕开 Tomcat 的衣服, 看看她到底是什么样子的.   </p>
<p>还是像刚开始说的: </p>
<ol>
<li>宏观上理解 tomcat 组件及架构设计.</li>
<li>从一个简单的例子来理解tomcat的底层设计, 到底是怎么做的.</li>
<li>从 tomcat 的各个组件各个击破, 理解每个组件的设计.</li>
<li>从2条路线去 debug, 验证之前的理论是否正确, 并深刻理解代码. 第一条路线是启动过程. 第二条路线是一个 http 请求到 Servlet 的 service() 方法的过程.</li>
<li>总结 tomcat 的设计.</li>
</ol>
<p>现在我们已经完成了第一步, 宏观上理解了有哪些组件和他的架构设计. 后面的学习我们按照计划来执行, 不要操之过急, 看源码最重要的就是沉的下心. 我们会<br>先从组件和接口分析, 比如 Connector 和 Container 接口, 还有4大容器接口和管道阀门, 还有 生命周期接口.他们分别使用了什么设计模式,还有tomcat 钩子的使用,  包括tomcat著名的类加载机制, 为什么违背双亲委任模型等等. 这些内容都将是什么重点关注的.</p>
<p>好了, 今天就到这里, good luck !!!!!</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat（三）Tomcat-底层实现原理</title>
    <url>/2017/11/19/2017/2017-11-19-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat%EF%BC%88%E4%B8%89%EF%BC%89Tomcat-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       又是一个周末，这篇文章将从一个简单的例子来理解tomcat的底层设计;


<p><strong>本文将介绍 Java Web 服务器是如何运行的, Web 服务器也称为超文本传输协议( HyperText Transfer Protocol, HTTP)服务器, 因为它使用 Http 与其客户端(通常是 Web 浏览器)进行通信, 基于 Java 的 Web 服务器会使用两个重要的类: java.net.Socket 类和 java.net.ServerSocket 类, 并通过发送 Http 消息进行通信. 我们先花一些篇幅介绍 Http 协议（如果同学们熟悉HTTP协议可直接跳过）和这两个类, 然后写一个简单的 Web 服务器.</strong></p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>Http : Http 允许 Web 服务器和浏览器通过 Internet 发送并接受数据, 是一种基于”请求—响应”的协议, 客户端请求一个文件, 服务器端对该请求进行响应. Http 使用可靠的 tcp 连接, tcp 协议默认使用 tcp 80端口, http协议的第一个版本是 http/0.9, 后来被 http/1.0取代, 随后 http/1.0又被http/1.1取代, http/1.1 定义域 RFC(Request for Comment, 请求注解)2616中. </p>
<p>如果各位对 Http1.1 有更多兴趣, 请阅读 RFC 2616.</p>
<p>在 Http 中, 总是由客户端通过建立连接并发送 http 请求来初始化一个事务的. Web 服务器端并不负责联系客户端或建立一个到客户端的回调连接.客户端或服务器端可提前关闭连接, 例如, 当使用 Web 浏览器浏览网页时, 可以单击浏览器上的 stop 按钮来停止下载文件, 这样就有效的关闭了一个 Web 服务器的 http 连接.</p>
<h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><p>一个 HTTP 请求包含以下三部分:</p>
<ul>
<li>请求方法—-统一资源标识符(Uniform Resource Identifier, URI)——协议/版本</li>
<li>请求头</li>
<li>实体</li>
</ul>
<p>下面是一个 HTTP 请求的例子： </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">POST</span> /examples/default.jsp HTTP/<span class="number">1</span>.<span class="number">1</span> </span><br><span class="line"><span class="attribute">Accept</span>: text/plain; text/html </span><br><span class="line"><span class="attribute">Accept</span>-Language: en-gb </span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive </span><br><span class="line"><span class="attribute">Host</span>: localhost </span><br><span class="line"><span class="attribute">User</span>-Agent: Mozilla/<span class="number">4</span>.<span class="number">0</span> (compatible; MSIE <span class="number">4</span>.<span class="number">01</span>; Windows <span class="number">98</span>)</span><br><span class="line"><span class="attribute">Content</span>-Length: <span class="number">33</span> Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip, deflate </span><br><span class="line"></span><br><span class="line"><span class="attribute">lastName</span>=Franks&amp;firstName=Michael  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  方法—统一资源标识符(URI)—协议/版本出现在请求的第一行。<br>  <code>POST /examples/default.jsp HTTP/1.1    </code>  </p>
<p>  这里 POST 是请求方法，<code>/examples/default.jsp</code> 是 URI，而 HTTP/1.1 是协议/版本部分。     每个 HTTP 请求可以使用 HTTP 标准里边提到的多种方法之一。HTTP 1.1 支持 7 种类型的请 求：GET, POST, HEAD, OPTIONS, PUT, DELETE 和 TRACE。GET 和 POST 在互联网应用里边最普遍使用的。     </p>
<p>  URI 完全指明了一个互联网资源。URI 通常是相对服务器的根目录解释的。因此，始终一斜 线/开头。统一资源定位器(URL)其实是一种 URI(查看 <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>)<br>来的。该协议版本代表了正在使用的 HTTP 协议的版本。 </p>
<p> 请求的头部包含了关于客户端环境和请求的主体内容的有用信息。例如它可能包括浏览器设 置的语言，主体内容的长度等等。每个头部通过一个回车换行符(CRLF)来分隔的。     </p>
<p> 对于 HTTP 请求格式来说，头部和主体内容之间有一个回车换行符(CRLF)是相当重要的。CRLF 告诉HTTP服务器主体内容是在什么地方开始的。在一些互联网编程书籍中，CRLF还被认为是HTTP 请求的第四部分。     </p>
<p> 在前面一个 HTTP 请求中，主体内容只不过是下面一行： </p>
<p><code>lastName=Franks&amp;firstName=Michael    </code></p>
<p>实体内容在一个典型的 HTTP 请求中可以很容易的变得更长。 </p>
<h3 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h3><p>类似于 HTTP 请求，一个 HTTP 响应也包括三个组成部分：  </p>
<ul>
<li>方法—统一资源标识符(URI)—协议/版本 </li>
<li>响应的头部  </li>
<li>主体内容      </li>
</ul>
<p> 下面是一个 HTTP 响应的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Server: Microsoft-IIS/4.0 </span><br><span class="line">Date: Mon, 5 Jan 2004 13:13:33 GMT </span><br><span class="line">Content-Type: text/html </span><br><span class="line">Last-Modified: Mon, 5 Jan 2004 13:13:12 GMT </span><br><span class="line">Content-Length: 112 </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP Response Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        Welcome to Brainy Software </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>响应头部的第一行类似于请求头部的第一行。第一行告诉你该协议使用 HTTP 1.1，请求成 功(200=成功)，表示一切都运行良好。 </p>
<p>响应头部和请求头部类似，也包括很多有用的信息。响应的主体内容是响应本身的 HTML 内 容。头部和主体内容通过 CRLF 分隔开来。 </p>
<h3 id="Socket-类"><a href="#Socket-类" class="headerlink" title="Socket 类"></a>Socket 类</h3><p> 套接字是网络连接的一个端点。套接字使得一个应用可以从网络中读取和写入数据。放在两 个不同计算机上的两个应用可以通过连接发送和接受字节流。为了从你的应用发送一条信息到另 一个应用，你需要知道另一个应用的 IP 地址和套接字端口。在 Java 里边，套接字指的是<code>java.net.Socket</code>类。 </p>
<p>要创建一个套接字，你可以使用 Socket 类众多构造方法中的一个。其中一个接收主机名称 和端口号:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span> <span class="params">(java.lang.String host, <span class="keyword">int</span> port)</span></span></span><br></pre></td></tr></table></figure>

<p>在这里主机是指远程机器名称或者 IP 地址，端口是指远程应用的端口号。例如，要连接 yahoo.com 的 80 端口，你需要构造以下的 Socket 对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Socket (<span class="string">&quot;yahoo.com&quot;</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<p>一旦你成功创建了一个 Socket 类的实例，你可以使用它来发送和接受字节流。要发送字节 流，你首先必须调用Socket类的getOutputStream方法来获取一个java.io.OutputStream对象。 要 发 送 文 本 到 一 个 远 程 应 用 ， 你 经 常 要 从 返 回 的 OutputStream 对 象 中 构 造 一 个 java.io.PrintWriter 对象。要从连接的另一端接受字节流，你可以调用 Socket 类的 getInputStream 方法用来返回一个 java.io.InputStream 对象。 </p>
<h3 id="ServerSocket-类"><a href="#ServerSocket-类" class="headerlink" title="ServerSocket 类"></a>ServerSocket 类</h3><p> Socket 类代表一个客户端套接字，即任何时候你想连接到一个远程服务器应用的时候你构 造的套接字，现在，假如你想实施一个服务器应用，例如一个 HTTP 服务器或者 FTP 服务器，你 需要一种不同的做法。这是因为你的服务器必须随时待命，因为它不知道一个客户端应用什么时 候会尝试去连接它。为了让你的应用能随时待命，你需要使用 java.net.ServerSocket 类。这是 服务器套接字的实现。</p>
<p>  ServerSocket 和 Socket 不同，服务器套接字的角色是等待来自客户端的连接请求。一旦服 务器套接字获得一个连接请求，它创建一个 Socket 实例来与客户端进行通信。 </p>
<p>   要创建一个服务器套接字，你需要使用 ServerSocket 类提供的四个构造方法中的一个。你 需要指定 IP 地址和服务器套接字将要进行监听的端口号。通常，IP 地址将会是 127.0.0.1，也 就是说，服务器套接字将会监听本地机器。服务器套接字正在监听的 IP 地址被称为是绑定地址。 服务器套接字的另一个重要的属性是 backlog，这是服务器套接字开始拒绝传入的请求之前，传 入的连接请求的最大队列长度。 </p>
<p> 其中一个 ServerSocket 类的构造方法如下所示: </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> backLog, InetAddress bindingAddress)</span></span>; </span><br></pre></td></tr></table></figure>


<h3 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h3><p>如果同学们下载过我们在第一篇文章提供的源码（How Tomcat Works）的话， 我们可以看一看我们的目录：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-eb2b886a4c98ce94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p> 我们的 web 服务器应用程序放在 cxs01.pyrmont(编译的时候因为错误改名字了，也就懒得改回来了) 包里边，由三个类组成： </p>
<ul>
<li>HttpServer  </li>
<li>Request  </li>
<li>Response</li>
</ul>
<p> 这个应用程序的入口点(静态 main 方法)可以在 HttpServer 类里边找到。main 方法创建了 一个 HttpServer 的实例并调用了它的 await 方法。await 方法，顾名思义就是在一个指定的端 口上等待 HTTP 请求,处理它们并发送响应返回客户端。它一直等待直至接收到 shutdown 命令。<br><img src="http://upload-images.jianshu.io/upload_images/4236553-ad482afb9756566e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p> 应用程序不能做什么，除了发送静态资源，例如放在一个特定目录的 HTML 文件和图像文件。 它也在控制台上显示传入的 HTTP 请求的字节流。不过，它不给浏览器发送任何的头部例如日期 或者 cookies。 </p>
<h5 id="下面我们来看看我们今天的重点，这三个类，也就是tomcat的雏形代码"><a href="#下面我们来看看我们今天的重点，这三个类，也就是tomcat的雏形代码" class="headerlink" title="下面我们来看看我们今天的重点，这三个类，也就是tomcat的雏形代码"></a>下面我们来看看我们今天的重点，这三个类，也就是tomcat的雏形代码</h5><h6 id="HttpServer-类"><a href="#HttpServer-类" class="headerlink" title="HttpServer 类"></a>HttpServer 类</h6><p>  HttpServer 类代表一个 web 服务器，也就是程序的入口，看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEB_ROOT =</span><br><span class="line">    System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + File.separator  + <span class="string">&quot;webroot&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭命令</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHUTDOWN_COMMAND = <span class="string">&quot;/SHUTDOWN&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否关闭</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> shutdown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HttpServer server = <span class="keyword">new</span> HttpServer();</span><br><span class="line">    server.await();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>main 方法中创建了一个HttpServer对象，并调用了该对象的await方法。看名字，该方法应该是等待http请求之类的东东。我们来看看方法内部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个socket服务器</span></span><br><span class="line">      serverSocket =  <span class="keyword">new</span> ServerSocket(port, <span class="number">1</span>, InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待http请求</span></span><br><span class="line">    <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">      Socket socket = <span class="keyword">null</span>;</span><br><span class="line">      InputStream input = <span class="keyword">null</span>;</span><br><span class="line">      OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待http请求</span></span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">        input = socket.getInputStream();</span><br><span class="line">        output = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Request对象用于解析http请求内容</span></span><br><span class="line">        Request request = <span class="keyword">new</span> Request(input);</span><br><span class="line">        request.parse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Response 对象，用于发送静态文本</span></span><br><span class="line">        Response response = <span class="keyword">new</span> Response(output);</span><br><span class="line">        response.setRequest(request);</span><br><span class="line">        response.sendStaticResource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查URI中是否有关闭命令</span></span><br><span class="line">        shutdown = request.getUri().equals(SHUTDOWN_COMMAND);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，该方法创建了一个Socket服务器，并循环阻塞监听http请求，当有http请求到来时， 该方法便创建一个Request对象，构造参数是socket获取的输入流对象， 用于读取客户端请求的数据并解析。 然后再创建一个Response对象，构造参数是socket的输出流对象， 并含有一个Request对象的成员变量。Response对象用于将静态页面发送给浏览器或者是其他的客户端。最后， 该方法校验请求中是否含有关闭命令的字符串，如果有，就停止服务器的运行。</p>
<p>这就是一个简单的服务器， 当我第一次看到的时候，心想： 真TMD简单啊。原来没那么复杂嘛。我想同学们心里想的跟我也一样吧。so， 不论多么庞大的代码，底层原理都是很简单的，只要我们学好了基础，学习起来就会轻松很多。</p>
<p>废话不多说，我们继续看看Request 是如何解析Http请求的吧。</p>
<h5 id="Request-类"><a href="#Request-类" class="headerlink" title="Request 类"></a>Request 类</h5><p>类结构图如下：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-1690572b88d907ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p> Request 类代表一个 HTTP 请求。从负责与客户端通信的 Socket 中传递过来 InputStream 对象来构造这个类的一个实例。你调用 InputStream 对象其中一个 read 方法来获 取 HTTP 请求的原始数据。其中最主要的方法就是parse 和 parseUri ，他们用于逐个解析每个从客户端传递过来的字节，我们先看parse方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Read a set of characters from the socket</span></span><br><span class="line">  StringBuffer request = <span class="keyword">new</span> StringBuffer(<span class="number">2048</span>);</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取流中内容</span></span><br><span class="line">    i = input.read(buffer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    i = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">   <span class="comment">// 将每个字节转换为字符</span></span><br><span class="line">    request.append((<span class="keyword">char</span>) buffer[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印字符串</span></span><br><span class="line">  System.out.print(request.toString());</span><br><span class="line">  <span class="comment">// 根据转换出来的字符解析URI</span></span><br><span class="line">  uri = parseUri(request.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也看到该方法是十分的简单， 创建一个StringBuffer 对象，然后从流中读取字节，然后循环将字节转成字符写入到Stringbuffer对象中。最后传入到parseUri方法中进行解析。 </p>
<p>我们再看看parseUri方法， 这个方法中，我们前面学习的关于HTTP的知识会起作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">parseUri</span><span class="params">(String requestString)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index1, index2;</span><br><span class="line">  <span class="comment">// 找到第一个空格</span></span><br><span class="line">  index1 = requestString.indexOf(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (index1 != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到第二个空格</span></span><br><span class="line">    index2 = requestString.indexOf(<span class="string">&#x27; &#x27;</span>, index1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (index2 &gt; index1)</span><br><span class="line">      <span class="comment">// 截取第一个空格到第二个空格之间的内容</span></span><br><span class="line">      <span class="keyword">return</span> requestString.substring(index1 + <span class="number">1</span>, index2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法从请求行里边获得 URI。parseUri 方法搜索请求里边的第一个和第二个空格并从中获取 URI。<br>为什么是第一个空格和第二个空格之间的内容呢？我们看看前面的Http请求的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /examples/default.jsp HTTP/1.1 </span><br><span class="line">Accept: text/plain; text/html </span><br><span class="line">Accept-Language: en-gb </span><br><span class="line">Connection: Keep-Alive </span><br><span class="line">Host: localhost </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows 98)</span><br><span class="line">Content-Length: 33 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip, deflate </span><br><span class="line"></span><br><span class="line">lastName=Franks&amp;firstName=Michael  </span><br></pre></td></tr></table></figure>

<p>我们看第一行：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-6a391bc0c6581bb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>POST 和 HTTP/1.1之间的就是我们需要的URI。so， 我们只需要将中间那段字符串截取就OK了。</p>
<p>我们总结一下Request类，这个类其实就是解析HTTP 消息头内容的，先将流中数据转成字节，然后将转成字符，最后将字符解析，得到自己感兴趣的内容。奏是这么简单。好了，我们再看看Response类。看看他是怎么实现的。</p>
<h4 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h4><p>我们先看看这个类的结构图：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-f5da79e8a3018c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Response 代表了Http请求中的一个响应。我们关注其中的 sendStaticResource 方法，看名字，该方法应该是发送静态资源给客户端。我们看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendStaticResource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">  FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(HttpServer.WEB_ROOT, request.getUri());</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">      <span class="comment">// 文件存在则从输出流中输出</span></span><br><span class="line">      fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      <span class="keyword">int</span> ch = fis.read(bytes, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">      <span class="keyword">while</span> (ch!=-<span class="number">1</span>) &#123;</span><br><span class="line">        output.write(bytes, <span class="number">0</span>, ch);</span><br><span class="line">        ch = fis.read(bytes, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有文件返回404</span></span><br><span class="line">      String errorMessage = <span class="string">&quot;HTTP/1.1 404 File Not Found\r\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;Content-Type: text/html\r\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;Content-Length: 23\r\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&lt;h1&gt;File Not Found&lt;/h1&gt;&quot;</span>;</span><br><span class="line">      output.write(errorMessage.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// thrown if cannot instantiate a File object</span></span><br><span class="line">    System.out.println(e.toString() );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fis!=<span class="keyword">null</span>)</span><br><span class="line">      fis.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，该方法也非常的简单， sendStaticResource 方法是用来发送一个静态资源，例如一个 HTML 文件。它首先通过传递 上一级目录的路径和子路径给 File 累的构造方法来实例化 java.io.File 类。</p>
<p>然后它检查该文件是否存在。假如存在的话，通过传递 File 对象让 sendStaticResource 构造一个 java.io.FileInputStream 对象。然后，它调用 FileInputStream 的 read 方法并把字 节数组写入 OutputStream 对象。请注意，这种情况下，静态资源是作为原始数据发送给浏览器 的。</p>
<p>假如文件并不存在，sendStaticResource 方法发送一个错误信息到浏览器</p>
<p>运行程序，启动HttpServer mian方法，使用Edge浏览器在地址栏敲入：<a href="http://localhost:8080/index.html">http://localhost:8080/index.html</a><br>返回：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-0d74bdf2b346030d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>表示文件存在， 再看看我们的后台控制台：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-282d24fa71c9d9e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如期打印了http请求头中的内容。并且下面还请求了一张图片。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们已经知道了一个简单的Web服务器是如何工作的。破除了我们之前的疑惑，实际上tomcat底层就是这么实现的，可能关于阻塞IO和非阻塞NIO会有区别，但总体上还是这个思路，然后其余的组件都是针对优化性能，提高扩展性来设计新的架构。所以，我们明白了底层设计，再去学习他的设计，就不会那么迷茫。从而感到泄气。毕竟每个夜晚，我们孤独的学习，不想徒劳无功。</p>
<p>好了，本文结束！！！ good luck ！！！</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat（五）源码剖析Tomcat-启动过程----类加载过程</title>
    <url>/2017/11/21/2017/2017-11-21-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat%EF%BC%88%E4%BA%94%EF%BC%89%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Tomcat-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B----%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ![](http://upload-images.jianshu.io/upload_images/4236553-3ef513e8de839335.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<p>这是我们深入理解tomcat的第五篇文章，按照我们的思路，这次我们本应该区分析tomcat的连接器组件，但楼主思前想后，觉得连接器组件不能只是纸上谈兵，需要深入源码，但楼主本能的认为我们应该先分析tomcat的启动过程，以能够和我们上一篇文章<code>深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型</code>相衔接。因为启动类加载器的核心代码就在启动过程中，所以，我决定先分析tomcat的启动过程，结合源码了解tomcat的类加载器如何实现，以彻底了解tomcat的类加载器。</p>
<p>因为Tomcat 的启动过程非常复杂，因此楼主将启动过程拆开分析，不能像之前说的按照启动过程分析了，否则，文章篇幅过长，条理也会变得不清晰，Tomcat的启动过程包括了初始化容器的生命周期，还涉及到JMX的管理，还有我们现在分析的类加载器，因此，我们必须换个维度分析。</p>
<p>再一个，因为连接器和容器紧紧关联，连接器的作用就是分析http请求，所以，楼主觉得我们之前的计划可能需要变更一下，我们将在分析完生命周期和类加载器之后将结合源码分析连接器和容器，以了解tomcat的核心组件在接受HTTP请求后如何运行。</p>
<p>所以，今天，我们的任务就是debug tomcat 源码，分析tomcat启动过程的每一步操作。在看这篇文章之前希望同学们看看我们的第四篇分析tomcat的文章以了解tomcat的类加载器。</p>
<p>下面是这篇文章的目录结构：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 启动tomcat，进入main方法</span><br><span class="line"><span class="bullet">2.</span> 进入 init 方法</span><br><span class="line"><span class="bullet">3.</span> 进入 setCatalinaHome 方法</span><br><span class="line"><span class="bullet">4.</span> 进入 setCatalinaBase 方法</span><br><span class="line"><span class="bullet">5.</span> 接下来则是类加载器大显身手的时候了. 进入 intiClassLoaders 方法</span><br><span class="line"><span class="bullet">6.</span> 进入 createClassLoader 方法</span><br><span class="line"><span class="bullet">7.</span> 我们回到 initClassLoaders 方法中来</span><br><span class="line"><span class="bullet">8.</span> 再回到 init 方法中, 类加载器初始化结束, 接下来干嘛?</span><br><span class="line"><span class="bullet">9.</span> 设置完线程上下文类加载器之后做什么呢? 进入 securityClassLoad 方法</span><br><span class="line"><span class="bullet">10.</span> 进入 loadCorePackage 方法</span><br><span class="line"><span class="bullet">11.</span> 回到 init 方法</span><br><span class="line"><span class="bullet">12.</span> 寻找 WebAppClassLoader， 进入 startInternal 方法</span><br><span class="line"><span class="bullet">13.</span> 进入 createClassLoader 方法</span><br><span class="line"><span class="bullet">14.</span> tomcat 类加载结构体系创建完毕</span><br></pre></td></tr></table></figure>
<h3 id="1-启动tomcat，进入main方法"><a href="#1-启动tomcat，进入main方法" class="headerlink" title="1. 启动tomcat，进入main方法"></a>1. 启动tomcat，进入main方法</h3><p>我们打开我们之前clone下的Tomcat-Source-Code 源码，找到Bootstrap 类，找到main方法，在451行打上断点，启动main方法，开始我们的调试：<img src="http://upload-images.jianshu.io/upload_images/4236553-60673beedbf0dde4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到楼主已经写了很多的注释，因为楼主已经debug过了.<br> 我们看代码，首先判断”守护“对象是否为null，肯定为null了，然后进入if 块， 创建一个默认构造器的Bootstrap对象，有一行注释<code>// Don&#39;t set daemon until init() has completed</code>, 说不要在init方法完成之前设置daemon 变量，因为后面的很多步骤都依赖该变量，所以必须初始化结束后才能设置值，再继续看，进入init方法：</p>
<h3 id="2-进入-init-方法"><a href="#2-进入-init-方法" class="headerlink" title="2. 进入 init 方法"></a>2. 进入 init 方法</h3><p><img src="http://upload-images.jianshu.io/upload_images/4236553-c23ee6115c29e76e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法注释：<code> Initialize daemon.</code>表明要初始化该守护程序，也就是这个变量Bootstrap：<img src="http://upload-images.jianshu.io/upload_images/4236553-1188f45052549f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看看该方法，首先<code>setCatalinaHome()</code>方法，也就是我们启动虚拟机的时候设置的 VM 参数:<br><img src="http://upload-images.jianshu.io/upload_images/4236553-3286c5cedfea4fb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p> 我们进入该方法看看</p>
<h3 id="3-进入-setCatalinaHome-方法"><a href="#3-进入-setCatalinaHome-方法" class="headerlink" title="3. 进入 setCatalinaHome 方法"></a>3. 进入 setCatalinaHome 方法</h3><p><img src="http://upload-images.jianshu.io/upload_images/4236553-9f66c38cb434d70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p> 很明显,我们设置过 Catalina.home , 所以获取classpath下的catalina.home 的值不为null，所以直接return， 如果不为null，则从项目根目录下获取boostrap的jar包。如果存在,则设置上一级目录为 catalina.home, 如果不存在,则设置项目根目录为 catalina.home.这就是 setCatalinaHome 方法的逻辑.</p>
<h3 id="4-进入-setCatalinaBase-方法"><a href="#4-进入-setCatalinaBase-方法" class="headerlink" title="4. 进入 setCatalinaBase 方法"></a>4. 进入 setCatalinaBase 方法</h3><p>下一步是执行 setCatalinaBase 方法, 也是一样能获取<code>catalina.base</code>, 直接 return,如果不存在, 则设置<code>catalina.home</code>为<code>catalina.base</code>, 如果<code> catalina.home</code>也是空,那么则设置项目根目录为<code> catatlina.base</code>.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e93ec0d70e3cb1a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<hr>
<h3 id="5-接下来则是类加载器大显身手的时候了-进入-intiClassLoaders-方法"><a href="#5-接下来则是类加载器大显身手的时候了-进入-intiClassLoaders-方法" class="headerlink" title="5. 接下来则是类加载器大显身手的时候了. 进入 intiClassLoaders 方法"></a>5. 接下来则是类加载器大显身手的时候了. 进入 intiClassLoaders 方法</h3><p><img src="http://upload-images.jianshu.io/upload_images/4236553-d24e1e66bf0ec5ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>intiClassLoaders(), 初始化多个类加载器. 我们进入该方法查看具体逻辑:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a591da8d1f6fd60f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先,创建一个 common 类加载器, 父类加载器为 null, 注意: 如果是 java 推荐的类加载器机制, 父类加载器应该是系统类加载器或者是扩展类加载器, 所以这明显违背了类加载器的双亲委派模型. 好, 我们继续看 tomcat, 我们进入 creatClassLoader 方法, 看看是如何实现的(该方法很长, 我们关注重要的逻辑):</p>
<h3 id="6-进入-createClassLoader-方法"><a href="#6-进入-createClassLoader-方法" class="headerlink" title="6.  进入 createClassLoader 方法"></a>6.  进入 createClassLoader 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 从/org/apache/catalina/startup/catalina.properties 中获取该 key 的配置</span></span><br><span class="line">        <span class="comment">// common.loader 对应的 Value=$&#123;catalina.base&#125;/lib,$&#123;catalina.base&#125;/lib/*.jar,$&#123;catalina.home&#125;/lib,$&#123;catalina.home&#125;/lib/*.jar</span></span><br><span class="line">        String value = CatalinaProperties.getProperty(name + <span class="string">&quot;.loader&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果不存在(默认存在), 返回 null</span></span><br><span class="line">        <span class="keyword">if</span> ((value == <span class="keyword">null</span>) || (value.equals(<span class="string">&quot;&quot;</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用环境变量对应的目录替换字符串</span></span><br><span class="line">        value = replace(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Repository是ClassLoaderFactory  中的一个静态内部类, 有2个属性, location, type, 表示某个位置的某种类型的文件</span></span><br><span class="line">        List&lt;Repository&gt; repositories = <span class="keyword">new</span> ArrayList&lt;Repository&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        省略部分代码, 此部分代码是处理value 变量并获取文件位置和类型</span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据给定的路径数组前去加载给定的 class 文件,</span></span><br><span class="line">        <span class="comment">// StandardClassLoader 继承了 java.net.URLClassLoader ,使用URLClassLoader的构造器构造类加载器.</span></span><br><span class="line">        <span class="comment">// 根据父类加载器是否为 null, URLClassLoader将启用不同的构造器.</span></span><br><span class="line">        <span class="comment">// 总之, common 类加载器没有指定父类加载器,违背双亲委派模型</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderFactory.createClassLoader<span class="comment">// 创建类加载器, 如果parent 是0,则</span></span><br><span class="line">            (repositories, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieving MBean server // 注册到 JMX 中管理 bean, 这个我们后面说</span></span><br><span class="line">        MBeanServer mBeanServer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (MBeanServerFactory.findMBeanServer(<span class="keyword">null</span>).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mBeanServer = MBeanServerFactory.findMBeanServer(<span class="keyword">null</span>).get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mBeanServer = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register the server classloader</span></span><br><span class="line">        ObjectName objectName =</span><br><span class="line">            <span class="keyword">new</span> ObjectName(<span class="string">&quot;Catalina:type=ServerClassLoader,name=&quot;</span> + name);</span><br><span class="line">        <span class="comment">// 生命周期管理.</span></span><br><span class="line">        mBeanServer.registerMBean(classLoader, objectName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classLoader;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">````</span><br><span class="line">虽然上面的代码写了注释,但是我们还是梳理一下逻辑:</span><br><span class="line"><span class="number">1.</span> 从`/org/apache/catalina/startup/catalina.properties `配置文件中获取 lib 仓库和 jar 包位置.  如果key （分别为common.loader、server.loader、shared.loader）所对应的value 不存在则返回父类加载器. 默认情况有.则继续下面的逻辑.</span><br><span class="line"><span class="number">2.</span> 处理从配置文件中获取的字符串, 得到jar 包的位置.</span><br><span class="line"><span class="number">3.</span> 使用`ClassLoaderFactory.createClassLoader(repositories, parent)`方法,  该方法使用一个继承自`java.net.URLClassLoader`废弃的`StandardClassLoader`类加载 jar 处理后得到的文件, 实际上调用的是URLClassLoader的构造方法, 下面代码是 crateClassLoader 方法中最后的逻辑, array 中是 jar 包的地址,根据父类加载器是否为 <span class="keyword">null</span> 调用`StandardClassLoader`不同的构造方法.</span><br><span class="line"><span class="number">4.</span> 将ClassLoader 注册到JMX服务中（这里涉及到生命周期的内容，我们按下不表，后面再说）。</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-4adc8d0b36c05114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">下面的是`StandardClassLoader`的构造方法,可以看到,实际上只是使用URLClassLoader 的构造方法:</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-973fd96d79b6594d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">而 URLClassLoader  将会调用父类 SecureClassLoader 的构造方法, 而 SecureClassLoader 将会调用 ClassLoader 的构造方法, 从而完成一个类加载器的初始化. 可谓不易.</span><br><span class="line"></span><br><span class="line">##### <span class="number">7.</span> 我们回到 initClassLoaders 方法中来</span><br><span class="line"></span><br><span class="line">执行完`commonLoader = createClassLoader(<span class="string">&quot;common&quot;</span>, <span class="keyword">null</span>);`, 接下里就会判断返回的类加载器是否为 <span class="keyword">null</span>, 什么时候会为 <span class="keyword">null</span> 呢? 找不到配置文件中的 key 的时候或者 key 对应的 value 为空的时候回返回 <span class="keyword">null</span>, 如果返回 <span class="keyword">null</span>, 那么就设置默认的类加载器为 common 类加载器. </span><br><span class="line"></span><br><span class="line">继续初始化 catalinaloader 和 sharedLoader 两个类加载器, 同样调用 createClassLoader 方法, 不同的是, 他们的父类加载器不是 <span class="keyword">null</span>, 而是上面的 common 类加载器. 我们看看他们进入这个方法的时候回怎么样?我们 debug 看一下:</span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-fd0d2db752af5723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-e81758f680ec5dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">可以看到两个获取到都是空, 所以他们直接返回父类加载器, 也就是说, 他们三个使用的是同一个类加载器.</span><br><span class="line"></span><br><span class="line">### <span class="number">8.</span> 再回到 init 方法中, 类加载器初始化结束, 接下来干嘛?</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-774ddc72bda64f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">将 catalinaLoader 类加载器设置为当前线程上下文类加载器. 并设置线程安全类加载器.同时检查是否安全, 如果不安全,则直接结束.</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-05cbefb1693430cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">#### <span class="number">9.</span> 设置完线程上下文类加载器之后做什么呢? 进入 securityClassLoad 方法</span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-a88757e3f188b647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-7b0ecfa890763864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">可以看到，该类时加载Tomcat容器中类资源，传递的ClassLoader时catalinaLoader，也就是说，Tomcat容器的类资源都是catalinaLoader加载完成的。</span><br><span class="line"></span><br><span class="line">securityClassLoad方法主要加载Tomcat容器所需的<span class="class"><span class="keyword">class</span>，包括：</span></span><br><span class="line"><span class="class">  * <span class="title">Tomcat</span>核心<span class="title">class</span>，即<span class="title">org</span>.<span class="title">apache</span>.<span class="title">catalina</span>.<span class="title">core</span>路径下的<span class="title">class</span>；</span></span><br><span class="line"><span class="class">  * <span class="title">org</span>.<span class="title">apache</span>.<span class="title">catalina</span>.<span class="title">loader</span>.<span class="title">WebappClassLoader</span>$<span class="title">PrivilegedFindResourceByName</span>；</span></span><br><span class="line"><span class="class">  * <span class="title">Tomcat</span>有关<span class="title">session</span>的<span class="title">class</span>，即<span class="title">org</span>.<span class="title">apache</span>.<span class="title">catalina</span>.<span class="title">session</span>路径下的<span class="title">class</span>；</span></span><br><span class="line"><span class="class">  * <span class="title">Tomcat</span>工具类的<span class="title">class</span>，即<span class="title">org</span>.<span class="title">apache</span>.<span class="title">catalina</span>.<span class="title">util</span>路径下的<span class="title">class</span>；</span></span><br><span class="line"><span class="class">  * <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">http</span>.<span class="title">Cookie</span>；</span></span><br><span class="line"><span class="class">  * <span class="title">Tomcat</span>处理请求的<span class="title">class</span>，即<span class="title">org</span>.<span class="title">apache</span>.<span class="title">catalina</span>.<span class="title">connector</span>路径下的<span class="title">class</span>；</span></span><br><span class="line"><span class="class">  * <span class="title">Tomcat</span>其它工具类的<span class="title">class</span>，也是<span class="title">org</span>.<span class="title">apache</span>.<span class="title">catalina</span>.<span class="title">util</span>路径下的<span class="title">class</span>；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#### 10. 进入 <span class="title">loadCorePackage</span> 方法</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">我们以加载<span class="title">Tomcat</span>核心<span class="title">class</span>的<span class="title">loadCorePackage</span>方法为例，我们看源码实现：</span></span><br><span class="line"><span class="class">```<span class="title">java</span></span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">static</span> <span class="title">final</span> <span class="title">void</span> <span class="title">loadCorePackage</span>(<span class="title">ClassLoader</span> <span class="title">loader</span>)</span></span><br><span class="line"><span class="class">        <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String basePackage = <span class="string">&quot;org.apache.catalina.core.&quot;</span>;</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;AccessLogAdapter&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;ApplicationContextFacade$1&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;ApplicationDispatcher$PrivilegedForward&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;ApplicationDispatcher$PrivilegedInclude&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">            <span class="string">&quot;AsyncContextImpl&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">            <span class="string">&quot;AsyncContextImpl$DebugException&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">            <span class="string">&quot;AsyncContextImpl$1&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">            <span class="string">&quot;AsyncContextImpl$PrivilegedGetTccl&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">            <span class="string">&quot;AsyncContextImpl$PrivilegedSetTccl&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">            <span class="string">&quot;AsyncListenerWrapper&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;ContainerBase$PrivilegedAddChild&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;DefaultInstanceManager$1&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;DefaultInstanceManager$2&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;DefaultInstanceManager$3&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;DefaultInstanceManager$AnnotationCacheEntry&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;DefaultInstanceManager$AnnotationCacheEntryType&quot;</span>);</span><br><span class="line">        loader.loadClass</span><br><span class="line">            (basePackage +</span><br><span class="line">             <span class="string">&quot;ApplicationHttpRequest$AttributeNamesEnumerator&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，catalinaClassLoader 加载了该包下的类。根据我们之前的理解：catalinaClassLoader 加载的类是Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见。</p>
<h4 id="11-回到-init-方法"><a href="#11-回到-init-方法" class="headerlink" title="11. 回到 init 方法"></a>11. 回到 init 方法</h4><p><img src="http://upload-images.jianshu.io/upload_images/4236553-a0dc0cc7c09d64a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先打印一波日志, 然后使用类 catalinaLoader 类加载器加载 <code>org.apache.catalina.startup.Catalina</code> 类, 接着创建该类的一个对象, 名为 startupInstance, 意为”启动对象实例”, 然后使用反射调用该实例的setParentClassLoader 方法, 参数为 sharedLoader, 表示该实例的父类加载器为 sharedLoader.</p>
<p>最后, 设置 catalinaDaemon 为该实例。</p>
<h4 id="12-寻找-WebAppClassLoader，-进入-startInternal-方法"><a href="#12-寻找-WebAppClassLoader，-进入-startInternal-方法" class="headerlink" title="12. 寻找 WebAppClassLoader， 进入 startInternal 方法"></a>12. 寻找 WebAppClassLoader， 进入 startInternal 方法</h4><p>我们通过源码知道了初始化了commonClassLoader, catalinaClassLoader, sharedLoader，但是，我们想起我们上一篇文章的图，好像少了点什么？<br><img src="http://upload-images.jianshu.io/upload_images/4236553-89bacc3467d513f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/462"></p>
<p>WebAppClassLoader呢？</p>
<p>我们知道， WebAppClassLoaser 是各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见，那么他是如何初始化的呢？WebAppClassLoaser 的初始化时间和这3个类加载器初始化的时间不同，由于WebAppClassLoaser 和Context 紧紧关联，因此咋初始化<br> org.apache.catalina.core.StandardContext 会一起初始化 WebAppClassLoader， 该类中startInternal方法含有初始化类加载器的逻辑，核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (getLoader() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          WebappLoader webappLoader = <span class="keyword">new</span> WebappLoader(getParentClassLoader());</span><br><span class="line">          webappLoader.setDelegate(getDelegate());</span><br><span class="line">          setLoader(webappLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((loader != <span class="keyword">null</span>) &amp;&amp; (loader <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">          ((Lifecycle) loader).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建 WebAppClassLoader ， 然后 setLoader（webappLoader），再调用start方法，该方法是个模板方法，内部有 startInternal 方法用于子类去实现， 我们看WebAppClassLoader的startInternal 方法核心实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        classLoader = createClassLoader();</span><br><span class="line">        classLoader.setResources(container.getResources());</span><br><span class="line">        classLoader.setDelegate(<span class="keyword">this</span>.delegate);</span><br><span class="line">        classLoader.setSearchExternalFirst(searchExternalFirst);</span><br><span class="line">        <span class="keyword">if</span> (container <span class="keyword">instanceof</span> StandardContext) &#123;</span><br><span class="line">            classLoader.setAntiJARLocking(</span><br><span class="line">                    ((StandardContext) container).getAntiJARLocking());</span><br><span class="line">            classLoader.setClearReferencesStatic(</span><br><span class="line">                    ((StandardContext) container).getClearReferencesStatic());</span><br><span class="line">            classLoader.setClearReferencesStopThreads(</span><br><span class="line">                    ((StandardContext) container).getClearReferencesStopThreads());</span><br><span class="line">            classLoader.setClearReferencesStopTimerThreads(</span><br><span class="line">                    ((StandardContext) container).getClearReferencesStopTimerThreads());</span><br><span class="line">            classLoader.setClearReferencesHttpClientKeepAliveThread(</span><br><span class="line">                    ((StandardContext) container).getClearReferencesHttpClientKeepAliveThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repositories.length; i++) &#123;</span><br><span class="line">            classLoader.addRepository(repositories[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-进入-createClassLoader-方法"><a href="#13-进入-createClassLoader-方法" class="headerlink" title="13.  进入 createClassLoader 方法"></a>13.  进入 createClassLoader 方法</h4><p>首先<code>classLoader = createClassLoader();</code>创建类加载器，并且设置其资源路径为当前Webapp下某个context的类资源。最后我们看看createClassLoader的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create associated classLoader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> WebappClassLoader <span class="title">createClassLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(loaderClass);</span><br><span class="line">    WebappClassLoader classLoader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parentClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentClassLoader = container.getParentClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] argTypes = &#123; ClassLoader.class &#125;;</span><br><span class="line">    Object[] args = &#123; parentClassLoader &#125;;</span><br><span class="line">    Constructor&lt;?&gt; constr = clazz.getConstructor(argTypes);</span><br><span class="line">    classLoader = (WebappClassLoader) constr.newInstance(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> classLoader;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的loaderClass 是 字符串 <code>org.apache.catalina.loader.WebappClassLoader</code>, 首先通过反射实例化classLoader。现在我们知道了， WebappClassLoader 是在 StandardContext 初始化的时候实例化的，也证明了WebappClassLoader 和 Context 息息相关。</p>
<h4 id="14-omcat-类加载结构体系创建完毕"><a href="#14-omcat-类加载结构体系创建完毕" class="headerlink" title="14. omcat 类加载结构体系创建完毕"></a>14. omcat 类加载结构体系创建完毕</h4><p>至此，我们的Tomcat 类加载结构体系创建完毕。真TMD复杂啊！！！ 不过，请记住， 阅读源码是提高我们水平最快速的手段。源码中大师们的设计模式和各种高级用法。会让我们功力大增。继续加油吧！！！</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat（四）Tomcat-类加载器之为何违背双亲委派模型</title>
    <url>/2017/11/20/2017/2017-11-20-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat%EF%BC%88%E5%9B%9B%EF%BC%89Tomcat-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E4%B8%BA%E4%BD%95%E8%BF%9D%E8%83%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       这是我们研究Tomcat的第四篇文章，前三篇文章我们搭建了源码框架，了解了tomcat的大致的设计架构， 还写了一个简单的服务器。按照我们最初订的计划，今天，我们要开始研究tomcat的几个主要组件（组件太多，无法一一解析，解析几个核心），包括核心的类加载器，连接器和容器，还有生命周期，还有pipeline 和 valve。一个一个来，今天来研究类加载器。

<p>我们分为4个部分来探讨:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 什么是类加载机制？</span><br><span class="line"><span class="bullet">2.</span> 什么是双亲委任模型？</span><br><span class="line"><span class="bullet">3.</span> 如何破坏双亲委任模型？</span><br><span class="line"><span class="bullet">4.</span> Tomcat 的类加载器是怎么设计的？</span><br></pre></td></tr></table></figure>
<p>我想，在研究tomcat 类加载之前，我们复习一下或者说巩固一下java 默认的类加载器。楼主以前对类加载也是懵懵懂懂，借此机会，也好好复习一下。</p>
<p>楼主翻开了神书《深入理解Java虚拟机》第二版，p227, 关于类加载器的部分。请看：</p>
<h2 id="1-什么是类加载机制？"><a href="#1-什么是类加载机制？" class="headerlink" title="1. 什么是类加载机制？"></a>1. 什么是类加载机制？</h2><blockquote>
<p>代码编译的结果从本地机器码转变成字节码，是存储格式的一小步，却是编程语言发展的一大步。</p>
</blockquote>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载进内存，并对数据进行校验，转换解析和初始化，最终形成可以呗虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
</blockquote>
<blockquote>
<p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这动作的代码模块成为“类加载器”。</p>
</blockquote>
<h6 id="类与类加载器的关系"><a href="#类与类加载器的关系" class="headerlink" title="类与类加载器的关系"></a>类与类加载器的关系</h6><blockquote>
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由<strong>加载他的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类命名空间。这句话可以表达的更通俗一些：比较两个类是否“相等”，<code>只有在这两个类是由同一个类加载器加载的前提下才有意义</code>，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这个两个类就必定不相等。</p>
</blockquote>
<h2 id="2-什么是双亲委任模型"><a href="#2-什么是双亲委任模型" class="headerlink" title="2. 什么是双亲委任模型"></a>2. 什么是双亲委任模型</h2><ol>
<li><p>从Java虚拟机的角度来说，只存在两种不同类加载器：一种是**启动类加载器(Bootstrap ClassLoader)**，这个类加载器使用C++语言实现（只限HotSpot），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>.</p>
</li>
<li><p>从Java开发人员的角度来看，类加载还可以划分的更细致一些，绝大部分Java程序员都会使用以下3种系统提供的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器复杂将存放在 JAVA_HOME/lib 目录中的，或者被-Xbootclasspath 参数所指定的路径种的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录下也不会重载）。</li>
<li>扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责夹杂JAVA_HOME/lib/ext 目录下的，或者被java.ext.dirs 系统变量所指定的路径种的所有类库。开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是ClassLoader 种的getSystemClassLoader方法的返回值，所以也成为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
</li>
</ol>
<p>这些类加载器之间的关系一般如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-c65e628b05bddb2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>图中各个类加载器之间的关系成为 <strong>类加载器的双亲委派模型（Parents Dlegation Mode）</strong>。双亲委派模型要求除了顶层的启动类加载器之外，<strong>其余的类加载器都应当由自己的父类加载器加载</strong>，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。</p>
<p>类加载器的双亲委派模型在JDK1.2 期间被引入并被广泛应用于之后的所有Java程序中，但他并不是个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h6 id="为什么要这么做呢？"><a href="#为什么要这么做呢？" class="headerlink" title="为什么要这么做呢？"></a>为什么要这么做呢？</h6><blockquote>
<p> 如果没有使用双亲委派模型，由各个类加载器自行加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，<strong>那系统将会出现多个不同的Object类</strong>， Java类型体系中最基础的行为就无法保证。应用程序也将会变得一片混乱。</p>
</blockquote>
<h6 id="双亲委任模型时如何实现的？"><a href="#双亲委任模型时如何实现的？" class="headerlink" title="双亲委任模型时如何实现的？"></a>双亲委任模型时如何实现的？</h6><blockquote>
<p>非常简单：所有的代码都在java.lang.ClassLoader中的loadClass方法之中，代码如下：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-9d33b8e0eb9984d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</blockquote>
<p>逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass方法， 如父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass方法进行加载。</p>
<h2 id="3-如何破坏双亲委任模型？"><a href="#3-如何破坏双亲委任模型？" class="headerlink" title="3. 如何破坏双亲委任模型？"></a>3. 如何破坏双亲委任模型？</h2><p>刚刚我们说过，双亲委任模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。在Java的世界中大部分的类加载器都遵循者模型，但也有例外，到目前为止，双亲委派模型有过3次大规模的“被破坏”的情况。<br><strong>第一次</strong>：在双亲委派模型出现之前—–即JDK1.2发布之前。<br><strong>第二次</strong>：是这个模型自身的缺陷导致的。我们说，双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，<strong>如果基础类调用会用户的代码</strong>怎么办呢？</p>
<p>这不是没有可能的。一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载。怎么办呢？</p>
<p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。</p>
<p>嘿嘿，有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，<strong>JDBC</strong>，JCE，JAXB，JBI等。</p>
<p><strong>第三次</strong>：为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。</p>
<p>书中还说到：</p>
<blockquote>
<p>Java 程序中基本有一个共识：OSGI对类加载器的使用时值得学习的，弄懂了OSGI的实现，就可以算是掌握了类加载器的精髓。</p>
</blockquote>
<p>牛逼啊！！！</p>
<p>现在，我们已经基本明白了Java默认的类加载的作用了原理，也知道双亲委派模型。说了这么多，差点把我们的tomcat给忘了，我们的题目是Tomcat 加载器为何违背双亲委派模型？下面就好好说说我们的tomcat的类加载器。</p>
<h2 id="4-Tomcat-的类加载器是怎么设计的？"><a href="#4-Tomcat-的类加载器是怎么设计的？" class="headerlink" title="4. Tomcat 的类加载器是怎么设计的？"></a>4. Tomcat 的类加载器是怎么设计的？</h2><p>首先，我们来问个问题：</p>
<h6 id="Tomcat-如果使用默认的类加载机制行不行？"><a href="#Tomcat-如果使用默认的类加载机制行不行？" class="headerlink" title="Tomcat 如果使用默认的类加载机制行不行？"></a>Tomcat 如果使用默认的类加载机制行不行？</h6><p>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：</p>
<ol>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖<strong>同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</li>
<li>部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。</li>
<li>web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li>
<li>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。</li>
</ol>
<p>再看看我们的问题：Tomcat 如果使用默认的类加载机制行不行？<br>答案是不行的。为什么？我们看，第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。第三个问题和第一个问题一样。我们再看第四个问题，我们想我们要怎么实现jsp文件的热修改（楼主起的名字），jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p>
<h5 id="Tomcat-如何实现自己独特的类加载机制？"><a href="#Tomcat-如何实现自己独特的类加载机制？" class="headerlink" title="Tomcat 如何实现自己独特的类加载机制？"></a>Tomcat 如何实现自己独特的类加载机制？</h5><p>所以，Tomcat 是怎么实现的呢？牛逼的Tomcat团队已经设计好了。我们看看他们的设计图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-89bacc3467d513f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看到，前面3个类加载和默认的一致，CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载<code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code>（在tomcat 6之后已经合并到根目录下的lib目录下）和<code>/WebApp/WEB-INF/*</code>中的Java类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，<strong>每一个Web应用程序</strong>对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。</p>
<ul>
<li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li>
<li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li>
</ul>
<p>从图中的委派关系中可以看出：</p>
<blockquote>
<p>CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。</p>
</blockquote>
<blockquote>
<p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</p>
</blockquote>
<blockquote>
<p>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。</p>
</blockquote>
<p>好了，至此，我们已经知道了tomcat为什么要这么设计，以及是如何设计的，那么，tomcat 违背了java 推荐的双亲委派模型了吗？答案是：违背了。 我们前面说过：</p>
<blockquote>
<p>双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。</p>
</blockquote>
<p>很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</p>
<h5 id="我们扩展出一个问题：如果tomcat-的-Common-ClassLoader-想加载-WebApp-ClassLoader-中的类，该怎么办？"><a href="#我们扩展出一个问题：如果tomcat-的-Common-ClassLoader-想加载-WebApp-ClassLoader-中的类，该怎么办？" class="headerlink" title="我们扩展出一个问题：如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？"></a>我们扩展出一个问题：如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？</h5><p>看了前面的关于破坏双亲委派模型的内容，我们心里有数了，我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。牛逼吧。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>好了，终于，我们明白了Tomcat 为何违背双亲委派模型，也知道了tomcat的类加载器是如何设计的。顺便复习了一下 Java 默认的类加载器机制，也知道了如何破坏Java的类加载机制。这一次收获不小哦！！！ 嘿嘿。</p>
<p>好了，今天到此为止。下篇 深入理解 Tomcat（五）Tomcat 两大核心组件—-连接器和容器！！！</p>
<p>good luck！！！</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat（六）源码剖析Tomcat-启动过程----生命周期和容器组件</title>
    <url>/2017/11/22/2017/2017-11-22-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat%EF%BC%88%E5%85%AD%EF%BC%89%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90Tomcat-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B----%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       好了,今天我们继续分析 tomcat 源码, 这是第六篇了, 上一篇我们一边 debug 一边研究了 tomcat 的类加载体系, 我觉得效果还不错, 楼主感觉对 tomcat 的类加载体系的理解又加深了一点. 所以, 我们今天还是按照之前的方式来继续看源码, 一边 debug, 一边看, 今天我们分析的是tomcat 中2个非常重要的组件-------生命周期和容器. tomcat 庞大的架构, 他是如何管理每个对象的呢? 我们在[深入理解 Tomcat (二) 从宏观上理解 Tomcat 组件及架构](http://www.jianshu.com/p/d74eef07487f)中说过一段:

<blockquote>
<p>基于JMX Tomcat会为每个组件进行注册过程，通过Registry管理起来，而Registry是基于JMX来实现的，因此在看组件的init和start过程实际上就是初始化MBean和触发MBean的start方法，会大量看到形如： Registry.getRegistry(null, null).invoke(mbeans, “init”, false); Registry.getRegistry(null, null).invoke(mbeans, “start”, false); 这样的代码，这实际上就是通过JMX管理各种组件的行为和生命期。</p>
</blockquote>
<p>当时大家可能还不是很理解这句话, 觉得这是在扯淡, 听不懂. 好吧, 今天我们就用代码说话, 看看 JMX 到底怎么管理 tomcat 的 组件.</p>
<h3 id="1-什么是-JMX"><a href="#1-什么是-JMX" class="headerlink" title="1. 什么是 JMX?"></a>1. 什么是 JMX?</h3><p>我们之前说过:</p>
<blockquote>
<p>JMX 即 Java Management Extensions(JMX 规范), 是用来对 tomcat 进行管理的. tomcat 中的实现是 commons modeler 库, Catalina 使用这个库来编写托管 Bean 的工作. 托管 Bean 就是用来管理 Catalina 中其他对象的 Bean.</p>
</blockquote>
<p><strong>简单来说: 就是一个可以为Java应用程序或系统植入远程管理功能的框架。</strong></p>
<p>既然是框架, 肯定要有架构图:<br><img src="http://upload-images.jianshu.io/upload_images/4236553-f4eb03538b446841.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里对上图中三个分层进行介绍：</p>
<ul>
<li><p>Probe Level：负责资源的检测（获取信息），包含MBeans，通常也叫做Instrumentation Level。MX管理构件（MBean）分为四种形式，分别是标准管理构件（Standard MBean）、动态管理构件（Dynamic MBean）、开放管理构件(Open Mbean)和模型管理构件(Model MBean)。</p>
</li>
<li><p>Agent Level：即MBeanServer，是JMX的核心，负责连接Mbeans和应用程序。 </p>
</li>
<li><p>Remote Management Level：通过connectors和adaptors来远程操作MBeanServer，常用的控制台，例如JConsole、<strong>VisualVM</strong>(等会我们就要用这个)等。</p>
</li>
</ul>
<h3 id="2-我们看看生命周期组件接口是如何设计的"><a href="#2-我们看看生命周期组件接口是如何设计的" class="headerlink" title="2. 我们看看生命周期组件接口是如何设计的:"></a>2. 我们看看生命周期组件接口是如何设计的:</h3><p><img src="http://upload-images.jianshu.io/upload_images/4236553-d20b1a4da501035f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是一张 IDEA 生成的简单的 StandardHost(Host 容器的标准实现) 的 UML类图, 基本上, tomcat 的容器类都是这样的继承结构.</p>
<p>因此我们就可以直接看下面这张图:<br><img src="http://upload-images.jianshu.io/upload_images/4236553-ebf5aa0870e5bf20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里对上图中涉及的主要类作个简单介绍：</p>
<ol>
<li><p>Lifecycle：定义了容器生命周期、容器状态转换及容器状态迁移事件的监听器注册和移除等主要接口；</p>
</li>
<li><p>LifecycleBase：作为Lifecycle接口的抽象实现类，运用抽象模板模式将所有容器的生命周期及状态转换衔接起来，此外还提供了生成LifecycleEvent事件的接口；</p>
</li>
<li><p>LifecycleSupport：提供有关LifecycleEvent事件的监听器注册、移除，并且使用经典的监听器模式，实现事件生成后触达监听器的实现；</p>
</li>
<li><p>MBeanRegistration：Java JMX框架提供的注册MBean的接口，引入此接口是为了便于使用JMX提供的管理功能；</p>
</li>
<li><p>LifecycleMBeanBase：Tomcat提供的对MBeanRegistration的抽象实现类，运用抽象模板模式将所有容器统一注册到JMX；</p>
</li>
<li><p>此外，ContainerBase、StandardServer、StandardService、WebappLoader、Connector、StandardContext、StandardEngine、StandardHost、StandardWrapper等容器都继承了LifecycleMBeanBase，因此这些容器都具有了同样的生命周期并可以通过JMX进行管理。</p>
</li>
</ol>
<h3 id="3-再看看我们的容器结构"><a href="#3-再看看我们的容器结构" class="headerlink" title="3. 再看看我们的容器结构"></a>3. 再看看我们的容器结构</h3><p>我们之前说, 如果从宏观上讲容器, 画画图, 讲讲就好了, 就可以在脑海里形成一个映象, 今天, 我们要好好的讲讲容器, 从代码层面去理解他们. 这样一来, 也顺便把我们的容器组件也讲了, 等于又讲了生命周期组件, 还有容器组件. 一举两得. 哈哈哈. 好吧, 不扯了, 回来, 我们继续讲容器. 还是先来一张图吧:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5ca9ad548f0736fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从上图中我们可以看到:　StandardServer、StandardService、Connector、StandardContext这些容器，彼此之间都有父子关系，每个容器都可能包含零个或者多个子容器，这些子容器可能存在不同类型或者相同类型的多个. 所以他们都包含的关系, 如果让你来设计这些容器的生命周期, 你会用什么设计模式呢?</p>
<h3 id="4-容器初始化-开始-Debug"><a href="#4-容器初始化-开始-Debug" class="headerlink" title="4. 容器初始化, 开始 Debug"></a>4. 容器初始化, 开始 Debug</h3><p>首先我们启动 main 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 命令</span></span><br><span class="line">        String command = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">        <span class="comment">// 如果命令行中输入了参数</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 命令 = 最后一个命令</span></span><br><span class="line">            command = args[args.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果命令是启动</span></span><br><span class="line">        <span class="keyword">if</span> (command.equals(<span class="string">&quot;startd&quot;</span>)) &#123;</span><br><span class="line">            args[args.length - <span class="number">1</span>] = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">            daemon.load(args);</span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果命令是停止了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stopd&quot;</span>)) &#123;</span><br><span class="line">            args[args.length - <span class="number">1</span>] = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">            daemon.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果命令是启动</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">            daemon.setAwait(<span class="keyword">true</span>);<span class="comment">// bootstrap 和 Catalina 一脉相连, 这里设置, 方法内部设置 Catalina 实例setAwait方法</span></span><br><span class="line">            daemon.load(args);<span class="comment">// args 为 空,方法内部调用 Catalina 的 load 方法.</span></span><br><span class="line">            daemon.start();<span class="comment">// 相同, 反射调用 Catalina 的 start 方法 ,至此,启动结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">            daemon.stopServer(args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;configtest&quot;</span>)) &#123;</span><br><span class="line">            daemon.load(args);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span>==daemon.getServer()) &#123;</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Bootstrap: command \&quot;&quot;</span> + command + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = t.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">        handleThrowable(t);</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉这个方法或者看过我们上篇文章的同学都知道, 我已经把类加载那部分代码去除了, 因为我们今天不研究类加载. 所以 ,我们看逻辑, 首先, 判断命令是什么, 我们现在的命令肯定是 start 啊, 所以进入 else if 块, 调用 load 方法 , 进入 load 方法, 可以看到, 该方法实际上就是 Catalina 类的 load 方法, 那么我们进入 Catalina 类的 load 方法看看(方法很长, 楼主去除了和今天的模块无关的代码):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Start the new server</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getServer().init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Catalina.start&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到, 这里有一个我们今天感兴趣的方法, getServer.init(), 这个方法看名字是启动 Server 的初始化, 而 Server 是我们上面图中最外层的容器. 因此, 我们去看看该方法, 也就是LifecycleBase.init() 方法. 该方法是一个模板方法, 只是定义了一个算法的骨架, 将一些细节算法延迟到了子类中. 看, 我们又学到了一个设计模式. 我们看看该方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">       <span class="comment">// 1</span></span><br><span class="line">       <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">           invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2</span></span><br><span class="line">       setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 模板方法</span></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 采用模板方法模式来对所有支持生命周期管理的组件的生命周期各个阶段进行了总体管理，</span></span><br><span class="line"><span class="comment">            * 每个需要生命周期管理的组件只需要继承这个基类，</span></span><br><span class="line"><span class="comment">            * 然后覆盖对应的钩子方法即可完成相应的声明周期阶段的管理工作</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           initInternal();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           ExceptionUtils.handleThrowable(t);</span><br><span class="line">           setStateInternal(LifecycleState.FAILED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                   sm.getString(<span class="string">&quot;lifecycleBase.initFail&quot;</span>,toString()), t);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3</span></span><br><span class="line">       setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看看该方法, 这应该就是容器启动的逻辑了, 先前我们定义了那么多状态, 现在用上了. 首先判断该方法的状态, 如果不是 NEW, 则抛出异常， 否则则设置状态为 INITIALIZING， 然后调用一个抽象方法 initInternal , 该方法由子类具体实现. 执行完则修改状态为 INITIALIZED. 这里应该是使用了状态模式. 依赖状态时,同步该方法, 防止并发错误. tomcat 可以的.</p>
<h3 id="5-那么我们来看看-StandardServer-是如何实现-initInternal-方法的"><a href="#5-那么我们来看看-StandardServer-是如何实现-initInternal-方法的" class="headerlink" title="5. 那么我们来看看 StandardServer 是如何实现 initInternal 方法的:"></a>5. 那么我们来看看 StandardServer 是如何实现 initInternal 方法的:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register global String cache</span></span><br><span class="line">    <span class="comment">// Note although the cache is global, if there are multiple Servers</span></span><br><span class="line">    <span class="comment">// present in the JVM (may happen when embedding) then the same cache</span></span><br><span class="line">    <span class="comment">// will be registered under multiple names</span></span><br><span class="line">    onameStringCache = register(<span class="keyword">new</span> StringCache(), <span class="string">&quot;type=StringCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the MBeanFactory</span></span><br><span class="line">    MBeanFactory factory = <span class="keyword">new</span> MBeanFactory();</span><br><span class="line">    factory.setContainer(<span class="keyword">this</span>);</span><br><span class="line">    onameMBeanFactory = register(factory, <span class="string">&quot;type=MBeanFactory&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Register the naming resources</span></span><br><span class="line">    globalNamingResources.init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Populate the extension validator with JARs from common and shared</span></span><br><span class="line">    <span class="comment">// class loaders</span></span><br><span class="line">    <span class="keyword">if</span> (getCatalina() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassLoader cl = getCatalina().getParentClassLoader();</span><br><span class="line">        <span class="comment">// Walk the class loader hierarchy. Stop at the system class loader.</span></span><br><span class="line">        <span class="comment">// This will add the shared (if present) and common class loaders</span></span><br><span class="line">        <span class="keyword">while</span> (cl != <span class="keyword">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">                URL[] urls = ((URLClassLoader) cl).getURLs();</span><br><span class="line">                <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            File f = <span class="keyword">new</span> File (url.toURI());</span><br><span class="line">                            <span class="keyword">if</span> (f.isFile() &amp;&amp;</span><br><span class="line">                                    f.getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                                ExtensionValidator.addSystemResource(f);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                            <span class="comment">// Ignore</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="comment">// Ignore</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cl = cl.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Initialize our defined Services</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">        services[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-LifecycleMBeanBase-initInternal-实现"><a href="#6-LifecycleMBeanBase-initInternal-实现" class="headerlink" title="6. LifecycleMBeanBase.initInternal() 实现"></a>6. LifecycleMBeanBase.initInternal() 实现</h3><p>首先调用父类的  super.initInternal() 方法，此initInternal方法用于将容器托管到JMX，便于运维管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// If oname is not null then registration has already happened via</span></span><br><span class="line">    <span class="comment">// preRegister().</span></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mserver = Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).getMBeanServer();</span><br><span class="line">        oname = register(<span class="keyword">this</span>, getObjectNameKeyProperties());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-LifecycleMBeanBase-register-方法实现"><a href="#7-LifecycleMBeanBase-register-方法实现" class="headerlink" title="7. LifecycleMBeanBase.register 方法实现"></a>7. LifecycleMBeanBase.register 方法实现</h3><p>LifecycleMBeanBase 会调用自身的 register 方法， 该方法会将容器注册到 MBeanServer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ObjectName <span class="title">register</span><span class="params">(Object obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        String objectNameKeyProperties)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Construct an object name with the right domain</span></span><br><span class="line">    StringBuilder name = <span class="keyword">new</span> StringBuilder(getDomain());</span><br><span class="line">    name.append(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    name.append(objectNameKeyProperties);</span><br><span class="line"></span><br><span class="line">    ObjectName on = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        on = <span class="keyword">new</span> ObjectName(name.toString());</span><br><span class="line">        <span class="comment">// 核心实现：registerComponent</span></span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(obj, on, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedObjectNameException e) &#123;</span><br><span class="line">        log.warn(sm.getString(<span class="string">&quot;lifecycleMBeanBase.registerFail&quot;</span>, obj, name),</span><br><span class="line">                e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(sm.getString(<span class="string">&quot;lifecycleMBeanBase.registerFail&quot;</span>, obj, name),</span><br><span class="line">                e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法内部核心方法是 Registry. registerComponent, 在org.apache.catalina.util 包下， 我们看看该方法实现。</p>
<h3 id="8-Registry-registerComponent-方法实现"><a href="#8-Registry-registerComponent-方法实现" class="headerlink" title="8. Registry.registerComponent 方法实现"></a>8. Registry.registerComponent 方法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponent</span><span class="params">(Object bean, ObjectName oname, String type)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>( log.isDebugEnabled() ) &#123;</span><br><span class="line">          log.debug( <span class="string">&quot;Managed= &quot;</span>+ oname);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>( bean ==<span class="keyword">null</span> ) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;Null component &quot;</span> + oname );</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>( type==<span class="keyword">null</span> ) &#123;</span><br><span class="line">              type=bean.getClass().getName();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ManagedBean managed = findManagedBean(bean.getClass(), type);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// The real mbean is created and registered</span></span><br><span class="line">          DynamicMBean mbean = managed.createMBean(bean);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(  getMBeanServer().isRegistered( oname )) &#123;</span><br><span class="line">              <span class="keyword">if</span>( log.isDebugEnabled()) &#123;</span><br><span class="line">                  log.debug(<span class="string">&quot;Unregistering existing component &quot;</span> + oname );</span><br><span class="line">              &#125;</span><br><span class="line">              getMBeanServer().unregisterMBean( oname );</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          getMBeanServer().registerMBean( mbean, oname);</span><br><span class="line">      &#125; <span class="keyword">catch</span>( Exception ex) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;Error registering &quot;</span> + oname, ex );</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法会为当前容器创建一个 DynamicMBean ， 并且注册到MBeanServer。调用 MBeanServer.registerMBean() 方法。而 MBeanServer 在 javax.management， 也就是 rt.jar 中，该包由 java 的 BootStrap 启动类加载器加载。</p>
<p>注册进MBeanServer 的 key 是什么呢？ 相信细心的同学会注意到 LifecycleMBeanBase.getObjectNameKeyProperties 和 LifecycleMBeanBase.getDomain 方法 和<br>LifecycleMBeanBase.getDomainInternal 方法， 这三个方法由具体子类实现，会生成一个专属于容器的key。格式为：<code>Catalina:type=Server</code>， 这是 Server 容器的 key， debug 可以看出来：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-fd0ee1be841208a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="9-JMX-如何管理-组件？"><a href="#9-JMX-如何管理-组件？" class="headerlink" title="9. JMX 如何管理 组件？"></a>9. JMX 如何管理 组件？</h3><p>至此， 我们已经知道 Tomcat 是如何将容器注册到 MBeanServer 中的。 那么注册到 MBeanServer 中后是什么样子呢？我们看图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c1765c2cd2d6c9b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是 JDK 自带的 JvisualVM 工具， 添加了 MBeans 插件， 就可以远程操作容器中的 组件了， 可以看到 Service 容器暴漏了很多接口， 用于运维人员管理容器和组件。</p>
<h3 id="10-回到-StandardServer-initInternal-方法"><a href="#10-回到-StandardServer-initInternal-方法" class="headerlink" title="10. 回到 StandardServer.initInternal 方法"></a>10. 回到 StandardServer.initInternal 方法</h3><p>好了， 我们回到 StandardServer.initInternal 方法， 回到我们梦最开始的地方，<code> super.initInternal</code> 方法就是将容器注册到 JMX 中。 那下面的逻辑是做什么的呢？ 在执行完父类的 super.initInternal 的方法后， 该方法又注册个两个 JMX 。然后寻启动子容器的 init 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize our defined Services</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">        services[i].init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而子容器的 init 方法和 Server 的 init 方法的逻辑基本一致，所以不再赘述。</p>
<h3 id="11-执行完-getServer-init-方法后做什么——容器启动"><a href="#11-执行完-getServer-init-方法后做什么——容器启动" class="headerlink" title="11. 执行完  getServer().init() 方法后做什么——容器启动"></a>11. 执行完 <code> getServer().init()</code> 方法后做什么——容器启动</h3><p>Bootstrap 的 load 方法调用了 Catalina 的 load 方法 ，该方法调用了Server 的init方法，执行完初始化过程，当然就是要执行 start 方法了， 那么如何执行呢？</p>
<p> Bootstrap 调用了 Catalina 的 start 方法，该方法也同样执行了 Server 的 start 方法， 该方法的具体实现也在LifecycleBase 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) ||</span><br><span class="line">                LifecycleState.STARTING.equals(state) ||</span><br><span class="line">                LifecycleState.STARTED.equals(state)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                Exception e = <span class="keyword">new</span> LifecycleException();</span><br><span class="line">                log.debug(sm.getString(<span class="string">&quot;lifecycleBase.alreadyStarted&quot;</span>,</span><br><span class="line">                        toString()), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(sm.getString(<span class="string">&quot;lifecycleBase.alreadyStarted&quot;</span>,</span><br><span class="line">                        toString()));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(LifecycleState.FAILED))&#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;</span><br><span class="line">                !state.equals(LifecycleState.STOPPED)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_START_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setStateInternal(LifecycleState.STARTING_PREP, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startInternal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            setStateInternal(LifecycleState.FAILED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                    sm.getString(<span class="string">&quot;lifecycleBase.startFail&quot;</span>,toString()), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.FAILED) ||</span><br><span class="line">                state.equals(LifecycleState.MUST_STOP)) &#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Shouldn&#x27;t be necessary but acts as a check that sub-classes are</span></span><br><span class="line">            <span class="comment">// doing what they are supposed to.</span></span><br><span class="line">            <span class="keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;</span><br><span class="line">                invalidTransition(Lifecycle.AFTER_START_EVENT);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            setStateInternal(LifecycleState.STARTED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-StandardServer-startInternal-启动容器方法实现"><a href="#12-StandardServer-startInternal-启动容器方法实现" class="headerlink" title="12. StandardServer.startInternal 启动容器方法实现"></a>12. StandardServer.startInternal 启动容器方法实现</h3><p>可以看到该方法对状态的判断特别多，我们感兴趣的是 try 块中的  startInternal() 方法， 同样， 该方法也是个抽象方法，需要子类去具体实现自己的启动逻辑。我们看看Server 的启动逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">       fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="keyword">null</span>);</span><br><span class="line">       setState(LifecycleState.STARTING);<span class="comment">//将自身状态更改为LifecycleState.STARTING；</span></span><br><span class="line">       globalNamingResources.start();</span><br><span class="line">       <span class="comment">// Start our defined Services</span></span><br><span class="line">       <span class="keyword">synchronized</span> (services) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">               services[i].start();<span class="comment">// 启动所有子容器</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-LifecycleSupport-fireLifecycleEvent-方法实现"><a href="#13-LifecycleSupport-fireLifecycleEvent-方法实现" class="headerlink" title="13. LifecycleSupport.fireLifecycleEvent()方法实现"></a>13. LifecycleSupport.fireLifecycleEvent()方法实现</h3><p>该方法首先执行自己的<code>fireLifecycleEvent</code>方法， 该方法内部是LifecycleSupport.fireLifecycleEvent()方法,  我们进入该方法看个究竟:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 事件监听,观察者模式的另一种方式</span></span><br><span class="line">        LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(lifecycle, type, data);</span><br><span class="line">        LifecycleListener interested[] = listeners;<span class="comment">// 监听器数组 关注 事件(启动或者关闭事件)</span></span><br><span class="line">        <span class="comment">// 循环通知所有生命周期时间侦听器????</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interested.length; i++)</span><br><span class="line">            <span class="comment">// 每个监听器都有自己的逻辑</span></span><br><span class="line">            interested[i].lifecycleEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法很简单, 楼主没有删一行代码, 首先, 创建一个事件对象, 然通知所有的监听器发生了该事件.并做响应.那么 Server 有哪些监听器呢?</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7b9d96095834dd0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这些监听器将根据这个事件的类型做出响应. </p>
<h3 id="14-我们回到-startInternal-方法-启动所有容器"><a href="#14-我们回到-startInternal-方法-启动所有容器" class="headerlink" title="14. 我们回到 startInternal 方法, 启动所有容器"></a>14. 我们回到 startInternal 方法, 启动所有容器</h3><p>事件监听结束之后,  调用 <code>setState(LifecycleState.STARTING);</code> 表明状态时开始中, 并且循环启动子容器, 这里的 Server 启动的是Service 数组, 循环启动他们的 start 方法. 以此类推. 启动所有的容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (services) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">            services[i].start();<span class="comment">// 启动所有子容器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>现在我们关注的是Server 容器， 因此， Server 会启动 services 数组中的所有 Service 组件。该方法就完成了通知所有监听器发送了启动事件，然后使用观察者模式，启动所有子容器，然后子容器继续递归启动。最后修改自己的状态并告诉监听器。</p>
<h3 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h3><p>其实楼主在啃代码最深的感触就是设计模式， 真的很牛逼，不知道同学们发现了几个设计模式，楼主在本篇文章中发现了状态模式， 观察者模式，模板方法， 事件监听，代理模式。真的收益良多。不枉楼主每天看代码。</p>
<p>还有就是对 Tomcat 生命周期组件的总结。我们再看看我们的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ebf5aa0870e5bf20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>tomcat 的主要容器都继承了 LifecycleMBeanBase 抽象类，该类中关于 init 和 start 两个模板方法。定义了主要算法骨架，而方法中又都有抽象方法，需要子类自己去实现。而 LifecycleBase 中又定义了如何实现事件监听代理，LifecycleBase 依赖 LifecycleSupport 去完成真正的事件监听。对了，监听器是如何添加进 LifecycleSupport 的呢？LifecycleSupport 中含有<br> addLifecycleListener 方法。该方法也是被LifecycleBase代理的。而每个容器下面的子容器也是使用相同的逻辑完成初始化和启动。父容器和子容器使用了聚合的方式设计。</p>
<p>可以说， tomcat的容器的生命周期组件设计是非常牛逼的。我们阅读源码不仅能了解他的设计原理，也能同大师交流，学会更多。</p>
<p>好了， 今天的深入理解 Tomcat（六）源码剖析Tomcat 启动过程—-生命周期和容器组件就到这里，谢谢大家的耐心，再这个世界，耐心和坚持是无比珍贵的。尤其是程序员。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat（七）源码剖析-Tomcat-完整启动过程</title>
    <url>/2017/11/23/2017/2017-11-23-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat%EF%BC%88%E4%B8%83%EF%BC%89%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-Tomcat-%E5%AE%8C%E6%95%B4%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       这是我们分析 Tomcat 的第七篇文章，前面我们依据启动过程理解了类加载过程，生命周期组件，容器组件等。基本上将启动过程拆的七零八落，分析的差不多了， 但是还没有从整体的视图下来分析Tomcat 的启动过程。因此，这篇文章的任务就是这个，我们想将Tomcat的启动过程彻底的摸清，把它最后一件衣服扒掉。然后我们就分析连接器和URL请求了，不再留恋这里了。

<p>好吧。我们开始吧。</p>
<p>说到Tomcat的启动，我们都知道，我们每次需要运行tomcat/bin/startup.sh这个脚本，而这个脚本的内容到底是什么呢？我们来看看。</p>
<h3 id="1-startup-sh-脚本内容"><a href="#1-startup-sh-脚本内容" class="headerlink" title="1. startup.sh 脚本内容"></a>1. startup.sh 脚本内容</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">os400=false</span><br><span class="line">case &quot;`uname`&quot; in</span><br><span class="line">OS400*) os400=true;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> resolve links - <span class="variable">$0</span> may be a softlink</span></span><br><span class="line">PRG=&quot;$0&quot;</span><br><span class="line"></span><br><span class="line">while [ -h &quot;$PRG&quot; ] ; do</span><br><span class="line">  ls=`ls -ld &quot;$PRG&quot;`</span><br><span class="line">  link=`expr &quot;$ls&quot; : &#x27;.*-&gt; \(.*\)$&#x27;`</span><br><span class="line">  if expr &quot;$link&quot; : &#x27;/.*&#x27; &gt; /dev/null; then</span><br><span class="line">    PRG=&quot;$link&quot;</span><br><span class="line">  else</span><br><span class="line">    PRG=`dirname &quot;$PRG&quot;`/&quot;$link&quot;</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">PRGDIR=`dirname &quot;$PRG&quot;`</span><br><span class="line">EXECUTABLE=catalina.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Check that target executable exists</span></span><br><span class="line">if $os400; then</span><br><span class="line"><span class="meta">  #</span><span class="bash"> -x will Only work on the os400 <span class="keyword">if</span> the files are:</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 1. owned by the user</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 2. owned by the PRIMARY group of the user</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> this will not work <span class="keyword">if</span> the user belongs <span class="keyword">in</span> secondary groups</span></span><br><span class="line">  eval</span><br><span class="line">else</span><br><span class="line">  if [ ! -x &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; ]; then</span><br><span class="line">    echo &quot;Cannot find $PRGDIR/$EXECUTABLE&quot;</span><br><span class="line">    echo &quot;The file is absent or does not have execute permission&quot;</span><br><span class="line">    echo &quot;This file is needed to run this program&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; start &quot;$@&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>楼主删除了一些无用的注释，我们来看看这脚本。该脚本中有2个重要的变量：</p>
<ol>
<li>PRGDIR：表示当前脚本所在的路径</li>
<li>EXECUTABLE：catalina.sh 脚本名称<br>其中最关键的一行代码就是 <code>exec &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; start &quot;$@&quot;</code>，表示执行了脚本catalina.sh，参数是start。</li>
</ol>
<h3 id="2-catalina-sh-脚本实现"><a href="#2-catalina-sh-脚本实现" class="headerlink" title="2. catalina.sh 脚本实现"></a>2. catalina.sh 脚本实现</h3><p>然后我们看看catalina.sh 脚本中的实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">elif [ &quot;$1&quot; = &quot;start&quot; ] ; then</span><br><span class="line"></span><br><span class="line">  if [ ! -z &quot;$CATALINA_PID&quot; ]; then</span><br><span class="line">    if [ -f &quot;$CATALINA_PID&quot; ]; then</span><br><span class="line">      if [ -s &quot;$CATALINA_PID&quot; ]; then</span><br><span class="line">        echo &quot;Existing PID file found during start.&quot;</span><br><span class="line">        if [ -r &quot;$CATALINA_PID&quot; ]; then</span><br><span class="line">          PID=`cat &quot;$CATALINA_PID&quot;`</span><br><span class="line">          ps -p $PID &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">          if [ $? -eq 0 ] ; then</span><br><span class="line">            echo &quot;Tomcat appears to still be running with PID $PID. Start aborted.&quot;</span><br><span class="line">            echo &quot;If the following process is not a Tomcat process, remove the PID file and try again:&quot;</span><br><span class="line">            ps -f -p $PID</span><br><span class="line">            exit 1</span><br><span class="line">          else</span><br><span class="line">            echo &quot;Removing/clearing stale PID file.&quot;</span><br><span class="line">            rm -f &quot;$CATALINA_PID&quot; &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">            if [ $? != 0 ]; then</span><br><span class="line">              if [ -w &quot;$CATALINA_PID&quot; ]; then</span><br><span class="line">                cat /dev/null &gt; &quot;$CATALINA_PID&quot;</span><br><span class="line">              else</span><br><span class="line">                echo &quot;Unable to remove or clear stale PID file. Start aborted.&quot;</span><br><span class="line">                exit 1</span><br><span class="line">              fi</span><br><span class="line">            fi</span><br><span class="line">          fi</span><br><span class="line">        else</span><br><span class="line">          echo &quot;Unable to read PID file. Start aborted.&quot;</span><br><span class="line">          exit 1</span><br><span class="line">        fi</span><br><span class="line">      else</span><br><span class="line">        rm -f &quot;$CATALINA_PID&quot; &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">        if [ $? != 0 ]; then</span><br><span class="line">          if [ ! -w &quot;$CATALINA_PID&quot; ]; then</span><br><span class="line">            echo &quot;Unable to remove or write to empty PID file. Start aborted.&quot;</span><br><span class="line">            exit 1</span><br><span class="line">          fi</span><br><span class="line">        fi</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  shift</span><br><span class="line">  touch &quot;$CATALINA_OUT&quot;</span><br><span class="line">  if [ &quot;$1&quot; = &quot;-security&quot; ] ; then</span><br><span class="line">    if [ $have_tty -eq 1 ]; then</span><br><span class="line">      echo &quot;Using Security Manager&quot;</span><br><span class="line">    fi</span><br><span class="line">    shift</span><br><span class="line">    eval $_NOHUP &quot;\&quot;$_RUNJAVA\&quot;&quot; &quot;\&quot;$LOGGING_CONFIG\&quot;&quot; $LOGGING_MANAGER $JAVA_OPTS $CATALINA_OPTS \</span><br><span class="line">      -classpath &quot;\&quot;$CLASSPATH\&quot;&quot; \</span><br><span class="line">      -Djava.security.manager \</span><br><span class="line">      -Djava.security.policy==&quot;\&quot;$CATALINA_BASE/conf/catalina.policy\&quot;&quot; \</span><br><span class="line">      -Dcatalina.base=&quot;\&quot;$CATALINA_BASE\&quot;&quot; \</span><br><span class="line">      -Dcatalina.home=&quot;\&quot;$CATALINA_HOME\&quot;&quot; \</span><br><span class="line">      -Djava.io.tmpdir=&quot;\&quot;$CATALINA_TMPDIR\&quot;&quot; \</span><br><span class="line">      org.apache.catalina.startup.Bootstrap &quot;$@&quot; start \</span><br><span class="line">      &gt;&gt; &quot;$CATALINA_OUT&quot; 2&gt;&amp;1 &quot;&amp;&quot;</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    eval $_NOHUP &quot;\&quot;$_RUNJAVA\&quot;&quot; &quot;\&quot;$LOGGING_CONFIG\&quot;&quot; $LOGGING_MANAGER $JAVA_OPTS $CATALINA_OPTS \</span><br><span class="line">      -classpath &quot;\&quot;$CLASSPATH\&quot;&quot; \</span><br><span class="line">      -Dcatalina.base=&quot;\&quot;$CATALINA_BASE\&quot;&quot; \</span><br><span class="line">      -Dcatalina.home=&quot;\&quot;$CATALINA_HOME\&quot;&quot; \</span><br><span class="line">      -Djava.io.tmpdir=&quot;\&quot;$CATALINA_TMPDIR\&quot;&quot; \</span><br><span class="line">      org.apache.catalina.startup.Bootstrap &quot;$@&quot; start \</span><br><span class="line">      &gt;&gt; &quot;$CATALINA_OUT&quot; 2&gt;&amp;1 &quot;&amp;&quot;</span><br><span class="line"></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  if [ ! -z &quot;$CATALINA_PID&quot; ]; then</span><br><span class="line">    echo $! &gt; &quot;$CATALINA_PID&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  echo &quot;Tomcat started.&quot;</span><br></pre></td></tr></table></figure>

<p>该脚本很长，但我们只关心我们感兴趣的：如果参数是 <code>start</code>， 那么执行这里的逻辑，关键再最后一行执行了 <code>org.apache.catalina.startup.Bootstrap &quot;$@&quot; start</code>， 也就是说，执行了我们熟悉的main方法，并且携带了start 参数，那么我们就来看Bootstrap 的main方法是如何实现的。</p>
<h3 id="3-Bootstrap-main-方法实现"><a href="#3-Bootstrap-main-方法实现" class="headerlink" title="3. Bootstrap.main 方法实现"></a>3. Bootstrap.main 方法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.err.println(<span class="string">&quot;Have fun and Enjoy! cxs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// daemon 就是 bootstrap</span></span><br><span class="line">    <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        daemon = bootstrap;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String command = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            command = args[args.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (command.equals(<span class="string">&quot;startd&quot;</span>)) &#123;</span><br><span class="line">            args[args.length - <span class="number">1</span>] = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">            daemon.load(args);</span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stopd&quot;</span>)) &#123;</span><br><span class="line">            args[args.length - <span class="number">1</span>] = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">            daemon.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">            daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">            daemon.load(args);</span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">            daemon.stopServer(args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;configtest&quot;</span>)) &#123;</span><br><span class="line">            daemon.load(args);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span>==daemon.getServer()) &#123;</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Bootstrap: command \&quot;&quot;</span> + command + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = t.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">        handleThrowable(t);</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看该方法， 首先 <code> bootstrap.init()</code> 的方法用于初始化类加载器，我们已经分析过该方法了，就不再赘述了，然后我们看下面的try块，默认命令行参数是 <code>start</code> ，但我们刚刚的脚本传的参数就是 start， 因此进入该if块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">      daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">      daemon.load(args);</span><br><span class="line">      daemon.start();</span><br></pre></td></tr></table></figure>
<ol>
<li>设置catalina 的 await 属性为true；</li>
<li>运行 catalina 的 load 方法。该方法内部主要逻辑是解析server.xml文件，初始化容器。我们已经再生命周期那篇文章中讲过容器的初始化。</li>
<li>运行 catalina 的 start 方法。也就是启动 tomcat。这个部分我们上次分析了容器启动。但是容器之后的逻辑我们没有分析。今天我们就来看看。</li>
</ol>
<h3 id="4-Catalina-start-方法"><a href="#4-Catalina-start-方法" class="headerlink" title="4. Catalina.start 方法"></a>4. Catalina.start 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">           load();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">           log.fatal(<span class="string">&quot;Cannot start server. Server instance is not configured.&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">       <span class="comment">// Start the new server</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           getServer().start();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">           log.fatal(sm.getString(<span class="string">&quot;catalina.serverStartFail&quot;</span>), e);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               getServer().destroy();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;destroy() failed for failed Server &quot;</span>, e1);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">       <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">           log.info(<span class="string">&quot;Server startup in &quot;</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">           <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">               shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">           &#125;</span><br><span class="line">           Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If JULI is being used, disable JULI&#x27;s shutdown hook since</span></span><br><span class="line">           <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">           <span class="comment">// if JULI&#x27;s hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">           LogManager logManager = LogManager.getLogManager();</span><br><span class="line">           <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">               ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                       <span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (await) &#123;</span><br><span class="line">           await();</span><br><span class="line">           stop();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>该方法我们上次分析到了 <code>getServer().start()</code> 这里，也就是容器启动的逻辑，我们不再赘述。<br>今天我们继续分析下面的逻辑。主要逻辑是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">           <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">               shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">           &#125;</span><br><span class="line">           Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If JULI is being used, disable JULI&#x27;s shutdown hook since</span></span><br><span class="line">           <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">           <span class="comment">// if JULI&#x27;s hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">           LogManager logManager = LogManager.getLogManager();</span><br><span class="line">           <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">               ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                       <span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (await) &#123;</span><br><span class="line">           await();</span><br><span class="line">           stop();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是 <code>Runtime.getRuntime().addShutdownHook(shutdownHook)</code>方法。那么这个方法的作用是什么呢？JDK 文档是这样说的：</p>
<blockquote>
<p>注册新的虚拟机来关闭钩子。<br>只是一个已初始化但尚未启动的线程。虚拟机开始启用其关闭序列时，它会以某种未指定的顺序启动所有已注册的关闭钩子，并让它们同时运行。运行完所有的钩子后，如果已启用退出终结，那么虚拟机接着会运行所有未调用的终结方法。最后，虚拟机会暂停。注意，关闭序列期间会继续运行守护线程，如果通过调用方法来发起关闭序列，那么也会继续运行非守护线程。</p>
</blockquote>
<p>简单来说，如果用户的程序出现了bug， 或者使用control + C 关闭了命令行，那么就需要做一些内存清理的工作。该方法就会再虚拟机退出时做清理工作。再ApplicationShutdownHooks 类种维护着一个IdentityHashMap&lt;Thread, Thread&gt;  Map，用于后台清理工作。那么该线程对象的run方法中是什么逻辑呢？我们来看看：</p>
<h3 id="5-CatalinaShutdownHook-run-线程方法实现"><a href="#5-CatalinaShutdownHook-run-线程方法实现" class="headerlink" title="5. CatalinaShutdownHook.run 线程方法实现"></a>5. CatalinaShutdownHook.run 线程方法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">CatalinaShutdownHook</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (getServer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Catalina.<span class="keyword">this</span>.stop();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">               ExceptionUtils.handleThrowable(ex);</span><br><span class="line">               log.error(sm.getString(<span class="string">&quot;catalina.shutdownHookFail&quot;</span>), ex);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// If JULI is used, shut JULI down *after* the server shuts down</span></span><br><span class="line">               <span class="comment">// so log messages aren&#x27;t lost</span></span><br><span class="line">               LogManager logManager = LogManager.getLogManager();</span><br><span class="line">               <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">                   ((ClassLoaderLogManager) logManager).shutdown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该线程是Catalina的内部类，方法逻辑是，如果Server容器还存在，就是执行Catalina的stop方法用于停止容器。（为什么要用Catalina.this.stop 呢？因为它继承了Thread，而Thread也有一个stop方法，因此需要显式的指定该方法）最后关闭日志管理器。我们看看stop方法的实现：</p>
<h3 id="6-Catalina-stop-方法实现："><a href="#6-Catalina-stop-方法实现：" class="headerlink" title="6. Catalina.stop 方法实现："></a>6. Catalina.stop 方法实现：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Remove the ShutdownHook first so that server.stop()</span></span><br><span class="line">            <span class="comment">// doesn&#x27;t get invoked twice</span></span><br><span class="line">            <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">                Runtime.getRuntime().removeShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If JULI is being used, re-enable JULI&#x27;s shutdown to ensure</span></span><br><span class="line">                <span class="comment">// log messages are not lost</span></span><br><span class="line">                LogManager logManager = LogManager.getLogManager();</span><br><span class="line">                <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">                    ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                            <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            <span class="comment">// This will fail on JDK 1.2. Ignoring, as Tomcat can run</span></span><br><span class="line">            <span class="comment">// fine without the shutdown hook.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shut down the server</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Server s = getServer();</span><br><span class="line">            LifecycleState state = s.getState();</span><br><span class="line">            <span class="keyword">if</span> (LifecycleState.STOPPING_PREP.compareTo(state) &lt;= <span class="number">0</span></span><br><span class="line">                    &amp;&amp; LifecycleState.DESTROYED.compareTo(state) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Nothing to do. stop() was already called</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.stop();</span><br><span class="line">                s.destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Catalina.stop&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先移除关闭钩子，为什么要移除呢，因为他的任务已经完成了。然后设置useShutdownHook 为true。最后执行Server的stop方法，Server的stop方法基本和init方法和start方法一样，都是使用父类的模板方法，首先出发事件，然后调用stopInternal，该方法内部循环停止子容器，子容器递归停止，和我们之前的逻辑一致，不再赘述。destroy方法同理。</p>
<p>好了，我们已经看清了关闭钩子的逻辑，其实就是开辟一个守护线程交给虚拟机，然后虚拟机在某些异常情况（比如System.exit(0)）前执行停止容器的逻辑。</p>
<p>好。我们回到start方法。</p>
<h3 id="7-回到-Catalina-start-方法"><a href="#7-回到-Catalina-start-方法" class="headerlink" title="7. 回到 Catalina.start 方法"></a>7. 回到 Catalina.start 方法</h3><p>在设置好关闭钩子后，tomcat 的启动过程还没有启动完毕，接下来的逻辑式什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">        shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If JULI is being used, disable JULI&#x27;s shutdown hook since</span></span><br><span class="line">    <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">    <span class="comment">// if JULI&#x27;s hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">    LogManager logManager = LogManager.getLogManager();</span><br><span class="line">    <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">        ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (await) &#123;</span><br><span class="line">    await();</span><br><span class="line">    stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在设置完关闭钩子之后，会将 useShutdownHook 这个变量为false，然后执行 await 方法。然后执行stop方法，我们记得stop方法式关闭容器的方法，神经病啊，好不容易启动了，为什么又要关闭呢？ 先不着急，我们还是看看 await 方法吧,该方法调用了Server.await 方法，我们来看看：</p>
<h3 id="8-Catalian-await-方法实现"><a href="#8-Catalian-await-方法实现" class="headerlink" title="8. Catalian.await 方法实现"></a>8. Catalian.await 方法实现</h3><p>注意：该方法很长</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Negative values - don&#x27;t wait on port - tomcat is embedded or we just don&#x27;t like ports</span></span><br><span class="line">    <span class="keyword">if</span>( port == -<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="comment">// undocumented yet - for embedding apps that are around, alive.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( port==-<span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            awaitThread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">while</span>(!stopAwait) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep( <span class="number">10000</span> );</span><br><span class="line">                &#125; <span class="keyword">catch</span>( InterruptedException ex ) &#123;</span><br><span class="line">                    <span class="comment">// continue and check the flag</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitThread = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up a server socket to wait on</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        awaitSocket = <span class="keyword">new</span> ServerSocket(port, <span class="number">1</span>,</span><br><span class="line">                InetAddress.getByName(address));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;StandardServer.await: create[&quot;</span> + address</span><br><span class="line">                           + <span class="string">&quot;:&quot;</span> + port</span><br><span class="line">                           + <span class="string">&quot;]: &quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        awaitThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop waiting for a connection and a valid command</span></span><br><span class="line">        <span class="keyword">while</span> (!stopAwait) &#123;</span><br><span class="line">            ServerSocket serverSocket = awaitSocket;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait for the next connection</span></span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            StringBuilder command = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream stream;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                    socket.setSoTimeout(<span class="number">10</span> * <span class="number">1000</span>);  <span class="comment">// Ten seconds</span></span><br><span class="line">                    stream = socket.getInputStream();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (AccessControlException ace) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;StandardServer.accept security exception: &quot;</span></span><br><span class="line">                            + ace.getMessage(), ace);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stopAwait) &#123;</span><br><span class="line">                        <span class="comment">// Wait was aborted with socket.close()</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.error(<span class="string">&quot;StandardServer.await: accept: &quot;</span>, e);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Read a set of characters from the socket</span></span><br><span class="line">                <span class="keyword">int</span> expected = <span class="number">1024</span>; <span class="comment">// Cut off to avoid DoS attack</span></span><br><span class="line">                <span class="keyword">while</span> (expected &lt; shutdown.length()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (random == <span class="keyword">null</span>)</span><br><span class="line">                        random = <span class="keyword">new</span> Random();</span><br><span class="line">                    expected += (random.nextInt() % <span class="number">1024</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (expected &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ch = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ch = stream.read();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        log.warn(<span class="string">&quot;StandardServer.await: read: &quot;</span>, e);</span><br><span class="line">                        ch = -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ch &lt; <span class="number">32</span>)  <span class="comment">// Control character or EOF terminates loop</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    command.append((<span class="keyword">char</span>) ch);</span><br><span class="line">                    expected--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Close the socket now that we are done with it</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Match against our command string</span></span><br><span class="line">            <span class="keyword">boolean</span> match = command.toString().equals(shutdown);</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                log.info(sm.getString(<span class="string">&quot;standardServer.shutdownViaPort&quot;</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                log.warn(<span class="string">&quot;StandardServer.await: Invalid command &#x27;&quot;</span></span><br><span class="line">                        + command.toString() + <span class="string">&quot;&#x27; received&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ServerSocket serverSocket = awaitSocket;</span><br><span class="line">        awaitThread = <span class="keyword">null</span>;</span><br><span class="line">        awaitSocket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the server socket and return</span></span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看一下他的逻辑：首先创建一个socketServer 链接，然后循环等待消息。如果发过来的消息为字符串<code>SHUTDOWN</code>, 那么就break，停止循环，关闭socket。否则永不停歇。回到我们刚刚的疑问，await 方法后面执行 stop 方法，现在一看就合情合理了，只要不发出关闭命令，则不会执行stop方法，否则则继续执行关闭方法。</p>
<p>到现在，Tomcat 的整体启动过程我们已经了然于胸了，总结一下就是：</p>
<ol>
<li>初始化类加载器。</li>
<li>初始化容器并注册到JMX后启动容器。</li>
<li>设置关闭钩子。</li>
<li>循环等待关闭命令。</li>
</ol>
<p>等一下。好像缺了点什么？？？ Tomcat 启动后就只接受关闭命令，接受的http请求怎么处理，还要不要做一个合格的服务器了？？？ 别急，实际上，这个是主线程，负责生命周期等事情。处理Http请求的线程在初始化容器和启动容器的时候由子容器做了，这块的逻辑我们下次再讲。大家不要疑惑。</p>
<h3 id="9-我们知道了Tomcat-是怎么启动的，那么是怎么关闭的呢？"><a href="#9-我们知道了Tomcat-是怎么启动的，那么是怎么关闭的呢？" class="headerlink" title="9. 我们知道了Tomcat 是怎么启动的，那么是怎么关闭的呢？"></a>9. 我们知道了Tomcat 是怎么启动的，那么是怎么关闭的呢？</h3><p>顺便说说关闭的逻辑：</p>
<p>shutdown.sh 脚本同样会调用 Bootstrap的main 方法，不同是传递 stop参数， 我们看看如果传递stop参数会怎么样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ry &#123;</span><br><span class="line">            String command = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">&quot;startd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stopd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">                daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;configtest&quot;</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span>==daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Bootstrap: command \&quot;&quot;</span> + command + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br></pre></td></tr></table></figure>
<p>可以看到调用的是 stopServer 方法，实际上就是 Catalina的stopServer 方法，我们看看该方法实现：</p>
<h3 id="10-Catalina-stopServer-方法"><a href="#10-Catalina-stopServer-方法" class="headerlink" title="10. Catalina.stopServer 方法"></a>10. Catalina.stopServer 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopServer</span><span class="params">(String[] arguments)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (arguments != <span class="keyword">null</span>) &#123;</span><br><span class="line">           arguments(arguments);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Server s = getServer();</span><br><span class="line">       <span class="keyword">if</span>( s == <span class="keyword">null</span> ) &#123;</span><br><span class="line">           <span class="comment">// Create and execute our Digester</span></span><br><span class="line">           Digester digester = createStopDigester();</span><br><span class="line">           digester.setClassLoader(Thread.currentThread().getContextClassLoader());</span><br><span class="line">           File file = configFile();</span><br><span class="line">           FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               InputSource is =</span><br><span class="line">                   <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</span><br><span class="line">               fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">               is.setByteStream(fis);</span><br><span class="line">               digester.push(<span class="keyword">this</span>);</span><br><span class="line">               digester.parse(is);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;Catalina.stop: &quot;</span>, e);</span><br><span class="line">               System.exit(<span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       fis.close();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       <span class="comment">// Ignore</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Server object already present. Must be running as a service</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               s.stop();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;Catalina.stop: &quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Stop the existing server</span></span><br><span class="line">       s = getServer();</span><br><span class="line">       <span class="keyword">if</span> (s.getPort()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">           Socket socket = <span class="keyword">null</span>;</span><br><span class="line">           OutputStream stream = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               socket = <span class="keyword">new</span> Socket(s.getAddress(), s.getPort());</span><br><span class="line">               stream = socket.getOutputStream();</span><br><span class="line">               String shutdown = s.getShutdown();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shutdown.length(); i++) &#123;</span><br><span class="line">                   stream.write(shutdown.charAt(i));</span><br><span class="line">               &#125;</span><br><span class="line">               stream.flush();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ConnectException ce) &#123;</span><br><span class="line">               log.error(sm.getString(<span class="string">&quot;catalina.stopServer.connectException&quot;</span>,</span><br><span class="line">                                      s.getAddress(),</span><br><span class="line">                                      String.valueOf(s.getPort())));</span><br><span class="line">               log.error(<span class="string">&quot;Catalina.stop: &quot;</span>, ce);</span><br><span class="line">               System.exit(<span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;Catalina.stop: &quot;</span>, e);</span><br><span class="line">               System.exit(<span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (stream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       stream.close();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       <span class="comment">// Ignore</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       socket.close();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       <span class="comment">// Ignore</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           log.error(sm.getString(<span class="string">&quot;catalina.stopServer&quot;</span>));</span><br><span class="line">           System.exit(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，该停止命令的虚拟机和启动的虚拟机不是一个虚拟机，因此，没有初始化 Server , 进入 IF 块，解析 server.xml 文件，获取文件中端口，用以创建Socket。然后像启动服务器发送 <code>SHUTDOWN</code> 命令，关闭启动服务器，启动服务器退出刚刚的循环，执行后面的 stop 方法，最后退出虚拟机，就是这么简单。</p>
<h3 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h3><p>我们从整体上解析了Tomcat的启动和关闭过程，发现不是很难，为什么？因为我们之前已经分析过很多遍了，有些逻辑我们已经清除了，这次分析只是来扫尾。复杂的Tomcat的启动过程我们基本就分析完了。我们知道了启动和关闭都依赖Socket。只是我们惊奇的发现他的关闭竟然是如此实现。很牛逼。我原以为会像我们平时一样，直接kill。哈哈哈。</p>
<p>好吧。今天我们就到这里 ，tomcat 这座大山我们已经啃的差不多了，还剩一个 URL 请求过程和连接器，这两个部分是高度关联的，因此，楼主也会将他们放在一起分析。透过源码看真相。</p>
<p>连接器，等着我们来撕开你的衣服！！！！</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat(十)-总结</title>
    <url>/2017/11/29/2017/2017-11-29-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat(%E5%8D%81)-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       这篇文章是我们深入理解 Tomcat 的第十篇文章,也是总结文章, 学习就是这样,先是理论,再是实践,最后是总结, 楼主习惯了在每次学习之后总结, 让从脑海中过的知识能够再扎实一点.

<p>我们的第一篇文章 <code>&lt;&lt; 深入理解 Tomcat（一）源码环境搭建和 How Tomcat works 源码&gt;&gt; </code>中介绍了楼主下载的源码和 git 地址, 方便大家去 clone 源码,不然怎么来依据理论去剖析源码实现呢? 楼主认为, 任何一门技术都要借助文档和源码一起去理解(可能是楼主比较菜).  而楼主也放了2个源码,一个是使用 maven 改过的 tomcat 7 源码,一个是名著 &lt;<How Tomcat Works>&gt; 的实例源码, 方便我们更深入的理解 tomcat.</p>
<p>源码环境搭建好了,楼主从网上,从早上… 额,不, 从各个地方看文章, 想了解 tomcat 的结构设计和文档, 当然也搭配楼主从图书馆借来的 <code>&lt;&lt;How Tomcat Works&gt;&gt;</code> 书, 最终写了一篇 <code>&lt;&lt;深入理解 Tomcat (二) 从宏观上理解 Tomcat 组件及架构&gt;&gt;</code>, 我们讲了我们准备如何学习, 以及什么是 Tomcat ,  什么是 Servlet, tomcat 源码目录的解释, tomcat 整体框架的层次结构和架构图, 分析每个组件, 包括 Connector, Container,  Component, 也从接口和类的角度(UML 类图)看架构. 这让我们对 tomcat 整体也有了一个大致的了解, 为我们接下来的分析源码做了铺垫.</p>
<p>我们在大致了解了 tomcat 的整体架构和设计后, 我们想了解一个最简单的 web 服务器是如何实现的, 我们写了一篇<code>&lt;&lt; 深入理解 Tomcat（三）Tomcat 底层实现原理&gt;&gt;</code>, 参照<code>&lt;&lt;How Tomcat Works&gt;&gt;</code>源码实现了一个简单的阻塞式的 Web 服务器, 虽然现在最新的 Tomcat 9 已经将阻塞 socket 去除了,全部使用 NIO 和 JNI 以提高速度, 但他仍是我们学习的一个很好的例子.</p>
<p>在了解原理之后, 我们开始循序渐进, 我们的第一个研究的就是著名的 Tomcat 的类加载机制, 于是我们写了一篇 <code>&lt;&lt; 深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型&gt;&gt;,</code> 先从 java 的类加载器开始分析, 分析双亲委任模型的原理, 以及类加载机制的发展及变化,  最后讲 Tomcat 的类加载机制的设计, 讲 Tomcat 为何破坏双亲委派模型. 也讲了 Tomcat 中每个类加载器的功能. 从理论上了解了 Tomcat 类加载器的设计. 为我们从源码层面理解做了铺垫.</p>
<p>在了解了 Tomcat 的类加载器理论后, 我们第一次开始 debug tomcat 的源码, 写了一篇<code>&lt;&lt;深入理解 Tomcat（五）源码剖析Tomcat 启动过程----类加载过程&gt;&gt;</code>, 从 BootStrap 开始, 我们一步步分析 Tomcat 是如何加载类,加载 jar 包, 是如何将公用的 jar 包使用 common 类加载器, 而私有的 jar 包及 web 应用使用<br> WebAppClassLoader 的. 并且知道了 WebAppClassLoader的加载时间和另外几个的时间不一致. 从源码层面知道了 Tomcat 的类加载设计和机制.</p>
<p>我们继续深入 tomcat, 开始按照我们在第二篇文章中的计划去阅读源码, 我们写了 <code>&lt;&lt; 深入理解 Tomcat（六）源码剖析Tomcat 启动过程----生命周期和容器组件&gt;&gt;</code>,  深入源码去了解 tomcat 是如何设计容器,容器是如何初始化的, 又是如何交给 JMX 去管理对象的. tomcat 的众多容器又是如何通过观察者模式来管理他们的生命周期的. </p>
<p>在了解了 tomcat 的生命周期组件和容器初始化过程后, 我们决定从整体上看看 tomcat 是如何启动的又是如何关闭的, 我们写了 <code>&lt;&lt;深入理解 Tomcat（七）源码剖析 Tomcat 完整启动过程&gt;&gt;</code>并且也见到 tomcat 传说中的钩子. tomcat 的关闭很有趣, 靠着启动一个 socket 去发送SHUTDOWN命令.</p>
<p>之后我们决定去深入另一个很重要的组件—-连接器, 在 <code>&lt;&lt;深入理解 Tomcat（八）源码剖析之连接器&gt;&gt;</code>中, 我们深入源码,  理解了连接器 Connector 的构造过程, 连接器是如何初始化的, 又是如何启动, 启动之后如何监听 Http 请求端口的. 如何处理浏览器发送过来的 socket 请求的.这些实在是太有意思了.</p>
<p>最后我们以一个最常见的请求为基础, 写了 <code>&lt;&lt;深入理解 Tomcat（九）源码剖析之请求过程&gt;&gt;</code>, 理解了一个 HTTP 请求是如何从 socket 到达我们编写的 Servlet 的, 并且了解了tomcat 是如何设计各个容器直接的通信—-使用管道和阀门. 也知道了 tomcat 是如何解析消息头, 如何设计过滤器. 让我们对 tomcat 的认识可以说更加的清晰.我们无意中也发现了 tomcat 7 中关于单例模式的一个潜在 bug(最新的 tomcat 已经修复).</p>
<p>最后, 就到了我们这篇总结的文章, 总的来说, 我们完成了我们最初定制的任务, 剖析了最重要的几个组件, 包括类加载器, 容器, 生命周期管理, 连接器, 管道, 阀门, 从启动过程和请求过程这两条路线去分析源码, 让我们不会在浩瀚的源码世界迷路. 虽然还要一些源码没有阅读, 但我们相信, 我们已经体会到了 tomcat 最重要的东西, 我们也不可能将所有的源码全都阅读一遍, 楼主是万万做不到的.</p>
<p>想想楼主最初阅读源码的目的, 就是好奇 tomcat 到底是如何实现的. 现在, 楼主认为楼主的疑问已经被解答, 接下来, 楼主就要研究另一个 Java 世界中有名的框架了, 楼主不要做个只知道 know how 不知道 know why 的人. </p>
<p>加油!!! good luck !!!!</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat（八）源码剖析之连接器</title>
    <url>/2017/11/24/2017/2017-11-24-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat%EF%BC%88%E5%85%AB%EF%BC%89%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%99%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       这是我们分析tomcat的第八篇文章，这次我们分析连接器，我们早就想分析连接器了，因为各种原因拖了好久。不过也确实复杂。

<p>首先我们之前定义过连接器：</p>
<blockquote>
<p>Tomcat都是在容器里面处理问题的， 而容器又到哪里去取得输入信息呢？ Connector就是专干这个的。 他会把从socket传递过来的数据， 封装成Request, 传递给容器来处理。 通常我们会用到两种Connector,一种叫http connectoer， 用来传递http需求的。 另一种叫AJP， 在我们整合apache与tomcat工作的时候，apache与tomcat之间就是通过这个协议来互动的。 （说到apache与tomcat的整合工作， 通常我们的目的是为了让apache 获取静态资源， 而让tomcat来解析动态的jsp或者servlet。）</p>
</blockquote>
<p>简单来说，连接器就是接收http请求并解析http请求，然后将请求交给servlet容器。</p>
<p>那么在 Tomcat中 ，那个类表示连接器呢？ 答案是 org.apache.catalina.connector.Connector，该类继承自 LifecycleMBeanBase， 也就是说，该类的生命周期归属于容器管理。而该类的父容器是谁呢？ 答案是 org.apache.catalina.core.StandardService，也就是我们的Service 组件，StandardService是该接口的标准实现。StandardService 聚合了 Connector 数组和一个Container 容器，也就验证了我们之前说的一个Service 组件中包含一个Container和多个连接器。</p>
<p>那么连接器什么时候初始化被放入容器和JMX呢?这是个大问题，也是我们今天的主要问题。</p>
<h3 id="1-Tomcat-解析-server-xml-并创建对象"><a href="#1-Tomcat-解析-server-xml-并创建对象" class="headerlink" title="1. Tomcat 解析 server.xml 并创建对象"></a>1. Tomcat 解析 server.xml 并创建对象</h3><p>我们之前扒过启动源码，我们知道，在Catalina 的 load 方法中是初始化容器的方法，所有的容器都是在该方法中初始化的。Connector 也不例外。我们还记得 Tomcat 的conf 目录下的server.xml 文件吗？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JasperListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8061&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log.&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到该配置文件中有2个Connector 标签，有就是说默认有2个连接器。一个是HTTP协议，一个AJP协议。</p>
<p>我们的Connector是什么时候创建的呢？就是在解析这个xml文件的时候，那么是怎么解析的呢？我们平时在解析 xml 的时候经常使用dom4j（真的不喜欢xml，最爱json），而tomcat 使用的是 Digester 解析xml，我们来看看 Catalina.load（） 关于解析并创建容器的关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create and execute our Digester</span></span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line">    digester.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建一个 Digester， 其中的关键代码我们看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Digester digester = <span class="keyword">new</span> Digester();</span><br><span class="line"></span><br><span class="line">digester.addRule(<span class="string">&quot;Server/Service/Connector&quot;</span>,</span><br><span class="line">                         <span class="keyword">new</span> ConnectorCreateRule());</span><br><span class="line">digester.addRule(<span class="string">&quot;Server/Service/Connector&quot;</span>,</span><br><span class="line">                         <span class="keyword">new</span> SetAllPropertiesRule(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;executor&quot;</span>&#125;));</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Service/Connector&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;addConnector&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;org.apache.catalina.connector.Connector&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码的意思是将对应的字符串创建成对应的角色，以便后面和xml对应便解析。</p>
<p>我们再看看它是如何解析的，由于 digester.parse(inputSource) 这个方法调用层次太深，而且该方法只是解析xml，因此楼主把就不把每段代码贴出来了，我们看看IDEA生成的该方法的方法调用栈：这些方法都是在 rt.jar 包中，因此我们不做分析了。主要就是解析xml。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5812cd514b57ad12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图是楼主在 Digester.startDocument 的方法中打的断点。该方法作用为开始解析 xml 做准备。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2640c24d6396199d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图是楼主在 Digester.startElement 的方法中打的断点，startDocument 和 startElement 是多次交替执行的，确定他们执行逻辑的是什么方法呢？从堆栈图中我们可以看到：是 com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse（）这个方法，代码我就不贴出来了，很长没有意义，该方法在 819行间接调用 startDocument，在841行间接调用startElement。上下执行，并且回执行多次。因为 xml 会解析多次嘛。</p>
<p>我们重点说说 startElement 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String namespaceURI, String localName,</span></span></span><br><span class="line"><span class="params"><span class="function">                             String qName, Attributes list)</span> </span>&#123;</span><br><span class="line"> List&lt;Rule&gt; rules = getRules().match(namespaceURI, match);</span><br><span class="line">        matches.push(rules);</span><br><span class="line">        <span class="keyword">if</span> ((rules != <span class="keyword">null</span>) &amp;&amp; (rules.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rules.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Rule rule = rules.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;  Fire begin() for &quot;</span> + rule);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rule.begin(namespaceURI, name, list);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Begin event threw exception&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">throw</span> createSAXException(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Begin event threw error&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>楼主只贴了关键代码，就是for循环中的逻辑，便利 Rule 集合，Rule 是什么呢？是我们之前 createStartDigester 方法里创建的。而 Rule 是一个接口，tomcat 中有很多不同的实现。然后循环调用他们的 begin 方法。我们看看有哪些实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-036007fb3b623be7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="$R_$UQLJE)Z0{F~C0(KVWIG.png"></p>
<p>我们从上图中看到了有很多的实现，而我们今天只关注连接器：也就是 ConnectorCreateRule 的 begin 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(String namespace, String name, Attributes attributes)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Service svc = (Service)digester.peek();</span><br><span class="line">        Executor ex = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ( attributes.getValue(<span class="string">&quot;executor&quot;</span>)!=<span class="keyword">null</span> ) &#123;</span><br><span class="line">            ex = svc.getExecutor(attributes.getValue(<span class="string">&quot;executor&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Connector con = <span class="keyword">new</span> Connector(attributes.getValue(<span class="string">&quot;protocol&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> ( ex != <span class="keyword">null</span> )  _setExecutor(con,ex);</span><br><span class="line">        </span><br><span class="line">        digester.push(con);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>方法不长，我们看看该方法逻辑，该方法首先从List中取出一个Service，然后会分别创建2个连接器，一个是HTTP， 一个是AJP，也就是我们配置文件中写的。</p>
<p>现在，我们已经剖析了tomcat 是如何解析xml的，并如何创建对象的，接下来，我们就看看创建对象的逻辑。</p>
<h3 id="2-创建连接器对象"><a href="#2-创建连接器对象" class="headerlink" title="2. 创建连接器对象"></a>2. 创建连接器对象</h3><p>我们来到我们的Connector类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">     setProtocol(protocol);</span><br><span class="line">     <span class="comment">// Instantiate protocol handler</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);</span><br><span class="line">         <span class="keyword">this</span>.protocolHandler = (ProtocolHandler) clazz.newInstance();<span class="comment">// 反射创建protocolHandler 默认 http1.1 协议实现 （org.apache.coyote.http11.Http11Protocol）</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(sm.getString(</span><br><span class="line">                 <span class="string">&quot;coyoteConnector.protocolHandlerInstantiationFailed&quot;</span>), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我记得阿里规约里说，构造器不要太复杂，复杂的逻辑请放在init里，不知道tomcat这么写算好还是不好呢？嘿嘿。我们还是来看看我们的逻辑吧。</p>
<ol>
<li>根据传进来的字符串设置协议处理器类名（setProtocol 方法中调用了setProtocolHandlerClassName 方法）。</li>
<li>根据刚刚设置好的 protocolHandlerClassName 反射创建 ProtocolHandler 类型的对象。</li>
</ol>
<p>既然是反射创建，那么我们就要看看完整的类名是什么了，所以需要看看设置 protocolHandlerClassName  方法的细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProtocol</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;HTTP/1.1&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                setProtocolHandlerClassName</span><br><span class="line">                    (<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AJP/1.3&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                setProtocolHandlerClassName</span><br><span class="line">                    (<span class="string">&quot;org.apache.coyote.ajp.AjpAprProtocol&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                setProtocolHandlerClassName(protocol);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setProtocolHandlerClassName</span><br><span class="line">                    (<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;HTTP/1.1&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                setProtocolHandlerClassName</span><br><span class="line">                    (<span class="string">&quot;org.apache.coyote.http11.Http11Protocol&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AJP/1.3&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                setProtocolHandlerClassName</span><br><span class="line">                    (<span class="string">&quot;org.apache.coyote.ajp.AjpProtocol&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                setProtocolHandlerClassName(protocol);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此方法会直接进入下面的else块，我们知道，该处可能会传 HTTP 或者 AJP ，根据不同的协议创建不同的协议处理器。也就是连接器，我们看到这里的全限定名是 <code>org.apache.coyote.http11.Http11Protocol</code> 或者 <code>org.apache.coyote.ajp.AjpProtocol</code>，这两个类都是在 coyote 包下，也就是连接器模块。</p>
<p>好了，到现在，我们的 Connector 对象就创建完毕了，创建它的过程同时也根据配置文件创建了 protocolHandler， 他俩是依赖关系。</p>
<h3 id="3-Http11Protocol-协议处理器构造过程"><a href="#3-Http11Protocol-协议处理器构造过程" class="headerlink" title="3. Http11Protocol 协议处理器构造过程"></a>3. Http11Protocol 协议处理器构造过程</h3><p>创建了 Http11Protocol 对象，我们有必要看看他的构造过程是什么样的。按照tomcat的性格，一般构造器都很复杂，所以，我们找到该类，看看他的类和构造器：</p>
<p>该类的类说明是这样说的：</p>
<blockquote>
<p>抽象协议的实现，包括线程等。处理器是单线程的，特定于基于流的协议，不适合像JNI那样的Jk协议。</p>
</blockquote>
<p>我们看看构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Http11Protocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    endpoint = <span class="keyword">new</span> JIoEndpoint();</span><br><span class="line">    cHandler = <span class="keyword">new</span> Http11ConnectionHandler(<span class="keyword">this</span>);</span><br><span class="line">    ((JIoEndpoint) endpoint).setHandler(cHandler);</span><br><span class="line">    setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);</span><br><span class="line">    setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);</span><br><span class="line">    setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我就说嘛，肯定和复杂。复杂也要看啊。</p>
<ol>
<li>创建以了一个 JIoEndpoint 对象。</li>
<li>创建了一个 Http11ConnectionHandler 对象，参数是 Http11Protocol；</li>
<li>设置处理器为 Http11ConnectionHandler  对象。</li>
<li>设置一些属性，比如超时，优化tcp性能。</li>
</ol>
<p>那么我们来看看 JIoEndpoint  这个类，这个类是什么玩意，如果大家平时调试tomcat比较多的话，肯定会熟悉这个类，楼主今天就遇到了，请看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="number">243</span>)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="number">210</span>)</span><br><span class="line">at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:<span class="number">121</span>)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:<span class="number">107</span>)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="number">243</span>)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="number">210</span>)</span><br><span class="line">at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:<span class="number">222</span>)</span><br><span class="line">at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:<span class="number">123</span>)</span><br><span class="line">at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:<span class="number">502</span>)</span><br><span class="line">at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:<span class="number">171</span>)</span><br><span class="line">at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:<span class="number">100</span>)</span><br><span class="line">at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:<span class="number">953</span>)</span><br><span class="line">at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:<span class="number">118</span>)</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:<span class="number">408</span>)</span><br><span class="line">at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:<span class="number">1041</span>)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:<span class="number">603</span>)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:<span class="number">310</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>
<p>异常信息，我们看倒数第四行，就是 JIoEndpoint   的内部类 SocketProcessor 的 run 方法报错了，我们今天就亲密接触一下这个类，顺便扒了它的衣服：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e48f35376f3b42bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>赤裸裸的在我们面前。所有错误的根源都在该方法中。</p>
<p>不扯了，我们继续看 JIoEndpoint 的构造器，该构造器很简单，就是设置最大连接数。默认是0，我们看代码：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-49329c61b697ecfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-dc50624db50626ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图中什么看到该方法将 maxConnections 设置为0，本来是10000，然后进入else if（maxCon &gt; 0） 的逻辑。这里也就完成了 JIoEndpoint 对象的创建过程。</p>
<p>我们回到 Http11Protocol 的构造方法中，执行完了 JIoEndpoint 的创建过程，下面就执行 Http11ConnectionHandler 的构造。参数是Http11Protocol自己，Http11ConnectionHandler 是 Http11Protocol 的静态内部类，该类中有一个属性就是Http11Protocol，一个简单的创建过程，然后设置 Http11Protocol 的 Handler 属性为 Http11ConnectionHandler。可以感觉的到，Http11Protocol， JIoEndpoint ， Http11ConnectionHandler 这三个类是互相依赖关系。</p>
<p>至此，完成了 Http11Protocol  对象的创建。同时也完成了 Connector 对象的创建。 创建完对象干嘛呢。。。。不要想歪了，不是啪啪啪，而是初始化。</p>
<h3 id="4-Connector-连接器的初始化-init-方法"><a href="#4-Connector-连接器的初始化-init-方法" class="headerlink" title="4. Connector 连接器的初始化 init 方法"></a>4. Connector 连接器的初始化 init 方法</h3><p>我们知道 Connector 的父容器是 Service ,Service 执行 initInternal  方法初始化的时候会同时初始化子容器，也就是 Connector，在一个 for 循环重启动。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-dbe62650a374975f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该段代码抽取自 StandardService.initInternal 方法，也就是Service 组件。通过debug我们知道了该连接器数组中只有2个连接器，就是我们的HTTP和AJP，刚刚创建的。并调用他们的 init 方法。我们看看该方法，该方法同所有容器一样，执行了LifecycleBase 的模板方法，重点在子类重写的抽象方法 initInternal 中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a821a17bd45ac041.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这既是 Connector 的 initInternal 方法实现，该方法有几个步骤：</p>
<ol>
<li>调用父类的 initInternal 方法，将自己注册到JMX中。</li>
<li>创建一个 CoyoteAdapter 对象，参数是自己。</li>
<li>设置 Http11Protocol 的适配器为刚刚创建的 CoyoteAdapter 适配器。</li>
<li>设置解析请求的请求方法类型，默认是 POST。</li>
<li><strong>初始化 Http11Protocol</strong>（不要小看这个类，Connector就是一个虚的，真正做事的就是这个类和 JIoEndpoint）；</li>
<li>初始化 mapperListener；</li>
</ol>
<p>我们重点关注 CoyoteAdapter 和 Http11Protocol 的初始化，CoyoteAdapter 是连接器的一种适配，构造参数是 Connector ，很明显，他是要适配 Connector，这里的设计模式就是适配器模式了，所以，写设计模式的时候，一定要在类名上加上设计模式的名字。方便后来人读代码。接下就是设置  Http11Protocol 的适配器为 刚刚构造的 CoyoteAdapter ，也就是说，tomcat 的设计者为了解耦或者什么将 Http11Protocol  和 Connector 中间插入了一个适配器。最后来到我们的 Http11Protocol  的初始化。</p>
<p>这个 Http11Protocol  的初始化很重要。Http11Protocol  不属于 Lifecycle 管理，他的 init 方法在他的抽象父类 org.apache.coyote.AbstractProtocol 中就已经写好了，我们来看看该方法的实现（很重要）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-fc055530b56fb747.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图就是 AbstractProtocol 的 init 方法，我们看看红框中的逻辑。</p>
<ol>
<li>将 endpoint 注册到JMX中。</li>
<li>将 Http11ConnectionHandler（Http11Protocol 的 内部类）注册到JMX中。</li>
<li>设置 endpoint 的名字，Http 连接器是 <code>http-bio-8080</code>;</li>
<li>endpoint 初始化。</li>
</ol>
<p>设置JMX的逻辑我们就不讲了，之前讲生命周期的时候讲过了，设置名字也没生命好讲的。最后讲最重要的 endpoint 的初始化。我们来看看他的 init 方法。该方法是 JIoEndpoint 抽象父类 AbstractEndpoint 的模板方法。该类被3个类继承：AprEndpoint, JIoEndpoint， NioEndpoint，我们今天只关心JIoEndpoint。我们还是先看看 AbstractEndpoint 的 init 方法吧：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0bbea8e4eec2a87e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>其中 bind（）是抽象方法，然后设置状态为绑定已经初始化。我们看看 JIoEndpoint 的 bind 方法。有兴趣也可以看看其他 Endpoint 的 bind 方法，比如NIO。我们看看JIo的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8a39edc151e9ef55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这个方法很重要，我们仔细看看逻辑：</p>
<ol>
<li>设置最大线程数，默认是200；</li>
<li>创建一个默认的 serverSocketFactory 工厂（就是一个封装了ServerSocket 的类）；</li>
<li>使用刚刚工厂创建一个 serverSocket。因此，JIoEndpoint 也就有了 serverSocket。</li>
</ol>
<p> 至此，我们完成了 Connector， Http11Protocol，JIoEndpoint 的初始化。</p>
<p>接下来就是启动了</p>
<h3 id="5-连接器启动"><a href="#5-连接器启动" class="headerlink" title="5. 连接器启动"></a>5. 连接器启动</h3><p>如我们所知，Connector 启动肯定在 startInternal 方法中，因此我们直接看此方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7f7f42c9c8fed78e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法步骤如下：</p>
<ol>
<li>设置启动中状态。状态更新会触发事件监听机制。</li>
<li>启动 org.apache.coyote.http11.Http11Protocol 的 srart 方法。</li>
<li>启动 org.apache.catalina.connector.MapperListener 的 start 方法。</li>
</ol>
<p>我们感兴趣的是 org.apache.coyote.http11.Http11Protocol 的 srart 方法。该方法由其抽象父类 AbstractProtocol.start 执行，我们看看该方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a624d208d6dd6475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法主要逻辑是启动 endpoint 的 start 方法。说明干事的还是 endpoint 啊 ，我们看看该方法实现，该方法调用了抽象父类的模板方法 AbstractEndpoint.start：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4edc4f12c7097fe7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>其主要逻辑是调用子类重写的 startInternal 方法，我们来看 JIoEndpoint 的实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-946e9e8232596dd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法可以说是 Tomcat 中 真正做事情的方法，绝对不是摸鱼员工。说说他的逻辑：</p>
<ol>
<li>创建一个线程阻塞队列，和一个线程池。</li>
<li>初始化最大连接数，默认200.</li>
<li>调用抽象父类 AbstractEndpoint 的 startAcceptorThreads 方法，默认创建一个守护线程。他的任务是<strong>等待客户端请求，并将请求（socket 交给线程池）</strong>。AbstractEndpoint  中有一个 Acceptor 数组，作用接收新的连接和传递请求。</li>
<li>创建一个管理超时socket 的线程。</li>
</ol>
<p>让我们看看他的详细实现：</p>
<h3 id="6-JIoEndpoint-startInternal（Tomcat-socket-管理）-方法的详细实现"><a href="#6-JIoEndpoint-startInternal（Tomcat-socket-管理）-方法的详细实现" class="headerlink" title="6. JIoEndpoint startInternal（Tomcat socket 管理） 方法的详细实现"></a>6. JIoEndpoint startInternal（Tomcat socket 管理） 方法的详细实现</h3><p><strong>先看第一步</strong>：创建一个线程阻塞队列，和一个线程池。我们进入该方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-621a92b09a05f827.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法步骤：</p>
<ol>
<li>创建一个 “任务队列”，实际上是一个继承了 LinkedBlockingQueue<Runnable> 的类。该队列最大长度为 int 最大值 0x7fffffff。</li>
<li>创建一个线程工厂，TaskThreadFactory 是一个继承 ThreadFactory 的类，默认创建最小线程 10， 最大线程200， 名字为 “http-bio-8080-exec-” 拼接线程池编号，优先级为5。</li>
<li>使用上面的线程工厂创建一个线程池，预先创建10个线程，最大线程200，线程空闲实际60秒.</li>
<li>将线程池设置为队列的属性，方便后期判断线程池状态而做一些操作。</li>
</ol>
<p><strong>再看第二步</strong>：初始化最大连接数，默认200.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-38d2672837730e55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法很简单，就是设置最大连接数为200；</p>
<p><strong>第三步</strong>：用抽象父类 AbstractEndpoint 的 startAcceptorThreads 方法，默认创建一个守护线程。他的任务是<strong>等待客户端请求，并将请求（socket 交给线程池）</strong>。AbstractEndpoint  中有一个 Acceptor 数组，作用接收新的连接和传递请求。我们看看该方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c134e88331d02220.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>步骤：</p>
<ol>
<li>获取可接收的连接数，并创建一个连接线程数组。</li>
<li>循环该数组，设置优先级为5，设置为守护线程。</li>
<li>启动该线程。</li>
</ol>
<p>该方法也不是很复杂，获取的这个连接数，在完美初始化的时候，调用bind 方法的时候设置的，请看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-aabd3d3b3715139c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>设置为1.</p>
<p><strong>复杂的是 Acceptor 中的逻辑</strong>，Acceptor 是一个抽象静态内部类，实现了 Runnable 接口，JIoEndpoint 类中也继承了该类，其中 run 方法如下(高能预警，方法很长)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop until we receive a shutdown command</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop if endpoint is paused</span></span><br><span class="line">        <span class="keyword">while</span> (paused &amp;&amp; running) &#123;</span><br><span class="line">            state = AcceptorState.PAUSED;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.RUNNING;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//if we have reached max connections, wait</span></span><br><span class="line">            countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Accept the next incoming connection from the server</span></span><br><span class="line">                <span class="comment">// socket</span></span><br><span class="line">                socket = serverSocketFactory.acceptSocket(serverSocket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                countDownConnection();</span><br><span class="line">                <span class="comment">// Introduce delay if necessary</span></span><br><span class="line">                errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                <span class="comment">// re-throw</span></span><br><span class="line">                <span class="keyword">throw</span> ioe;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Successful accept, reset the error delay</span></span><br><span class="line">            errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Configure the socket</span></span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; !paused &amp;&amp; setSocketOptions(socket)) &#123;</span><br><span class="line">                <span class="comment">// Hand this socket off to an appropriate processor</span></span><br><span class="line">                <span class="keyword">if</span> (!processSocket(socket)) &#123;</span><br><span class="line">                    countDownConnection();</span><br><span class="line">                    <span class="comment">// Close socket right away</span></span><br><span class="line">                    closeSocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                countDownConnection();</span><br><span class="line">                <span class="comment">// Close socket right away</span></span><br><span class="line">                closeSocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (running) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">&quot;endpoint.accept.fail&quot;</span>), x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">            <span class="keyword">if</span> (running) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">&quot;endpoint.accept.fail&quot;</span>), npe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            log.error(sm.getString(<span class="string">&quot;endpoint.accept.fail&quot;</span>), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state = AcceptorState.ENDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实逻辑也还好，不是那么复杂，我们化整为零，一个一个分析，首先判断状态，进入循环，然后设置一些状态，最后进入一个 try 块。</p>
<ol>
<li>执行 countUpOrAwaitConnection 方法，该方法注释说：如果已经达到最大连接，就等待。</li>
<li>阻塞获取socket。</li>
<li>setSocketOptions(socket) 设置 tcp 一些属性优化性能，比如缓冲字符大小，超时等。</li>
<li>执行 processSocket(socket) 方法，将请求包装一下交给线程池执行。</li>
</ol>
<p>我们看看第一个方法 countUpOrAwaitConnection：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e9038e87cdcbfb57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>主要是 latch.countUpOrAwait() 这个方法，我们看看该方法内部实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-56953568b0df5521.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这个 Sync 类 变量是 继承了java.util.concurrent.locks.AbstractQueuedSynchronizer 抽象类（该类是JDK 1.8 新增的），说实话，楼主不熟悉这个类。再一个今天的主题也不是并发，因此放过这个类，给大家一个链接 <a href="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer">深度解析Java 8：AbstractQueuedSynchronizer的实现分析（下）</a>;<br>我们暂时知道这个方法作用是什么就行了，就像注释说的：如果已经达到最大连接，就等待。我们继续我们的分析。</p>
<p>我们跳过设置 tcp 优化，重点查看 processSocket 方法，这个方法是 JIoEndpoint 的，我们看看该方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-cdc69bf7436e5b2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法逻辑是：</p>
<ol>
<li>封装一个 SocketWrapper。</li>
<li>设置长连接时间为100，</li>
<li>然后封装成 SocketProcessor(还记得这个类吗，就是我们刚开始异常信息里出现的类，原来是在这里报错的，哈哈) 交给线程池执行。</li>
</ol>
<p>到这里，我们必须停下来，因为如果继续追踪 SocketProcessor 这个类，这篇文章就停不下来了，楼主想留在下一篇文章慢慢咀嚼。慢慢品味。</p>
<p><strong>第四步</strong>：好了，回到我们的 JIoEndpoint.startInternal 方法，我们已经解析完了 startAcceptorThreads 方法，那么我们继续向下走，看到一个 timeoutThread 线程。创建一个管理超时socket 的线程。设置为了守护线程，名字叫 “http-bio-8080-AsyncTimeout”，优先级为5.</p>
<p>我们看看该程序的实现，还好，代码不多：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2bd3009dfaf06e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看看主要逻辑：</p>
<ol>
<li>获取当前时间；</li>
<li>waitingRequests 的类型是 ConcurrentLinkedQueue&lt;SocketWrapper<Socket>&gt;，一个并发安全的阻塞对垒，里面有包装过的 SocketWrapper。</li>
<li>判断如果该队列中有，则取出，判断如果该socket 设定的超时时间大于0（默认-1），且当前时间大于访问时间，则交给线程池处理。</li>
</ol>
<p>那么什么时候会往该 waitingRequests 里添加呢？我们看过之前的 SocketProcessor. run 方法， 如果 SocketState 的状态是LONG，就设置该 socket 的访问时间为当前时间，并添加进超时队列。而这个超时的判断也非常的复杂，想想也对，任何一个连接都不能随意丢弃。所以需要更严谨的对待，万一是个支付请求呢？</p>
<p>好了，JIoEndpoint 的 startInternal 方法已经执行完毕，总结一下该方法：创建线程池，初始化最大连接数，启动接收请求线程，设置超时线程。可以说tomcat 考虑的很周到。很完美。不过还有更完美的NIO还没有体验。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>今天的文章真是超长啊，谁叫连接器是tomcat中最重要的组件呢？其实还没有讲完呢；我们讲了连接器的如何根据server.xml 创建对象，如何初始化connector 和 endpoint ，如何启动connector，如何启动 endpoint中各个线程。楼主能力有限，暂时先讲这么多，还有很多的东西我们都还没讲，没事，留着下次讲。</p>
<p>天色已晚，楼主该回家了。各位再见！！！！</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Tomcat（九）源码剖析之请求过程</title>
    <url>/2017/11/27/2017/2017-11-27-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Tomcat%EF%BC%88%E4%B9%9D%EF%BC%89%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ***

<p>不知不觉，这已经是我们深入理解tomcat的第九篇文章了，我们在第八篇分析了tomcat的<strong>连接器</strong>，分析了连接器的的Connector，Http11Protocol，Http11ConnectionHandler，JIoEndpoint，Acceptor 等等这些有关连接器的类和组件，当时我们分析到Acceptor的run方法后就停止分析了，因为后面的代码与请求过程高度相关，而且请求过程这段代码时比较复杂的，需要很大的篇幅去讲述。废话不多说，今天我们就开始分析 <code>http://localhost:8080</code> 在tomcat中是如何运作的，是如何到达的Servlet的。</p>
<h2 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h2><p>首先来一张楼主画的序列图，然后，我们这篇文章基本就按照我们的这张图来讲述了。这张图有47个层次的调用，上传到简书就变模糊了，因此楼主将图片放到了github上，大家可以看的清楚一点。</p>
<p><a href="https://raw.githubusercontent.com/stateIs0/Tomcat-Source-Code/master/socketProcessor.png">时序图-点击查看</a></p>
<hr>
<p>楼主这次分析，会先启动tomcat， 然后在</p>
<h2 id="1-JIoEndpoint-分析"><a href="#1-JIoEndpoint-分析" class="headerlink" title="1. JIoEndpoint 分析"></a>1. JIoEndpoint 分析</h2><p>上次我们分析连接器的时候提到了一个干实事不摸鱼的好员工，JIoEndpoint，该类在创建Http11Protocol对象的时候会一起被创建，可以说他们是依赖关系。并且 JIoEndpoint 也包含一个 Http11ConnectionHandler 协议连接处理器类，该类是 Http11Protocol 的静态内部类。而 Http11ConnectionHandler 由依赖 Http11Protocol，可以说三者是一种循环的关系，Http11Protocol 依赖着 JIoEndpoint，Http11ConnectionHandler 依赖着 Http11Protocol ，JIoEndpoint 依赖着 Http11ConnectionHandler 。而处理 HTTP BIO 模式的连接主要由 JIoEndpoint 和它的两个（共4个内部类和一个内部接口）内部类 Acceptor 和 SocketProcessor 完成的。下面是JIoEndpoint 的类结构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-936a78467c562d0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Acceptor 我们在上次分析连接器的时候已经分析过了，它其实是用于接收HTTP 请求的线程。用于从 SocketServer 接受请求。</p>
<p>SocketProcessor 则是我们今天分析的源头，因为从我们的第八篇文章中知道，Acceptor 将请求处理之后会交给 SocketProcessor 进行真正的处理。那么我们就来分析分析该类。</p>
<h2 id="2-SocketProcessor-分析"><a href="#2-SocketProcessor-分析" class="headerlink" title="2. SocketProcessor 分析"></a>2. SocketProcessor 分析</h2><p>首先该类是一个继承了 Runnable 的内部类，还记得在连接器启动的时候，会启动一个线程池，该连接池就是用于执行该线程的。那么我们就看看该类的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * This class is the equivalent of the Worker, but will simply use in an</span></span><br><span class="line"><span class="comment">    * external Executor thread pool.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 这个类相当于工作人员，但是只会在一个外部执行器线程池中使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">protected</span> SocketWrapper&lt;Socket&gt; socket = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">protected</span> SocketStatus status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">SocketProcessor</span><span class="params">(SocketWrapper&lt;Socket&gt; socket)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (socket==<span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">           <span class="keyword">this</span>.socket = socket;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">SocketProcessor</span><span class="params">(SocketWrapper&lt;Socket&gt; socket, SocketStatus status)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>(socket);</span><br><span class="line">           <span class="keyword">this</span>.status = status;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">boolean</span> launch = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">synchronized</span> (socket) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   SocketState state = SocketState.OPEN;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">// SSL handshake</span></span><br><span class="line">                       serverSocketFactory.handshake(socket.getSocket()); <span class="comment">// 什么都不做</span></span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                       ExceptionUtils.handleThrowable(t);</span><br><span class="line">                       <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                           log.debug(sm.getString(<span class="string">&quot;endpoint.err.handshake&quot;</span>), t);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// Tell to close the socket</span></span><br><span class="line">                       state = SocketState.CLOSED;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> ((state != SocketState.CLOSED)) &#123;<span class="comment">// open</span></span><br><span class="line">                       <span class="keyword">if</span> (status == <span class="keyword">null</span>) &#123; <span class="comment">// status == null</span></span><br><span class="line">                           state = handler.process(socket, SocketStatus.OPEN);<span class="comment">// AbstractProtocol.process(); state 变为 close</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123; <span class="comment">// handler == Http11Protocol$Http11ConnectionHandler</span></span><br><span class="line">                           state = handler.process(socket,status); <span class="comment">// state = closed</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (state == SocketState.CLOSED) &#123;</span><br><span class="line">                       <span class="comment">// Close socket</span></span><br><span class="line">                       <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                           log.trace(<span class="string">&quot;Closing socket:&quot;</span>+socket);</span><br><span class="line">                       &#125;</span><br><span class="line">                       countDownConnection();<span class="comment">// 进入该方法</span></span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           socket.getSocket().close(); <span class="comment">// 关闭流</span></span><br><span class="line">                       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                           <span class="comment">// Ignore</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.OPEN ||</span><br><span class="line">                           state == SocketState.UPGRADING  ||</span><br><span class="line">                           state == SocketState.UPGRADED)&#123;</span><br><span class="line">                       socket.setKeptAlive(<span class="keyword">true</span>);</span><br><span class="line">                       socket.access();</span><br><span class="line">                       launch = <span class="keyword">true</span>; <span class="comment">// 此时才走finally try 逻辑</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.LONG) &#123;</span><br><span class="line">                       socket.access();</span><br><span class="line">                       waitingRequests.add(socket);<span class="comment">// 长连接，</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (launch) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           getExecutor().execute(<span class="keyword">new</span> SocketProcessor(socket, SocketStatus.OPEN));</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (RejectedExecutionException x) &#123;</span><br><span class="line">                           log.warn(<span class="string">&quot;Socket reprocessing request was rejected for:&quot;</span>+socket,x);</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="comment">//unable to handle connection at this time</span></span><br><span class="line">                               handler.process(socket, SocketStatus.DISCONNECT);</span><br><span class="line">                           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               countDownConnection();</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                       &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (running) &#123;</span><br><span class="line">                               log.error(sm.getString(<span class="string">&quot;endpoint.launch.fail&quot;</span>),</span><br><span class="line">                                       npe);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           socket = <span class="keyword">null</span>; <span class="comment">// 完成请求</span></span><br><span class="line">           <span class="comment">// Finish up this request</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先该类由2个属性，一个是 SocketWrapper<Socket> ，看名字就知道他其实就是 Socket 的包装类，另一个是 SocketStatus， 也就是 Socket 的状态。我们看看该类的 run 方法的执行逻辑：</p>
<ol>
<li>首先处理socket的SSL。实际上 DefaultServerSocketFactory（也就是我们默认的） 是空的，什么都不做。</li>
<li>判断socket状态，如果是null，则设置为open，执行 Http11ConnectionHandler  的 process 方法。</li>
<li>执行 Http11ConnectionHandler  的 process 方法会返回一个 SocketState，后面会根据该状态执行不同的逻辑，如果是关闭，则减去一个连接数，并且关闭流。如果是开或则升级状态，则进入finally块继续交给线程池执行。如果是长连接，则放入ConcurrentLinkedQueue 队列，供另一个线程 AsyncTimeout 执行（最后还是交给 SocketProcessor 执行 ）；</li>
</ol>
<p>可以看到这个方法不是很复杂，并且我们能感觉到主要逻辑会在第二步，因此我们就进入到第二步的 process 方法中查看。</p>
<h2 id="3-Http11ConnectionHandler-process-方法剖析"><a href="#3-Http11ConnectionHandler-process-方法剖析" class="headerlink" title="3. Http11ConnectionHandler  process 方法剖析"></a>3. Http11ConnectionHandler  process 方法剖析</h2><p>进入handler 的process 方法，实际上是进入了 Http11ConnectionHandler 的父类 AbstractConnectionHandler 的 process 方法，该方法是个模板方法，让我们看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapper&lt;S&gt; socket,</span></span></span><br><span class="line"><span class="params"><span class="function">          SocketStatus status)</span> </span>&#123;</span><br><span class="line">      Processor&lt;S&gt; processor = connections.remove(socket.getSocket()); <span class="comment">// connections 是用于缓存长连接的socket</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (status == SocketStatus.DISCONNECT &amp;&amp; processor == <span class="keyword">null</span>) &#123; <span class="comment">// 如果是断开连接状态且协议处理器为null</span></span><br><span class="line">          <span class="comment">//nothing more to be done endpoint requested a close</span></span><br><span class="line">          <span class="comment">//and there are no object associated with this connection</span></span><br><span class="line">          <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      socket.setAsync(<span class="keyword">false</span>);<span class="comment">// 非异步</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (processor == <span class="keyword">null</span>) &#123;</span><br><span class="line">              processor = recycledProcessors.poll();<span class="comment">// 如果从缓存中没取到，从可以循环使用的 ConcurrentLinkedQueue 获取</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (processor == <span class="keyword">null</span>) &#123;</span><br><span class="line">              processor = createProcessor(); <span class="comment">// 如果还没有，则创建一个</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          initSsl(socket, processor); <span class="comment">// 设置SSL 属性，默认为null，可以配置</span></span><br><span class="line"></span><br><span class="line">          SocketState state = SocketState.CLOSED;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (status == SocketStatus.DISCONNECT &amp;&amp;</span><br><span class="line">                      !processor.isComet()) &#123;</span><br><span class="line">                  <span class="comment">// Do nothing here, just wait for it to get recycled</span></span><br><span class="line">                  <span class="comment">// Don&#x27;t do this for Comet we need to generate an end</span></span><br><span class="line">                  <span class="comment">// event (see BZ 54022)</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processor.isAsync() ||</span><br><span class="line">                      state == SocketState.ASYNC_END) &#123;</span><br><span class="line">                  state = processor.asyncDispatch(status); <span class="comment">// 如果是异步的</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processor.isComet()) &#123;</span><br><span class="line">                  state = processor.event(status); <span class="comment">// 事件驱动？？？</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processor.isUpgrade()) &#123;</span><br><span class="line">                  state = processor.upgradeDispatch(); <span class="comment">// 升级转发？？？</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  state = processor.process(socket); <span class="comment">// 默认的 AbstractHttp11Processor.process</span></span><br><span class="line">              &#125;</span><br><span class="line">    </span><br><span class="line">              <span class="keyword">if</span> (state != SocketState.CLOSED &amp;&amp; processor.isAsync()) &#123;</span><br><span class="line">                  state = processor.asyncPostProcess();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (state == SocketState.UPGRADING) &#123;</span><br><span class="line">                  <span class="comment">// Get the UpgradeInbound handler</span></span><br><span class="line">                  UpgradeInbound inbound = processor.getUpgradeInbound();</span><br><span class="line">                  <span class="comment">// Release the Http11 processor to be re-used</span></span><br><span class="line">                  release(socket, processor, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="comment">// Create the light-weight upgrade processor</span></span><br><span class="line">                  processor = createUpgradeProcessor(socket, inbound);</span><br><span class="line">                  inbound.onUpgradeComplete();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> (state == SocketState.ASYNC_END ||</span><br><span class="line">                  state == SocketState.UPGRADING);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (state == SocketState.LONG) &#123;</span><br><span class="line">              <span class="comment">// In the middle of processing a request/response. Keep the</span></span><br><span class="line">              <span class="comment">// socket associated with the processor. Exact requirements</span></span><br><span class="line">              <span class="comment">// depend on type of long poll</span></span><br><span class="line">              longPoll(socket, processor);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.OPEN) &#123;</span><br><span class="line">              <span class="comment">// In keep-alive but between requests. OK to recycle</span></span><br><span class="line">              <span class="comment">// processor. Continue to poll for the next request.</span></span><br><span class="line">              release(socket, processor, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.SENDFILE) &#123;</span><br><span class="line">              <span class="comment">// Sendfile in progress. If it fails, the socket will be</span></span><br><span class="line">              <span class="comment">// closed. If it works, the socket will be re-added to the</span></span><br><span class="line">              <span class="comment">// poller</span></span><br><span class="line">              release(socket, processor, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.UPGRADED) &#123;</span><br><span class="line">              <span class="comment">// Need to keep the connection associated with the processor</span></span><br><span class="line">              longPoll(socket, processor);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Connection closed. OK to recycle the processor.</span></span><br><span class="line">              <span class="keyword">if</span> (!(processor <span class="keyword">instanceof</span> UpgradeProcessor)) &#123;</span><br><span class="line">                  release(socket, processor, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> state;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(java.net.SocketException e) &#123;</span><br><span class="line">          <span class="comment">// SocketExceptions are normal</span></span><br><span class="line">          getLog().debug(sm.getString(</span><br><span class="line">                  <span class="string">&quot;abstractConnectionHandler.socketexception.debug&quot;</span>), e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">          <span class="comment">// IOExceptions are normal</span></span><br><span class="line">          getLog().debug(sm.getString(</span><br><span class="line">                  <span class="string">&quot;abstractConnectionHandler.ioexception.debug&quot;</span>), e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Future developers: if you discover any other</span></span><br><span class="line">      <span class="comment">// rare-but-nonfatal exceptions, catch them here, and log as</span></span><br><span class="line">      <span class="comment">// above.</span></span><br><span class="line">      <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          ExceptionUtils.handleThrowable(e);</span><br><span class="line">          <span class="comment">// any other exception or error is odd. Here we log it</span></span><br><span class="line">          <span class="comment">// with &quot;ERROR&quot; level, so it will show up even on</span></span><br><span class="line">          <span class="comment">// less-than-verbose logs.</span></span><br><span class="line">          getLog().error(</span><br><span class="line">                  sm.getString(<span class="string">&quot;abstractConnectionHandler.error&quot;</span>), e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Don&#x27;t try to add upgrade processors back into the pool</span></span><br><span class="line">      <span class="keyword">if</span> (!(processor <span class="keyword">instanceof</span> UpgradeProcessor)) &#123;</span><br><span class="line">          release(socket, processor, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该方法很长，我们简略的说一下主要逻辑：</p>
<ol>
<li>从 ConcurrentHashMap 中获取长连接的封装了soceket的处理类。</li>
<li>如果没有，则从循环使用的 ConcurrentLinkedQueue 队列中获取。如果还没有，则调用自己的  createProcessor 直接创建一个。</li>
<li>调用子类的 initSsl 方法，初始化 SSL 属性。如果配置文件没配置，则设置为null。</li>
<li>根据不同的属性调用不同的方法，优先判断是否异步，默认使用同步，也就是 Http11Processor.process 方法。</li>
<li>执行结束后，根据返回的不同的状态调用不同的方法，比如 longPoll，release，参数也不同，默认是 <code> release(socket, processor, true, false)</code>，放入ConcurrentLinkedQueue （recycledProcessors）队列中。</li>
</ol>
<p>我们重点关注 AbstractHttp11Processor.process 方法，该方法是处理socket的主要逻辑。</p>
<h2 id="4-Http11Processor-process-方法解析"><a href="#4-Http11Processor-process-方法解析" class="headerlink" title="4. Http11Processor.process 方法解析"></a>4. Http11Processor.process 方法解析</h2><p>该方法其实是其父类 AbstractHttp11Processor 的方法，特别的长，不知道为什么tomcat的大师们为什么不封装一下，代码这么长真的不太好看。楼主认为一个方法最好不要超过50行。越短越好。楼主无奈，只好贴出楼主简化的代码，大家凑合着看，如果想看详细的源码，可以留言也可以去我的github clone；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapper&lt;S&gt; socketWrapper)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// Setting up the I/O</span></span><br><span class="line">     setSocketWrapper(socketWrapper);</span><br><span class="line">     getInputBuffer().init(socketWrapper, endpoint);<span class="comment">// 设置输入流</span></span><br><span class="line">     getOutputBuffer().init(socketWrapper, endpoint);<span class="comment">// 设置输出流</span></span><br><span class="line"></span><br><span class="line">     prepareRequest();<span class="comment">// 准备请求内容</span></span><br><span class="line"></span><br><span class="line">     adapter.service(request, response); <span class="comment">// 真正处理的方法 CoyoteAdapter</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> SocketState.OPEN;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法步骤：</p>
<ol>
<li>设置socket。</li>
<li>设置输入流和输出流。</li>
<li>继续向下执行。执行 CoyoteAdapter 的service 方法。</li>
<li>返回状态（默认返回 OPEN）供上层判断。</li>
</ol>
<p>我们重点关注 CoyoteAdapter 的service 方法；</p>
<h2 id="5-CoyoteAdapter-service-方法解析"><a href="#5-CoyoteAdapter-service-方法解析" class="headerlink" title="5. CoyoteAdapter.service 方法解析"></a>5. CoyoteAdapter.service 方法解析</h2><p>该方法同样很长，我们看看该方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Service method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(org.apache.coyote.Request req,</span></span></span><br><span class="line"><span class="params"><span class="function">                    org.apache.coyote.Response res)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Request request = (Request) req.getNote(ADAPTER_NOTES); <span class="comment">// 实现了 servlet 标准的 Request</span></span><br><span class="line">    Response response = (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create objects</span></span><br><span class="line">        request = connector.createRequest();</span><br><span class="line">        request.setCoyoteRequest(req);</span><br><span class="line">        response = connector.createResponse();</span><br><span class="line">        response.setCoyoteResponse(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Link objects</span></span><br><span class="line">        request.setResponse(response); <span class="comment">// 互相关联</span></span><br><span class="line">        response.setRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set as notes</span></span><br><span class="line">        req.setNote(ADAPTER_NOTES, request);</span><br><span class="line">        res.setNote(ADAPTER_NOTES, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set query string encoding</span></span><br><span class="line">        req.getParameters().setQueryStringEncoding <span class="comment">// 解析 uri</span></span><br><span class="line">            (connector.getURIEncoding());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connector.getXpoweredBy()) &#123; <span class="comment">// 网站安全狗IIS</span></span><br><span class="line">        response.addHeader(<span class="string">&quot;X-Powered-By&quot;</span>, POWERED_BY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> comet = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> async = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse and set Catalina and configuration specific</span></span><br><span class="line">        <span class="comment">// request parameters</span></span><br><span class="line">        req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">boolean</span> postParseSuccess = postParseRequest(req, request, res, response); <span class="comment">// 解析请求内容</span></span><br><span class="line">        <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">//check valves if we support async</span></span><br><span class="line">            request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">            <span class="comment">// Calling the container 调用 容器</span></span><br><span class="line">            connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); <span class="comment">// 一个复杂的调用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (request.isComet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!response.isClosed() &amp;&amp; !response.isError()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (request.getAvailable() || (request.getContentLength() &gt; <span class="number">0</span> &amp;&amp; (!request.isParametersParsed()))) &#123;</span><br><span class="line">                        <span class="comment">// Invoke a read event right away if there are available bytes</span></span><br><span class="line">                        <span class="keyword">if</span> (event(req, res, SocketStatus.OPEN)) &#123;</span><br><span class="line">                            comet = <span class="keyword">true</span>;</span><br><span class="line">                            res.action(ActionCode.COMET_BEGIN, <span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        comet = <span class="keyword">true</span>;</span><br><span class="line">                        res.action(ActionCode.COMET_BEGIN, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Clear the filter chain, as otherwise it will not be reset elsewhere</span></span><br><span class="line">                    <span class="comment">// since this is a Comet request</span></span><br><span class="line">                    request.setFilterChain(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();</span><br><span class="line">        <span class="keyword">if</span> (asyncConImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            async = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!comet) &#123;</span><br><span class="line">            request.finishRequest();</span><br><span class="line">            response.finishResponse();</span><br><span class="line">            <span class="keyword">if</span> (postParseSuccess &amp;&amp;</span><br><span class="line">                    request.getMappingData().context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Log only if processing was invoked.</span></span><br><span class="line">                <span class="comment">// If postParseRequest() failed, it has already logged it.</span></span><br><span class="line">                <span class="comment">// If context is null this was the start of a comet request</span></span><br><span class="line">                <span class="comment">// that failed and has already been logged.</span></span><br><span class="line">                ((Context) request.getMappingData().context).logAccess(</span><br><span class="line">                        request, response,</span><br><span class="line">                        System.currentTimeMillis() - req.getStartTime(),</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            req.action(ActionCode.POST_REQUEST , <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        req.getRequestProcessor().setWorkerThreadName(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// Recycle the wrapper request and response</span></span><br><span class="line">        <span class="keyword">if</span> (!comet &amp;&amp; !async) &#123;</span><br><span class="line">            request.recycle();</span><br><span class="line">            response.recycle();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clear converters so that the minimum amount of memory</span></span><br><span class="line">            <span class="comment">// is used by this processor</span></span><br><span class="line">            request.clearEncoders();</span><br><span class="line">            response.clearEncoders();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们分析一下该方法的逻辑：</p>
<ol>
<li>创建实现 Servlet 标准的 Request 和 Response。</li>
<li>将Request 和 Response 互相关联。</li>
<li>执行 postParseRequest 解析请求内容。</li>
<li>执行最重要的步骤：connector.getService().getContainer().getPipeline().getFirst().invoke(request, response)；</li>
<li>执行一些清理工作。</li>
</ol>
<h2 id="6-CoyoteAdapter-postParseRequest-方法解析"><a href="#6-CoyoteAdapter-postParseRequest-方法解析" class="headerlink" title="6. CoyoteAdapter.postParseRequest 方法解析"></a>6. CoyoteAdapter.postParseRequest 方法解析</h2><p>我们看看他是如何解析请求的内容的，也就是 postParseRequest  方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">postParseRequest</span><span class="params">(org.apache.coyote.Request req,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Request request,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   org.apache.coyote.Response res,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX the processor may have set a correct scheme and port prior to this point,</span></span><br><span class="line">    <span class="comment">// in ajp13 protocols dont make sense to get the port from the connector...</span></span><br><span class="line">    <span class="comment">// otherwise, use connector configuration</span></span><br><span class="line">    <span class="keyword">if</span> (! req.scheme().isNull()) &#123;</span><br><span class="line">        <span class="comment">// use processor specified scheme to determine secure state</span></span><br><span class="line">        request.setSecure(req.scheme().equals(<span class="string">&quot;https&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// use connector scheme and secure configuration, (defaults to</span></span><br><span class="line">        <span class="comment">// &quot;http&quot; and false respectively)</span></span><br><span class="line">        req.scheme().setString(connector.getScheme());</span><br><span class="line">        request.setSecure(connector.getSecure());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> the code below doesnt belongs to here,</span></span><br><span class="line">    <span class="comment">// this is only have sense</span></span><br><span class="line">    <span class="comment">// in Http11, not in ajp13..</span></span><br><span class="line">    <span class="comment">// At this point the Host header has been processed.</span></span><br><span class="line">    <span class="comment">// Override if the proxyPort/proxyHost are set</span></span><br><span class="line">    String proxyName = connector.getProxyName();</span><br><span class="line">    <span class="keyword">int</span> proxyPort = connector.getProxyPort();</span><br><span class="line">    <span class="keyword">if</span> (proxyPort != <span class="number">0</span>) &#123;</span><br><span class="line">        req.setServerPort(proxyPort);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proxyName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        req.serverName().setString(proxyName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the raw URI to the decodedURI</span></span><br><span class="line">    MessageBytes decodedURI = req.decodedURI();</span><br><span class="line">    decodedURI.duplicate(req.requestURI());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the path parameters. This will:</span></span><br><span class="line">    <span class="comment">//   - strip out the path parameters</span></span><br><span class="line">    <span class="comment">//   - convert the decodedURI to bytes</span></span><br><span class="line">    parsePathParameters(req, request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// URI decoding</span></span><br><span class="line">    <span class="comment">// %xx decoding of the URL</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        req.getURLDecoder().convert(decodedURI, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        res.setStatus(<span class="number">400</span>);</span><br><span class="line">        res.setMessage(<span class="string">&quot;Invalid URI: &quot;</span> + ioe.getMessage());</span><br><span class="line">        connector.getService().getContainer().logAccess(</span><br><span class="line">                request, response, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Normalization</span></span><br><span class="line">    <span class="keyword">if</span> (!normalize(req.decodedURI())) &#123;</span><br><span class="line">        res.setStatus(<span class="number">400</span>);</span><br><span class="line">        res.setMessage(<span class="string">&quot;Invalid URI&quot;</span>);</span><br><span class="line">        connector.getService().getContainer().logAccess(</span><br><span class="line">                request, response, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Character decoding</span></span><br><span class="line">    convertURI(decodedURI, request);</span><br><span class="line">    <span class="comment">// Check that the URI is still normalized</span></span><br><span class="line">    <span class="keyword">if</span> (!checkNormalize(req.decodedURI())) &#123;</span><br><span class="line">        res.setStatus(<span class="number">400</span>);</span><br><span class="line">        res.setMessage(<span class="string">&quot;Invalid URI character encoding&quot;</span>);</span><br><span class="line">        connector.getService().getContainer().logAccess(</span><br><span class="line">                request, response, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the remote principal</span></span><br><span class="line">    String principal = req.getRemoteUser().toString();</span><br><span class="line">    <span class="keyword">if</span> (principal != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.setUserPrincipal(<span class="keyword">new</span> CoyotePrincipal(principal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the authorization type</span></span><br><span class="line">    String authtype = req.getAuthType().toString();</span><br><span class="line">    <span class="keyword">if</span> (authtype != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.setAuthType(authtype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request mapping.</span></span><br><span class="line">    MessageBytes serverName;</span><br><span class="line">    <span class="keyword">if</span> (connector.getUseIPVHosts()) &#123;</span><br><span class="line">        serverName = req.localName();</span><br><span class="line">        <span class="keyword">if</span> (serverName.isNull()) &#123;</span><br><span class="line">            <span class="comment">// well, they did ask for it</span></span><br><span class="line">            res.action(ActionCode.REQ_LOCAL_NAME_ATTRIBUTE, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverName = req.serverName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncStarted()) &#123;</span><br><span class="line">        <span class="comment">//TODO SERVLET3 - async</span></span><br><span class="line">        <span class="comment">//reset mapping data, should prolly be done elsewhere</span></span><br><span class="line">        request.getMappingData().recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> mapRequired = <span class="keyword">true</span>;</span><br><span class="line">    String version = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mapRequired) &#123;</span><br><span class="line">        <span class="keyword">if</span> (version != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Once we have a version - that is it</span></span><br><span class="line">            mapRequired = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This will map the the latest version by default</span></span><br><span class="line">        connector.getMapper().map(serverName, decodedURI, version,</span><br><span class="line">                                  request.getMappingData());</span><br><span class="line">        request.setContext((Context) request.getMappingData().context);</span><br><span class="line">        request.setWrapper((Wrapper) request.getMappingData().wrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Single contextVersion therefore no possibility of remap</span></span><br><span class="line">        <span class="keyword">if</span> (request.getMappingData().contexts == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mapRequired = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is no context at this point, it is likely no ROOT context</span></span><br><span class="line">        <span class="comment">// has been deployed</span></span><br><span class="line">        <span class="keyword">if</span> (request.getContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.setStatus(<span class="number">404</span>);</span><br><span class="line">            res.setMessage(<span class="string">&quot;Not found&quot;</span>);</span><br><span class="line">            <span class="comment">// No context, so use host</span></span><br><span class="line">            Host host = request.getHost();</span><br><span class="line">            <span class="comment">// Make sure there is a host (might not be during shutdown)</span></span><br><span class="line">            <span class="keyword">if</span> (host != <span class="keyword">null</span>) &#123;</span><br><span class="line">                host.logAccess(request, response, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now we have the context, we can parse the session ID from the URL</span></span><br><span class="line">        <span class="comment">// (if any). Need to do this before we redirect in case we need to</span></span><br><span class="line">        <span class="comment">// include the session id in the redirect</span></span><br><span class="line">        String sessionID = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (request.getServletContext().getEffectiveSessionTrackingModes()</span><br><span class="line">                .contains(SessionTrackingMode.URL)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the session ID if there was one</span></span><br><span class="line">            sessionID = request.getPathParameter(</span><br><span class="line">                    SessionConfig.getSessionUriParamName(</span><br><span class="line">                            request.getContext()));</span><br><span class="line">            <span class="keyword">if</span> (sessionID != <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.setRequestedSessionId(sessionID);</span><br><span class="line">                request.setRequestedSessionURL(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Look for session ID in cookies and SSL session</span></span><br><span class="line">        parseSessionCookiesId(req, request);</span><br><span class="line">        parseSessionSslId(request);</span><br><span class="line"></span><br><span class="line">        sessionID = request.getRequestedSessionId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapRequired) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sessionID == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No session means no possibility of needing to remap</span></span><br><span class="line">                mapRequired = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Find the context associated with the session</span></span><br><span class="line">                Object[] objs = request.getMappingData().contexts;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = (objs.length); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    Context ctxt = (Context) objs[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (ctxt.getManager().findSession(sessionID) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Was the correct context already mapped?</span></span><br><span class="line">                        <span class="keyword">if</span> (ctxt.equals(request.getMappingData().context)) &#123;</span><br><span class="line">                            mapRequired = <span class="keyword">false</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// Set version so second time through mapping the</span></span><br><span class="line">                            <span class="comment">// correct context is found</span></span><br><span class="line">                            version = ctxt.getWebappVersion();</span><br><span class="line">                            <span class="comment">// Reset mapping</span></span><br><span class="line">                            request.getMappingData().recycle();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (version == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// No matching context found. No need to re-map</span></span><br><span class="line">                    mapRequired = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mapRequired &amp;&amp; request.getContext().getPaused()) &#123;</span><br><span class="line">            <span class="comment">// Found a matching context but it is paused. Mapping data will</span></span><br><span class="line">            <span class="comment">// be wrong since some Wrappers may not be registered at this</span></span><br><span class="line">            <span class="comment">// point.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// Should never happen</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Reset mapping</span></span><br><span class="line">            request.getMappingData().recycle();</span><br><span class="line">            mapRequired = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Possible redirect</span></span><br><span class="line">    MessageBytes redirectPathMB = request.getMappingData().redirectPath;</span><br><span class="line">    <span class="keyword">if</span> (!redirectPathMB.isNull()) &#123;</span><br><span class="line">        String redirectPath = urlEncoder.encode(redirectPathMB.toString());</span><br><span class="line">        String query = request.getQueryString();</span><br><span class="line">        <span class="keyword">if</span> (request.isRequestedSessionIdFromURL()) &#123;</span><br><span class="line">            <span class="comment">// This is not optimal, but as this is not very common, it</span></span><br><span class="line">            <span class="comment">// shouldn&#x27;t matter</span></span><br><span class="line">            redirectPath = redirectPath + <span class="string">&quot;;&quot;</span> +</span><br><span class="line">                    SessionConfig.getSessionUriParamName(</span><br><span class="line">                        request.getContext()) +</span><br><span class="line">                <span class="string">&quot;=&quot;</span> + request.getRequestedSessionId();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (query != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This is not optimal, but as this is not very common, it</span></span><br><span class="line">            <span class="comment">// shouldn&#x27;t matter</span></span><br><span class="line">            redirectPath = redirectPath + <span class="string">&quot;?&quot;</span> + query;</span><br><span class="line">        &#125;</span><br><span class="line">        response.sendRedirect(redirectPath);</span><br><span class="line">        request.getContext().logAccess(request, response, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter trace method</span></span><br><span class="line">    <span class="keyword">if</span> (!connector.getAllowTrace()</span><br><span class="line">            &amp;&amp; req.method().equalsIgnoreCase(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">        Wrapper wrapper = request.getWrapper();</span><br><span class="line">        String header = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (wrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String[] methods = wrapper.getServletMethods();</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;methods.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;TRACE&quot;</span>.equals(methods[i])) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (header == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        header = methods[i];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        header += <span class="string">&quot;, &quot;</span> + methods[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.setStatus(<span class="number">405</span>);</span><br><span class="line">        res.addHeader(<span class="string">&quot;Allow&quot;</span>, header);</span><br><span class="line">        res.setMessage(<span class="string">&quot;TRACE method is not allowed&quot;</span>);</span><br><span class="line">        request.getContext().logAccess(request, response, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置 请求的消息类型。</li>
<li>设置代理名称和代理端口（如果配置文件有的话）。</li>
<li> 解析URL路径参数。 </li>
<li>转换 URI 的编码。</li>
<li>从Connector 容器中的Mapper 中取出对应的 Context 和 Servlet, 设置 Request 的 WebApp应用和Servlet。如果Context不存在，则返回404。</li>
<li>解析cookie，解析sessionId，设置 SessionId，</li>
<li>判断方法类型是否是 TRACE 类型的方法，如果是，则返回405.不允许该方法进入服务器。</li>
</ol>
<h2 id="7-connector-getService-getContainer-getPipeline-getFirst-invoke-request-response-中的管道与阀门解析"><a href="#7-connector-getService-getContainer-getPipeline-getFirst-invoke-request-response-中的管道与阀门解析" class="headerlink" title="7.connector.getService().getContainer().getPipeline().getFirst().invoke(request, response) 中的管道与阀门解析"></a>7.connector.getService().getContainer().getPipeline().getFirst().invoke(request, response) 中的管道与阀门解析</h2><p>好，解析完 postParseRequest  之后，我们再看看下面的步骤：：connector.getService().getContainer().getPipeline().getFirst().invoke(request, response)，这个链式调用可以说很自信，一点不怕 NPE。很明显，他们很自信，因为再启动过程中就已经设置这些属性了。而这段代码也引出了2个概念，管道和阀，getPipeline 获取管道 Pipeline，getFirst 获取第一个阀。我们先说说什么是管道？什么是阀门？</p>
<p>我们知道，Tomcat 是由容器组成的，容器从大到小的排列依次是：Server–&gt;Service—-&gt;Engine—&gt;Host—&gt;Context—&gt;Wrapper，那么当一个请求过来，从大容器到小容器，他们一个一个的传递，像接力比赛，如果是我们设计，我们可能只需要将让大容器持有小容器就好了，即能够传递了，<strong>但是</strong>，如果在传递的过程中我们需要做一些事情呢？比如校验，比如记录日志，比如记录时间，比如权限，并且我们要保证不能耦合，随时可去除一个功能。我们该怎么办？相信由经验的同学已经想到了。</p>
<p>那就是使用过滤器模式。</p>
<p>众多的过滤器如何管理？使用管道，将过滤器都放在管道中，简直完美！！！</p>
<p>那么Tomcat中 Pipeline 就是刚刚说的管道，过滤器就是阀门 Valve，每个 Pipeline 只持有第一个阀门，后面的就不管了，因为第一个会指向第二个，第二个会指向第三个，便于拆卸。</p>
<p>那么现在是时候看看我们的时序图了，我们先请出一部分：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4381e805e4adf175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从图中我们可以看出：请求从SocketProcessor 进来，然后交给 Http11ConnectionHandler，最后交给 CoyoteAdapter，开始触及容器的管道。CoyoteAdapter 持有一个 Connector 实例，我们再初始化的时候已经知道了，Connector 会获取他对应的容器（一个容器对应多个连接器）StandardService，StandardService会获取他的下级容器 StandardEngine，这个时候，就该获取管道了，管道管理着阀门。阀门接口 Pipeline 只有一个标准实现 StandardPipeline，每个容器都持有该管道实例（在初始化的时候就创建好了）。管道会获取第一个阀门，如果不存在，就返回一个基础阀门（每个容器创建的时候都会放入一个标准的对应的容器阀门作为其基础阀门）。再调用阀门的 invoke 方法，该方法在执行完自己的逻辑之后，便调用子容器的管道中的阀门的 invoke 方法。依次递归。</p>
<p>现在我们图也看了，原理也说了，现在该看代码了，也就是 StandardEnglineValve 阀门的 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Select the appropriate child Host to process this request,</span></span><br><span class="line"><span class="comment"> * based on the requested server name.  If no matching Host can</span></span><br><span class="line"><span class="comment"> * be found, return an appropriate HTTP error.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 根据所请求的服务器名称选择适当的子主机来处理这个请求。如果找不到匹配的主机，则返回一个适当的HTTP错误。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Select the Host to be used for this Request</span></span><br><span class="line">    Host host = request.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">        response.sendError</span><br><span class="line">            (HttpServletResponse.SC_BAD_REQUEST,</span><br><span class="line">             sm.getString(<span class="string">&quot;standardEngine.noHost&quot;</span>, </span><br><span class="line">                          request.getServerName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">        request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask this Host to process this request</span></span><br><span class="line">    host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法很简单，校验该Engline 容器是否含有Host容器，如果不存在，返回400错误，否则继续执行 <code>host.getPipeline().getFirst().invoke(request, response)</code>，可以看到 Host 容器先获取自己的管道，再获取第一个阀门，我们再看看该阀门的 invoke 方法。</p>
<h2 id="8-host-getPipeline-getFirst-invoke-解析"><a href="#8-host-getPipeline-getFirst-invoke-解析" class="headerlink" title="8.  host.getPipeline().getFirst().invoke 解析"></a>8.  host.getPipeline().getFirst().invoke 解析</h2><p>该链式调用获取的不是Basic 阀门，因为他设置了第一个阀门：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Valve <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> basic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的是 AccessLogValve 实例，我们进入 AccessLogValve 的 invoke 方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">        ServletException </span>&#123;</span><br><span class="line">    getNext().invoke(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啥也没做，只是将请求交给了下一个阀门，执行getNext，该方法是其父类 ValveBase 的方法。下一个阀门是谁呢? ErrorReportValve，我们看看该阀门的 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Perform the request</span></span><br><span class="line">       getNext().invoke(request, response);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Throwable throwable =</span><br><span class="line">               (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (request.isAsyncStarted() &amp;&amp; response.getStatus() &lt; <span class="number">400</span> &amp;&amp;</span><br><span class="line">               throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// The response is an error</span></span><br><span class="line">           response.setError();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Reset the response (if possible)</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               response.reset();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">               <span class="comment">// Ignore</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           response.sendError</span><br><span class="line">               (HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       response.setSuspended(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           report(request, response, throwable);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">           ExceptionUtils.handleThrowable(tt);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (request.isAsyncStarted()) &#123;</span><br><span class="line">           request.getAsyncContext().complete();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法首先执行了下个阀门的 invoke 方法。然后根据返回的Request 属性设置一些错误信息。那么下个阀门是谁呢？其实就是基础阀门了：StandardHostValve，该阀门的 invoke 的方法是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Select the Context to be used for this Request</span></span><br><span class="line">       Context context = request.getContext();</span><br><span class="line">       <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">           response.sendError</span><br><span class="line">               (HttpServletResponse.SC_INTERNAL_SERVER_ERROR,</span><br><span class="line">                sm.getString(<span class="string">&quot;standardHost.noContext&quot;</span>));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Bind the context CL to the current thread</span></span><br><span class="line">       <span class="keyword">if</span>( context.getLoader() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">           <span class="comment">// Not started - it should check for availability first</span></span><br><span class="line">           <span class="comment">// This should eventually move to Engine, it&#x27;s generic.</span></span><br><span class="line">           <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">               PrivilegedAction&lt;Void&gt; pa = <span class="keyword">new</span> PrivilegedSetTccl(</span><br><span class="line">                       context.getLoader().getClassLoader());</span><br><span class="line">               AccessController.doPrivileged(pa);                </span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Thread.currentThread().setContextClassLoader</span><br><span class="line">                       (context.getLoader().getClassLoader());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">           request.setAsyncSupported(context.getPipeline().isAsyncSupported());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Don&#x27;t fire listeners during async processing</span></span><br><span class="line">       <span class="comment">// If a request init listener throws an exception, the request is</span></span><br><span class="line">       <span class="comment">// aborted</span></span><br><span class="line">       <span class="keyword">boolean</span> asyncAtStart = request.isAsync(); </span><br><span class="line">       <span class="comment">// An async error page may dispatch to another resource. This flag helps</span></span><br><span class="line">       <span class="comment">// ensure an infinite error handling loop is not entered</span></span><br><span class="line">       <span class="keyword">boolean</span> errorAtStart = response.isError();</span><br><span class="line">       <span class="keyword">if</span> (asyncAtStart || context.fireRequestInitEvent(request)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Ask this Context to process this request</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               context.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               ExceptionUtils.handleThrowable(t);</span><br><span class="line">               <span class="keyword">if</span> (errorAtStart) &#123;</span><br><span class="line">                   container.getLogger().error(<span class="string">&quot;Exception Processing &quot;</span> +</span><br><span class="line">                           request.getRequestURI(), t);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);</span><br><span class="line">                   throwable(request, response, t);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// If the request was async at the start and an error occurred then</span></span><br><span class="line">           <span class="comment">// the async error handling will kick-in and that will fire the</span></span><br><span class="line">           <span class="comment">// request destroyed event *after* the error handling has taken</span></span><br><span class="line">           <span class="comment">// place</span></span><br><span class="line">           <span class="keyword">if</span> (!(request.isAsync() || (asyncAtStart &amp;&amp;</span><br><span class="line">                   request.getAttribute(</span><br><span class="line">                           RequestDispatcher.ERROR_EXCEPTION) != <span class="keyword">null</span>))) &#123;</span><br><span class="line">               <span class="comment">// Protect against NPEs if context was destroyed during a</span></span><br><span class="line">               <span class="comment">// long running request.</span></span><br><span class="line">               <span class="keyword">if</span> (context.getState().isAvailable()) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!errorAtStart) &#123;</span><br><span class="line">                       <span class="comment">// Error page processing</span></span><br><span class="line">                       response.setSuspended(<span class="keyword">false</span>);</span><br><span class="line">   </span><br><span class="line">                       Throwable t = (Throwable) request.getAttribute(</span><br><span class="line">                               RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line">   </span><br><span class="line">                       <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           throwable(request, response, t);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           status(request, response);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">   </span><br><span class="line">                   context.fireRequestDestroyEvent(request);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Access a session (if present) to update last accessed time, based on a</span></span><br><span class="line">       <span class="comment">// strict interpretation of the specification</span></span><br><span class="line">       <span class="keyword">if</span> (ACCESS_SESSION) &#123;</span><br><span class="line">           request.getSession(<span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Restore the context classloader</span></span><br><span class="line">       <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">           PrivilegedAction&lt;Void&gt; pa = <span class="keyword">new</span> PrivilegedSetTccl(</span><br><span class="line">                   StandardHostValve.class.getClassLoader());</span><br><span class="line">           AccessController.doPrivileged(pa);                </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Thread.currentThread().setContextClassLoader</span><br><span class="line">                   (StandardHostValve.class.getClassLoader());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先校验了Request 是否存在 Context，其实在执行 CoyoteAdapter.postParseRequest 方法的时候就设置了，如果Context 不存在，就返回500，接着还是老套路：context.getPipeline().getFirst().invoke，该管道获取的是基础阀门：StandardContextValve，我们还是关注他的 invoke 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Disallow any direct access to resources under WEB-INF or META-INF</span></span><br><span class="line">        MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">        <span class="keyword">if</span> ((requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/META-INF/&quot;</span>, <span class="number">0</span>))</span><br><span class="line">                || (requestPathMB.equalsIgnoreCase(<span class="string">&quot;/META-INF&quot;</span>))</span><br><span class="line">                || (requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/WEB-INF/&quot;</span>, <span class="number">0</span>))</span><br><span class="line">                || (requestPathMB.equalsIgnoreCase(<span class="string">&quot;/WEB-INF&quot;</span>))) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Select the Wrapper to be used for this Request</span></span><br><span class="line">        Wrapper wrapper = request.getWrapper();</span><br><span class="line">        <span class="keyword">if</span> (wrapper == <span class="keyword">null</span> || wrapper.isUnavailable()) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Acknowledge the request</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.sendAcknowledgement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            container.getLogger().error(sm.getString(</span><br><span class="line">                    <span class="string">&quot;standardContextValve.acknowledgeException&quot;</span>), ioe);</span><br><span class="line">            request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">            request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());</span><br><span class="line">        &#125;</span><br><span class="line">        wrapper.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法也只是一些校验，最后卡是调用 <code>wrapper.getPipeline().getFirst().invoke</code>，获取到的也是基础阀门，该阀门是StandardWeapperValve ，我们看看该方法。该方法很重要。</p>
<h2 id="9-wrapper-getPipeline-getFirst-invoke-解析"><a href="#9-wrapper-getPipeline-getFirst-invoke-解析" class="headerlink" title="9. wrapper.getPipeline().getFirst().invoke 解析"></a>9. wrapper.getPipeline().getFirst().invoke 解析</h2><p>该方法超长:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize local variables we may need</span></span><br><span class="line">    <span class="keyword">boolean</span> unavailable = <span class="keyword">false</span>;</span><br><span class="line">    Throwable throwable = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// This should be a Request attribute...</span></span><br><span class="line">    <span class="keyword">long</span> t1=System.currentTimeMillis();</span><br><span class="line">    requestCount++;</span><br><span class="line">    StandardWrapper wrapper = (StandardWrapper) getContainer();</span><br><span class="line">    Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">    Context context = (Context) wrapper.getParent();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check for the application being marked unavailable</span></span><br><span class="line">    <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardContext.isUnavailable&quot;</span>));</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for the servlet being marked unavailable</span></span><br><span class="line">    <span class="keyword">if</span> (!unavailable &amp;&amp; wrapper.isUnavailable()) &#123;</span><br><span class="line">        container.getLogger().info(sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                wrapper.getName()));</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Retry-After&quot;</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                    sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                    sm.getString(<span class="string">&quot;standardWrapper.notFound&quot;</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a servlet instance to process this request</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!unavailable) &#123;</span><br><span class="line">            servlet = wrapper.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">        container.getLogger().error(</span><br><span class="line">                sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>,</span><br><span class="line">                        wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Retry-After&quot;</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardWrapper.notFound&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), StandardWrapper.getRootCause(e));</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">        servlet = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify if the request is Comet related now that the servlet has been allocated</span></span><br><span class="line">    <span class="keyword">boolean</span> comet = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (servlet <span class="keyword">instanceof</span> CometProcessor &amp;&amp; request.getAttribute(</span><br><span class="line">            Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) &#123;</span><br><span class="line">        comet = <span class="keyword">true</span>;</span><br><span class="line">        request.setComet(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">    DispatcherType dispatcherType = DispatcherType.REQUEST;</span><br><span class="line">    <span class="keyword">if</span> (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; </span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</span><br><span class="line">            requestPathMB);</span><br><span class="line">    <span class="comment">// Create the filter chain for this request</span></span><br><span class="line">    ApplicationFilterFactory factory =</span><br><span class="line">        ApplicationFilterFactory.getInstance();</span><br><span class="line">    ApplicationFilterChain filterChain =</span><br><span class="line">        factory.createFilterChain(request, wrapper, servlet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Reset comet flag value after creating the filter chain</span></span><br><span class="line">    request.setComet(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the filter chain for this request</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> This also calls the servlet&#x27;s service() method</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// Swallow output if needed</span></span><br><span class="line">            <span class="keyword">if</span> (context.getSwallowOutput()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SystemLogHandler.startCapture();</span><br><span class="line">                    <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                        <span class="comment">//TODO SERVLET3 - async</span></span><br><span class="line">                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comet) &#123;</span><br><span class="line">                        filterChain.doFilterEvent(request.getEvent());</span><br><span class="line">                        request.setComet(<span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        filterChain.doFilter(request.getRequest(), </span><br><span class="line">                                response.getResponse());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    String log = SystemLogHandler.stopCapture();</span><br><span class="line">                    <span class="keyword">if</span> (log != <span class="keyword">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        context.getLogger().info(log);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                    <span class="comment">//TODO SERVLET3 - async</span></span><br><span class="line">                    ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comet) &#123;</span><br><span class="line">                    request.setComet(<span class="keyword">true</span>);</span><br><span class="line">                    filterChain.doFilterEvent(request.getEvent());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterChain.doFilter</span><br><span class="line">                        (request.getRequest(), response.getResponse());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientAbortException e) &#123;</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">&quot;standardWrapper.serviceException&quot;</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">&quot;standardWrapper.serviceException&quot;</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        <span class="comment">//            throwable = e;</span></span><br><span class="line">        <span class="comment">//            exception(request, response, e);</span></span><br><span class="line">        wrapper.unavailable(e);</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Retry-After&quot;</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                        sm.getString(<span class="string">&quot;standardWrapper.notFound&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do not save exception in &#x27;throwable&#x27;, because we</span></span><br><span class="line">        <span class="comment">// do not want to do exception(request, response, e) processing</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        Throwable rootCause = StandardWrapper.getRootCause(e);</span><br><span class="line">        <span class="keyword">if</span> (!(rootCause <span class="keyword">instanceof</span> ClientAbortException)) &#123;</span><br><span class="line">            container.getLogger().error(sm.getString(</span><br><span class="line">                    <span class="string">&quot;standardWrapper.serviceExceptionRoot&quot;</span>,</span><br><span class="line">                    wrapper.getName(), context.getName(), e.getMessage()),</span><br><span class="line">                    rootCause);</span><br><span class="line">        &#125;</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">&quot;standardWrapper.serviceException&quot;</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the filter chain (if any) for this request</span></span><br><span class="line">    <span class="keyword">if</span> (filterChain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.isComet()) &#123;</span><br><span class="line">            <span class="comment">// If this is a Comet request, then the same chain will be used for the</span></span><br><span class="line">            <span class="comment">// processing of all subsequent events.</span></span><br><span class="line">            filterChain.reuse();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            filterChain.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate the allocated servlet instance</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (servlet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wrapper.deallocate(servlet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.deallocateException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            throwable = e;</span><br><span class="line">            exception(request, response, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this servlet has been marked permanently unavailable,</span></span><br><span class="line">    <span class="comment">// unload it and release this instance</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">            (wrapper.getAvailable() == Long.MAX_VALUE)) &#123;</span><br><span class="line">            wrapper.unload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.unloadException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            throwable = e;</span><br><span class="line">            exception(request, response, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> t2=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> time=t2-t1;</span><br><span class="line">    processingTime += time;</span><br><span class="line">    <span class="keyword">if</span>( time &gt; maxTime) maxTime=time;</span><br><span class="line">    <span class="keyword">if</span>( time &lt; minTime) minTime=time;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析一下该方法的重要步骤：</p>
<ol>
<li>获取 StandardWrapper（封装了Servlet） 实例调用 allocate 方法获取 Stack 中的 Servlet 实例；</li>
<li>判断servlet 是否实现了 CometProcessor 接口，如果实现了则设置 request 的comet（<a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/">Comet：基于 HTTP 长连接的“服务器推”技术</a>） 属性为 true。</li>
<li>获取 ApplicationFilterFactory 单例（注意：这个获取单例的代码是有线程安全问题的），调用该单例的 createFilterChain 方法获取 ApplicationFilterChain 过滤器链实例。</li>
<li>执行过滤器链 filterChain 的 doFilter 方法。该方法会循环执行所有的过滤器，最终执行 servlet 的 servie 方法。</li>
</ol>
<p>我们分析一下 allocate 方法。</p>
<h2 id="10-StandardWrapper-allcate-获取-Servlet-实例方法解析"><a href="#10-StandardWrapper-allcate-获取-Servlet-实例方法解析" class="headerlink" title="10. StandardWrapper.allcate 获取 Servlet 实例方法解析"></a>10. StandardWrapper.allcate 获取 Servlet 实例方法解析</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Servlet <span class="title">allocate</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// If we are currently unloading this servlet, throw an exception</span></span><br><span class="line">     <span class="keyword">if</span> (unloading)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">           (sm.getString(<span class="string">&quot;standardWrapper.unloading&quot;</span>, getName()));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> newInstance = <span class="keyword">false</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// If not SingleThreadedModel, return the same instance every time</span></span><br><span class="line">     <span class="keyword">if</span> (!singleThreadModel) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Load and initialize our instance if necessary</span></span><br><span class="line">         <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                             log.debug(<span class="string">&quot;Allocating non-STM instance&quot;</span>);</span><br><span class="line"></span><br><span class="line">                         instance = loadServlet();</span><br><span class="line">                         <span class="keyword">if</span> (!singleThreadModel) &#123;</span><br><span class="line">                             <span class="comment">// For non-STM, increment here to prevent a race</span></span><br><span class="line">                             <span class="comment">// condition with unload. Bug 43683, test case</span></span><br><span class="line">                             <span class="comment">// #3</span></span><br><span class="line">                             newInstance = <span class="keyword">true</span>;</span><br><span class="line">                             countAllocated.incrementAndGet();</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                         <span class="keyword">throw</span> e;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                         ExceptionUtils.handleThrowable(e);</span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">                             (sm.getString(<span class="string">&quot;standardWrapper.allocate&quot;</span>), e);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!instanceInitialized) &#123;</span><br><span class="line">             initServlet(instance);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (singleThreadModel) &#123;</span><br><span class="line">             <span class="keyword">if</span> (newInstance) &#123;</span><br><span class="line">                 <span class="comment">// Have to do this outside of the sync above to prevent a</span></span><br><span class="line">                 <span class="comment">// possible deadlock</span></span><br><span class="line">                 <span class="keyword">synchronized</span> (instancePool) &#123;</span><br><span class="line">                     instancePool.push(instance);</span><br><span class="line">                     nInstances++;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">                 log.trace(<span class="string">&quot;  Returning non-STM instance&quot;</span>);</span><br><span class="line">             <span class="comment">// For new instances, count will have been incremented at the</span></span><br><span class="line">             <span class="comment">// time of creation</span></span><br><span class="line">             <span class="keyword">if</span> (!newInstance) &#123;</span><br><span class="line">                 countAllocated.incrementAndGet();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> (instance);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (instancePool) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (countAllocated.get() &gt;= nInstances) &#123;</span><br><span class="line">             <span class="comment">// Allocate a new instance if possible, or else wait</span></span><br><span class="line">             <span class="keyword">if</span> (nInstances &lt; maxInstances) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     instancePool.push(loadServlet());</span><br><span class="line">                     nInstances++;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> e;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                     ExceptionUtils.handleThrowable(e);</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">                         (sm.getString(<span class="string">&quot;standardWrapper.allocate&quot;</span>), e);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     instancePool.wait();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     <span class="comment">// Ignore</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (log.isTraceEnabled())</span><br><span class="line">             log.trace(<span class="string">&quot;  Returning allocated STM instance&quot;</span>);</span><br><span class="line">         countAllocated.incrementAndGet();</span><br><span class="line">         <span class="keyword">return</span> instancePool.pop();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>该方法很长，我们来看看该方法步骤： 判断该类（StandardWrapper）中的 Servlet 实例是否为null，默认不为null，该实例在初始化的时候就已经注入，如果没有注入，则调用 loadServlet 方法，反射加载实例（注意，如果这个servlet 实现了 singleThreadModel 接口，该StandardWrapper 就是多个servlet 实例的，默认是单个实例，多个实例会放入一个Stack（这个栈不是早就不建议使用了吗） 类型的栈中）。</p>
<h2 id="11-ApplicationFilterFactory-解析（tomcat-7-会有并发问题）"><a href="#11-ApplicationFilterFactory-解析（tomcat-7-会有并发问题）" class="headerlink" title="11. ApplicationFilterFactory 解析（tomcat 7 会有并发问题）"></a>11. ApplicationFilterFactory 解析（tomcat 7 会有并发问题）</h2><p>获取创建过滤器链工厂的单例，但楼主看了代码，发现该代码一定会有问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationFilterFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> ApplicationFilterFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读过楼主 <code>深入解析单例模式</code> 的文章应该知道，这种写法并发的时候一定是有问题的，会创建多个实例。但是楼主下载了最新的 tomcat 源码，已经解决了该 bug，新的 tomcat 已经把 getInstance 去除了，将 createFilterChain 方法改为静态方法。</p>
<p>获取过滤器工厂链后，创建过滤器链实例，从该Wrapper 中获取父容器，从父容器 StandardContext 中获取实例，从该实例中获取 filterMaps，该 filterMaps 在初始化容器时从web.xml 中创建。</p>
<h2 id="12-执行过滤器链的-doFilter-方法"><a href="#12-执行过滤器链的-doFilter-方法" class="headerlink" title="12. 执行过滤器链的 doFilter 方法"></a>12. 执行过滤器链的 doFilter 方法</h2><p>该方法主要执行  ApplicationFilterChain.internalDoFilter() 方法，那么 方法 internalDoFilter 内部又是如何实现的呢？下面时该方法的主要逻辑（主要时楼主字数受限了）：<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Call the next filter if there is one</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">      filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  servlet.service(request, response);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，ApplicationFilterChain 中维护了2个变量，当前位置 pos 和 过滤器数量，因此要执行完所有的过滤器，而过滤器最终又会执行 doFilter 方法，就会又回到该方法，直到执行完所有的过滤器，最后执行 servlet 的 service 方法。到这里，一个完整的http请求就从socket 到了我们编写的servlet中了。</p>
<h2 id="13-总结"><a href="#13-总结" class="headerlink" title="13. 总结"></a>13. 总结</h2><p>终于，我们完成了对tomcat请求过程的剖析，详细理解了tomcat是如何处理一个http请求，也完了我们最初的计划，下一篇就是总结我们的前9篇文章，敬请期待。</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title>自己动手实现一个简单的-IOC</title>
    <url>/2017/12/05/2017/2017-12-05-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-IOC/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       再上一篇文章中，楼主和大家一起分析spring的 IOC 实现，剖析了Spring的源码，看的出来，源码异常复杂，这是因为Spring的设计者需要考虑到框架的扩展性，健壮性，性能等待元素，因此设计的很复杂。楼主在最后也说要实现一个简单的 IOC，让我们更加深刻的理解IOC，因此，有了这篇文章。

<p>当然我们是仿照Spring 的 IOC，因此代码命名和设计基本是仿照spring的。</p>
<p>我们将分为几步来编写简易 IOC，首先设计组件，再设计接口，然后关注实现。</p>
<h2 id="1-设计组件。"><a href="#1-设计组件。" class="headerlink" title="1. 设计组件。"></a>1. 设计组件。</h2><p>我们还记得Spring中最重要的有哪些组件吗？<code>BeanFactory</code> 容器，<code>BeanDefinition</code> Bean的基本数据结构，当然还需要加载Bean的<code>资源加载器</code>。大概最后最重要的就是这几个组件。容器用来存放初始化好的Bean，BeanDefinition 就是Bean的基本数据结构，比如Bean的名称，Bean的属性 <code>PropertyValue</code>，Bean的方法，是否延迟加载，依赖关系等。资源加载器就简单了，就是一个读取XML配置文件的类，读取每个标签并解析。</p>
<h2 id="2-设计接口"><a href="#2-设计接口" class="headerlink" title="2. 设计接口"></a>2. 设计接口</h2><p>首先肯定需要一个BeanFactory，就是Bean容器，容器接口至少有2个最简单的方法，一个是获取Bean，一个注册Bean.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要一个beanFactory 定义ioc 容器的一些行为 比如根据名称获取bean， 比如注册bean，参数为bean的名称，bean的定义</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2017/11/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据bean的名称从容器中获取bean对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name bean 名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> bean实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将bean注册到容器中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name bean 名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> bean bean实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition bean)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据Bean的名字获取Bean对象，注册参数有2个，一个是Bean的名字，一个是 BeanDefinition 对象。</p>
<p>定义完了Bean最基本的容器，还需要一个最简单 BeanDefinition  接口，我们为了方便，但因为我们这个不必考虑扩展，因此可以直接设计为类，BeanDefinition  需要哪些元素和方法呢？ 需要一个 Bean 对象，一个Class对象，一个ClassName字符串，还需要一个元素集合 PropertyValues。这些就能组成一个最基本的 BeanDefinition 类了。那么需要哪些方法呢？其实就是这些属性的get set 方法。 我们看看该类的详细：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thinkinjava.myspring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean 的定义</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * bean</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * bean 的 CLass 对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Class beanClass;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * bean 的类全限定名称</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String ClassName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 类的属性集合</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> PropertyValues propertyValues = <span class="keyword">new</span> PropertyValues();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取bean对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置bean的对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bean = bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取bean的Class对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class <span class="title">getBeanclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanClass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过设置类名称反射生成Class对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassname</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ClassName = name;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanClass = Class.forName(name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取bean的属性集合</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertyValues;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置bean的属性</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues pv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.propertyValues = pv;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了基本的 BeanDefinition 数据结构，还需要一个从XML中读取并解析为 BeanDefinition 的操作类，首先我们定义一个 BeanDefinitionReader 接口，该接口只是一个标识，具体由抽象类去实现一个基本方法和定义一些基本属性，比如一个读取时需要存放的注册容器，还需要一个委托一个资源加载器 ResourceLoader， 用于加载XML文件，并且我们需要设置该构造器必须含有资源加载器，当然还有一些get set 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thinkinjava.myspring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的bean定义读取类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册bean容器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; registry;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 资源加载器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造器器必须有一个资源加载器， 默认插件创建一个map容器</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> resourceLoader 资源加载器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取容器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, BeanDefinition&gt; <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取资源加载器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resourceLoader;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了这几个抽象类和接口，我们基本能形成一个雏形，BeanDefinitionReader 用于从XML中读取配置文件，生成 BeanDefinition 实例，存放在 BeanFactory 容器中，初始化之后，就可以调用 getBean 方法获取初始化成功的Bean。形成一个完美的闭环。</p>
<h2 id="3-如何实现"><a href="#3-如何实现" class="headerlink" title="3. 如何实现"></a>3. 如何实现</h2><p>刚刚我们说了具体的流程：从XML中读取配置文件， 解析成 BeanDefinition，最终放进容器。说白了就3步。那么我们就先来设计第一步。</p>
<h3 id="1-从XML中读取配置文件，-解析成-BeanDefinition"><a href="#1-从XML中读取配置文件，-解析成-BeanDefinition" class="headerlink" title="1.  从XML中读取配置文件， 解析成 BeanDefinition"></a>1.  从XML中读取配置文件， 解析成 BeanDefinition</h3><p>我们刚刚设计了一个读取BeanDefinition 的接口 BeanDefinitionReader 和一个实现它的抽象类 AbstractBeanDefinitionReader，抽象了定义了一些简单的方法，其中由一个委托类—–ResourceLoader， 我们还没有创建， 该类是资源加载器，根据给定的路径来加载资源。我们可以使用Java 默认的类库 java.net.URL 来实现，定义两个类，一个是包装了URL的类 ResourceUrl， 一个是依赖 ResourceUrl 的资源加载类。</p>
<p><strong>ResourceUrl 代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceUrl</span> <span class="keyword">implements</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 类库URL</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 需要一个类库URL</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResourceUrl</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从URL中获取输入流</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputstream</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    URLConnection urlConnection = url.openConnection();</span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    <span class="keyword">return</span> urlConnection.getInputStream();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ResourceLoader 实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceUrl</span> <span class="keyword">implements</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 类库URL</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 需要一个类库URL</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResourceUrl</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从URL中获取输入流</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputstream</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    URLConnection urlConnection = url.openConnection();</span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    <span class="keyword">return</span> urlConnection.getInputStream();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还需要一个接口，只定义了一个抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thinkinjava.myspring.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源定义</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取输入流</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">InputStream <span class="title">getInputstream</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好了， AbstractBeanDefinitionReader 需要的元素已经有了， 但是，很明显该方法不能实现读取 BeanDefinition 的任务。那么我们需要一个类去继承抽象类，去实现具体的方法， 既然我们是XML 配置文件读取，那么我们就定义一个 XmlBeanDefinitionReader 继承 AbstractBeanDefinitionReader ，实现一些我们需要的方法， 比如读取XML 的readrXML， 比如将解析出来的元素注册到 registry 的 Map 中， 一些解析的细节。我们还是看代码吧。 </p>
<p><strong>XmlBeanDefinitionReader  实现读取配置文件并解析成Bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thinkinjava.myspring.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.AbstractBeanDefinitionReader;</span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.BeanReference;</span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.PropertyValue;</span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Element;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析XML文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造器，必须包含一个资源加载器</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> resourceLoader 资源加载器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(resourceLoader);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readerXML</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个资源加载器</span></span><br><span class="line">    ResourceLoader resourceloader = <span class="keyword">new</span> ResourceLoader();</span><br><span class="line">    <span class="comment">// 从资源加载器中获取输入流</span></span><br><span class="line">    InputStream inputstream = resourceloader.getResource(location).getInputstream();</span><br><span class="line">    <span class="comment">// 获取文档建造者工厂实例</span></span><br><span class="line">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">    <span class="comment">// 工厂创建文档建造者</span></span><br><span class="line">    DocumentBuilder docBuilder = factory.newDocumentBuilder();</span><br><span class="line">    <span class="comment">// 文档建造者解析流 返回文档对象</span></span><br><span class="line">    Document doc = docBuilder.parse(inputstream);</span><br><span class="line">    <span class="comment">// 根据给定的文档对象进行解析，并注册到bean容器中</span></span><br><span class="line">    registerBeanDefinitions(doc);</span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    inputstream.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据给定的文档对象进行解析，并注册到bean容器中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> doc 文档对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取文档的根元素</span></span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    <span class="comment">// 解析元素的根节点及根节点下的所有子节点并添加进注册容器</span></span><br><span class="line">    parseBeanDefinitions(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析元素的根节点及根节点下的所有子节点并添加进注册容器</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> root XML 文件根节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取根元素的所有子元素</span></span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="comment">// 遍历子元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      <span class="comment">// 获取根元素的给定位置的节点</span></span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="comment">// 类型判断</span></span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        <span class="comment">// 强转为父类型元素</span></span><br><span class="line">        Element ele = (Element) node;</span><br><span class="line">        <span class="comment">// 解析给给定的节点，包括name，class，property， name， value，ref</span></span><br><span class="line">        processBeanDefinition(ele);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析给给定的节点，包括name，class，property， name， value，ref</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> ele XML 解析元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取给定元素的 name 属性</span></span><br><span class="line">    String name = ele.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取给定元素的 class 属性</span></span><br><span class="line">    String className = ele.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建一个bean定义对象</span></span><br><span class="line">    BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">    <span class="comment">// 设置bean 定义对象的 全限定类名</span></span><br><span class="line">    beanDefinition.setClassname(className);</span><br><span class="line">    <span class="comment">// 向 bean 注入配置文件中的成员变量</span></span><br><span class="line">    addPropertyValues(ele, beanDefinition);</span><br><span class="line">    <span class="comment">// 向注册容器 添加bean名称和bean定义</span></span><br><span class="line">    getRegistry().put(name, beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加配置文件中的属性元素到bean定义实例中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> ele 元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beandefinition bean定义 对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPropertyValues</span><span class="params">(Element ele, BeanDefinition beandefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取给定元素的 property 属性集合</span></span><br><span class="line">    NodeList propertyNode = ele.getElementsByTagName(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">    <span class="comment">// 循环集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i++) &#123;</span><br><span class="line">      <span class="comment">// 获取集合中某个给定位置的节点</span></span><br><span class="line">      Node node = propertyNode.item(i);</span><br><span class="line">      <span class="comment">// 类型判断</span></span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        <span class="comment">// 将节点向下强转为子元素</span></span><br><span class="line">        Element propertyEle = (Element) node;</span><br><span class="line">        <span class="comment">// 元素对象获取 name 属性</span></span><br><span class="line">        String name = propertyEle.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 元素对象获取 value 属性值</span></span><br><span class="line">        String value = propertyEle.getAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断value不为空</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 向给定的 “bean定义” 实例中添加该成员变量</span></span><br><span class="line">          beandefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果为空，则获取属性ref</span></span><br><span class="line">          String ref = propertyEle.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果属性ref为空，则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;</span></span><br><span class="line">                    + name + <span class="string">&quot;&#x27; must specify a ref or value&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果不为空，测创建一个 “bean的引用” 实例，构造参数为名称，实例暂时为空</span></span><br><span class="line">          BeanReference beanRef = <span class="keyword">new</span> BeanReference(name);</span><br><span class="line">          <span class="comment">// 向给定的 “bean定义” 中添加成员变量</span></span><br><span class="line">          beandefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanRef));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以说代码注释写的非常详细，该类方法如下：</p>
<ol>
<li>public void readerXML(String location) 公开的解析XML的方法，给定一个位置的字符串参数即可。</li>
<li>private void registerBeanDefinitions(Document doc) 给定一个文档对象，并进行解析。</li>
<li>private void parseBeanDefinitions(Element root) 给定一个根元素，循环解析根元素下所有子元素。</li>
<li>private void processBeanDefinition(Element ele) 给定一个子元素，并对元素进行解析，然后拿着解析出来的数据创建一个 BeanDefinition 对象。并注册到BeanDefinitionReader 的 Map 容器（该容器存放着解析时的所有Bean）中。</li>
<li> private void addPropertyValues(Element ele, BeanDefinition beandefinition) 给定一个元素，一个 BeanDefinition 对象，解析元素中的  property 元素， 并注入到 BeanDefinition  实例中。</li>
</ol>
<p>一共5步，完成了解析XML文件的所有操作。 最终的目的是将解析出来的文件放入到 BeanDefinitionReader 的 Map 容器中。</p>
<p>好了，到这里，我们已经完成了从XML文件读取并解析的步骤，那么什么时候放进BeanFactory的容器呢？ 刚刚我们只是放进了 AbstractBeanDefinitionReader 的注册容器中。因此我们要根据BeanFactory 的设计来实现如何构建成一个真正能用的Bean呢？因为刚才的哪些Bean只是一些Bean的信息。没有我们真正业务需要的Bean。</p>
<h3 id="2-初始化我们需要的Bean（不是Bean定义）并且实现依赖注入"><a href="#2-初始化我们需要的Bean（不是Bean定义）并且实现依赖注入" class="headerlink" title="2. 初始化我们需要的Bean（不是Bean定义）并且实现依赖注入"></a>2. 初始化我们需要的Bean（不是Bean定义）并且实现依赖注入</h3><p>我们知道Bean定义是不能干活的，只是一些Bean的信息，就好比一个人，BeanDefinition 就相当你在公安局的档案，但是你人不在公安局，可只要公安局拿着你的档案就能找到你。就是这样一个关系。</p>
<p>那我们就根据BeanFactory的设计来设计一个抽象类 AbstractBeanFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thinkinjava.myspring.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个抽象类， 实现了 bean 的方法，包含一个map，用于存储bean 的名字和bean的定义</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 容器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, BeanDefinition&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据bean的名称获取bean， 如果没有，则抛出异常 如果有， 则从bean定义对象获取bean实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    BeanDefinition beandefinition = map.get(name);</span><br><span class="line">    <span class="keyword">if</span> (beandefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No bean named &quot;</span> + name + <span class="string">&quot; is defined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean = beandefinition.getBean();</span><br><span class="line">    <span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">      bean = doCreate(beandefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册 bean定义 的抽象方法实现，这是一个模板方法， 调用子类方法doCreate，</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beandefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object bean = doCreate(beandefinition);</span><br><span class="line">    beandefinition.setBean(bean);</span><br><span class="line">    map.put(name, beandefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 减少一个bean</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> Object <span class="title">doCreate</span><span class="params">(BeanDefinition beandefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该类实现了接口的2个基本方法，一个是getBean，一个是 registerBeanDefinition， 我们也设计了一个抽象方法供这两个方法调用，将具体逻辑创建逻辑延迟到子类。这是什么设计模式呢？模板模式。主要还是看 doCreate 方法，就是创建bean 具体方法，所以我们还是需要一个子类， 叫什么呢? AutowireBeanFactory， 自动注入Bean，这是我们这个标准Bean工厂的工作。看看代码吧？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.thinkinjava.myspring.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.PropertyValue;</span><br><span class="line"><span class="keyword">import</span> cn.thinkinjava.myspring.BeanReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现自动注入和递归注入(spring 的标准实现类 DefaultListableBeanFactory 有 1810 行)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据bean 定义创建实例， 并将实例作为key， bean定义作为value存放，并调用 addPropertyValue 方法 为给定的bean的属性进行注入</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreate</span><span class="params">(BeanDefinition beandefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object bean = beandefinition.getBeanclass().newInstance();</span><br><span class="line">    addPropertyValue(bean, beandefinition);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 给定一个bean定义和一个bean实例，为给定的bean中的属性注入实例。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addPropertyValue</span><span class="params">(Object bean, BeanDefinition beandefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 循环给定 bean 的属性集合</span></span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : beandefinition.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">      <span class="comment">// 根据给定属性名称获取 给定的bean中的属性对象</span></span><br><span class="line">      Field declaredField = bean.getClass().getDeclaredField(pv.getname());</span><br><span class="line">      <span class="comment">// 设置属性的访问权限</span></span><br><span class="line">      declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 获取定义的属性中的对象</span></span><br><span class="line">      Object value = pv.getvalue();</span><br><span class="line">      <span class="comment">// 判断这个对象是否是 BeanReference 对象</span></span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanReference) &#123;</span><br><span class="line">        <span class="comment">// 将属性对象转为 BeanReference 对象</span></span><br><span class="line">        BeanReference beanReference = (BeanReference) value;</span><br><span class="line">        <span class="comment">// 调用父类的 AbstractBeanFactory 的 getBean 方法，根据bean引用的名称获取实例，此处即是递归</span></span><br><span class="line">        value = getBean(beanReference.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 反射注入bean的属性</span></span><br><span class="line">      declaredField.set(bean, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到 doCreate 方法使用了反射创建了一个对象，并且还需要对该对象进行属性注入，如果属性是 ref 类型，那么既是依赖关系，则需要调用 getBean 方法递归的去寻找那个Bean（因为最后一个Bean 的属性肯定是基本类型）。这样就完成了一次获取实例化Bean操作，并且也实现类依赖注入。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>我们通过这些代码实现了一个简单的 IOC 依赖注入的功能，也更加了解了 IOC， 以后遇到Spring初始化的问题再也不会手足无措了。直接看源码就能解决。哈哈</p>
<p>具体代码楼主放在了github上，地址：<a href="https://github.com/stateIs0/simpleIoc">自己实现的一个简单IOC,包括依赖注入</a></p>
<p>good luck ！！！</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Spring-之-源码剖析AOP（XML配置方式）</title>
    <url>/2017/12/07/2017/2017-12-07-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-%E4%B9%8B-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90AOP%EF%BC%88XML%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       Spring 的两大核心，一是IOC，我们之前已经学习过，并且已经自己动手实现了一个，而令一个则是大名鼎鼎的 AOP，AOP的具体概念我就不介绍了，我们今天重点是要从源码层面去看看 spring 的 AOP 是如何实现的。注意，今天楼主给大家分享的是 XML 配置AOP的方式，不是我们经常使用的注解方式，为什么呢？

<p>有几个原因：</p>
<ol>
<li>Spring AOP 在 2.0 版本之前都是使用的 XML 配置方式，封装的层次相比注解要少，对于我们学习AOP是个很好的例子。</li>
<li>虽然现在是2017年，现在使用SpringBoot 都是使用注解了， 但是底层原理都是一样的，只不过多了几层封装。当然，我们也是要去扒开它的源码的。但不是今天。</li>
<li>楼主也还没有分析注解方式的AOP。-_-|||</li>
</ol>
<p>我们主要分为几个步骤去理解：</p>
<ol>
<li>查看源码了解 spring AOP 的接口设计。Advice，PointCut，Advisor。</li>
<li>用一个最简单的代码例子 debug 追踪源码。</li>
</ol>
<p>那么我们现看第一步：</p>
<h2 id="1-Spring-AOP-接口设计"><a href="#1-Spring-AOP-接口设计" class="headerlink" title="1. Spring AOP 接口设计"></a>1. Spring AOP 接口设计</h2><h3 id="1-1-PointCut-（连接点，定义匹配哪些方法）"><a href="#1-1-PointCut-（连接点，定义匹配哪些方法）" class="headerlink" title="1.1 PointCut （连接点，定义匹配哪些方法）"></a>1.1 PointCut （连接点，定义匹配哪些方法）</h3><p>我们打开 Spring 的源码，查看 PointCut 接口设计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line">	<span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line">	Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该接口定义了2 个方法，一个成员变量。我们先看第一个方法， <code>ClassFilter getClassFilter()</code> ，该方法返回一个类过滤器，由于一个类可能会被多个代理类代理，于是Spring引入了责任链模式，另一个方法则是 <code>MethodMatcher getMethodMatcher()</code> ，表示返回一个方法匹配器，我们知道，AOP 的作用是代理方法，那么，Spirng 怎么知道代理哪些方法呢？必须通过某种方式来匹配方法的名称来决定是否对该方法进行增强，这就是 MethodMatcher  的作用。还有要给默认的 Pointcut 实例，该实例对于任何方法的匹配结果都是返回 true。</p>
<p>我们关注一下 MethodMatcher 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass, Object... args)</span></span>;</span><br><span class="line">	MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口定义了静态方法匹配器和动态方法匹配器。所谓静态方法匹配器，它仅对方法名签名（包括方法名和入参类型及顺序）进行匹配；而动态方法匹配器，会在运行期检查方法入参的值。静态匹配仅会判别一次，而动态匹配因为每次调用方法的入参都可能不一样，所以每次都必须判断。一般情况下，动态匹配不常用。方法匹配器的类型由isRuntime()返回值决定，返回false表示是静态方法匹配器，返回true表示是动态方法匹配器。</p>
<p>总的来说， PointCut 和 MethodMatcher 是依赖关系，定义了AOP应该匹配什么方法以及如何匹配。</p>
<h3 id="1-2-Advice-通知，定义在链接点做什么"><a href="#1-2-Advice-通知，定义在链接点做什么" class="headerlink" title="1.2 Advice (通知，定义在链接点做什么)"></a>1.2 Advice (通知，定义在链接点做什么)</h3><p>注意，Advice 接口只是一个标识，什么也没有定义，但是我们常用的几个接口，比如 BeforeAdvice，AfterAdvice，都是继承自它。我们关注一下 AfterAdvice 的子接口 AfterReturningAdvice ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">该接口定义了一个方法，afterReturning，参数分别是返回值，目标方法，参数，目标方法类，在目标方法执行之后会回调该方法。那么我们就可以在该方法中执行我们的切面逻辑，BeforeAdvice 也是一样的道理。</span><br><span class="line"></span><br><span class="line">### <span class="number">1.3</span> Advisor (通知器，将 Advice 和 PointCut 结合起来)</span><br><span class="line"></span><br><span class="line">有了对目标方法的增强接口 Advice 和 如何匹配目标方法接口 PointCut 接口后，那么我们就需要用一个对象将他们结合起来，发挥AOP 的作用，所以Spring 设计了 Advisor（通知器），经过我们刚刚的描述，我们应该知道了，这个 Advisor 肯定依赖了 Advice 和 PointCut，我们看看接口设计：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Advice EMPTY_ADVICE = <span class="keyword">new</span> Advice() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">Advice <span class="title">getAdvice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有他的子接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PointcutAdvisor</span> <span class="keyword">extends</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Pointcut <span class="title">getPointcut</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最重要的两个方法，getAdvice，getPointcut。和我们预想的基本一致。</p>
<p>接下来，我们可以停下来思考一下，现在有了这个东西，我们怎么实现面向切面编程；</p>
<ol>
<li>首先我们需要告诉AOP在哪里进行切面。比如在某个类的方法前后进行切面。</li>
<li>告诉AOP 切面之后做什么，也就是说，我们知道了在哪里进行切面，那么我们也该让spring知道在切点处做什么。</li>
<li>我们知道，Spring AOP 的底层实现是动态代理（不管是JDK还是Cglib），那么就需要一个代理对象，那么如何生成呢？</li>
</ol>
<p>接下来，我们将通过代码的方式，解答这三个疑惑。</p>
<h2 id="2-从一个简单的AOP例子"><a href="#2-从一个简单的AOP例子" class="headerlink" title="2. 从一个简单的AOP例子"></a>2. 从一个简单的AOP例子</h2><p>首先，我们需要实现刚刚我们说的3个接口，还有一个目标类，还要一个配置文件。一个一个来。</p>
<h3 id="2-1-Pointcut-接口实现"><a href="#2-1-Pointcut-接口实现" class="headerlink" title="2.1. Pointcut  接口实现"></a>2.1. Pointcut  接口实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.ClassFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ClassFilter.TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MethodMatcher() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object[] args)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;test&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;test&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们如何定义匹配？只要方法名称是test则对该方法进行增强或者说拦截。</p>
<h3 id="2-2-AfterAdvice-实现"><a href="#2-2-AfterAdvice-实现" class="headerlink" title="2.2 AfterAdvice 实现"></a>2.2 AfterAdvice 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAfterAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method,</span></span></span><br><span class="line"><span class="params"><span class="function">			Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(</span><br><span class="line">				<span class="string">&quot;after &quot;</span> + target.getClass().getSimpleName() + <span class="string">&quot;.&quot;</span> + method.getName() + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在方法执行完毕后打印该方法的名称和该目标类的名称。这就是我们做的简单增强。</p>
<h3 id="2-3-Advisor-通知器的实现"><a href="#2-3-Advisor-通知器的实现" class="headerlink" title="2.3 Advisor 通知器的实现"></a>2.3 Advisor 通知器的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aopalliance.aop.Advice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.PointcutAdvisor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAdvisor</span> <span class="keyword">implements</span> <span class="title">PointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取通知处理逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> TestAfterAdvice();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取切入点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> TestPointcut();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们实现了 PointcutAdvisor 接口，返回我们刚才定义的两个类。完成了他们的组合。</p>
<h3 id="2-4-定义目标类-Targe"><a href="#2-4-定义目标类-Targe" class="headerlink" title="2.4 定义目标类 Targe"></a>2.4 定义目标类 Targe</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;target.test()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;target.test2()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该目标的实现和简单，就是2个方法，分别打印自己的名字。</p>
<h3 id="2-5-定义XML-配置文件"><a href="#2-5-定义XML-配置文件" class="headerlink" title="2.5 定义XML 配置文件"></a>2.5 定义XML 配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testAdvisor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;test.TestAdvisor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testTarget&quot;</span> <span class="attr">class</span>=<span class="string">&quot;test.TestTarget&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testAOP&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>testTarget<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>testAdvisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，我们定义了3个bean，上面两个是我们刚刚定义的，下面一个我们要好好说说，ProxyFactoryBean 是一个什么东西呢？首先他是一个 FactoryBean，我们在学习 IOC 的时候知道， FactoryBean 是Spring 留给我们扩展用的，实现该接口的类可以自定类的各种功能。ProxyFactoryBean 当然也实现了自己的很多自定义功能。ProxyFactoryBean 也是Spring IOC 环境中创建AOP 应用的底层方法，Spring 正式通过它来实现对AOP的封装。这样我们更加接近Spring的底层设计。而该类需要注入两个属性一个目标类，一个拦截类，ProxyFactoryBean 会生成一个动态代理类来完成对目标方法的拦截。</p>
<h3 id="2-6-测试类"><a href="#2-6-测试类" class="headerlink" title="2.6 测试类"></a>2.6 测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line">				<span class="string">&quot;spring-context/src/test/java/test/beans.xml&quot;</span>);</span><br><span class="line">		TestTarget target = (TestTarget) applicationContext.getBean(<span class="string">&quot;testAOP&quot;</span>);</span><br><span class="line">		target.test();</span><br><span class="line">		System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">		target.test2();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看看运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9df3c2c91c3fff9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到结果符合我们的预期，因为我们只配置了在test名称的方法之后打印该方法的名称和该目标类的名称，而test2 则没有配置，因此也就没有打印。</p>
<p>那么是怎么实现的呢？ 让我们进入源码看个究竟。</p>
<h2 id="3-深入-AOP-源码实现"><a href="#3-深入-AOP-源码实现" class="headerlink" title="3. 深入 AOP 源码实现"></a>3. 深入 AOP 源码实现</h2><p>首先我们看看我们的测试代码，我们第一句代码是IOC 初始化，这个我们就不讲了，我们在之前的文章已经分析过，我们重点看第二行代码，我们debug 到第三行，看看第二行返回的对象是什么？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4cfca549cde2acc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看到，第二行从IOC容器中取出的是一个Cglib 生成的代理对象，也既是继承了我们TestTarge 类的实例，而不是我们在 XML 中定义的 ProxyFactoryBean 对象，也就是说， FactoryBean 确实能够在IOC容器中做一些定制化。那么我们就很好奇，这个代理对象是怎么生成的。我们从第二行代码开始进入。</p>
<p>首先进入抽象类 AbstractApplicationContext 的getBean 方法，从容器或获取 Bean，再调用 doGetBean 方法，这个方法我们很熟悉，因为再之前的IOC过程中，我们看了好多遍了，我们重点看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">		<span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">			String nameToLookup = originalBeanName(name);</span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">				<span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">						nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">				<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();<span class="comment">// 设置依赖关系</span></span><br><span class="line">			<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					getBean(dep);<span class="comment">// 递归</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create bean instance.</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;<span class="comment">// 创建bean</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">						<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">						<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<span class="comment">// 获取实例</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String scopeName = mbd.getScope();</span><br><span class="line">				<span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">							<span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">							<span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">							ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">	<span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">			<span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> convertedBean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">						ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会进入到第一个if块中的 <code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, null)</code> 方法中，而 getObjectForBeanInstance 方法则会先判断缓存是否存在，如果不存在，则进入父类的 getObjectForBeanInstance 方法，我们看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">	<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">	<span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">	<span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">	<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object object = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">		object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Return bean instance from factory.</span></span><br><span class="line">		FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">		<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">		object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先判断是否是 Bean 引用类型并且是否是 Factory 类型，很面向不是Bean 引用类型（Bean引用类型指的是IOC在解析XML文件 的时候，会有 ref 属性，而这个ref 对象还没有实例化，则暂时创建一个Bean引用类型的实例，用于在依赖注入的时候判断是否是Bean的属性类型，如果是，则从容器中取出，如果不是，则是基本类型，就直接赋值），然后进入下面的if判断，很明显会直接跳过。进入下面的 getCachedObjectForFactoryBean(beanName) 方法，从缓存中取出，很明显，第一次肯定返回null，继续向下，进入if块，重点在 object = getObjectFromFactoryBean(factory, beanName, !synthetic) 方法，我们进入该方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">			Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">				object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">				<span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">				<span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">				Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">					object = alreadyThere;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">									<span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> object;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">		<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法还是先重缓存中取出，然后进入  doGetObjectFromFactoryBean(factory, beanName) 方法，我们看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object object;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			AccessControlContext acc = getAccessControlContext();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt;</span><br><span class="line">						factory.getObject(), acc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">				<span class="keyword">throw</span> pae.getException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			object = factory.getObject();<span class="comment">// 此处调用 ProxyFactoryBean</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line">	<span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">	<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(</span><br><span class="line">					beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		object = <span class="keyword">new</span> NullBean();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会直接进入  object = factory.getObject() 行，也就是 ProxyFactoryBean 的 getObject 方法，还记得我们说过，Spring 允许我们从写 getObject 方法来实现特定逻辑吗？ 我们看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	initializeAdvisorChain();<span class="comment">// 为代理对象配置Advisor链</span></span><br><span class="line">	<span class="keyword">if</span> (isSingleton()) &#123;<span class="comment">// 单例</span></span><br><span class="line">		<span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">			logger.warn(<span class="string">&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot;</span> +</span><br><span class="line">					<span class="string">&quot;Enable prototype proxies by setting the &#x27;targetName&#x27; property.&quot;</span>);</span><br><span class="line">		&#125;<span class="comment">// 非单例</span></span><br><span class="line">		<span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法很重要，首先初始化通知器链，然后获取单例，这里返回的就是我们最初看到的Cglib 代理。这里的初始化过滤器链的重要作用就是将连接起来，基本实现就是循环我们在配置文件中配置的通知器，按照链表的方式连接起来。具体代码各位有兴趣自己去看，今天这个不是重点。首先判断是否是单例，然后我们着重关注下面的方法 getSingletonInstance()；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.targetSource = freshTargetSource();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">			<span class="comment">// Rely on AOP infrastructure to tell us what interfaces to proxy.</span></span><br><span class="line">			Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">&quot;Cannot determine target class for proxy&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Initialize the shared singleton instance.</span></span><br><span class="line">		<span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">		<span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法是同步方法，防止并发错误，因为有共享变量。首先返回一个包装过的目标对象，然后是否含有接口，我们的目标类没有接口，进入if块，从目标类中取出所有接口并设置接口。很明显，并没有什么作用，然后向下走，重要的一行是 <code>getProxy(createAopProxy())</code>，先创建AOP，再获取代理。我们先看 crateAopProxy。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法返回一个AopProxy 类型的实例，我们看看该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该接口定义了两个重载方法，我们看看它有哪些实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ea75ed2f65c3a0d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是该接口的继承图，分别是 JdkDynamicAopProxy 动态代理和 CglibAopProxy 代理。而 JdkDynamicAopProxy 实现了 InvocationHandler 接口，如果熟悉Java 动态代理，应该和熟悉该接口，实现了该接口的类并实现invoke方法，再代理类调用的时候，会回调该方法。实现动态代理。</p>
<p>我们继续看 createAopProxy 方法，该方法主要逻辑是创建一个AOP 工厂，默认工厂是 DefaultAopProxyFactory，该类的 createAopProxy 方法则根据 ProxyFactoryBean 的一些属性来决定创建哪种代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">		Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">		<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">					<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要满足三个条件中的其中一个就，我们看最后一个判断，是否含有接口，没有则返回ture，也就是说，如果目标类含有接口，则创建Cglib 代理，否则则是JDK代理。最终创建了一个 ObjenesisCglibAopProxy 代理。</p>
<p>我们回到 ProxyFactoryBean 类的 getProxy 方法，当 createAopProxy 返回一个Cglib 代理的后，则调用 getProxy 方法获取一个代理对象，我们看看该方法实现：</p>
<pre><code class="java">    @Override
    public Object getProxy(@Nullable ClassLoader classLoader) &#123;
        if (logger.isDebugEnabled()) &#123;
            logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource());
        &#125;

        try &#123;
            Class&lt;?&gt; rootClass = this.advised.getTargetClass();
            Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);

            Class&lt;?&gt; proxySuperClass = rootClass;
            if (ClassUtils.isCglibProxyClass(rootClass)) &#123;
                proxySuperClass = rootClass.getSuperclass();
                Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();
                for (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;
                    this.advised.addInterface(additionalInterface);
                &#125;
            &#125;

            // Validate the class, writing log messages as necessary.
            validateClassIfNecessary(proxySuperClass, classLoader);

            // Configure CGLIB Enhancer...
            Enhancer enhancer = createEnhancer();
            if (classLoader != null) &#123;
                enhancer.setClassLoader(classLoader);
                if (classLoader instanceof SmartClassLoader &amp;&amp;
                        ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;
                    enhancer.setUseCache(false);
                &#125;
            &#125;
            enhancer.setSuperclass(proxySuperClass);
            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
            enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));

            Callback[] callbacks = getCallbacks(rootClass);
            Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length];
            for (int x = 0; x &lt; types.length; x++) &#123;
                types[x] = callbacks[x].getClass();
            &#125;
            // fixedInterceptorMap only populated at this point, after getCallbacks call above
            enhancer.setCallbackFilter(new ProxyCallbackFilter(
                    this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
            enhancer.setCallbackTypes(types);

            // Generate the proxy class and create a proxy instance.
            return createProxyClassAndInstance(enhancer, callbacks);
        &#125;
        catch (CodeGenerationException | IllegalArgumentException ex) &#123;
            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; +
                    this.advised.getTargetClass() + &quot;]: &quot; +
                    &quot;Common causes of this problem include using a final class or a non-visible class&quot;,
                    ex);
        &#125;
        catch (Throwable ex) &#123;
            // TargetSource.getTarget() failed
            throw new AopConfigException(&quot;Unexpected AOP exception&quot;, ex);
        &#125;
    &#125;
</code></pre>
<p>该方法基本上就是使用了Cglib 的库的一些API最后通过字节码生成代理类，比如 Enhancer 增强器，楼主对ASM 和 Cglib 也不是很熟悉，下次有机会再看详细实现。总之，我们已经知道了Spring 是如何生成代理对象的，主要的通过 ProxyFactoryBean 来实现。</p>
<p>最后，返回代理类，执行代理类的方法。完成切面编程。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>我们通过一个简单的例子debug spring 源码，了解了通过配置文件方式配置AOP的详细过程，其中起最重要作用的还是 ProxyFactoryBean ，在定制化Bena的过程中起到了很大的作用，也提醒了我们，如果想在Spring的bean容器实现一些特别的功能，可以实现 FactoryBean 接口，自定义自己的需要Bean。还有一点，今天我们学习的例子是通过XML方式，而这个方式确实有些古老，虽然不妨碍我们学习 AOP 的精髓，但我们还是希望能够深入了解基于注解的AOP的具体实现，也许实现源码相似，但我们还是想知道到底有哪些不同，最起码楼主在刚刚的调试中发现最新的SpringBoot的AOP不是基于ProxyFactroyBean实现的。但不要灰心，原理都是相同的。剩下的就是我们自己去挖掘。</p>
<p>good luck！！！</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Spring-之-源码剖析AOP（注解方式）</title>
    <url>/2017/12/09/2017/2017-12-09-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-%E4%B9%8B-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90AOP%EF%BC%88%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       上一篇文章我们从XML 配置文件的方式剖析了AOP的源码，我们也说了，虽然现在用XML配置的几乎没有了，但作为学习的例子，XML配置仍然是我们理解Spring AOP 的一个绝好的样本，但作为一个由追求的程序员，我们天天使用的注解方式的AOP 肯定也是要去看看到底是如何实现的。现在有了之前阅读 XML 配置的源码的基础，今天我们来阅读注解方式的源码也变得轻松起来。

<p>还记得我们之前说过，XML 配置的AOP是使用 ProxyFactoryBean ，实现了 FactoryBean的接口，而FactoryBean是Spring特意留给开发者们扩展的接口，而Spring 留给开发者们不止一个扩展接口，比如 BeanPostProcess 接口，实现着接口就可以在每个Bean的生成前后做一些增强或自定义（具体Spring 留给我们有哪些扩展接口，楼主有机会将会再写一篇文章解析）。</p>
<p>接下来就要好好讲讲我们上篇文章漏讲的接口设计。这是我们理解 AOP 的基础。</p>
<p>先从 ProxyFactoryBean 讲起，这个熟悉的哥们。</p>
<h2 id="1-ProxyFactoryBean-类结构"><a href="#1-ProxyFactoryBean-类结构" class="headerlink" title="1. ProxyFactoryBean 类结构"></a>1. ProxyFactoryBean 类结构</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-8f7b7e8cbc75bd8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="1-1-ProxyCreatorSupport-类结构图"><a href="#1-1-ProxyCreatorSupport-类结构图" class="headerlink" title="1.1 ProxyCreatorSupport  类结构图"></a>1.1 ProxyCreatorSupport  类结构图</h3><p>它继承了 ProxyCreatorSupport 这个类，这个类很重要，我们看看该类结构</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e701dd5d103ed2b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类有2个重要的方法，分别是获取代理工厂，创建代理。那么代理工厂是什么呢？AopProxyFactory ，是个接口，只定义了一个方法：AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException， 并且该接口目前只有一个默认实现类：DefaultAopProxyFactory，该类主要重写了接口方法 createAopProxy， 内部逻辑是根据给定的类配置来创建不同的代理 AopProxy，那么 AopProxy 是什么呢？就是真正创建代理的工厂，他是一个接口，有3个实现：</p>
<h3 id="1-2-AopProxy-接口"><a href="#1-2-AopProxy-接口" class="headerlink" title="1.2  AopProxy  接口"></a>1.2  AopProxy  接口</h3><p><img src="http://upload-images.jianshu.io/upload_images/4236553-bfe7da9a3822fafd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="1-3-AopProxy-继承结构"><a href="#1-3-AopProxy-继承结构" class="headerlink" title="1.3 AopProxy  继承结构"></a>1.3 AopProxy  继承结构</h3><p><img src="http://upload-images.jianshu.io/upload_images/4236553-9cc1dfc406fe22bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从名字上可以看出来，一个是 JDK 动态代理，一个是 Cglib 代理，ObjenesisCglibAopProxy 扩展了它的父类 CglibAopProxy，在 DefaultAopProxyFactory 的实现里，使用的就是 ObjenesisCglibAopProxy 来实现 Cglib 的代理。他们分别实现了自己的getProxy 方法用以创建代理。我们看看这两个类的继承结构：</p>
<h3 id="1-4-JdkDynamicAopProxy-继承结构"><a href="#1-4-JdkDynamicAopProxy-继承结构" class="headerlink" title="1.4 JdkDynamicAopProxy 继承结构"></a>1.4 JdkDynamicAopProxy 继承结构</h3><p><img src="http://upload-images.jianshu.io/upload_images/4236553-b3be043ca9c4dd64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="1-5-CglibAopProxy-继承结构没什么，主要是众多内部类"><a href="#1-5-CglibAopProxy-继承结构没什么，主要是众多内部类" class="headerlink" title="1.5 CglibAopProxy 继承结构没什么，主要是众多内部类"></a>1.5 CglibAopProxy 继承结构没什么，主要是众多内部类</h3><p><img src="http://upload-images.jianshu.io/upload_images/4236553-24378f87337615ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到哟非常多的内部类，这些内部类是为了实现了 Cglib 的各种回调而实现的。主要实现了 MethodInterceptor 接口，<br>Callback 接口，Joinpoint 接口，Invocation 接口等待，总之是实现了Spring 的 cglib 模块的各种接口。</p>
<p>说了那么多，我们回来看看 ProxyCreatorSupport  ，下面是 ProxyCreatorSupport  的继承结构</p>
<h2 id="2-ProxyCreatorSupport-类继承图"><a href="#2-ProxyCreatorSupport-类继承图" class="headerlink" title="2. ProxyCreatorSupport   类继承图"></a>2. ProxyCreatorSupport   类继承图</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-46b4346d53d57b3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类有3个子类， 其中就有一个我们熟悉的 ProxyFactoryBean，该类实现了我们熟悉的 FactoryBean，还有一个可以获取容器内Bean的 BeanFactoyAware 接口，第二个是陌生的 AspectJProxyFactory 类，该类是用于集成 Spring 和 AspectJ 的。而最后一个类ProxyFactory 就是我们今天的主角，Spring 的类注释说：<code>用于编程使用的AOP代理，而不是在bean工厂中通过声明式设置。这个类提供了一种简单的方法，可以在定制的用户代码中获取和配置AOP代理实例</code>，大概意思就是通过编程的方式获取Bean 代理吧，而不是通过配置文件的方式。我们今天就可以见识到。</p>
<h2 id="3-AnnotationAwareAspectJAutoProxyCreator-类"><a href="#3-AnnotationAwareAspectJAutoProxyCreator-类" class="headerlink" title="3. AnnotationAwareAspectJAutoProxyCreator 类"></a>3. AnnotationAwareAspectJAutoProxyCreator 类</h2><p>这个类的名字很长，为什么要说这个类呢？还记得我们刚开始说的 BeanPostProcessor 扩展接口吗？我们说该接口是spring 留给开发人员自定义增强bean的接口。而该类则实现了该接口，看名字也知道，该类是根据注解自动创建代理的创建者类。我们看看他的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-93afd4512e1ce792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，最底层的该类实现了 BeanPostProcessor 接口，可以在每个bena生成前后做操作。该类由 Rod Johnson 编写，注释上是这么说的：<code>任何AspectJ注释的类都将自动被识别，它们也会被识别</code>。和我们预想的一致。</p>
<p>我们知道了 AnnotationAwareAspectJAutoProxyCreator 是根据注解自动创建代理，而该类也算是 ProxyBean 的代理，那么，和它一样继承抽象父类的其他几个类的作用是什么呢？来都来了，就看看吧！我们看看类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a0bdae69da37cb7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到该类由4个实现：他们实现了不同的创建代理的方式：</p>
<ol>
<li>匹配Bean的名称自动创建匹配到的Bean的代理，实现类BeanNameAutoProxyCreator</li>
<li>根据Bean中的AspectJ注解自动创建代理，实现类AnnotationAwareAspectJAutoProxyCreator，也就是我们今天说的注解类。</li>
<li>根据Advisor的匹配机制自动创建代理，会对容器中所有的Advisor进行扫描，自动将这些切面应用到匹配的Bean中，实现类DefaultAdvisorAutoProxyCreator</li>
<li>InfrastructureAdvisorAutoProxyCreator，该类只在 AopConfigUtils 中的静态块用到，该类的注释：自动代理创建者只考虑基础设施顾问bean，忽略任何应用程序定义的顾问。意思应该是只是Sprnig的基础代理，开发者的应用会忽略。有知道的同学可以告诉我。</li>
</ol>
<p>加上我们的ProxyFactoryBean，一共5种实现方法。从这里可以看出Spring 对于扩展的软件设计是多么优秀。</p>
<p>那么我们就来看看 AnnotationAwareAspectJAutoProxyCreator 是如何创建代理的。我们说 BeanPostProcessor 是Spring 留给我们扩展的接口，那么他是如何定义的呢？我们看看该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口定义了两个方法，一个是在bean初始化之前执行，一个是在bean初始化之后执行。也就是说，开发者可以在这两个方法中做一些有趣的事情。我们看看 AnnotationAwareAspectJAutoProxyCreator 是如何实现该方法的。实际上 AnnotationAwareAspectJAutoProxyCreator 的抽象父类已经实现了该方法，我们看看是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a proxy with the configured interceptors if the bean is</span></span><br><span class="line"><span class="comment"> * identified as one to proxy by the subclass.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getAdvicesAndAdvisorsForBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>before 方法直接返回了bean，并没有做什么增强操作，重点在after方法，我们可以看该方法的注释：如果bean是由子类标识的，那么就创建一个配置的拦截器的代理。Spring 就是在这里创建了代理，我们进入关键方法 wrapIfNecessary 看看。该方法用来包装给定的Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">		Object proxy = createProxy(</span><br><span class="line">				bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">		<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已将可以看到一个关键一行代码：Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean))，创建一个代理，该方法携带了bean的Class对象，benaName， 通知器数组，还有一个包装过的单例Bean，我们看看该方法实现（该方法对于我们来说已经到终点了），</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	proxyFactory.addAdvisors(advisors);</span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们能够看到其中有一行让我们激动的代码，就是 ProxyFactory proxyFactory = new ProxyFactory()，创建了一个ProxyFactory 对象，我们刚刚说过，该对象和ProxyFactoryBean一样，继承了 ProxyCreatorSupport， 因此也就和 ProxyFactoryBean 一样拥有了 getProxy 方法，到这里，我们的一切都豁然开朗。当然上面几行代码是设置了通知器链。我们先按下不表。</p>
<blockquote>
<p>ProxyFactoryBean 扩展了 FactoryBean 接口， AnnotationAwareAspectJAutoProxyCreator 扩展了 BenaPostProcessor 了接口，其目的都是在Bean生成的时候做增强操作，Spring 通过这两种方式，完成了两种不同的代理生成方式，但最终都是继承了 ProxyCreatorSupport 类，该类才是生成代理的核心类。</p>
</blockquote>
<p>我们可以看看XML 配置方式和 注解方式的方法堆栈调用图，从中我们可以看出一些端倪：</p>
<p><strong>XML 配置方式堆栈图</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a871bbe51757ee51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>注解配置方法堆栈图</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-dcb8067d88ae0e46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们可以看到两者在AbstractBeanFactory 的 doGetBean 方法开始分道扬镳，走向了不同的逻辑，那么我们看看到底哪里不同，直接看代码：我们看XML配置堆栈，在258行：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6ebd125978fb6d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从这里进入，该方法做了些什么呢？为什么让他们走向不同的路线？我们看看该方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c9a53c9c01e81754.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法有个重要的判断：是否是 FactoryBean 的子类型，很明显，我们的XML配置的ProxyFacoroyBean 返回 false，而注解方式的Bean则返回 false，ProxyFacoroyBean 会一直向下走，直到创建代理，而注解方式则会直接返回。走到302行：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-44e7e4e5ccc84ecf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注解方式会执行 getSingleton 方法，最后触发 createBean 回调方法，完成创建代理的过程。</p>
<p>到此为止，现在我们知道了到 XML 配置方式的 AOP 和注解的方式AOP 的生成区别。我们可以开始总结了。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>首先，通过分析源码我们知道注解方式和 XML 配置方式的底层实现都是一样的，都是通过继承 ProxyCreatorSupport 来实现的，不同的通过扩展不同的 Spring 提供的接口，XML 扩展的是FactoryBean 接口， 而注解方式扩展的是 BenaPostProcessor 接口，通过Spring 的扩展接口，能够对特定的Bean进行增强。而 AOP 正式通过这种方式实现的。这也提醒了我们，我们也可以通过扩展 Spring  的某些接口来增强我们需要的 Bean 的某些功能。当然，篇幅有限，我们这篇文章只是了解了XML 配置方式和注解方式创建代理的区别，关于如何 @Aspect 和 @Around 的底层实现，还有通知器的底层实现，我们还没有分析，但我们隐隐的感觉到，其实万变不离其宗，底层的也是通过扩展 advice 和 pointcut  接口来实现的。 我们将会在后面的文章继续分析 AOP 是如何编织通知的。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Spring-之源码剖析IOC-</title>
    <url>/2017/12/04/2017/2017-12-04-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Spring-%E4%B9%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90IOC-/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       作为Java程序员，Spirng我们再熟悉不过，可以说比自己的女朋友还要亲密，每天都会和他在一起，然而我们真的了解spring吗？

<p>我们都知道，Spring的核心是IOC和AOP，但楼主认为，如果从这两个核心中挑选一个更重要的，那非IOC莫属。AOP 也是依赖于IOC，从某些角度讲，AOP就是IOC的一个扩展功能。</p>
<p>什么是IOC？ IOC解决了什么问题？IOC的原理是什么？Spring的IOC是怎么实现的？今天我们将会将这几个问题一起解决。</p>
<h3 id="1-什么是IOC？"><a href="#1-什么是IOC？" class="headerlink" title="1. 什么是IOC？"></a>1. 什么是IOC？</h3><blockquote>
<p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>
</blockquote>
<p>这是维基百科的说法，楼主按照自己的思路分析一下IOC，楼主认为，分析一个问题，或者说证明一个事情，有2种方法，一是正向验证，即按照该事务的逻辑去验证正确性，还有一种是反向验证，证明该事务是否正确。楼主想反向证明IOC，我们提出一个疑问：如果没有IOC会怎么样？</p>
<p>想象一下，在没有IOC的世界里，我们的系统会有大量的对象，这些对象有些是数据，有些是处理数据的，各个对象相互依赖，我们需要控制他们的依赖关系，什么时候new ，什么时候销毁，什么时候需要单例，什么时候不需要单例等等这些问题，你能想象吗，当你一个系统有几千个类，你如何管理他们的依赖关系，说起依赖，我们可能会想起 maven 或者 gradle，他们管理着我们的 jar 包依赖，而我们的系统代码呢？想想都头大。</p>
<p>但是如果有一种东西，他能够帮助我们管理所有类的创建，销毁，是否是单例模式，类与类之间的多层依赖关系(在我们的MVC框架中，3层依赖已经是最少)，那该多好，我们只需要关注业务逻辑。于是 ，IOC诞生了。</p>
<h3 id="2-IOC-解决了什么问题？"><a href="#2-IOC-解决了什么问题？" class="headerlink" title="2.  IOC 解决了什么问题？"></a>2.  IOC 解决了什么问题？</h3><blockquote>
<p>简单来说, IOC 解决了类与类之间的依赖关系。程序员将控制<code>类与类之间依赖的权利</code>交给了IOC，即：控制被反转了。</p>
</blockquote>
<h3 id="3-IOC-的原理是什么？"><a href="#3-IOC-的原理是什么？" class="headerlink" title="3. IOC 的原理是什么？"></a>3. IOC 的原理是什么？</h3><blockquote>
<p>其实 IOC 的原理很简单，底层就是java的反射。给定一个字符串能创建一个实例，利用set方法对实例的依赖进行注入。</p>
</blockquote>
<p>我们来一段代码证明一下是多么的简单：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-224ffcb80ca73a9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到该代码非常的简单，但实际上IOC 就是这么简单，在真正的开发中，我们只需要在配置文件给定一个类名字符串，就什么都不用管了，对象就会创建出来，系统启动完毕之后，我们只需要直接使用该对象就好了，不必自己去new。解决了我们的对象创建问题。我们通过反射调用该方法的setText方法，完成了依赖注入。我们不再需要去new，然后去set，IOC 已经为我们做好了一切。</p>
<p>介绍完了几个基本知识，其实都是为我们今天的重头戏做准备，Spring的IOC是怎么实现的？</p>
<h3 id="4-Spring的IOC是怎么实现的？"><a href="#4-Spring的IOC是怎么实现的？" class="headerlink" title="4. Spring的IOC是怎么实现的？"></a>4. Spring的IOC是怎么实现的？</h3><p>这是一个浩大的问题，虽然底层实现可能就那么几行代码，但楼主说过，所有框架的底层技术都很简单，但是我们的框架大师们为了软件的健壮性，扩展性和性能，做了无数的优化，我们的系统源码也就变得越来越复杂，spirng的 release  版本至今已经到了 5.0.3，和最初的 interface21 已经有了翻天复地的变化，现在也有了springboot， springcloud，俨然一个庞大的spring家族，想分析源码的我们该从哪里下手呢？</p>
<p><strong>万剑归宗，始于一处。</strong></p>
<p><strong>Bean。</strong></p>
<p>我们要研究spring的IOC，我们要了解的就是spring的bean，这是spring的核心的核心。虽然bena依赖着context 模块提供bean的环境，依赖core 提供着一系列强化的工具。但今天我们不关心，我们只关系bean。只关心IOC。就像这个信息过载，技术不断更新的时代，程序们需要有自己的判断，自己需要研究什么，什么是最重要的？扯远了。</p>
<p>在开始研究源码之前，楼主有必要介绍一下IOC的一些核心组件，否则一旦进入源码，就会被细节捆住，无法从宏观的角度理解IOC。</p>
<ol>
<li>BeanFactory：这是IOC容器的接口定义，如果将IOC容器定位为一个水桶，那么BeanFactory 就定义了水桶的基本功能，能装水，有把手。这是最基本的，他的实现类可以拓展水桶的功能。</li>
<li>ApplicationContext：这是我们最常见的，上面我们说水桶，BeanFactory是最基本的水桶，而 ApplicationContext 则是扩展后的水桶，它通过继承 MessageSource，ResourceLoader，ApplicationEventPublisher 接口，在BeanFactory 简单IOC容器的基础上添加了许多对高级容器的支持。</li>
<li>BeanDefinition：我们知道，每个bean都有自己的信息，各个属性，类名，类型，是否单例，这些都是bena的信息，spring中如何管理bean的信息呢？对，就是 BeanDefinition， Spring通过定义 BeanDefinition 来管理基于Spring的应用中的各种对象以及他们直接的相互依赖关系。BeanDefinition 抽象了我们对 Bean的定义，是让容器起作用的主要数据类型。对 IOC 容器来说，BeanDefinition 就是对依赖反转模式中管理的对象依赖关系的数据抽象。<strong>也是容器实现依赖反转功能的核心数据结构</strong>。 </li>
</ol>
<h4 id="1-搭建源码研究环境"><a href="#1-搭建源码研究环境" class="headerlink" title="1. 搭建源码研究环境"></a>1. 搭建源码研究环境</h4><p>楼主研究源码的思路有2个，一个是创建一个简单的spirng maven 项目，还有一个是直接从 spirng 的github 上 clone 源码。</p>
<p>这是楼主的普通 maven 项目：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-57d6384b39073470.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是楼主的 clone 的 spring-framework 源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8d331a6bc3354a13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意：clone 该源码的时候，楼主很艰辛，因为要科学上网，否则 gradle 无法下载依赖会导致报错。如果各位无法科学上网，可以使用 maven 项目勉强学习。</p>
<h4 id="2-开启研究源码第一步"><a href="#2-开启研究源码第一步" class="headerlink" title="2. 开启研究源码第一步"></a>2. 开启研究源码第一步</h4><p>我们打开spring-framework 源码。</p>
<p>还记的我们初学spring的写的第一行代码是什么吗？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f079dbd8857d6816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>怎么写配置文件楼主就不说了，我们回忆一下我们最初学spring的时候，虽然现在都是2017年了，我们都用springboot，都是用注解了，但spring的核心代码还是 spring 之父 Rod Johnson 在  2001 年写的。所以不影响我们学习spring 的核心。</p>
<p>我们仔细看看该代码（该代码位置必须在spring-context模块下）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.tests.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">		ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext</span><br><span class="line">				(<span class="string">&quot;spring-beans/src/test/resources/beans.xml&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;number : &quot;</span> + ctx.getBeanDefinitionCount());</span><br><span class="line">		((Person) ctx.getBean(<span class="string">&quot;person&quot;</span>)).work();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">熟悉的 ApplicatContext ，看名字是应用上下文，什么意思呢？就是spirng整个运行环境的背景，好比一场舞台剧，ApplicatContext 就是舞台，IOC 管理的Bean 就是演员，Core 就是道具。而ApplicatContext 的标准实现是 FileSystemXmlApplicationContext。</span><br><span class="line"></span><br><span class="line">该类的构造方法中包含了容器的启动，IOC的初始化。所以我们 debug 启动该项目，运行main方法。打好断点。</span><br><span class="line"></span><br><span class="line">#### <span class="number">3.</span> 从 FileSystemXmlApplicationContext 开始剖析</span><br><span class="line"></span><br><span class="line">从这里开始，我们即将进入复杂的源码。</span><br><span class="line"></span><br><span class="line">我们进入 FileSystemXmlApplicationContext 的构造方法：</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-68d0fed37d45af94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">可以看到该构造方法被重载了，可以传递 configLocation 数组，也就是说，可以传递过个配置文件的地址。默认刷新为<span class="keyword">true</span>，parent 容器为<span class="keyword">null</span>。进入另一个构造器：</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-b61ee400629edb3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">该构造器做了<span class="number">2</span>件事情，一是设置配置文件，二是刷新容器，我们可以感觉到，refresh 方法才是初始化容器的重要方法。我们进入该方法看看：该方法是 FileSystemXmlApplicationContext  的父类 AbstractApplicationContext 的方法。</span><br><span class="line"></span><br><span class="line">#### <span class="number">4.</span> AbstractApplicationContext.refresh() 方法实现</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1. 构建Be按Factory，以便产生所需要的bean定义实例</span></span><br><span class="line"><span class="comment">	 * 2. 注册可能感兴趣的事件</span></span><br><span class="line"><span class="comment">	 * 3. 创建bean 实例对象</span></span><br><span class="line"><span class="comment">	 * 4. 触发被监听的事件</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// 为刷新准备应用上下文</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line">			<span class="comment">// 告诉子类刷新内部bean工厂，即在子类中启动refreshBeanFactory()的地方----创建bean工厂，根据配置文件生成bean定义</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">			<span class="comment">// 在这个上下文中使用bean工厂</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 设置BeanFactory的后置处理器</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line">				<span class="comment">// 调用BeanFactory的后处理器，这些后处理器是在Bean定义中向容器注册的</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">				<span class="comment">// 注册Bean的后处理器，在Bean创建过程中调用</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line">				<span class="comment">//对上下文的消息源进行初始化</span></span><br><span class="line">				initMessageSource();</span><br><span class="line">				<span class="comment">// 初始化上下文中的事件机制</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line">				<span class="comment">// 初始化其他的特殊Bean</span></span><br><span class="line">				onRefresh();</span><br><span class="line">				<span class="comment">// 检查监听Bean并且将这些Bean向容器注册</span></span><br><span class="line">				registerListeners();</span><br><span class="line">				<span class="comment">// 实例化所有的（non-lazy-init）单件</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">				<span class="comment">//  发布容器事件，结束refresh过程</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 为防止bean资源占用，在异常处理中，销毁已经在前面过程中生成的单件bean</span></span><br><span class="line">				destroyBeans();</span><br><span class="line">				<span class="comment">// 重置“active”标志</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以说该方法就是整个IOC容器初始化的所有逻辑。因此，如果读懂了该方法的每一行代码，就了解了spring的整个功能。该方法的调用层次之深可以想象一下。</p>
<p>我们先大致说下该方法的步骤：</p>
<ol>
<li>构建BeanFactory，以便于产生所需的 Bean。</li>
<li>注册可能感兴趣的事件。</li>
<li>常见Bean实例对象。</li>
<li>触发被监听的事件。</li>
</ol>
<p>我们一个个来看：<br>首先构建BeanFactory，在哪里实现的呢？也就是obtainFreshBeanFactory 方法，返回了一个ConfigurableListableBeanFactory，该方法调用了 refreshBeanFactory() ，该方法是个模板方法，交给了 AbstractRefreshableApplicationContext 去实现。我们看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">			<span class="comment">// 如果存在就销毁</span></span><br><span class="line">			destroyBeans();</span><br><span class="line">			closeBeanFactory();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// new DefaultListableBeanFactory(getInternalParentBeanFactory())</span></span><br><span class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">			<span class="comment">// 设置序列化</span></span><br><span class="line">			beanFactory.setSerializationId(getId());</span><br><span class="line">			<span class="comment">// 定制的BeanFactory</span></span><br><span class="line">			customizeBeanFactory(beanFactory);</span><br><span class="line">			<span class="comment">// 使用BeanFactory加载bean定义 AbstractXmlApplicationContext</span></span><br><span class="line">			loadBeanDefinitions(beanFactory);</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到BeanFactory的创建过程，首先判断是否存在了 BeanFactory，如果有则销毁重新创建，调用 createBeanFactory 方法，该方法中就是像注释写的：创建了 DefaultListableBeanFactory ，也既是说，DefaultListableBeanFactory 就是 BeanFactory的默认实现。然后我们看到一个很感兴趣的方法，就是 loadBeanDefinitions(beanFactory)，看名字是加载 Definitions，这个我们很感兴趣，我们之前说过， Definition 是核心之一，代表着 IOC 中的基本数据结构。该方法也是个抽象方法，默认实现是 AbstractXmlApplicationContext ，我们看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">	<span class="comment">// resource loading environment.</span></span><br><span class="line">	beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">	beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">	<span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法我没有写中文注释，我们看看英文注释: 首先创建一个 XmlBeanDefinitionReader ，用于读取XML中配置，设置了环境，资源加载器，最后初始化，加载。可以说，该方法将加载，解析Bean的定义，也就是把用户定义的数据结构转化为 IOC容器中的特定数据结构。而我们关心的则是最后一行的 loadBeanDefinitions(beanDefinitionReader) 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	<span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;<span class="comment">// 加载给定的路径文件</span></span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法会略过第一个if块，进入第二个if块，进入 AbstractBeanDefinitionReader.loadBeanDefinitions(String… locations) 方法，该方法内部循环加载配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">		counter += loadBeanDefinitions(location);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们关心的是 for 循环中的loadBeanDefinitions(location)方法，该方法核心逻辑在 AbstractBeanDefinitionReader.loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">		<span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">&quot;Cannot import bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">			<span class="comment">// Resource pattern matching available.</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">				<span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);<span class="comment">// 根据配置文件加载bean定义</span></span><br><span class="line">				<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">						actualResources.add(resource);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> loadCount;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">						<span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">			Resource resource = resourceLoader.getResource(location);</span><br><span class="line">			<span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">			<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">				actualResources.add(resource);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> loadCount;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line">该方法首先获取资源加载器，然后进入 <span class="keyword">if</span> 块，获取资源数组，调用 loadBeanDefinitions(resources) ，根据配置文件加载Bean定义。进入该方法后，循环加载resource 资源数组，进入 loadBeanDefinitions(resource) 方法中，最后进入到 XmlBeanDefinitionReader.loadBeanDefinitions(EncodedResource encodedResource) 方法中，该方法主要调用 doLoadBeanDefinitions(inputSource, encodedResource.getResource()) 方法。我们有必要看看该方法实现：</span><br><span class="line"></span><br><span class="line">```<span class="function">java</span></span><br><span class="line"><span class="function">	<span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">			<span class="keyword">return</span> registerBeanDefinitions(doc, resource);<span class="comment">// 真正的注册bean</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出该方法主要逻辑是根据输入流加载 Document 文档对象，然后根据得到的文档对象注册到容器，因此我们看看倒是是如何注册到容器的，该方法首先创建一个 BeanDefinitionDocumentReader， 用于读取  BeanDefinition，该对象会调用 registerBeanDefinitions(doc, createReaderContext(resource)) 方法，该方法最后从文档对象总获取根元素，最后调用<br>DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(root)  进行注册。该方法最核心的逻辑就是调用 parseBeanDefinitions(root, this.delegate)，我们看看该方法具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		NodeList nl = root.getChildNodes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node = nl.item(i);</span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">				Element ele = (Element) node;</span><br><span class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					parseDefaultElement(ele, delegate);<span class="comment">// 解析</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法就是一个解析XML 文档的步骤，核心是调用 parseDefaultElement(ele, delegate)，我们进入该方法查看，该方法调用了 processBeanDefinition(ele, delegate) 方法进行解析。我们有必要看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<span class="comment">// 解析</span></span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<span class="comment">// 开始注册</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先创建一个 BeanDefinitionHolder，该方法会调用 BeanDefinitionReaderUtils.registerBeanDefinition 方法， 最后执行容器通知事件。该静态方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">	String beanName = definitionHolder.getBeanName();</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());<span class="comment">// 注册</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到首先从bean的持有者那里获取了beanName，然后调用 registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())， 将bena的名字和 BeanDefinition 注册，我们看看最后的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">	oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Cannot register bean definition [&quot;</span> + beanDefinition + <span class="string">&quot;] for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27;: There is already [&quot;</span> + oldBeanDefinition + <span class="string">&quot;] bound.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.warn(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">						oldBeanDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.info(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + oldBeanDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + oldBeanDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">					Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">					updatedSingletons.remove(beanName);</span><br><span class="line">					<span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase // 最终放进这个map 实现注册</span></span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<span class="comment">// 走这里 // private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span></span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			<span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以说是注册bean的最后一步，将beanName和 beanDefinition 放进一个 ConcurrentHashMap（256） 中。</p>
<p>那么这个 beanDefinition  是时候创建的呢？ 就是在 DefaultBeanDefinitionDocumentReader.processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) 方法中，在这里创建了 BeanDefinitionHolder， 而该实例中解析Bean并将Bean 保存在该对象中。所以称为持有者。该实例会调用  parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) 方法，该方法用于解析XML文件并创建一个 BeanDefinitionHolder 返回，该方法会调用 parseBeanDefinitionElement(ele, beanName, containingBean) 方法， 我们看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">	String className = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">		className = ele.getAttribute(CLASS_ATTRIBUTE).trim();<span class="comment">// 类全限定名称</span></span><br><span class="line">	&#125;</span><br><span class="line">	String parent = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">		parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		AbstractBeanDefinition bd = createBeanDefinition(className, parent);<span class="comment">// 创建</span></span><br><span class="line"></span><br><span class="line">		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">		parseMetaElements(ele, bd);</span><br><span class="line">		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">		parseConstructorArgElements(ele, bd);</span><br><span class="line">		parsePropertyElements(ele, bd);</span><br><span class="line">		parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">		bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">		bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> bd;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">		error(<span class="string">&quot;Class that bean class [&quot;</span> + className + <span class="string">&quot;] depends on not found&quot;</span>, ele, err);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		error(<span class="string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看看该方法，可以看到，该方法从XML元素中取出 class 元素，然后拿着className调用 createBeanDefinition(className, parent) 方法，该方法核心是调用 BeanDefinitionReaderUtils.createBeanDefinition 方法，我们看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">	GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();<span class="comment">// 泛型的bean定义，也就是最终生成的bean定义。</span></span><br><span class="line">	bd.setParentName(parentName);</span><br><span class="line">	<span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">			bd.setBeanClass(ClassUtils.forName(className, classLoader));<span class="comment">// 设置Class 对象</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			bd.setBeanClassName(className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法很简单，创建一个 Definition  的持有者，然后设置该持有者的Class对象，该对象就是我们在配置文件中配置的Class对象。最后返回。</p>
<p>到这里，我们一走完了第一步，创建bean工厂，生成Bean定义。但还没有实例化该类。</p>
<h4 id="5-如何创建Bean实例并构建Bean的依赖关系网"><a href="#5-如何创建Bean实例并构建Bean的依赖关系网" class="headerlink" title="5. 如何创建Bean实例并构建Bean的依赖关系网"></a>5. 如何创建Bean实例并构建Bean的依赖关系网</h4><p>我们刚刚创建了Bean工厂，并创建 BeanDefinitions 放进Map里，以beanName为key。那么我们现在有了Bean定义，但还没有实例，也没有构建Bean与Bean之间的依赖关系。我们知道，构建依赖关系是 IOC 的一个重要的任务，我们怎么能放过。那么是在哪里做的呢？在  finishBeanFactoryInitialization(beanFactory) 方法中。该方法中重要的一步是 ： beanFactory.preInstantiateSingletons()，我们有必要看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">	<span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">	List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">				<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);<span class="comment">// 注意：FactoryBean</span></span><br><span class="line">				<span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">				<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">					isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;</span><br><span class="line">							((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(),</span><br><span class="line">							getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">							((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				getBean(beanName);<span class="comment">// 创建bean</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		Object singletonInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">			<span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先循环所有的BeanNames，并且调用getBean方法，该方法实际上就是创建bean并递归构建依赖关系。该方法会调用 doGetBean(name, null, null, false)，我们进入该方法查看，该方法很长，楼主挑选重要代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] dependsOn = mbd.getDependsOn();<span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		registerDependentBean(dep, beanName);</span><br><span class="line">		getBean(dep);<span class="comment">// 递归</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">	sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">			<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">			<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">			destroySingleton(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，该方法首先会获取依赖关系，拿着依赖的BeanName 递归调用 getBean方法，直到调用 getSingleton 方法返回依赖bean，而 getSingleton 方法的参数是 createBean 返回的实例，该方法内部调用 AbstractAutowireCapableBeanFactory.doCreateBean 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the bean.</span></span><br><span class="line">	BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">	<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">	<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">							<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">							<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">							<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">							<span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法很长，我们只关注二行代码： </p>
<ol>
<li>instanceWrapper = createBeanInstance(beanName, mbd, args) 创建实例。</li>
<li>populateBean(beanName, mbd, instanceWrapper) ， 该方法用于填充Bean，该方法可以就是说就是发生依赖注入的地方。</li>
</ol>
<p>我们看看 createBeanInstance 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">	Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">				<span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">	<span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">		<span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">	<span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">				resolved = <span class="keyword">true</span>;</span><br><span class="line">				autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">		<span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Need to determine the constructor...</span></span><br><span class="line">	Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">	<span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">			mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">			mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">		<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">	<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的doc注释是这样介绍的：为指定的bean创建一个新的实例，使用适当的实例化策略:工厂方法、构造函数自动装配或简单实例化。我们看，该方法首先创建Class 对象，然后获取构造器对象，最后调用 instantiateBean(beanName, mbd) 方法，我们看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object beanInstance;</span><br><span class="line">		<span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">					getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">					getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">		&#125;</span><br><span class="line">		BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		<span class="keyword">return</span> bw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法核心逻辑是 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent)，携带BeanName ,RootBeanDefinition ,发挥的策略对象是 SimpleInstantiationStrategy，该方法内部调用静态方法<br> BeanUtils.instantiateClass(constructorToUse)， 组后调用 Constructor 的 newInstance 方法， 也就是最终使用反射创建了该实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException </span>&#123;</span><br><span class="line">	Assert.notNull(ctor, <span class="string">&quot;Constructor must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">		<span class="keyword">return</span> (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?</span><br><span class="line">				KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is it an abstract class?&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is the constructor accessible?&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Illegal arguments for constructor&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Constructor threw exception&quot;</span>, ex.getTargetException());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会判断是否是 Kotlin 类型。如果不是，则调用构造器的实例方法。</p>
<p>到这里，我们的实例已经创建。但是我们的实例的依赖还没有设置，刚刚我们在 doCreateBean  方法说关心2行代码：</p>
<ol>
<li>instanceWrapper = createBeanInstance(beanName, mbd, args) 创建实例。</li>
<li>populateBean(beanName, mbd, instanceWrapper) ， 该方法用于填充Bean，该方法可以就是说就是发生依赖注入的地方。</li>
</ol>
<p>我们已经解析了第一个，现在看第二个方法：</p>
<p>我们看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">		<span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">		<span class="comment">// to support styles of field injection.</span></span><br><span class="line">		<span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">					<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">						continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">			MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">				autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">				autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pvs = newPvs;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">		<span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">				pvs = mbd.getPropertyValues();</span><br><span class="line">			&#125;</span><br><span class="line">			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">			<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">				<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">					<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">						<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">				checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">			applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该方法核心逻辑是 PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null)， 即获取该bean的所有属性，也就是我们配置property元素。最后执行 applyPropertyValues(beanName, mbd, bw, pvs) 方法。注意，现在的PropertyValues 都是字符串，没有值的，这个方法的作用就是获取值，关键代码：Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue)，该方法会获取 pvName 所对应的容器value，该方法内部会调用 BeanWrapperImpl.resolveReference(argName, ref) 方法，我们看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object bean;</span><br><span class="line">		String refName = ref.getBeanName();</span><br><span class="line">		refName = String.valueOf(doEvaluate(refName));</span><br><span class="line">		<span class="keyword">if</span> (ref.isToParent()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.getParentBeanFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">						<span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line">						<span class="string">&quot;Can&#x27;t resolve reference to bean &#x27;&quot;</span> + refName +</span><br><span class="line">						<span class="string">&quot;&#x27; in parent factory: no parent factory available&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			bean = <span class="keyword">this</span>.beanFactory.getParentBeanFactory().getBean(refName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			bean = <span class="keyword">this</span>.beanFactory.getBean(refName);</span><br><span class="line">			<span class="keyword">this</span>.beanFactory.registerDependentBean(refName, <span class="keyword">this</span>.beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			bean = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				<span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line">				<span class="string">&quot;Cannot resolve reference to bean &#x27;&quot;</span> + ref.getBeanName() + <span class="string">&quot;&#x27; while setting &quot;</span> + argName, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一行熟悉的代码：bean = this.beanFactory.getBean(refName)，对，这里就是发生递归的地方。该方法会拿着属性名称从容器中获取实例。</p>
<p>我们回到 applyPropertyValues 方法。此时deepCopy 集合已经有值了，不再仅仅是字符串了。然后调用 setPropertyValues(new MutablePropertyValues(deepCopy)) 方法， 该方法会调用 AbstractPropertyAccessor.setPropertyValues 方法完成注入，而该方法会循环元素列表， 循环中调用 setPropertyValue(PropertyValue pv) 方法， 该方法最后会调用  nestedPa.setPropertyValue(tokens, pv) 方法， 该方法又会调用  processLocalProperty(tokens, pv) 方法，该方法最后又会调用 ph.setValue(valueToApply) 方法，也就是BeanWrapperImpl.setValue() 方法，终于，我们要看到反射了，看到反射说明到了尽头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">final</span> <span class="meta">@Nullable</span> Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Method writeMethod = (<span class="keyword">this</span>.pd <span class="keyword">instanceof</span> GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">			((GenericTypeAwarePropertyDescriptor) <span class="keyword">this</span>.pd).getWriteMethodForActualAccess() :</span><br><span class="line">			<span class="keyword">this</span>.pd.getWriteMethod());</span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">			ReflectionUtils.makeAccessible(writeMethod);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt;</span><br><span class="line">					writeMethod.invoke(getWrappedInstance(), value), acc);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (PrivilegedActionException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex.getException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ReflectionUtils.makeAccessible(writeMethod);</span><br><span class="line">		writeMethod.invoke(getWrappedInstance(), value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是最后一步，我们看到该方法会找的set方法，然后调用 Method 的 invoke 方法，完成属性注入。</p>
<p>真的不容易。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>我们从源码层面剖析 IOC 的初始化过程,也了解了 IOC 的底层原理实现, 我们总结一下: Spring 的 Bean 其实就是 BeanDefinition, 在 Bean 的创建和依赖注入的过程中, 需要根据 BeanDefinition 的信息来递归的完成依赖注入, 从我们分析的代码可以看到,这些递归都是以 getBean() 为入口的, 一个递归是在上下文体系中查找需要的 Bean 和创建 Bean 的递归调用, 另一个 Bean 实在依赖注入时,通过递归调用容器的 getBean 方法, 得到当前的依赖 Bean, 同时也触发对依赖 Bean 的创建和注入. 在对 Bean 的属性尽心依赖注入时, 解析的过程也是一个递归的过程, 这样, 根据依赖关系, 一层一层的完成 Bean 的创建和注入, 知道最后完成当前 Bean 的创建, 有了这个顶层 Bean 的创建和对他的属性依赖注入的完成, 意味着当前 Bean 相关的整个依赖链的注入也完成了.</p>
<p>总结一下 IOC 的初始化过程吧:</p>
<ol>
<li>资源(Resource)定位;</li>
<li>BeanDefinition 的载入和 BeanFactory 的构造.</li>
<li>想 IOC 容器(BeanFactory)注册 BeanDefinition.</li>
<li>根据 lazy-init 属性初始化 Bean 实例和依赖注入.</li>
</ol>
<p>现在回过头看看, 我们已经了解了 Spring IOC 的设计, 那么我们自己可以实现一个简单的 IOC 吗? 楼主想试试, 并且楼主已经写好了, 下篇, 和大家一起实现一个简单的 IOC. </p>
<p>Good Luck!!!</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Spring-之-Spring-进阶开发必知必会-之-Spring-扩展接口</title>
    <url>/2017/12/13/2017/2017-12-13-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-%E4%B9%8B-Spring-%E8%BF%9B%E9%98%B6%E5%BC%80%E5%8F%91%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E4%B9%8B-Spring-%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       我们在前几篇文章中已经深入了解了 Spring 的 IOC 机制和 AOP 机制，在阅读源码的同时，楼主对 Spring 中设计模式的运用可以说五体投地，还有我们还知道更重要的一点就是：Spring 留给了我们大量的扩展接口供开发者去自定义自己的功能，甚至于 AOP 就是在 Spring 预留的扩展接口中实现的，意思是只要基于 Spring IOC，遵守 Spring 对扩展接口的约定，那么就能实现自己想要的功能。可见 IOC 的强大，那么。今天我们就将 Spring 留给我们的接口拿出来说一说。而我们的标题是Spring 进阶开发，为什么这么说，如果说只是简单的使用 Spring 中的bean，那么只是Spring的初级开发者。如何精通Spring 就看有没有掌握好Spring留给我们的这些扩展接口，以及如何使用他们。

<p>我们今天主要讲述以下几个接口，如有遗漏，请指出：</p>
<ol>
<li>FactroyBean 我们熟悉的AOP基础bean</li>
<li>BeanPostProcess 在每个bena初始化成前后做操作。</li>
<li>InstantiationAwareBeanPostProcessor 在Bean实例化前后做一些操作。</li>
<li>BeanNameAware、ApplicationContextAware 和 BeanFactoryAware 针对bean工厂，可以获取上下文，可以获取当前bena的id。</li>
<li>BeanFactoryPostProcessor Spring允许在Bean创建之前，读取Bean的元属性，并根据自己的需求对元属性进行改变，比如将Bean的scope从singleton改变为prototype。</li>
<li>InitialingBean 在属性设置完毕后做一些自定义操作 DisposableBean 在关闭容器前做一些操作。</li>
</ol>
<h2 id="1-FactroyBean-我们熟悉的AOP基础bean"><a href="#1-FactroyBean-我们熟悉的AOP基础bean" class="headerlink" title="1. FactroyBean 我们熟悉的AOP基础bean"></a>1. FactroyBean 我们熟悉的AOP基础bean</h2><p>这个Bean 我们再属性不过，我们再学习 AOP 的时候，知道 XML 方式的 AOP 就是通过该接口实现的。我们复习以下该接口的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该接口定义了3个方法，获取bean实例，获取bean类型，是否是单例。Spring 在 IOC 初始化的时候，一般的Bean都是直接调用构造方法，而如果该Bean实现了FactoryBean 接口，则会调用该Bean的 getObject 方法获取bean，这也是Spring 使用此接口构造AOP的原因。在 IOC 调用此方法的时候，返回一个代理，完成AOP代理的创建。</p>
<p>我们做个测试：定义一个FactoryBean，重写他的 getObject 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0690073c1a323270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>测试类中调用：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-420c6f81201b7dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意：此时返回的已经是 AOP 类型的Bean，因为我们在 getObject 返回到是 new Aop（），验证了我们之前说的。使用该接口，能够为我们做很多有趣的事情。就靠你来想象了。</p>
<h2 id="2-BeanPostProcess-在每个bean初始化成前后做操作。"><a href="#2-BeanPostProcess-在每个bean初始化成前后做操作。" class="headerlink" title="2. BeanPostProcess 在每个bean初始化成前后做操作。"></a>2. BeanPostProcess 在每个bean初始化成前后做操作。</h2><p>该接口我们应该也非常的熟悉，还记的我们的注解配置的AOP是如何实现的。就是间接实现了该接口。在 IOC 初始化的时候，会调用的该接口的后置处理方法。我们看看该接口定义：</p>
<pre><code class="java">public interface BeanPostProcessor &#123;

    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;

    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
&#125;
</code></pre>
<p>一个是前置方法，一个是后置方法，注解方式的AOP的实现就是在 postProcessAfterInitialization 方法中实现的。我们写一个测试类，看看结果是什么？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d5b8cb9a8e309d0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们在Bean 初始化之前后之后都打印以下该Bean的名称，那么运行结果是什么呢？下面是SpringBoot 启动后的一部分日志：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2994bfb922c69ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到我们项目中所有的Bean在初始化的时候都调用该方法。因此，我们在以后的开发中就可以做一些自定义的事情。</p>
<h2 id="3-InstantiationAwareBeanPostProcessor-在Bean实例化前后做一些操作。"><a href="#3-InstantiationAwareBeanPostProcessor-在Bean实例化前后做一些操作。" class="headerlink" title="3. InstantiationAwareBeanPostProcessor 在Bean实例化前后做一些操作。"></a>3. InstantiationAwareBeanPostProcessor 在Bean实例化前后做一些操作。</h2><p>这个接口实际上我们也是非常的熟悉，该接口在我们剖析注解配置AOP的时候是我们的老朋友，实际上，注解配置的AOP是间接实现 BeanPostProcess  接口的，而 InstantiationAwareBeanPostProcessor 就是继承该接口的。我们看看他的继承图谱：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-74dcb5b9177f71b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到该接口在继承的基础上又增加了3个方法，增加了扩展bean的功能。我们写个 Demo 测试一下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-29ddb24f49ffece8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，需要实现 5 个方法，其中2个方法是 BeanPostProcess 接口定义的方法：在bean初始化的前后执行，而 InstantiationAwareBeanPostProcessor 则新增了 3 个方法，分别是 postProcessBeforeInstantiation （实例化之前），postProcessAfterInstantiation （实例化之后），postProcessPropertyValues （在处理Bean属性之前），开发者可以在这三个方法中添加自定义逻辑，比如AOP。我们看看运行结果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d96008103fc9befc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，所有的Bean在IOC的时候都执行了我们的方法，其中实例化在初始化之前执行，这个顺序对我们使用该接口是很重要的，千万不要弄混。</p>
<h2 id="4-BeanNameAware、ApplicationContextAware-和-BeanFactoryAware-针对bean工厂，可以获取上下文，可以获取当前bena的id。"><a href="#4-BeanNameAware、ApplicationContextAware-和-BeanFactoryAware-针对bean工厂，可以获取上下文，可以获取当前bena的id。" class="headerlink" title="4. BeanNameAware、ApplicationContextAware 和 BeanFactoryAware 针对bean工厂，可以获取上下文，可以获取当前bena的id。"></a>4. BeanNameAware、ApplicationContextAware 和 BeanFactoryAware 针对bean工厂，可以获取上下文，可以获取当前bena的id。</h2><p>这三个接口的功能其中都一样，我们看看他们的继承图谱就知道了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f5fb19b0b26f3952.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，这三个接口都继承自 Aware 接口，并分别定义了自己的接口定义方法。实现这些接口就能得到Spring的Bean 工厂。从而调用getBean方法获取Bean。很多项目中都使用此接口做了Spring的工具类。比如可以像这么使用：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-244d60d8fba15307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们写了一个测试类，然后看以下运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d92ed33522990841.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-dee8507b0239efd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，在IOC的过程中，该Bean的三个方法都被执行，我们就可以获取到容器，从而可以做很多自定义的额事情。</p>
<h2 id="5-BeanFactoryPostProcessor-Spring允许在Bean创建之前，读取Bean的元属性，并根据自己的需求对元属性进行改变，比如将Bean的scope从singleton改变为prototype。"><a href="#5-BeanFactoryPostProcessor-Spring允许在Bean创建之前，读取Bean的元属性，并根据自己的需求对元属性进行改变，比如将Bean的scope从singleton改变为prototype。" class="headerlink" title="5. BeanFactoryPostProcessor Spring允许在Bean创建之前，读取Bean的元属性，并根据自己的需求对元属性进行改变，比如将Bean的scope从singleton改变为prototype。"></a>5. BeanFactoryPostProcessor Spring允许在Bean创建之前，读取Bean的元属性，并根据自己的需求对元属性进行改变，比如将Bean的scope从singleton改变为prototype。</h2><p>我们看看该接口的定义：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-68faef012c4f21e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>只定义了一个方法，该方法注释：在它的标准初始化之后修改应用程序上下文的内部bean工厂。所有的bean定义都已经加载了，但是还没有实例化bean。这允许覆盖或添加属性，甚至是对初始化bean的属性。参数是什么呢？应用程序上下文所使用的bean工厂。也就是说，我们可以获取某个Bean的定义，然后修改该Bean的定义：比如下面这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-181c10f1798c536a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看看运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b0b2ed0df773fd6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们将成功的单例的Bean改成了多例。</p>
<h2 id="6-InitialingBean-在属性设置完毕后做一些自定义操作。-DisposableBean-在关闭容器前做一些操作。"><a href="#6-InitialingBean-在属性设置完毕后做一些自定义操作。-DisposableBean-在关闭容器前做一些操作。" class="headerlink" title="6. InitialingBean 在属性设置完毕后做一些自定义操作。 DisposableBean 在关闭容器前做一些操作。"></a>6. InitialingBean 在属性设置完毕后做一些自定义操作。 DisposableBean 在关闭容器前做一些操作。</h2><p>我们写以下demo 看看是如何运行的：</p>
<p>实现这两个接口： </p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f8c60f69a5d149a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>启动类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9e5c0949f89c1dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在运行启动类之后，就会关闭容器。退出虚拟机，我们看看运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-89fe607165ba9df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在执行Set 属性方法后，立即执行 afterPropertiesSet 方法，因此，我们就可以在该方法中做一些事情，然后在执行  System.exit(0) 后，执行 destroy 方法，我们也可以在该方法中执行一些逻辑。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p>我们了解了 Spring 留给我们的扩展接口，以提高我们使用 Spring 的水平，在以后的业务中，也就可以基于 Spring 做一些除了简单的注入这种基本功能之外的功能。同时，我们也发现，Spring 的扩展性非常的高，符合设计模式中的开闭原则，对修改关闭，对扩展开放，实现这些的基础就是 Spring 的 IOC，IOC 可以说是 Spring 的核心， 在 IOC 的过程中，对预定义的接口做了很多的预留工作。这让其他框架与 Spring 的组合变得更加的简单，我们在以后的开发工作中也可以借鉴 Spring 的思想，让程序更加的优美。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Spring-之-源码剖析-SpringBoot-Aop-切面编织过程和代理执行过程</title>
    <url>/2017/12/11/2017/2017-12-11-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-%E4%B9%8B-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-SpringBoot-Aop-%E5%88%87%E9%9D%A2%E7%BC%96%E7%BB%87%E8%BF%87%E7%A8%8B%E5%92%8C%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       # 源码：
![](http://upload-images.jianshu.io/upload_images/4236553-811b1a3202d0b159.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](http://upload-images.jianshu.io/upload_images/4236553-d6e5c7b8778a1e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](http://upload-images.jianshu.io/upload_images/4236553-ed80419b292c033f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




<h2 id="前言"><a href="#前言" class="headerlink" title="# 前言"></a># 前言</h2><p>前两篇文章我们分析了AOP的原理，知道了AOP的核心就是代理，通知器，切点。我们也知道了XML配置方式和注解方式的底层实现都是相同的，都是通过 ProxyCreatorSupport  创建代理，但是XML是通过 ProxyFactoryBean 来实现的，而 注解是通过 BeanPostProcessor 来实现创建代理的逻辑。</p>
<p>我们上篇讲解注解方式的文章，剖析了 AnnotationAwareAspectJAutoProxyCreator 这个类，这个类就是根据注解创建代理的默认类。那么到底该类在Spring 中是如何运行的？基于注解的 AOP 在现在流行的 SpringBoot 中是如何设计实现的？今天楼主就要以一个简单的demo来 debug 一次源码，彻底了解 SpringBoot 下的AOP 是如何运作的。</p>
<p>我们将分为几个方面来讲：</p>
<ol>
<li>AnnotationAwareAspectJAutoProxyCreator  后置处理器注册过程。</li>
<li>标注 @Aspect 注解的 bean 的后置处理器的处理过程</li>
<li>创建代理的过程</li>
<li>目标对象方法调用的过程</li>
</ol>
<h2 id="1-AnnotationAwareAspectJAutoProxyCreator-后置处理器注册过程"><a href="#1-AnnotationAwareAspectJAutoProxyCreator-后置处理器注册过程" class="headerlink" title="1. AnnotationAwareAspectJAutoProxyCreator  后置处理器注册过程"></a>1. AnnotationAwareAspectJAutoProxyCreator  后置处理器注册过程</h2><h3 id="1-1-后置处理器继承图谱"><a href="#1-1-后置处理器继承图谱" class="headerlink" title="1.1 后置处理器继承图谱"></a>1.1 后置处理器继承图谱</h3><p>我们先回顾一下该类的继承图谱 ，看图中红框部分，可以看到该类间接实现了 BeanPostProcessor 接口，而且也实现了 InstantiationAwareBeanPostProcessor 接口，InstantiationAwareBeanPostProcessor 接口继承了BeanPostProcessor 接口。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d4c9a1ccb7919d3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们重点看看这两个接口的关系，InstantiationAwareBeanPostProcessor 接口通过继承 BeanPostProcessor 拥有了父接口的两个方法，父类的两个方法是在bean初始化前后做一些控制，而 InstantiationAwareBeanPostProcessor  自己增加的方法则是在bean的实例化做一些控制，顺序：先执行 InstantiationAwareBeanPostProcessor 自身的两个实例化方法，再执行父接口的初始化方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e586c1039d657127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看到这些方法肯定会问，BeanPostProcessor 这个接口不是在初始化前和初始化后都能做一些操作吗，为什么只叫后置处理器，应该叫前后置处理器啊？那么我们就去看看源码，该方法被多处重写，我们查看重写该方法的所有的实现，可以看到所有处理该方法的逻辑都是直接返回bean，没有任何逻辑操作，可见该方法就是一个空方法。而 postProcessAfterInitialization 后置处理初始化方法各个实现类都有不同的操作。还有一个需要注意的的地方就是，InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个方法名称极其相似，注意区分，BeanPostProcessor 是初始化，InstantiationAwareBeanPostProcessor  是实例化，实例化先执行，初始化后执行。</p>
<p>为什么大张旗鼓的说后置处理器这个事情呢？因为 AnnotationAwareAspectJAutoProxyCreator 就是后置处理器啊，他继承了 AbstractAutoProxyCreator 抽象类，该类实现了后置处理器接口的方法。</p>
<p>既然是个后置处理器，那么就需要注册，我们就看看注册后置处理器的过程。</p>
<h3 id="1-2-后置处理器注册过程"><a href="#1-2-后置处理器注册过程" class="headerlink" title="1.2 后置处理器注册过程"></a>1.2 后置处理器注册过程</h3><p>我们会议一下Spring 容器初始化的方法 refresh ，当时我们说，该方法是整个spring 的核心代码，所有的逻辑都是从这里作为入口，那么该方法中有注册后置处理器的逻辑吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// 为刷新准备应用上下文</span></span><br><span class="line">           prepareRefresh();</span><br><span class="line">		<span class="comment">// 告诉子类刷新内部bean工厂，即在子类中启动refreshBeanFactory()的地方----创建bean工厂，根据配置文件生成bean定义</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">		<span class="comment">// 在这个上下文中使用bean工厂</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 设置BeanFactory的后置处理器// 默认什么都不做</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line">			<span class="comment">// 调用BeanFactory的后处理器，这些后处理器是在Bean定义中向容器注册的</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">			<span class="comment">// 注册Bean的后处理器，在Bean创建过程中调用</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line">			<span class="comment">//对上下文的消息源进行初始化</span></span><br><span class="line">			initMessageSource();</span><br><span class="line">			<span class="comment">// 初始化上下文中的事件机制</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line">			<span class="comment">// 初始化其他的特殊Bean</span></span><br><span class="line">			onRefresh();</span><br><span class="line">			<span class="comment">// 检查监听Bean并且将这些Bean向容器注册</span></span><br><span class="line">			registerListeners();</span><br><span class="line">			<span class="comment">// 实例化所有的（non-lazy-init）单件</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">			<span class="comment">//  发布容器事件，结束refresh过程</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="comment">// 为防止bean资源占用，在异常处理中，销毁已经在前面过程中生成的单件bean</span></span><br><span class="line">			destroyBeans();</span><br><span class="line">			<span class="comment">// 重置“active”标志</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们看一下代码，可以看到，其中有一行代码，registerBeanPostProcessors(beanFactory)，注册后置处理器，携带BeanFactory参数，该方法会调用 PostProcessorRegistrationDelegate 的一个静态方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d7f55959d7fbf004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该静态方法很长，主要逻辑就是，从BeanFactory 中找到所有实现了 BeanPostProcessor 接口的bean，然后添加进集合，最后调用自身的 registerBeanPostProcessors 静态方法，循环调用 beanFactory 的addBeanPostProcessor 方法，将后置处理器添加进bean工厂。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-81866e2e2cae5b12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>bean工厂的 addBeanPostProcessor 方法如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-79144b5798143a93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>将后置处理器放在一个集合中，并保证只有一个不会重复。然后判断是否 InstantiationAwareBeanPostProcessor 类型的后置处理器，如果有，就将状态hasInstantiationAwareBeanPostProcessors 改为 true。</p>
<p>这个时候也就是完成了后置处理器的注册过程。</p>
<h2 id="2-标注-Aspect-注解的-bean-的后置处理器的处理过程"><a href="#2-标注-Aspect-注解的-bean-的后置处理器的处理过程" class="headerlink" title="2. 标注 @Aspect 注解的 bean 的后置处理器的处理过程"></a>2. 标注 @Aspect 注解的 bean 的后置处理器的处理过程</h2><p>我们在使用 @Aspec 同时也会使用类似 @Component 的注解，表示这是一个Bean，只要是bean，就会调用getBean方法，只要调用 getBean 方法，都会调用 AbstractAutowireCapableBeanFactory 的 createBean 方法，该方法其中有一行函数调用：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-918a38a8f60e6094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注释说，会返回一个代理，我们看看该方法到底是什么逻辑：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-35bae00d974ffcfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们注意看该方法的 if 判断，hasInstantiationAwareBeanPostProcessors， 就是判断我们刚刚设置的状态，向下走，获取到Bean的类型，先调用 applyBeanPostProcessorsBeforeInstantiation 方法，如果该方法有返回值，则调用 applyBeanPostProcessorsAfterInitialization 方法，注意，上面调用的是  “实例化前方法”，下面那个调用的是 “初始化后方法”，是不同的接口实现。通常在第一次调用的的时候，是不会有返回值的。我们看看该方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-591acd118d547219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法会获取所有的后置处理器，就是之前注册在BeanFactory 的后置处理器，并循环调用他们的 postProcessBeforeInstantiation 方法，但是还是要判断是不是 InstantiationAwareBeanPostProcessor 类型，我们关注的当然是我们在之前的说的 AbstractAutoProxyCreator 后置处理器，我们看看他的 postProcessBeforeInstantiation 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4eb22a60fbd9b84a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法首先检验参数，如果缓存中存在的话就直接返回。如果不在，则判断该bean的类型是否是基础类型，上面是基础类型？ 我们看代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1f9a10f5fc032543.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法首先调用父类的的 isInfrastructureClass 方法，然后调用 isAspcet 方法。我们看看这两个方法的实现：</p>
<p><strong>isInfrastructureClass</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f33bd77d62f2dd56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>判断是否是这几个基础类。</p>
<p><strong>isAspect</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-246c3ee1e44c9ede.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>判断该类是否含有Aspect 注解并且该类属性中含有 “ajc$” 开头的成员变量。</p>
<p>那么后面的那个判断呢？shouldSkip ，字面意思：是否应该跳过。  该方法默认实现是false，但该类注释说，子类需要重写该方法。我们看看该方法是如何重写的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-22b53568dfeb4d04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先找到所有候选的通知器，然后循环通知器数组，如果该通知器是 AspectJPointcutAdvisor 类型，并且该通知器的通知的切面名称和bean的名字相同，就返回 true。重点在如果获取通知器，在XML配置中，我们知道，通知器是我们显式的实现了 PointcutAdvisor 接口的类，并在配置文件中配置。而这里我们没有配置。Spring 是如何找到的呢？我们看看 findCandidateAdvisors 方法，该方法委托了 advisorRetrievalHelper 调用 findAdvisorBeans 方法，我们看看该方法实现。<br>注意：findCandidateAdvisors 方法被重写了，我们看子类实现。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7fca130fe119060f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>子类方法比父类方法多了一行 buildAspectJAdvisors。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Determine list of advisor bean names, if not cached already.</span></span><br><span class="line">		String[] advisorNames = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">			<span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">				<span class="comment">// uninitialized to let the auto-proxy creator apply to them!</span></span><br><span class="line">				advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">						<span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">				<span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">&quot;Skipping currently created advisor &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">						Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line">						<span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;</span><br><span class="line">							BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">							<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(bce.getBeanName())) &#123;</span><br><span class="line">								<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">									logger.debug(<span class="string">&quot;Skipping advisor &#x27;&quot;</span> + name +</span><br><span class="line">											<span class="string">&quot;&#x27; with dependency on currently created bean: &quot;</span> + ex.getMessage());</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="comment">// Ignore: indicates a reference back to the bean we&#x27;re trying to advise.</span></span><br><span class="line">								<span class="comment">// We want to find advisors other than the currently created bean itself.</span></span><br><span class="line">								<span class="keyword">continue</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> advisors;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法会通过  BeanFactoryUtils.beanNamesForTypeIncludingAncestors 方法获取容器中所有实现了Advisor 接口的Bean，然而我们的demo程序里上面都没有。如果是XML就会返回了。</p>
<p>那我们看第二行的 this.aspectJAdvisorsBuilder.buildAspectJAdvisors(）方法，该方法根据注解创建通知器。我们看看该方法逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">			<span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">				List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">				aspectNames = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">				String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">						<span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">				<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line">					<span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">					Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">					<span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">						aspectNames.add(beanName);</span><br><span class="line">						AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">						<span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">							MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">									<span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">							List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">							<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">								<span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> &#123;</span><br><span class="line">								<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">							&#125;</span><br><span class="line">							advisors.addAll(classAdvisors);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="comment">// Per target or per this.</span></span><br><span class="line">							<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">								<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName +</span><br><span class="line">										<span class="string">&quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;</span>);</span><br><span class="line">							&#125;</span><br><span class="line">							MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">									<span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">							<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">							advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">				<span class="keyword">return</span> advisors;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">		List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">		<span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advisors.addAll(cachedAdvisors);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">			advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法很长，我们看看主要逻辑：先调用静态方法 BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false) ，也就是获取容器中所有的bean，然后循环处理每个bean。这个 buildAspectJAdvisors 有个注意的地方就是，每次执行该方法，最后都会更新 aspectBeanNames 属性，该属性是通知器的名称集合。在循环中，会先创建一个 AspectMetadata 切面元数据对象，然后创建 BeanFactoryAspectInstanceFactory 对象，在使用 advisorFactory 的 getAdvisors 方法携带刚刚创建的 factory 对象获取该Class 对应的所有 通知器。</p>
<p>我们看看 getAdvisors 的标准实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">	String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">	validate(aspectClass);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line">	<span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">	MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">			<span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">		Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">		<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advisors.add(advisor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If it&#x27;s a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">	<span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">		Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">		advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find introduction fields.</span></span><br><span class="line">	<span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">		Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">		<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advisors.add(advisor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 getAdvisors 方法中，会先根据Bean 的Class，比如 Aop.class，和 切面名称，也就是benaNanme，然后根据class，获取所有不带 @Pointcut.class 的 Method 对象集合，也就是 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class 这些注解。拿到这些方法数组后，进行循环处理，调用自己的 getAdvisor 方法，我们看看 getAdvisor 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line">	AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">			candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">	<span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">			<span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，则根据method 对象获取Pointcut，getPointcut 会将该方法上面的注解解析成一个 AspectJExpressionPointcut 切面表达式切入点对象，最后 getAdvisor 将所有参数和 刚刚创建的对象 包装成 InstantiationModelAwarePointcutAdvisorImpl 对象也就是 Advisor 的子类 返回。</p>
<p>回到 getAdvisors 方法中， 该方法会将 getAdvisor 方法的返回值添加到 Advisors 数组中，然后如果数组不为空的话，创建一个合成的，没有作用的通知器。 然后，循环切面类的所有属性，解析含有 DeclareParents 注解的成员变量。</p>
<p>至此，得到了该类所有的通知器。然后放入缓存。最后 ，将 aspectBeanNames 属性重新赋值。并返回 advisors。</p>
<p>回到 findCandidateAdvisors 方法，也就是寻找候选的通知器。然后将创建的通知器返回。</p>
<p>回到  AbstractAutoProxyCreator 的 postProcessBeforeInstantiation 的方法， 该方法的 shouldSkip 判断返回false， 没能进入if块返回，继续向下走。 </p>
<p>首先寻找 Bean 的目标类，我们并没有设置目标类，然后，就返回null。至此，resolveBeforeInstantiation 方法返回了null。并没有像注释说的返回一个代理，除非设置了 customTargetSourceCreators。虽然这里也能创建代理。而该方法也就结束了。该方法主要执行了后置处理器的 “实例化之前” 方法。</p>
<h2 id="3-创建代理的过程"><a href="#3-创建代理的过程" class="headerlink" title="3. 创建代理的过程"></a>3. 创建代理的过程</h2><p>在执行完 resolveBeforeInstantiation 返回 null 之后，就执行 doCreateBean 方法，我们很熟悉这个方法，该方法在调用 populateBean 方法后完成了依赖注入，然后进行初始化， 调用 initializeBean 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c75d6790082ba381.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>initializeBean 方法</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-17699c53bcffcae8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>initializeBean  方法中调用了3个重要的逻辑，applyBeanPostProcessorsBeforeInitialization 方法 ， 和 invokeInitMethods 方法（如果实现了InitializingBean 接口，则会调用 afterPropertiesSet 方法），还有重要的 applyBeanPostProcessorsAfterInitialization 方法。</p>
<p>首先调用了前置处理器的 postProcessBeforeInitialization 方法，简单的返回了bean。<br>然后判断是否实现 InitializingBean  接口从而决定是否调用  afterPropertiesSet  方法。</p>
<p> 最后到了最重要的 applyBeanPostProcessorsAfterInitialization  方法， 该方法会循环调用每个bean的后置处理器的 postProcessAfterInitialization 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f909b6dc9103de4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>现在，来到了我们熟悉的 postProcessAfterInitialization 方法，该方法重写了 BeanPostProcessor 接口的方法，然后进入到 wrapIfNecessary 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-80c3acf11b904dc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先判断是否 targetSourcedBeans 目标bean 集合中是否存在，有则直接返回。<br>再判断对应的bean是否含有通知器。<br>再判断是不是基础类，我们之前看过了，如果有，则返回true。也就会直接返回bean。或则调用 shouldSkip 方法判断，如果其中某个通知器 实现了AspectJPointcutAdvisor 接口，则返回 true。我们的Bean 两者都不是，所以都是false，向下走。</p>
<p>这里就是我们曾经分析过的代码，今天再分析一下，主要还是创建代理。首先获取所有的通知器。如果在后置处理器注册的时候该Bean没有设置通知器，则不会创建代理。然后还有就是我们之前注册的后置处理器了。如过后置处理不是null，则再缓存中存储bean的名字和是否有通知器的boolean值，再创建完代理后，将代理类和bean的名字存入代理类型缓存。以便以后可以随时实例化代理。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-093d9f04424e9f0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>createProxy 是我们的老朋友，首先判断 BeanFactory 是否实现了 ConfigurableListableBeanFactory 接口，默认是实现了的。调用 AutoProxyUtils.exposeTargetClass 方法，</p>
<p>然后创建 ProxyFactory 实例，这个我们分析过了，然后将 AnnotationAwareAspectJAutoProxyCreator 数据复制到 ProxyFactory 中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-11c6733d7d15a050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>buildAdvisors  创建通知器数组，根据bean的名称，和刚刚注册的通知器。我们看看该方法，该方法首先调用 resolveInterceptorNames 方法，生成通知器数组，但我们没有设置该属性（XML 配置曾经设置过）。 然后将我们给定的通知器添加到一个数组，然后判断，如果配置了通知器，则将配置的通知器放在数组前面， 否则就放在后面。</p>
<p>最后，循环该通知器数组，调用 advisorAdapterRegistry 的warp 方法，包装通知器。最后返回，如何包装呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7223ae4f79bae998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看看warp 方法，判断如果是Advisor 类型，则直接返回，如果不是Advice类型，抛出异常，如果是，则判断是否是 MethodInterceptor 类型，如果是，则包装成 DefaultPointcutAdvisor 类型返回。如果都不满足，则循环该类的adappters 适配器数组， 判断如果支持 Advice ，则也创建一个默认的 DefaultPointcutAdvisor 返回。该适配器数组，默认就有3个适配器，一个before，一个after，一个throws。而我们的通知器都是 Advisor，所以直接返回了。</p>
<p>到这里 buildAdvisors 方法也就结束了，返回了一个Advisors 数组。</p>
<p>回到 createProxy 方法， 得到了注册的通知器，于是 proxyFactory 可以设置 通知器属性了，也设置了目标类属性，这时候就可以拿着工厂去创建代理了。</p>
<p>如何创建代理工厂我们就不看了，因为我们之前已经分析过了，我们的demo肯定创建的是 Cglib 代理，因此我们进入到Cglib 的getProxy 方法中查看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">		Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">			proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">			Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">				<span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">		validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">		Enhancer enhancer = createEnhancer();</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">			enhancer.setClassLoader(classLoader);</span><br><span class="line">			<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">					((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">				enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">		enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">		Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">		Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">			types[x] = callbacks[x].getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">		enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">				<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">		enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">		<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断是否是Cglib类型，怎么判断呢？就判断类名中是否含有两个$$ 符号，如果是的，则从当前类中获取所有接口，并添加到 advised 属性中，很明显，我们不是。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-08f11ff29f49e2a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d5e8b8e2f0a1ffac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>然后校验Class，写日志。</p>
<p>创建一个增强器。是 org.springframework.cglib.proxy 包下的。给增强器设置类加载器，设置父类，设置接口，设置命名规则，默认是 BySpringCGLIB，设置策略（不知道是什么意思），，设置回调类型（七个回调，都是CglibAopProxy 的内部类），设置了回调的过滤器，最后创建代理，再下面我们就不深究了。</p>
<p>我们从整个流程可以看到，AOP的编织是通过定义@Aspect 和 @Around 等注解创建通知器，和我们在XML中编程几乎一样，只是Sprng 向我们屏蔽了底层。最后，Spring 拿着目标类和通过器去创建代理。</p>
<h2 id="4-目标对象方法调用的过程"><a href="#4-目标对象方法调用的过程" class="headerlink" title="4. 目标对象方法调用的过程"></a>4. 目标对象方法调用的过程</h2><p>那么创建代理后做什么呢？</p>
<p>这时候就需要调用被 @PostConstruct 注解 的方法了，该注解的作用就是在Spring 实例化该bena后执行该方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3e914591cc018fbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>此时返回的已经是代理类了，代理类执行testController 方法，代理类内部回调了 CglibAopProxy 的内部类 DynamicAdvisedInterceptor 的 intercept 方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">	Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">	Object target = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		target = getTarget();</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">			targetClass = target.getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">		Object retVal;</span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">			releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先获取目标类， 然后传入目标方法和 目标类获取通知器链， 最终调用 DefaultAdvisorChainFactory 的 getInterceptorsAndDynamicInterceptionAdvice 方法， 该方法参数为  AdvisedSupport， 目标方法，目标类。我们进入该方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		Advised config, Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is somewhat tricky... We have to process introductions first,</span></span><br><span class="line">	<span class="comment">// but we need to preserve order in the ultimate list.</span></span><br><span class="line">	List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;Object&gt;(config.getAdvisors().length);</span><br><span class="line">	Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">	<span class="keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">	AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">			<span class="comment">// Add it conditionally.</span></span><br><span class="line">			PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">			<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">				MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">				<span class="keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">						<span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">						<span class="comment">// isn&#x27;t a problem as we normally cache created chains.</span></span><br><span class="line">						<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">							interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">			IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">			<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">			interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用 hasMatchingIntroductions 方法，返回false，该方法会判断通知器是否是 IntroductionAdvisor 类型，如果是，则判断类过滤器是否匹配当前的目标类型。我们这里不是 IntroductionAdvisor 类型，因此都返回false。然后获取全局的三个通知器适配器，然后循环匹配，最后将匹配成功的包装到 InterceptorAndDynamicMethodMatcher 中后添加到拦截器数组中。</p>
<p>回到  intercept ,得到了拦截器数组，如果拦截器数组是空的并且方法修饰符是public 的，就直接调用该方法，如果不是，则创建一个Cglib 方法调用器。并执行proceed方法，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8a29bc66cbefbbba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>由于我们的方法不是public 的，则执行 else 逻辑，我们看看该 proceed 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object interceptorOrInterceptionAdvice =</span><br><span class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">			<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">			<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">			InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">				<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">				<span class="keyword">return</span> proceed(); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">			<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>); <span class="comment">// 执行这里</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">proceed 方法会先获取第一个拦截器，如果拦截器不是 InterceptorAndDynamicMethodMatcher 类型的，则执行拦截器的invoke 方法。</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//upload-images.jianshu.io/upload_images/4236553-bac2d17a91f35eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在invoke 方法中，先将 mehodInvocation 对象放置在ThreadLocal 中，然后又回调自己的proceed方法，判断当前拦截器下标是否到了最大。再次执行的拦截器也就是通知器是 AspectJAroundAdvice 的invoke 方法，也就是我们定义的<span class="meta">@Around</span> 注解的方法。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);</span><br><span class="line">		&#125;</span><br><span class="line">		ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">		ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">		JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">		<span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>首先创建一个我们熟知的 ProceedingJoinPoint 对象，然后调用 invokeAdviceMethod 方法，是其抽象父类的AbstractAspectJAdvice 的方法。该方法继续调用invokeAdviceMethodWithGivenArgs 方法。</p>
<pre><code class="java">    protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable &#123;
        Object[] actualArgs = args;
        if (this.aspectJAdviceMethod.getParameterTypes().length == 0) &#123;
            actualArgs = null;
        &#125;
        try &#123;
            ReflectionUtils.makeAccessible(this.aspectJAdviceMethod);
            // TODO AopUtils.invokeJoinpointUsingReflection
            return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);
        &#125;
        catch (IllegalArgumentException ex) &#123;
            throw new AopInvocationException(&quot;Mismatch on arguments to advice method [&quot; +
                    this.aspectJAdviceMethod + &quot;]; pointcut expression [&quot; +
                    this.pointcut.getPointcutExpression() + &quot;]&quot;, ex);
        &#125;
        catch (InvocationTargetException ex) &#123;
            throw ex.getTargetException();
        &#125;
    &#125;
</code></pre>
<p>终于，在这里调用我们的test方法了。执行反射方法this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs） 。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-33165987eefb4864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>然后回调自己的proceed 方法，回到了 ReflectiveMethodInvocation 的 proceed 方法，继续判断是否还有拦截器，没有则执行 invokeJoinpoint 方法，也就是目标类本身的方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-87c3aa4b21d8450f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-07b7b0f94d4f6832.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如果方法是public 的，则直接执行方法代理的invoke方法，如果不是，执行父类的 invokeJoinpoint 方法， 实际上是执行的 AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments) 方法，该方法执行反射方法 method.invoke ，最终执行目标方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-031fc424f99d1ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-310e620c947bc5ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>最终返回到拦截器的方法中，也就是我们的Aop.tesst 方法，继续执行下面的逻辑。</p>
<p>执行完毕，AbstractAspectJAdvice 通知器的invokeAdviceMethod 的方法结束，开始逐层返回。返回到 intercept 方法， 继续向下执行。下面就是一些处理返回值的逻辑，最后返回返回值。完成了代理的一次调用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9c4715d518893dcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>这篇文章可以说是非常的长，从 AOP 的切面编织，到代理的生成，到方法的调用，可以说，非常的复杂。 不过，Spring 中最复杂的 AOP 我们已经彻底搞清楚了他的原理，功夫不负苦心人。不论是老旧的 XML 配置方式，还是新的 SpringBoot 方式，我们都能够了解他的原理，在以后的程序排错中，也更加游刃有余，实际上，我们得到的不止是这个，我们知道了Spring 的众多扩展接口，这些接口是AOP 赖以生存的条件，正式通过他们，完成了AOP的增强。我们也知道了，无论是注解还是配置文件，都是依赖同一个底层原理，这也警醒了我们，无论多么复杂的系统，底层都是相似的，通过层层封装后变得更加好用的同时也变得难以理解，但只要明白底层原理，一切都没那么复杂，楼主认为底层原理更是网络，OS，计组，编译原理，数据结构这些。山高路远，我们将一直走下去。</p>
<p>good luck !!!!!</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>深入剖析-Mybatis-原理（一）</title>
    <url>/2017/12/16/2017/2017-12-16-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-mybatis-%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在java程序员的世界里，最熟悉的开源软件除了 Spring，Tomcat，还有谁呢？当然是 Mybatis 了，今天楼主是来和大家一起分析他的原理的。

<h2 id="1-回忆JDBC"><a href="#1-回忆JDBC" class="headerlink" title="1. 回忆JDBC"></a>1. 回忆JDBC</h2><p>首先，楼主想和大家一起回忆学习JDBC的那段时光：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>);</span><br><span class="line">      String url = <span class="string">&quot;jdbc:sqlserver://192.168.0.251:1433;DatabaseName=test&quot;</span>;</span><br><span class="line">      String user = <span class="string">&quot;sa&quot;</span>;</span><br><span class="line">      String password = <span class="string">&quot;$434343%&quot;</span>;</span><br><span class="line">      connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getRole</span><span class="params">(Long id)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Connection connection = getConnection();</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ps = connection.prepareStatement(<span class="string">&quot;select * from user_info where id = ?&quot;</span>);</span><br><span class="line">      ps.setLong(<span class="number">1</span>, id);</span><br><span class="line">      rs = ps.executeQuery();</span><br><span class="line">      <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        Long roleId = rs.getLong(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String userName = rs.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String realname = rs.getString(<span class="string">&quot;realname&quot;</span>);</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        userInfo.id = roleId.intValue();</span><br><span class="line">        userInfo.username = userName;</span><br><span class="line">        userInfo.realname = realname;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      connection.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      rs.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    JdbcDemo jdbcDemo = <span class="keyword">new</span> JdbcDemo();</span><br><span class="line">    UserInfo userInfo = jdbcDemo.getRole(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(userInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看着这么多 try catch finally 是不是觉得很亲切呢？只是现如今，我们再也不会这么写代码了，都是在Spring和Mybatis 中整合了，一个 userinfoMapper.selectOne(id)  方法就搞定了上面的这么多代码，这都是我们今天的主角 Mybatis 的功劳，而他主要做的事情，就是封装了上面的除SQL语句之外的重复代码，为什么说是重复代码呢？因为这些代码，细想一下，都是不变的。</p>
<p>那么，Mybatis 做了哪些事情呢？</p>
<p>实际上，Mybatis 只做了两件事情：</p>
<ol>
<li>根据 JDBC 规范 建立与数据库的连接。</li>
<li>通过反射打通Java对象和数据库参数和返回值之间相互转化的关系。</li>
</ol>
<h2 id="2-从-Mybatis-的一个-Demo-案例开始"><a href="#2-从-Mybatis-的一个-Demo-案例开始" class="headerlink" title="2. 从 Mybatis 的一个 Demo 案例开始"></a>2. 从 Mybatis 的一个 Demo 案例开始</h2><p>此次楼主从 github 上 clone 了mybatis 的源码，过程比Spring源码顺利，主要注意一点：在 IDEA 编辑器中（Eclipse 楼主不知道），需要排除 src/test/java/org/apache/ibatis/submitted 包，防止编译错误。</p>
<p>楼主在源码中写了一个Demo，给大家看一下目录结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5cfb1aa4a43ff9c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>图片中的红框部分是楼主自己新增的，然后看看代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-07699f39b410380c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JavaBean代码"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e90a237b1248591c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mapper 接口代码"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c777dde3a5a4df02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Main 测试类代码"></p>
<p>再看看 mybatis-config.xml 配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="comment">&lt;!--定义属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:sqlserver://192.168.0.122:1433;DatabaseName=test&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sa&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;434343&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 类型别名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;userInfo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.ibatis.mybatis.UserInfo&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--环境--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span><span class="comment">&lt;!--采用jdbc 的事务管理模式--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--映射器  告诉 MyBatis 到哪里去找到这些语句--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserInfoMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;/configuration</span><br></pre></td></tr></table></figure>

<p>UserInfoMapper.xml 配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.apache.ibatis.mybatis.UserInfoMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.apache.ibatis.mybatis.UserInfo&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user_info  WHERE  id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>好了，我们的测试代码就这么多，运行一下测试类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f65d976a9b239786.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>结果正确，打印了2次，因为我们使用了两种不同的方式来执行SQL。</p>
<p>那么，我们就从这个简单的例子来看看 Mybatis 是如何运行的。</p>
<h2 id="3-深入源码之前的理论知识"><a href="#3-深入源码之前的理论知识" class="headerlink" title="3. 深入源码之前的理论知识"></a>3. 深入源码之前的理论知识</h2><p>再深入源码之前，楼主想先来一波理论知识，避免因进入源码的汪洋大海导致迷失方向。</p>
<p>首先, Mybatis 的运行可以分为2个部分,第一部分是读取配置文件创建 Configuration 对象, 用以创建 SqlSessionFactroy, 第二部分是 SQLSession 的执行过程. </p>
<p>我们再来看看我们的测试代码:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c777dde3a5a4df02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Main 测试类代码"></p>
<p>这是一个和我们平时使用不同的方式, 但如果细心观察,会发现, 实际上在 Spring 和 Mybatis 整合的框架中也是这么使用的, 只是 Spring 的 IOC 机制帮助我们屏蔽了创建对象的过程而已. 如果我们忘记创建对象的过程, 这段代码就是我们平时使用的代码.</p>
<p>那么,我们就来看看这段代码, 首先创建了一个流, 用于读取配置文件, 然后使用流作为参数, 使用 SqlSessionaFactoryBuilder 创建了一个 SqlSessionFactory 对象,然后使用该对象获取一个 SqlSession, 调用 SqlSession 的 selectOne 方法 获取了返回值,或者 调用了 SqlSession 的 getMapper 方法获取了一个代理对象, 调用代理对象的 selectById 方法 获取返回值.</p>
<p>在这里, 楼主觉得有必要讲讲这几个类的生命周期:</p>
<ol>
<li><p>SqlSessionaFactoryBuilder  该类主要用于创建 SqlSessionFactory, 并给与一个流对象, 该类使用了创建者模式, 如果是手动创建该类(这种方式很少了,除非像楼主这种测试代码), 那么建议在创建完毕之后立即销毁.</p>
</li>
<li><p>SqlSessionFactory 该类的作用了创建 SqlSession, 从名字上我们也能看出, 该类使用了工厂模式, 每次应用程序访问数据库, 我们就要通过 SqlSessionFactory 创建 SqlSession, 所以SqlSessionFactory 和整个 Mybatis 的生命周期是相同的. 这也告诉我们不同创建多个同一个数据的 SqlSessionFactory, 如果创建多个, 会消耗尽数据库的连接资源, 导致服务器夯机. 应当使用单例模式. 避免过多的连接被消耗, 也方便管理. </p>
</li>
<li><p>SqlSession 那么是什么 SqlSession 呢? SqlSession 相当于一个会话, 就像 HTTP 请求中的会话一样, 每次访问数据库都需要这样一个会话, 大家可能会想起了 JDBC 中的 Connection, 很类似,但还是有区别的, 何况现在几乎所有的连接都是使用的连接池技术, 用完后直接归还而不会像 Session 一样销毁. 注意:他是一个线程不安全的对象, 在设计多线程的时候我们需要特别的当心, 操作数据库需要注意其隔离级别, 数据库锁等高级特性, 此外, 每次创建的 SqlSession 都必须及时关闭它, 它长期存在就会使数据库连接池的活动资源减少,对系统性能的影响很大, 我们一般在 finally 块中将其关闭. 还有, SqlSession 存活于一个应用的请求和操作,可以执行多条 Sql, 保证事务的一致性. </p>
</li>
<li><p>Mapper 映射器， 正如我们编写的那样, Mapper 是一个接口, 没有任何实现类, 他的作用是发送 SQL, 然后返回我们需要的结果. 或者执行 SQL 从而更改数据库的数据, 因此它应该在 SqlSession 的事务方法之内, 在 Spring 管理的 Bean 中, Mapper 是单例的。</p>
</li>
</ol>
<p>大家应该还看见了另一种方式， 就是上面的我们不常见到的方式，其实， 这个方法更贴近Mybatis底层原理，只是该方法还是不够面向对象， 使用字符串当key的方式也不易于IDE 检查错误。我们常用的还是getMapper方法。</p>
<h2 id="4-开始深入源码"><a href="#4-开始深入源码" class="headerlink" title="4. 开始深入源码"></a>4. 开始深入源码</h2><p>我们一行一行看。</p>
<p>首先根据maven的classes目录下的配置文件并创建流，然后创建 SqlSessionFactoryBuilder 对象，该类结构如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-00d7a8cfaee87f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到该类只有一个方法并且被重载了9次，而且没有任何属性，可见该类唯一的功能就是通过配置文件创建 SqlSessionFactory。那我们就紧跟来看看他的build方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-bf9d626ff8e31b3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法，默认环境为null， 属性也为null，调用了自己的另一个重载build方法，我们看看该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建SqlSession 工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputStream xml 配置文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> environment 默认null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> properties 默认null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建XML解析器</span></span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    <span class="comment">// 创建 session 工厂</span></span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法只有2个步骤，第一，根据给定的参数创建一个 XMLConfigBuilder XML配置对象，第二，调用重载的 build 方法。并将上一行返回的 Configuration 对象作为参数。我们首先看看创建 XMLConfigBuilder  的过程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4bb38e62682a7486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先还是调用了自己的构造方法，参数是 XPathParser 对象， 环境（默认是null），Properties （默认是null），然后调用了父类的构造方法并传入 Configuration 对象，注意，Configuration 的构造器做了很多的工作，或者说他的默认构造器做了很多的工作。我们看看他的默认构造器：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8dc6c85223797288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该构造器主要是注册别名，并放入到一个HashMap中，这些别名在解析XML配置文件的时候会用到。如果平时注意mybatis配置文件的话，这些别名应该都非常的熟悉了。</p>
<p>我们回到 XMLConfigBuilderd 的构造方法中，也就是他的父类 BaseBuilder 构造方法，该方法如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-58b9a670559964aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>主要是一些赋值过程，主要将刚刚创建的 Configuration 对象和他的属性赋值到  XMLConfigBuilder 对象中。</p>
<p>我们回到 SqlSessionFactoryBuilder 的 build 方法中，此时已经创建了 XMLConfigBuilder 对象，并调用该对象的 parse 方法，我们看看该方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ac32d3e8f2e2258d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先判断了最多只能解析一次，然后调用 XPathParser 的 evalNode 方法，该方法返回了 XNode 对象 ，而XNode 对象就和我们平时使用的 Dom4j 的 node 对象差不多，我们就不深究了，总之是解析XML 配置文件，加载 DOM 树，返回 DOM 节点对象。然后调用 parseConfiguration 方法，我们看看该方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b6c374992177cb40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法的作用是解析刚刚的DOM节点，可以看到我们熟悉的一些标签，比如：properties，settings，objectWrapperFactory，mappers。我们重点看看最后一行 mapperElement 方法，其余的方法，大家如果又兴趣自己也可以看看，mapperElement 方法如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-154cf740319bd474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法循环了 mapper 元素，如果有 “package” 标签，则获取value值，并添加进映射器集合Map中，该Map如何保存呢，找到包所有class，并将Class对象作为key，MapperProxyFactory 对象作为 value 保存， MapperProxyFactory 类中有2个属性，一个是 Class<T> mapperInterface ，也就是接口的类名，一个 Map&lt;Method, MapperMethod&gt; methodCache 方法缓存。我们回到 XMLConfigBuilder 的 mapperElement 方法中， 如果没有 “package” 属性，则尝试获取 “resource”， “url”，“class”属性，并一个个判断，最后都会和 “package”方法一样，调用 configuration.addMapper 方法。将 namespace 属性和配置文件关联。</p>
<p>在执行完 parseConfiguration 方法后，也就完成了 XMLConfigBuilder 对象的 parse 方法，调用重载方法 build ：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-19d309939b8b8a98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>返回了一个默认的 DefaultSqlSessionFactory 对象。</p>
<p>至此，解析配置文件的工作就结束了，此时创建了 SqlSessionFactory 对象和 Configuration 对象，这两个对象都是单例的，且他们的声明周期和 Mybatis 是一致的。 Configuration 对象中包含了 Mybatis 配置文件中的所有信息，在后面大有用处，SqlSessionFactory  将创建后面所有的SqlSession对象，可见其重要性。</p>
<p>可以看到，创建 SqlSessionFactory  对象是比较简单的，然后，SqlSession 的执行过程就不那么简单了。我们继续往下看。</p>
<h2 id="5-SqlSession-创建过程"><a href="#5-SqlSession-创建过程" class="headerlink" title="5. SqlSession 创建过程"></a>5. SqlSession 创建过程</h2><p>我们接下来要看看 SqlSession 的创建过程和运行过程，首先调用了 sqlSessionFactory.openSession() 方法。该方法默认实现类是 DefaultSqlSessionFactory ，我们看看该方法如何被重写的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c07afdcda8675b80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>调用了自身的 openSessionFromDataSource 方法，注意，参数中 configuration 获取了默认的执行器 “SIMPLE”，自动提交我们没有配置，默认是false，我们进入到 openSessionFromDataSource  方法查看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a274a61f8c8067f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法以下几个步骤：</p>
<ol>
<li>获取配置文件中的环境，也就是我们配置的 <environments default="development">标签，并根据环境获取事务工厂，事务工厂会创建一个事务对象，而 configurationye 则会根据事务对象和执行器类型创建一个执行器。最后返回一个默认的 DefaultSqlSession 对象。 可以说，这段代码，就是根据配置文件创建 SqlSession 的核心地带。我们一步步看代码，首先从配置文件中取出刚刚解析的环境对象。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b40e29ac4a68a083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>然后根据环境对象获取事务工厂，如果配置文件中没有配置，则创建一个 ManagedTransactionFactory 对象直接返回。否则调用环境对象的 getTransactionFactory 方法，该方法和我们配置的一样返回了一个  JdbcTransactionFactory，而实际上，TransactionFactory 只有2个实现类，一个是 ManagedTransactionFactory ，一个是 JdbcTransactionFactory。</p>
<p>我们回到 openSessionFromDataSource 方法，获取了 JdbcTransactionFactory 后，调用 JdbcTransactionFactory 的 newTransaction 方法创建一个事务对象，参数是数据源，level 是null， 自动提交还是false。newTransaction  创建了一个 JdbcTransaction 对象，我们看看该类的构造：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8207c6f9d9684477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，该类都是有关连接和事务的方法，比如commit，openConnection，rollback，和JDBC 的connection 功能很相似。而我们刚刚看到的level是什么呢?在源码中我们看到了答案：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c09212de6416ff7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>就是 “事务的隔离级别”。并且该事务对象还包含了JDBC 的Connection 对象和 DataSource 数据源对象，好亲切啊，可见这个事务对象就是JDBC的事务的封装。</p>
<p>继续回到 openSessionFromDataSource 方，法此时已经创建好事务对象。接下来将事务对象执行器作为参数执行 configuration 的 newExecutor 方法来获取一个 执行器类。我们看看该方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f67272bccc43bc02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先，该方法判断给定的执行类型是否为null，如果为null，则使用默认的执行器， 也就是 ExecutorType.SIMPLE，然后根据执行的类型来创建不同的执行器，默认是 SimpleExecutor 执行器，这里楼主需要解释以下执行器：</p>
<p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<ol>
<li><p>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
</li>
<li><p>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p>
</li>
<li><p>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
</li>
</ol>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<p>我们再看看默认执行器的构造方法，2个参数，一个是  Configuration， 一个是事务对象。该构造器调用了父类 BaseExecutor 的构造器，我们看看该方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b586790992cea340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类包装了事务对象，延迟加载的队列，本地缓存，永久缓存，配置对象，还包装了自己。</p>
<p>回到 newExecutor 方法，判断是否使用缓存，默认是true， 则将刚刚的执行器包装到新的 CachingExecutor 缓存执行器中。最后将执行器添加到所有的拦截器中（如果配置了话），我们这里没有配置。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-47e3864f4b327f2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-bc2ade41a79fc830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>现在，我们回到 openSessionFromDataSource 方法，我们已经有了执行器，此时创建 DefaultSqlSession 对象，携带 configuration, executor, autoCommit 三个参数，该构造器就是简单的赋值过程。我们有必要看看该类的结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-30b574550856e92c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类包含了常用的所有方法，包括事务方法，可以说，该类封装了执行器和事务类。而执行器才是具体的执行工作人员。</p>
<p>至此，我们已经完成了 SqlSession 的创建过程。</p>
<p>接下来，就要看看他的执行过程。</p>
<h2 id="6-SqlSession-执行过程"><a href="#6-SqlSession-执行过程" class="headerlink" title="6. SqlSession 执行过程"></a>6. SqlSession 执行过程</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-afd19f6711b1fef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们创建了一个map，并放入了参数，重点看红框部分，我们钻进去看看。selectOne 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-fd43c0822b881b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法实际上还是调用了selectList方法，最后取得了List中的第一个，如果返回值长度大于1，则抛出异常。啊，原来，经常出现的异常就是这么来的啊，终于知道你是怎么回事了。我们也看的出来，重点再 selectList 方法中，我们进入看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-cd9cee3ea1d69cee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法携带了3个参数，SQL 声明的key，参数Map，默认分页对象（不分页），注意，mybatis 分页是假分页，即一次返回所有到内存中，再进行提取，如果数据过多，可能引起OOM。我们继续向下走：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-00b7390220c4022b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法首先根据 key或者说 id 从 configuration 中取出 SQL 声明对象， 那么是如何取出的呢?我们知道，我们的SQL语句再XML中编辑的时候，都有一个key，加上我们全限定类名，就成了一个唯一的id，我们进入到该方法查看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-30fafd9f514ca7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法调用了自身的 getMappedStatement 方法，默认需要验证SQL语句是否正确，也就是 buildAllStatements 方法，最后从继承了 HashMap 的StrictMap 中取出 value，这个StrictMap 有个注意的地方，他基本扩展了HashMap 的方法，我们重点看看他的get方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-bc8068feee7ad99f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如何扩展呢？如果返回值是null，则抛出异常，JDK中HashMap 可是不抛出异常的，如果 value是 Ambiguity 类型，也抛出异常，说明 key 值不够清晰。</p>
<p>那么  buildAllStatements  方法做了什么呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7353a66e7ec15c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意看注释（大意）：解析缓存中所有未处理的语句节点。当所有的映射器都被添加时，建议调用这个方法，因为它提供了快速失败语句验证。意思是如果链表中任何一个不为空，则抛出异常，是一种快速失败的机制。那么这些是什么时候添加进链表的呢？答案是catch的时候，看代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-75390a37889c5735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这个时候会将错误的语句添加进该链表中。</p>
<p>我们回到 selectList 方法，此时已经返回了 MappedStatement 对象，这个时候该执行器出场了，调用执行器的query方法，携带映射声明，包装过的参数对象，分页对象。那么如何包装参数对象呢？我们看看 wrapCollection 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-058b1748548d4332.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法首先判断是否是集合类型，如果是，则创建一个自定义Map，key是collection，value是集合，如果不是，并且还是数组，则key为array，都不满足则直接返回该对象。那么我们该进入 query 一探究竟：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3ff9d26b338715e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>进入 CachingExecutor 的query 方法，首先根据参数获取 BoundSql 对象，最终会调用 StaticSqlSource 的 getBoundSql 方法，该方法会构造一个 BoundSql 对象，构造过程是什么样子的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a76186a7b806d2bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>会有5个属性被赋值，sql语句，参数，</p>
<p>参数是我们刚刚传递的，那么SQL 是怎么来的呢，答案是在 XMLConfigBuilder 的 parseConfiguration 方法中，通过层层调用，最终执行 StaticSqlSource 的构造方法，将mapper 文件中的Sql解析到该类中，最后会将XML 中的 #{id} 构造成一个ParameterMapping 对象，格式入下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9cdb2c5fe63022d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>并将配置对象赋值给该类。</p>
<p>回到 BoundSql 的构造器，首先赋值SQL， 参数映射对象数组，参数对象，默认的额外参数，还有一个元数据参数。</p>
<p>回到我们的 getBoundSql 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-98d8efe76c568290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们已经有了参数绑定对象，该对象中有SQL语句，参数。继续向下执行，从该对象获取参数映射集合，如果为空，则再次创建一个 BoundSql 对象。接着循环参数，先获取 resultMap id，如果有，则从配置对下中获取resultMap 对象，如果不为null，则修改 hasNestedResultMaps 为 true。最后返回 BoundSql 对象。</p>
<p>我们回到 CachingExecutor 的 query 方法， 我们已经有了sql绑定对象， 接下来创建一个缓存key，根据sql绑定对象，方法声明对象，参数对象，分页对象，注意：mybatis 一级缓存默认为true，二级缓存默认false。创建缓存的过程很简单，就是将所有的参数的key或者id构造该 CacheKey 对象，使该对象唯一。最后执行query方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-93df6710f7e40702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法步骤：</p>
<ol>
<li>获取缓存，如果没u偶，则执行代理执行器的query方法，如果有，且需要清空了，则清空缓存（也就是Map）。</li>
<li>如果该方法声明使用缓存并且结果处理器为null，则校验参数，如果方法声明使存储过程，且所有参数有任意一个不是输入类型，则抛出异常。意思是当为存储过程时，确保不能有输出参数。</li>
<li>调用 TransactionalCacheManager 事务缓存处理器执行 getObject 方法，如果返回值时null，则调用代理执行器的query方法，最后添加进事务缓存处理器。</li>
</ol>
<p>我们重点关注代理执行器的query方法，也就是我们 SimpleExecutor 执行器。该方法如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a76a619de62e642a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol>
<li>首先判断执行器状态是否关闭。</li>
<li>判断是否需要清除缓存。</li>
<li>判断结果处理器是否为null，如果不是null，则返回null，如果不是，则从本地缓存中取出。</li>
<li>如果返回的list不是null，则处理缓存和参数。否则调用queryFromDatabase 方法从数据库查询。</li>
<li>如果需要延迟加载，则开始加载，最后清空加载队列。</li>
<li>如果配置文件中的缓存范围是声明范围，则清空本地缓存。</li>
<li>最后返回list。</li>
</ol>
<p>可以看出，我们重点要关注的是 queryFromDatabase 方法，其余的方法都是和缓存相关，但如果没有从数据库取出来，缓存也没什么用。进入该方法查看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5680fa8b3da8f595.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们关注红框部分。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-eeee1b04199d7667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法创建了一个声明处理器，然后调用了 prepareStatement 方法，最后调用了声明处理器的query方法，注意，这个声明处理器有必要说一下：</p>
<p>mybatis 的SqlSession 有4大对象：</p>
<ol>
<li>Executor代表执行器，由它调度StatementHandler、ParameterHandler、ResultSetHandler等来执行对应的SQL。其中StatementHandler是最重要的。</li>
<li>StatementHandler的作用是使用数据库的Statement（PreparedStatement）执行操作，它是四大对象的核心，起到承上启下的作用，许多重要的插件都是通过拦截它来实现的。</li>
<li>ParamentHandler是用来处理SQL参数的。</li>
<li>ResultSetHandler是进行数据集的封装返回处理的，它相当复杂，好在我们不常用它。</li>
</ol>
<p>好，我们继续查看  configuration 是如何创建 StatementHandler 对象的。我们看看他的  newStatementHandler 方法:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-dbfaf55c877acee2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先根据方法声明类型创建一个声明处理器，有最简单的，有预编译的，有存储过程的，在我们这个方法中，创建了一个预编译的方法声明对象，这个对象的构造器对  configuration 等很多参数进行的赋值。我们还是看看吧：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3324e00a9a3bc1e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看到了刚刚提到了parameterHandler和resultSetHandler。</p>
<p>回到 newStatementHandler 方法，需要执行下面的拦截器链的pluginAll方法，由于我们这里没有配置拦截器，该方法也就结束了。拦截器就是实现了Interceptor接口的类，国内著名的分页插件pagehelper就是这个原理，在mybais 源码里，有一个插件使用的例子，我们可以随便看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ca93d45baf7cb0f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>执行了Plugin 的静态 wrap 方法，包装目标类（也就是方法声明处理器），该静态方法如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0cfaac93cf46fbfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里就是动态代理的知识了，获取目标类的接口，最后执行拦截器的invoke方法。有机会和大家再一起探讨如何编写拦截器插件。这里由于篇幅原因就不展开了。</p>
<p>我们回到 newStatementHandler 方法，此时，如果我们有拦截器，返回的应该是被层层包装的代理类，但今天我们没有。返回了一个普通的方法声明器。</p>
<p>执行 prepareStatement 方法，携带方法声明器，日志对象。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d8674faf768a85c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>第一行，获取连接器。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9a1762498ba07e81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从事务管理器中获取连接器（该方法中还需要设置是否自动提交，隔离级别）。如果我们的事务日志是debug级别，则创建一个日志代理对象，代理Connection。</p>
<p>回到 prepareStatement 方法，看第二行，开始让预编译处理器预编译sql（也就是让connection预编译），我看看看是如何执行的。注意，我们没有配置timeout。因此返回null。</p>
<p>进入 RoutingStatementHandler 的 prepare 方法，调用了代理类的 PreparedStatementHandler 的prepare方法，该方法实现入下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1af51c153a43db22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法以下几个步骤：</p>
<ol>
<li>实例化SQL，也就是调用connection 启动 prepareStatement 方法。我们熟悉的JDBC方法。</li>
<li>设置超时时间。</li>
<li>设置fetchSize ，作用是，执行查询时，一次从服务器端拿多少行的数据到本地jdbc客户端这里来。</li>
<li>最后返回映射声明处理器。</li>
</ol>
<p>我们主要看看第一步：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-563e5d0c2e2c547d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>有没有很亲切，我们看到我们在刚开始回忆JDBC编程的 connection.prepareStatement 代码，由此证明mybatis 就是封装了 JDBC。首先判断是否含有返回主键的功能，如果有，则看 keyColumnNames 是否存在，如果不存在，取第一个列为主键。最后执行else 语句，开始预编译。注意：此connection 已经被动态代理封装过了，因此会调用 invoke 方法打印日志。最后返回声明处理器对象。</p>
<p>我们回到 SimpleExecutor 的 prepareStatement 方法， 执行第三行  handler.parameterize(stmt)，该方法其实也是委托了 PreparedStatementHandler 来执行，而 PreparedStatementHandler 则委托了  DefaultParameterHandler 执行 setParameters 方法，我们看看该方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8c13340618fe4e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先获取参数映射集合，然后从配置对象创建一个元数据对象，最后从元数据对象取出参数值。再从参数映射对象中取出类型处理器，最后将类型处理器和参数处理器关联。我们看看最后一行代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-57e6b678c9be8d4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>还是JDBC。而这个下标的顺序则就是参数映射的数组下标。</p>
<p>终于，在准备了那么多之后，我们回到 doQuery 方法，有了预编译好的声明处理器，接下来就是执行了。当然还是调用了PreparedStatementHandler 的query方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-730168730b6bd014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，直接执行JDBC 的 execute 方法，注意，该对象也被日志对象代理了，做打印日志工作，和清除工作。如果方法名称是 “executeQuery” 则返回 ResultSet 并代理该对象。 否则直接执行。我们继续看看DefaultResultSetHandler 的 handleResultSets 是如何执行的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-36d358b086e58156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先调用 getFirstResultSet 方法获取包装过的 ResultSet ，然后从映射器中获取 resultMap 和resultSet，如果不为null，则调用 handleResultSet 方法，将返回值和resultMaps处理添加进multipleResults list中 ，然后做一些清除工作。最后调用 collapseSingleResultList 方法，该方法内容如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-db65040a44a7c30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如果返回值长度等于1，返回第一个值，否则返回本身。</p>
<p>至此，终于返回了一个List。不容易啊！！！！最后在返回值的时候执行关闭 Statement 等操作。我们还需要关注一下 SqlSession 的 close 方法，该方法是事务最后是否生效的关键，当然真正的执行者是executor，在<br>CachingExecutor 的close 方法中：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-bccab4f8984ed528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法决定了到底是commit 还是rollback，最后执行代理执行器的 close 方法，也就是 SimpleExecutor 的close方法，该方法内容入下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3f543715a3672aef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先执行rollback方法，该方法内部主要是清除缓存，校验是否清除 Statements。然后执行  transaction.close()方法，重置事务（重置事务的autoCommit 属性为true），最后调用 connection.close() 方法，和我们JDBC 一样，关闭连接，但实际上，该connection 被代理了，被 PooledConnection 连接池代理了，在该代理的invoke方法中，会将该connection从连接池集合删除，在创建一个新的连接放在集合中。最后回到 SimpleExecurtor 的 close 方法中，在执行完事务的close 方法后，在finally块中将所有应用置为null，等待GC回收。清除工作也就完毕了。</p>
<p>到这里 SqlSession的运行就基本结束了。</p>
<p>最后返回到我们的main方法，打印输出。 </p>
<p>我们再看看这行代码，这么一行简单的代码里面 mybatis 为我们封装了无数的调用。可不简单。 </p>
<blockquote>
<p>UserInfo userInfo1 = sqlSession.selectOne(“org.apache.ibatis.mybatis.UserInfoMapper.selectById”, parameter); </p>
</blockquote>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>今天我们从一个小demo开始 debug  mybatis 源码，从如何加载配置文件，到如何创建SqlSedssionFactory，再到如何创建 SqlSession，再到 SqlSession 是如何执行的，我们知道了他们的生命周期。其中创建SqlSessionFactory 和 SqlSession 是比较简单的，执行SQL并封装返回值是比较复杂的，因为还需要配置事务，日志，插件等工作。</p>
<p>还记得我们刚开始说的吗？mybatis 做的什么工作?</p>
<ol>
<li>根据 JDBC 规范 建立与数据库的连接。</li>
<li>通过反射打通Java对象和数据库参数和返回值之间相互转化的关系。</li>
</ol>
<p>还有Mybatis 的运行过程？</p>
<ol>
<li>读取配置文件创建 Configuration 对象, 用以创建 SqlSessionFactroy.</li>
<li> SQLSession 的执行过程.</li>
</ol>
<p>我们也知道了其实在mybatis 层层封装下，真正做事情的是 StatementHandler，他下面的各个实现类分别代表着不同的SQL声明，我们看看他有哪些属性就知道了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-16701f4328d42870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类可以说囊括了所有执行SQL的必备属性：配置，对象工厂，类型处理器，结果集处理器，参数处理器，SQL执行器，映射器（保存这个SQL 所有相关属性的地方，比放入SQL语句，参数，返回值类型，配置，id，声明类型等等）， 分页对象， 绑定SQL与参数对象。有了这些东西，还有什么SQL执行不了的呢？</p>
<p>当然，StatementHandler 只是 SqlSession 4 大对象的其中之一，还有Executor 执行器，他负责调度 StatementHandler，ParameterHandler，ResultHandler 等来执行对应的SQL，而 StatementHandler  的作用是使用数据库的 Statement(PreparedStatement ) 执行操作，他是4大对象的核心，起到承上启下的作用。ParameterHandler 就是封装了对参数的处理，ResultHandler  封装了对结果级别的处理。</p>
<p>到这里，我们这篇文章就结束了，当然，大家肯定还想知道 getMapper 的原理是怎么回事，其实我们开始说过，getMapper 更加的面向对象，但也是对上面的代码的封装。篇幅有限，我们将在下篇文章中详细解析。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>深入剖析-Mybatis-原理（三）如何整合Spring</title>
    <url>/2017/12/19/2017/2017-12-19-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-mybatis-%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E5%A6%82%E4%BD%95%E6%95%B4%E5%90%88Spring/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在前两篇文章我们在 mybatis 源码中探究了他的运行原理，但在实际使用中，我们需要将其和Spring整合使用，特别是当下流行的SpringBoot，那么，myBatis 在 SpringBoot 中是如何运行的呢？

<p>我们需要带着问题去研究，这样才能印象更深刻，以下是楼主的问题，不知道各位有没有自己的问题，如果有，也可以和楼主一起探讨，或者自己查看源码。</p>
<ol>
<li>SqlSessionFactory，SqlSession 如何生成?</li>
<li>Mapper 代理如何生成？如何运行？</li>
</ol>
<h2 id="1-SqlSessionFactory，SqlSession-如何生成"><a href="#1-SqlSessionFactory，SqlSession-如何生成" class="headerlink" title="1. SqlSessionFactory，SqlSession 如何生成?"></a>1. SqlSessionFactory，SqlSession 如何生成?</h2><p>由于楼主的项目是SpringBoot ，因此基本没有配置文件，只有一个简单的配置，这也是Spring团队一直追求的目标：无配置。但由于我们的团队开始使用SpringCloud ，于是配置又多了起来，看来，配置文件始终是消灭不掉的。那么，废话了这么多，楼主的关于Mybatis的配置由以下几个部分组成：</p>
<ol>
<li>jar 包 maven导入artifactId 为 mybatis-spring 的jar包，该jar包是整合Spring和mybatis的粘合剂。</li>
<li>使用硬编码的方式配置bean。比如SqlSessionFactory，SqlSessionTemplate, PlatformTransactionManager.</li>
<li>扫描接口包。</li>
</ol>
<p><strong>配置 SqlSessionFactory</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;sqlSessionFactory&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">  bean.setDataSource(dataSource());</span><br><span class="line"></span><br><span class="line">  bean.setTypeAliasesPackage(TYPE_ALIASES_PACKAGE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加插件</span></span><br><span class="line">  bean.setPlugins(MybatisUtil.getInterceptor());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加XML目录</span></span><br><span class="line">  ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"></span><br><span class="line">  bean.setMapperLocations(resolver.getResources(<span class="string">&quot;classpath:mapper/*.xml&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> bean.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：dataSource 方法会返回一个楼主自己配置的多数据源。但这不是我们今天的重点。</p>
<p><strong>SqlSessionTemplate 配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过刚刚的 sqlSessionFactory 创建一个 SqlSessionTemplate  ，该类非常重要，是Spring 和 Mybatis 整合的核心。稍后会详细介绍。</p>
<p><strong>PlatformTransactionManager 事务管理配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">annotationDrivenTransactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：为什么这里会有一个重写注解，因为楼主这个类实现了 TransactionManagementConfigurer 接口，该接口是Spring的事务基础结构中的核心接口。应用程序可以直接使用它，但他并不作为主要API，通常，应用程序可以使用 TransactionTemplate 或通过AOP进行声明式事务划分。</p>
<p>可以看到，楼主在这三个方法上面都加入了@Bean 注解，表示这个方法会返回一个Bean。</p>
<p>还有就是如何扫描包 <code>@MapperScan(basePackages = &quot;cn.think.in.java.mapper&quot;)</code>，通过这个注解扫描需要生成代理的包名。</p>
<p>好了，我们开始一个个分析，首先看 SqlSessionFactory 如何生成，我们先看看我们写的代码，首先创建了一个 SqlSessionFactoryBean， 然后设置该Bean的数据源，再然后设置别名，再设置插件，再设置资源URL，最后调用getObject 方法返回一个SqlSessionFactory。我们看到了 getObject 方法，如果看过我们 Spring 源码解析系列文章，就知道，这式 Spring 扩展接口 FactoryBean 中一个非常重要的方法，其中有一种类型的AOP就是通过该接口实现的。我就不讲这个接口的原理了。那么，这个 SqlSessionFactoryBean 肯定实现了该接口，我们看看源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8ef197331427f4bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到该类实现类 Spring 中几个重要的接口，比如 FactoryBean ，InitializingBean 接口。这对该类的拓展起到了非常大的作用。我们再看看该类有哪些属性：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-189dcc7e65ebcb58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到该类俨然一个SqlSession，该有的属性都有了，资源，配置，数据源，事务工厂，SqlSessionFactoryBuilder， SqlSessionFactory，类型处理器， 别名，缓存，对象工厂，环境。。。。等等等，一应俱全。注意：该类在 org.mybatis.spring 包下，也就是说，该类就是Spring和Mybatis 的整合包，粘合剂。</p>
<p>我们重点看看该类的 getObject 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5b49a2cd5ba050a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>逻辑很简单，如果 sqlSessionFactory 为null，则调用 afterPropertiesSet 方法，该方法核心是调用了自身的 buildSqlSessionFactory 方法，我们看看该方法实现。该方法代码很多，楼主就不贴出来了，主要逻辑就是创建 Configuration 对象，然后设置 Configuration 的各种参数，比如插件，别名， 然后创建一个 SpringManagedTransactionFactory 事务工厂赋值给默认属性。再给 configuration 对象设置环境属性，参数是 事务工厂，数据源， 默认环境 “SqlSessionFactoryBean”，然后开始解析设置的 mapperLocations 到 configuration 对象中， 最后调用 sqlSessionFactoryBuilder.build(configuration) 返回一个 SqlSessionFactory，和我们之前创建 SqlSessionFactory 基本相同。返回的也是默认的 DefaultSqlSessionFactory。</p>
<p>那么有了 SqlSessionFactory ，就可以创建 SqlSession 了， 如何创建呢？ 还记得我们配置的 SqlSessionTemplate 吗，该类就是 MyBatis 将 Spring 和 MyBatis 框架粘合的类，我们看看该类的继承关联体系图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-266769f50a60dc38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到该类实现了 SqlSession 接口，同时也依赖个 SqlSession 的代理. 那么我们再看看该类的属性方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-29cfcab75dea8044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="属性图"></p>
<p>该类含有一个 SqlSessionFactory 工厂类，一个执行器类型（SqlSession 底层使用的 ExecutorType 类型），一个 SqlSessionProxy JDK 生成的代理对象，  还有一个异常转换器。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b785c62042085836.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法图"></p>
<p>我们看到该类有实现了 SqlSession 的所有方法，但内部全部委托了JDK 代理的 SqlSessionProxy 来实现。 我们还注意到，有一个拦截器内部类，该类就是创建 JDK 动态代理时的那个拦截类， 我们看看该类的 invoke 方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1934c0be8a377391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SqlSessionInterceptor 实现"></p>
<p>我们看看方法，首先调用 SqlSessionUtils 的静态方法 getSqlSession 获取 SqlSession 对象， 然后调用 SqlSession 的响应方法， 检测事务是否由 Spring 管理，并根据此结果决定是否提交事务。 最后，返回结果，并在 finally 块中清除 Session（将 Connection 赋值为 null）。</p>
<p>也就是说，在执行 SqlSession 的 SelectOne 之类的方法的时候，都会经过该类。每条 SQL 的事务也都是在这里进行处理（如果 Spring 没有管理的话）。</p>
<h2 id="2-Mapper-代理如何生成？如何运行？"><a href="#2-Mapper-代理如何生成？如何运行？" class="headerlink" title="2.  Mapper 代理如何生成？如何运行？"></a>2.  Mapper 代理如何生成？如何运行？</h2><p>好了，我们有了 DefaultSqlSessionFactory，那么什么适合创建 SqlSessionTemplate 呢，答案是再创建 Mapper 代理的时候，当Spring 对Controller 的bean进行依赖注入的以后，会循环寻找引用，找到Service层，接着找到 Service 层的Mapper，那么，Mapper 代理怎么来的呢？</p>
<p>还记得我们写过一个注解：<code>@MapperScan(basePackages = &quot;cn.think.in.java.mapper&quot;)</code>，这个注解在 IOC 初始化的时候会起到作用。</p>
<p>虽然我们只使用了该注解的一个字段，但我们仔细看看该注解还有没有其他功能:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line"></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包名， 这些指定的包都会被扫描</span></span><br><span class="line">  String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  <span class="comment">// basePackages 的替代方法，扫描指定的类</span></span><br><span class="line">  Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  <span class="comment">// 名称生成器</span></span><br><span class="line">  Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator.class;</span><br><span class="line">  <span class="comment">// annotationClass 注解标记的接口</span></span><br><span class="line">  Class&lt;? extends Annotation&gt; annotationClass() <span class="keyword">default</span> Annotation.class;</span><br><span class="line">  <span class="comment">// 此属性指定扫描程序将要搜索的父项。</span></span><br><span class="line">  <span class="comment">// 扫描器将注册基本包中的所有接口</span></span><br><span class="line">  <span class="comment">// 指定的接口类作为父类。</span></span><br><span class="line">  <span class="comment">// 注意这可以和annotationClass结合使用。</span></span><br><span class="line">  Class&lt;?&gt; markerInterface() <span class="keyword">default</span> Class.class;</span><br><span class="line">  <span class="comment">// sqlSessionTemplate 的引用</span></span><br><span class="line">  <span class="function">String <span class="title">sqlSessionTemplateRef</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// sqlSessionFactory 的引用</span></span><br><span class="line">  <span class="function">String <span class="title">sqlSessionFactoryRef</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 指定一个自定义的MapperFactoryBean来作为spring bean返回一个mybatis代理。</span></span><br><span class="line">  Class&lt;? extends MapperFactoryBean&gt; factoryBean() <span class="keyword">default</span> MapperFactoryBean.class;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到该注解功能繁多，那么该注解作用是什么呢？使用这个注解来注册MyBatis映射器接口。也就是说，我们在启动类上加入了 @ MapperScan 注解，而该注解同时又含有 @Import 注解，在 IOC 启动的时候，会加载该注解标识的类，也就是 MapperScannerRegistrar.class，该类是什么样子的呢？以下是该类继承图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9b46ee65ed130760.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Spring IOC 在启动的时候会调用该类的 registerBeanDefinitions 方法，该方法很长，我们还是看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this check is needed in Spring 3.1</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      scanner.setResourceLoader(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">&quot;annotationClass&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">&quot;markerInterface&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">      scanner.setMarkerInterface(markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">      scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">&quot;factoryBean&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">      scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">&quot;sqlSessionTemplateRef&quot;</span>));</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">&quot;sqlSessionFactoryRef&quot;</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String pkg : annoAttrs.getStringArray(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String pkg : annoAttrs.getStringArray(<span class="string">&quot;basePackages&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : annoAttrs.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class="line">      basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>首先找到 @MapperScan 注解， 然后一个一个的处理注解中的属性。最后关键的一点执行 ClassPathMapperScanner 的 doscan 方法，参数是包名数组。我们看看该方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ab757793254124a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先调用父类的 doScan 方法，返回了一个 BeanDefinitionHolder 的 Set 集合，然后判断是否为空，不为空则执行 processBeanDefinitions 方法，该方法可谓非常的重要，该方法会将制定包下的 Mapper 接口改成 mapperFactoryBean 的类型，也就是说，Spring getBean 返回的就是 mapperFactoryBean 类型，我们还是看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">  GenericBeanDefinition definition;</span><br><span class="line">  <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">    definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Creating MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() </span><br><span class="line">        + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + definition.getBeanClassName() + <span class="string">&quot;&#x27; mapperInterface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">    <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">    definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); <span class="comment">// issue #59</span></span><br><span class="line">    definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">    definition.getPropertyValues().add(<span class="string">&quot;addToConfig&quot;</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">      explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">      explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">      explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">      explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法循环处理所包下所有的 Bean 定义对象，首先修改 Bean 的 Class 为mapperFactoryBean ，然后增加了很多属性，比如addToConfig， sqlSessionFactory，sqlSessionTemplate，并且将该 Bean 的注入类型设置为按照类型注入。 最后在 doScan 方法中返回了这些修改过的 Bean 定义。</p>
<p>我们有头绪了，捋一捋，首先，我们在启动类上写入了注解，标注哪些类或者哪些包需要扫描，并且该注解包含一个 @Import 注解，Spring 会将该注解标识的类 MapperScannerRegistrar 加入到 IOC 的启动过程，然后执行该类的 registerBeanDefinitions 注册 Bean 定义方法， 在该方法中，会将制定包或接口全部修改，加入一些和 SqlSession 相关的属性，并将该接口的 Bean 的类型改为 mapperFactoryBean 类型。 那么 mapperFactoryBean 是什么呢？</p>
<p>我们看看 MapperFactoryBean 的继承图谱：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-63cfa51d5d72762b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MapperFactoryBean"></p>
<p>可以看到，该类实现了 Spring 常用的扩展接口 FactoryBean，也等于拥有了 getObject 方法，我们说，可以在该方法中动一些手脚。继承了 SqlSessionDaoSupport， 该类中有几个方法我们能够看到，就是设置 SqlSessionFactory 和 SqlSessionTemplate，getSession 等方法。该类可以说是开发者们在 Dao 层支持类，如果可以，完全可以继承该类，获取 SqlSession 直接操作数据库。但是这样就太复杂了。当然还有，MapperFactorybean 还间接实现了 InitializingBean 接口，也就是 Spring 留给我们的扩展接口。 需要重写 afterPropertiesSet 方法。我们还是看看该类吧。</p>
<p>该类既然是个 FactoryBean ,那么我们第一个看的就是他的 getObject 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-cd9b64661c0e4eea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>是不是很熟悉，该方法就是获取 SqlSession 然后调用 SqlSession 的 getMapper 方法，参数是 mapperInterface 接口（该参数在构造器中传入）。也就是说，Spring 根据 Bean 定义对象，找到该方法，再在 getObject 方法中构造代理对象。我们终于知道了为什么在 ClassPathMapperScanner 的 doScan 方法中要将接口的 Bean 定义的改成 MapperFactorybean  ，原来最终的目的就是调用 getObject 方法，然后调用 getMapper 方法。并且设置的那些属性就是在对 MapperFactoryBean 的父类 SqlSessionDaoSupport 的属性进行赋值。</p>
<p> getMapper 方法我想应该不用解释了吧，在我们关于Mybatis 的第二篇文章中已经知道所有逻辑了。</p>
<p>还记得 MapperFactoryBean 实现的 InitializingBean 接口，该接口定义的方法是在属性设置完毕后执行，那么该方法是如何执行的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-135be8a988cc6fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先执行了 checkDaoConfig 方法，该方法是个抽象方法， 然后调用了 initDao 方法，该方法是个空方法。那么 checkDaoConfig 的具体实现是什么呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f43157a0324c4609.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法会校验接口是否存在，然后调用 configuration 的 addMapper 方法，该方法底层调用了 MapperRegistry 的 addMapper 方法，将 namespace 属性和 配置文件关联。这之前我们已经分析过了。</p>
<p>我们开始说，创建 SqlSessionTemplate，是在 IOC 初始化 Mapper 的时候创建的。什么时候呢？ 就是在 ClassPathMapperScanner 的 processBeanDefinitions 方法中，设置了 sqlSessionTemplate 属性，最终会触发 SqlSessionDaoSupport 的 setSqlSessionTemplate 方法，该方法从容器中获取 SqlSessionTemplate 实例，从而触发我们编写的 new SqlSessionTemplate 方法，如果不写也没事，setSqlSessionFactory 会默认创建一个。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b74d051db6c160d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>好了，我们可以总结一下 Mapper 的创建过程：</p>
<ol>
<li><p>IOC 通过注解扫描指定包名，在初始化的时候调用@MapperScan 注解中指定的类最终执行 doScan 方法，将所有的 Mapper 接口的 Bean 定义都改成 FactoryBean 的子类 MapperFactoryBean，并将该 SqlSessionFactory 和 SqlSessionTemplate 添加到该类中。</p>
</li>
<li><p>Spring IOC 在实例化该 Bean 的时候，需要传入接口类型，并将 SqlSessionFactory 和 SqlSessionTemplate 注入到该 Bean 中。并调用 configuration 的 addMapper 方法，解析配置文件。</p>
</li>
<li><p>当调用 MapperFactoryBean 的 getObject 方法的时候，事实上是调用 SqSession 的 getMapper 方法，而这个方法会返回一个动态代理对象。所有对这个对象的方法调用都是底层的 SqlSession 的方法。</p>
</li>
</ol>
<p>而 Spring 和 MyBatis 的整合也和 AOP 相似，都是通过 Spring 留下的扩展接口 FactoryBean 来实现的。在 FactoryBean 中包装了 SqlSession ，而 SqlSession 则会返回代理。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>这是我们剖析mybatis 的第三篇文章了，我们分析了Mybatis 是如何整合Spring的，通过mybatis 提供的 mybatis-spring 的jar包，粘合了Spring和mybaits， mybatis 和 AOP 一样，都是通过扩展 Spring 提供的各种接口来完成扩展功能，比如 Factory，在SqSessionTemplate 中，底层还是调用 Mybatis 自己的SqlSession 创建动态代理来实现的。可谓万变不离其宗。同时，我们也学习到了Java世界两大框架的优秀，比如灵活扩展。非侵入式，特别式Spring，设计的可谓趋于完美。作为程序员，我们更要向这些优秀的源码学习。加油！！！</p>
<p>good luck！！！</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Spring-之-SpringBoot-事务原理</title>
    <url>/2017/12/25/2017/2017-12-25-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Spring-%E4%B9%8B-SpringBoot-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       今天是平安夜，先祝大家平安夜快乐。

<p>我们之前的数十篇文章分析了 Spring 和 Mybatis 的原理，基本上从源码层面都了解了他们的基本原理，那么。在我们日常使用这些框架的时候，还有哪些疑问呢？就楼主而言，楼主已经明白了 IOC ，AOP 的原理，也明白了 Mybatis 的原理，也明白了 Spring 和 Mybatis 是如何整合的。但是，我们漏掉了 JavaEE 中一个非常重要的特性：事务。事务是 Java 程序员开发程序时不可避免的问题。我们就不讨论 ACID 的事务特性，楼主这里假定大家都已经了了解了事务的原理。如果还不了解，可以先去谷歌看看。那么，我们今天的任务是剖析源码，看看Spring 是怎么运行事务的，并且是基于当前最流行的SpringBoot。还有，我们之前剖析Mybatis 的时候，也知道，Mybatis 也有事务，那么，他俩融合之后，事务是交给谁的？又是怎么切换的？今天这几个问题，我们都要从源码中找到答案。</p>
<h2 id="1-Spring-的事务如何运行？"><a href="#1-Spring-的事务如何运行？" class="headerlink" title="1. Spring 的事务如何运行？"></a>1. Spring 的事务如何运行？</h2><p>如果各位使用过SpringBoot ，那么就一定知道如何在Spring中使用注解，比如在一个类或者一个方法上使用 @Transactional 注解，在一个配置类上加入一个 @EnableTransactionManagement 注解代表启动事务。而这个配置类需要实现 TransactionManagementConfigurer 事务管理器配置接口。并实现 annotationDrivenTransactionManager 方法返回一个包含了 配置好数据源的 DataSourceTransactionManager 事务对象。这样就完成了事务配置，就可以在Spring使用事务的回滚或者提交功能了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-cfc259620f573921.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-112ad1d23f28d020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4900c9a43c325e49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这个 saveList 方法就在Spring事务的控制之下，如果发生了异常，就会回滚事务。如果各位知道更多的Spring的事务特性，可以在注解中配置，比如什么异常才能回滚，比如超时时间，比如隔离级别，比如事务的传播。就更有利于理解今天的文章了。</p>
<p>我们基于一个 Junit 测试用例，来看看Spring的事务时如何运行的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-60b40a98331487dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在测试用例中执行该方法，参数时一个空的List，这个Sql的运行肯定是失败的。我们主要看看他的运行过程。我们讲断点打在该方法上。断点进入该方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-603d4e012ceea008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意，dataCollectionShareService 对象已经被 Cglib 代理了，那么他肯定会走 DynamicAdvisedInterceptor 的 intercept 方法，我们断点进入该方法查看，这个方法我们已经很属性了，该方法中，最重要的事情就是执行通知器或者拦截器的方法，那么，该代理有通知器吗？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9a3f166c88b56ec3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>有一个通知器。是什么呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-40d107782c659d0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>一个事务拦截器，也就是说，如果通知器链不为空，就会依次执行通知器链的方法。那么 TransactionInterceptor 到底是什么呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9a30b4722ed6458a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类实现了通知器接口，也实现类 MethodInterceptor 接口，并实现了该接口的 invoke 方法，在 DynamicAdvisedInterceptor 的 intercept 方法中，最终会调用每个 MethodInterceptor 的 invoke 方法，那么，TransactionInterceptor  的 invoke 方法是如何实现的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-bdd281b4ec68bffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>invoke 方法中会调用自身的 invokeWithinTransaction 方法，看名字，该方法和事务相关。该方法参数是由目标方法，目标类，一个回调对象构成。 那么我们就进入该方法查看，该方法很长：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General delegate for around-advice-based subclasses, delegating to several other template</span></span><br><span class="line"><span class="comment"> * methods on this class. Able to handle &#123;<span class="doctag">@link</span> CallbackPreferringPlatformTransactionManager&#125;</span></span><br><span class="line"><span class="comment"> * as well as regular &#123;<span class="doctag">@link</span> PlatformTransactionManager&#125; implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method the Method being invoked</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetClass the target class that we&#x27;re invoking the method on</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invocation the callback to use for proceeding with the target invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the return value of the method, if any</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable propagated from the target invocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">	<span class="keyword">final</span> TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">	<span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">	<span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">		TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">		Object retVal = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">			<span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">			retVal = invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// target invocation exception</span></span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// It&#x27;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,</span><br><span class="line">					<span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">							TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="keyword">return</span> invocation.proceedWithInvocation();</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">								<span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">									<span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line">									<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">										<span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">									&#125;</span><br><span class="line">									<span class="keyword">else</span> &#123;</span><br><span class="line">										<span class="keyword">throw</span> <span class="keyword">new</span> ThrowableHolderException(ex);</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">else</span> &#123;</span><br><span class="line">									<span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line">									<span class="keyword">return</span> <span class="keyword">new</span> ThrowableHolder(ex);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">finally</span> &#123;</span><br><span class="line">								cleanupTransactionInfo(txInfo);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check result: It might indicate a Throwable to rethrow.</span></span><br><span class="line">			<span class="keyword">if</span> (result <span class="keyword">instanceof</span> ThrowableHolder) &#123;</span><br><span class="line">				<span class="keyword">throw</span> ((ThrowableHolder) result).getThrowable();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex.getCause();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要逻辑：</p>
<ol>
<li>获取事务属性，根据事务属性，获取事务管理器。</li>
<li>判断属性是否空，或者事务管理器是否不是 CallbackPreferringPlatformTransactionManager 类型，如果是该类型，则会执行事务管理器的 execute 方法。</li>
<li>生成一个封装了事务管理器，事务属性，方法签名字符串，事务状态对象 的 TransactionInfo 事务信息对象。该对象会在事务回滚或者失败时起作用。</li>
<li>调用目标对象方法或者是下一个过滤器的方法。</li>
<li>如果方法由异常则执行 completeTransactionAfterThrowing 方法，调用事务管理器的回滚方法。如果没有异常，调用 commitTransactionAfterReturning 提交方法。最后返回返回值。</li>
</ol>
<p>可以说，该方法就是Spring 事务的核心调用，根据目标方法是否有异常进行事务的回滚。</p>
<p>那么，我们需要一行一行的看看该方法实现。</p>
<p>首先看事务的属性。</p>
<h2 id="2-TransactionAttribute-事务属性"><a href="#2-TransactionAttribute-事务属性" class="headerlink" title="2. TransactionAttribute 事务属性"></a>2. TransactionAttribute 事务属性</h2><p>invokeWithinTransaction 方法中调用了 自身的 getTransactionAttributeSource 方法返回一个TransactionAttributeSource 对象，并调用该对象的 getTransactionAttribute 方法，参数是目标方法和目标类对象。首先看 getTransactionAttributeSource 方法，该方法直接返回了抽象类 TransactionAspectSupport 中定义的 TransactionAttributeSource 属性。该属性的是什么时候生成的我们稍后再说。我们debug 后返回的是 TransactionAttributeSource 接口的实现类 AnnotationTransactionAttributeSource ，看名字，注解事务属性资源，名字起的好很重要啊。我们进入该类查看。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-bec4cff1542d000a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是该类的继承机构图。我们重点还是关注该类的 getTransactionAttribute 方法，该方法有抽象类 AbstractFallbackTransactionAttributeSource 也就是 AnnotationTransactionAttributeSource  的父类完成。我们看看该方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8c063dce4193dae8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法大部分都是缓存判断，最重要的一行代码楼主已红框标出。computeTransactionAttribute 方法，计算事务属性。进入该方法查看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-63eb53d0c640cd0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法是返回事务属性的核心方法，首先，根据 class 和 method 对象，生成一个完整的method 对象，然后调用 findTransactionAttribute 方法，参数就是该 method 对象，findTransactionAttribute 方法是抽象方法，由子类实现，可见 computeTransactionAttribute 是个模板方法模式。那么我们就看看他的子类 AnnotationTransactionAttributeSource 是如何实现的。该方法调用了自身的 determineTransactionAttribute 方法。该方法实现入下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c747b5f262b7d2db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法会判断该 Method 对象是否含有注解。并循环 AnnotationTransactionAttributeSource 对象的 annotationParsers 注解解析器集合，对该方法进行解析。如果解析成功，则返回该注解元素。我想我们也已经猜到了，这个注解解析器解析的就是  @Transactional 注解。</p>
<h2 id="3-Transactional-注解解析器-SpringTransactionAnnotationParser"><a href="#3-Transactional-注解解析器-SpringTransactionAnnotationParser" class="headerlink" title="3. @Transactional  注解解析器 SpringTransactionAnnotationParser"></a>3. @Transactional  注解解析器 SpringTransactionAnnotationParser</h2><p>我们说AnnotationTransactionAttributeSource  对象中又多个解析器。那么这些解析器是什么时候生成的呢？构造方法中生成的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-00711cd6d27a7276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该构造方法由一个布尔属性，然后创建一个链表，也创建一个 SpringTransactionAnnotationParser 对象添加进链表中。这样就完成了解析器的创建。构造方法什么时候调用的呢？我们稍后再讲。</p>
<p>我们看看注解解析器是怎么解析方法对象的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-96230369822a2ef5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先根据指定的 Transactional 注解和给定的方法，调用工具方法 getMergedAnnotationAttributes ，获取方法上的注解属性。然后调用重载方法 parseTransactionAnnotation 。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d12844be8788d1e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，该方法首先创建了一个 RuleBasedTransactionAttribute 对象，然后一个个解析注解中的元素，并将这些元素设置到 RuleBasedTransactionAttribute 对象中，注意，其中有个 RollbackRuleAttribute 的集合，存储着该注解属性的回滚相关的属性。最后添加到 RuleBasedTransactionAttribute 的RollbackRules 集合中。</p>
<p>到这里，就完成了解析器的解析。返回了一个 RuleBasedTransactionAttribute 对象。</p>
<p>回到 拦截器的 invokeWithinTransaction  方法中，此时已经获取了 属性对象。根据方法，也就是说，如果返回值是null，说明该方法没有事务注解，在 getTransactionAttribute 方法中，也会将该方法作为key ，NULL_TRANSACTION_ATTRIBUTE 作为 value，放入缓存，如果不为null，那么就将 TransactionAttribute 作为 value 放入缓存。</p>
<p>有了事务属性，再获取事务管理器。也就是 determineTransactionManager 方法。</p>
<h2 id="4-事务管理器。"><a href="#4-事务管理器。" class="headerlink" title="4. 事务管理器。"></a>4. 事务管理器。</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-5d51433cdd8fce48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们注意到，调用了自身的 determineTransactionManager 方法，返回了一个 PlatformTransactionManager 事务管理器。这个事务管理器就是我们在我们的配置类中写的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4ba143baaa43e87a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>那么这个事务管理器是什么呢？事务管理器就是真正执行事务回滚或提交的执行单位，我们看看该类：</p>
<p>继承图：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-7241daa34fa74cc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>结构图：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-4d9ecce214dbd360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>红框标注的方法就是执行正在事务逻辑的方法，其中又封装了数据源，也就是 JDBC 的 Connection 。比如 doCommit 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e16bd2db1474426e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们看看determineTransactionManager 是如何获取事务管理器的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-eaf7239f86432942.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法步骤入下：</p>
<ol>
<li>如果事务属性为null 或者 容器工厂为null，则返会自身的 transactionManager 事务管理器。</li>
<li>如果都不为null，则获取事务属性的限定符号，根据限定符从容器中获取 事务管理器。</li>
<li>如果没有限定符，则根据事务管理器的BeanName从容器中获取。</li>
<li>如果都没有，则获取自身的事务管理器，如果自身还没有，则从缓存中取出默认的。如果默认的还没有，则从容器中获取PlatformTransactionManager 类型的事务管理器，最后返回。</li>
</ol>
<p>这里重点是自身的事务管理器从何而来？我们先按下不表。</p>
<p>到这里，我们已经有了事务管理器。就需要执行 invokeWithinTransaction 下面的逻辑了。回到 invokeWithinTransaction 方法，我们的返回值肯定满足第一个if 条件，因为我们的事务管理器不是 CallbackPreferringPlatformTransactionManager 类型的。进入if 块。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-557f6911d9b99e69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先创建一个事务信息对象。该类是什么呢？</p>
<p>属性：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-e8a8083b7590c398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>构造方法：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-a88c1a38834531eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类包含了一个 事务管理器，事务属性，事务方法字符串。</p>
<p>接着执行回调类InvocationCallback 的 proceedWithInvocation 方法，该方法会执行下一个通知器的拦截方法（如果有的话），最后执行目标方法，这里，目标方法被 try 住了，如果发生异常，则执行completeTransactionAfterThrowing 方法，并抛出异常，在 finally 块中执行清理工作。如果成功执行，则执行<br>commitTransactionAfterReturning 方法。最后返回目标方法返回值。</p>
<p>我们重点看看 completeTransactionAfterThrowing 方法和 commitTransactionAfterReturning 方法。</p>
<h2 id="5-TransactionInterceptor-的-completeTransactionAfterThrowing-方法（事务如何回滚）。"><a href="#5-TransactionInterceptor-的-completeTransactionAfterThrowing-方法（事务如何回滚）。" class="headerlink" title="5. TransactionInterceptor 的 completeTransactionAfterThrowing 方法（事务如何回滚）。"></a>5. TransactionInterceptor 的 completeTransactionAfterThrowing 方法（事务如何回滚）。</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-5c15034853258152.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法主要内容在红框中，首先判断该事务对象是否和该异常匹配，如果匹配，则回滚，否则，则提交。那么，是否匹配的逻辑是怎么样的呢？我们的事务属性是什么类型的？RuleBasedTransactionAttribute ，就是我们刚刚创建解析注解后创建的。那么我就看看该类的 rollbackOn 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-73df2cdd08589066.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先，循环解析注解时添加进集合的回滚元素。并递归调用RollbackRuleAttribute 的 getDepth 方法，如果这个异常的名字和注解中的异常名字匹配，则返回该异常的回滚类型。最后判断，如果没有匹配到，则调用父类的 rollbackOn 方法，如果匹配到了，并且该属性类型不是 NoRollbackRuleAttribute 类型，返回true。表示匹配到了，可以回滚。那么父类的 rollbackOn 方法肯定就是默认的回滚方法了。</p>
<p>这是父类的 rollbackOn 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c8ee8a9ccbb2db92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法判断，该异常如果是 RuntimeException 类型异常或者 是 Error 类型的，就回滚。这就是默认的回滚策略。</p>
<p>那么我们的方法肯定是匹配的 RuntimeException 异常，就会执行下面的方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1132805e31316f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，这行代码就是执行了我们的事务管理器的 rollback 方法，并且携带了事务状态对象。该方法实现在抽象类 AbstractPlatformTransactionManager 中，调用了自身的 processRollback 方法做真正的实现。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5a6f1d12d7985007.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法首先切换事务状态，其实就是关闭SqlSession。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3eccb847363718d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>然后调用 doRollback 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1a468d7075f82f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先，从状态对象中获取数据库连接持有对象，然后获取数据库连接，调用 Connection 的 rollback 方法，也就是我们学习JDBC 时使用的方法。最后修改事务的状态。</p>
<p>到这里，事务的回滚就结束了。</p>
<p>那么，事务时如何提交的呢？</p>
<h2 id="6-TransactionInterceptor-的-commitTransactionAfterReturning-方法（事务如何提交）。"><a href="#6-TransactionInterceptor-的-commitTransactionAfterReturning-方法（事务如何提交）。" class="headerlink" title="6. TransactionInterceptor 的 commitTransactionAfterReturning 方法（事务如何提交）。"></a>6. TransactionInterceptor 的 commitTransactionAfterReturning 方法（事务如何提交）。</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-04056214359dca61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法简单的调用了事务管理器的 commit 方法。</p>
<p>AbstractPlatformTransactionManager 的 commit 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ac608644a6239ef7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先判断了事务的状态，如果状态不匹配，则调用回滚方法。如果状态正常，执行 processCommit 方法。该方法很长，楼主只截取其中一段：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8acc2e2b6922d68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先，commit 之前做一些状态切换工作。最重要的是执行 doCommit 方法，如果异常了，则回滚。那么 DataSourceTransactionManager 的 doCommit 是如何执行的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-63a241cf81f99525.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，底层也是调用 JDBC 的 Connection 的 commit 方法。</p>
<p>到这里，我们就完成了数据库的提交。</p>
<h2 id="7-事务运行之前做了哪些工作？"><a href="#7-事务运行之前做了哪些工作？" class="headerlink" title="7. 事务运行之前做了哪些工作？"></a>7. 事务运行之前做了哪些工作？</h2><p>从前面的分析，我们已经知道了事务是如何运行的，如何回滚的，又是如何提交的。在这是交互型的框架里，事务系统肯定做了很多的准备工作，同时，我们留下了很多的疑问，比如事务管理器从何而来？ TransactionAttributeSource  属性何时生成？AnnotationTransactionAttributeSource  构造什么时候调用？</p>
<p>我们一个个的来解释。</p>
<p>在Spring 中，有一个现成的类，ProxyTransactionManagementConfiguration，我们看看该类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1282b126083060ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>看到这个类，应该可以解开我们的疑惑，这个类标注了配置注解，会在IOC的时候实例化该类，而该类中产生了几个Bean，比如事务拦截器 TransactionInterceptor，创建了 AnnotationTransactionAttributeSource 对象，并向事务拦截器添加了事务管理器。最后，将事务拦截器封装成通知器。那么，剩下最后一个问题就是，事务管理器从何而来？答案是他的父类 AbstractTransactionManagementConfiguration ：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-fcb24dd388fceea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类也是个配置类，自动注入了 TransactionManagementConfigurer 的配置集合，而并且寻找了配置 EnableTransactionManagement 注解的类，而我们在我们的项目中就是按照这个标准来实现的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-28d41758c9d322bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们关联这两个类就能一目了然，Spring在启动的时候，会加载这两个配置类，在对 AbstractTransactionManagementConfiguration 的 setConfigurers 方法进行注入的时候，会从容器中找到对应类型的配置，并调用配置类的 annotationDrivenTransactionManager 方法，也就是我们实现的方法，获取到我们创建的 DataSourceTransactionManager 类。这样，我们的事务拦截器相关的类就完成了在Spring中的依赖关系。</p>
<p>但是，这个时候Spring中的事务运行还没有搭建完成。比如什么时候创建类的代理？根据什么创建代理，因为我们知道，Spring 中的事务就是使用AOP来完成的，必须使用动态代理或者 Cglib 代理来对目标方法进行拦截。</p>
<p>这就要复习我们之前的Spring IOC 的启动过程了。Spring 在创建bean的时候，会对每个Bean 的所有方法进行遍历，如果该方法匹配系统中任何一个拦截器的切点，就创建一个该Bean的代理对象。并且会将对应的通知器放入到代理类中。以便在执行代理方法的时候进行拦截。</p>
<p>具体代码步骤楼主贴一下：</p>
<ol>
<li>在对bean 进行初始化的时候会执行 AutowireCapableBeanFactory 接口的 applyBeanPostProcessorsAfterInitialization 的方法，其中会遍历容器中所有的bean后置处理器，后置处理器会调用 postProcessAfterInitialization 方法对bean进行处理。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6d44b133cc6edd7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol start="2">
<li>在处理过程中，对bean 进行包装，也就是代理的创建，调用 getAdvicesAndAdvisorsForBean 方法，该方法会根据bean的信息获取到对应的拦截器并创建代理，创建代理的过程我们之前已经分析过了，不再赘述。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0a490ac3757e1051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol start="3">
<li>寻找匹配拦截器过程：首先找到所有的拦截器，然后，根据bean的信息进行匹配。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-923c9504b34b97bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol start="4">
<li>匹配的过程就是，找到目标类的所有方法，遍历，并调用拦截器的方法匹配器对每个方法进行匹配。方法匹配器就是事务拦截器中的 BeanFactoryTransactionAttributeSourceAdvisor 类，该类封装了 AnnotationTransactionAttributeSource 用于匹配事务注解的匹配器。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-66a202405bbbd189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2465b95ec883d884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol start="5">
<li>最终调用方法匹配器中封装的注解解析器解析方法，判断方法是否含有事务注解从而决定是否生成代理：</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-935654e3a9876b64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>到这里，就完成了所有事务代理对象的创建。</p>
<p>项目中的每个Bean都有了代理对象，在执行目标方法的时候，代理类会查看目标方法是否匹配代理中拦截器的方法匹配器中定义的切点。如果匹配，则执行拦截器的拦截方法，否则，直接执行目标方法。这就是含有事务注解和不含有事务注解方法的执行区别。</p>
<p>到这里，我们还剩下最后一个问题，我们知道，在分析mybatis 的时候，mybatis 也有自己的事务管理器，那么他们融合之后，他们的事务管理权在谁的手上，又是根据什么切换的呢？</p>
<h2 id="8-mybatis-和-Spring-的事务管理权力之争"><a href="#8-mybatis-和-Spring-的事务管理权力之争" class="headerlink" title="8. mybatis 和 Spring 的事务管理权力之争"></a>8. mybatis 和 Spring 的事务管理权力之争</h2><p>我们之前说过，在Spring中，mybatis 有 SqlSessionTemplate 代理执行，其实现类动态代理的 InvocationHandler 方法，那么最重要的方法就是 invoke 方法，其实这个方法我们已经看过了，今天再看一遍：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0d8c648dd2f915a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们今天重点关注是否提交（报错肯定回滚），其中红框标出来的 if 判断，就是判断这个事务到底是Spring 来提交，还是 mybatis 来提交，那么我们看看这个方法 isSqlSessionTransactional ：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-be3d8eadd431999d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法从Spring 的容器中取出持有 SqlSession 的 持有类，判断Spirng 持有的 SqlSession 和 Mybatis 持有的是否是同一个，如果是，则交给Spring，否则，Mybatis 自己处理。可以说很合理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天的这篇文章可以说非常的长，我们分析了 SpringBoot 的事务运行过程，事务环境的搭建过程，mybatis 的事务和 Spring 事务如何协作。知道了整个事务其实是建立在AOP的基础之上，其核心类就是 TransactionInterceptor，该类就是 invokeWithinTransaction 方法是就事务处理的核心方法，其中封装了我们创建的 DataSourceTransactionManager 对象，该对象就是执行回滚或者提交的执行单位 其实，TransactionInterceptor 和我们平时标注 @Aspect 注解的类的作用相同，就是拦截指定的方法，而在<br>TransactionInterceptor  中是通过是否标有事务注解来决定的。如果一个类中任意方法含有事务注解，那么这个方法就会被代理。而Mybatis 的事务和Spring 的事务协作则根据他们的SqlSession 是否是同一个SqlSession 来决定的，如果是同一个，则交给Spring，如果不是，Mybatis 则自己处理。</p>
<p>通过阅读源码，我们已经弄清楚了SpirngBoot 整个事务的运行过程。实际上，Spring 的其他版本也大同小异。底层都是 TransactionInterceptor ，只不过入口不一样。我相信，在以后的工作中，如果遇到了Spring事务相关的问题，再也不会感到无助了，因为知道了原理，可以深入到源码中查看。</p>
<p>到这里，楼主的 Spring ，mybatis ，Tomcat 的源码阅读之路暂时就告一段落了。源码只要领会精华即可。还有其他的知识需要花费更多的时间学习。比如并发，JVM.</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>深入剖析-Mybatis-原理（四）插件的原理和应用</title>
    <url>/2017/12/22/2017/2017-12-22-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-mybatis-%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       >《 一生所爱》
从前现在过去了再不来
红红落叶长埋尘土内
开始终结总是没变改
天边的你飘泊白云外
苦海翻起爱恨
在世间难逃避命运
相亲竟不可接近
或我应该相信是缘份
情人别后永远再不来(消散的情缘)
无言独坐放眼尘世外(愿来日再续)
鲜花虽会凋谢(只愿)
但会再开(为你)
一生所爱 隐约(守候)
在白云外(期待)
苦海翻起爱恨
在世间难逃避命运
相亲竟不可接近
或我应该相信是缘份
苦海翻起爱恨
在世间难逃避命运
相亲竟不可接近
或我应该相信是缘份



<p>这是我们分析 mybatis 的第四篇文章，看标题，我们是分析 mybatis 的插件，其实，在前面的三篇文章中，我们已经在剖析源码的时候多多少少接触到 mybatis 的插件设计和运行过程了，只是没有单独的开一篇文章来讲这个，mybatis 的日志系统就是基于插件的。这个在我们之前的源码剖析里也说过。插件在整个mybatis 中只占很小的一部分，mybatis 不像 Spring ，留了很多的接口给使用者扩展，只留了一个接口给开发者扩展。究其原因还是两者的目标和工作不同。有了之前三篇文章的基础，我们今天研究 mybatis 的插件，基本就是一个复习的过程，整体上还是比较轻松的。那么，接下来我们就看看吧！</p>
<p>我们将分为 2 个部分来讲述，一个是插件原理，一个是如何应用插件接口并且对比国内流行的插件。</p>
<h2 id="1-插件原理"><a href="#1-插件原理" class="headerlink" title="1.插件原理"></a>1.插件原理</h2><p>我们在剖析 mybatis 的时候，就已经发现了 mybatis 的插件在他自己框架身上的应用，我们回顾一下在哪里出现的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1961c16a50346791.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="newExecutor"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-51cf94e1006fefd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="newParameterHandler"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8445007df33a92a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="newResultSetHandler"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2818fc2f50fb3f54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="newStatementHandler"></p>
<p>从上面的截图，可以看到，在mybatis 4大对象的创建过程中，都调用了 interceptorChain.pluginAll 方法，可见该方法的重要性，那么该方法的作用是上面呢？我们首先猜测一下，从该方法的名字可以看出，该方法是拦截器链调用插件方法，并传入了一个对象，最后返回了一个该对象，那么，我们看看该方法是如何实现的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-26ef0f9af17d1ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InterceptorChain"></p>
<p>该类可以说是非常的简单，所谓大道无形，该类是 mybatis 插件核心，首先有一个插件集合，一个 pluginAll 方法，一个 addInterceptor 方法， 一个getInterceptors 方法，可以看的出来该类就是一个过滤器链，类似tomcat 的过滤器和Spring的AOP，我们主要看两个方法，一个是 pluginAll，一个是 addInterceptor 方法，我们首先看看 addInterceptor 方法，也即使添加过滤器，什么时候添加呢？我们看看该方法的调用栈：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-cfe8cae58f6f9bd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用栈"></p>
<p>可以看到，从我们的main方法开始，调用了 SqlSessionFactoryBuilder.build 方法，再调用了 XMLConfigBuilder 的 parse 方法，该方法又调用了自身的 parseConfiguration 方法，在 parseConfiguration 方法中调用了 pluginElement 解析 “plugins” 属性，在该方法中调用了 configuration.addInterceptor 方法，该方法又调用了 interceptorChain.addInterceptor 方法，将插件添加进该集合。也就是说，该方法是在解析XML配置文件的时候调用的，将配置好的插件添加进集合中，以便之后的调用。</p>
<p>那么 pluginAll 方法是什么时候运行的呢？我们同样看看他的方法调用栈：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b700d9ecf29671a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pluginAll  调用栈"></p>
<p>我们在方法调用栈图上看到的最后一层调用了 openSession 方法，也就是我们 sqlSessionFactory.openSession() 方法生成 SqlSession 的时候，该方法会调用 自身的<br> openSessionFromDataSource 方法，然后调用 configuration.newExecutor 方法插件 Executor，在 newExecutor 方法中，我们上面的图上也有，调用了 executor = (Executor) interceptorChain.pluginAll(executor) 方法，返回了一个 executor，很显然，这个对象肯定被处理过了。这里我们只说了 executor 对象，4大对象的其余三个对象也是这么生成的，我们就不一一讲了，有兴趣的同学可以翻看源码。</p>
<p>那么，我们就要看看该方法到底是如何实现的，让 mybatis 的 4 大对象都要调用该方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1ee8c80e5c9ed37d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法循环了所有的拦截器，并调用了拦截器的 plugin 方法，每次都讲返回的 target 对象作为参数作为下一次调用。那么 plugin 方法的内容是什么呢？Interceptor 是个接口，在mybatis 源码中，只有2个实现类，我们找其中一个 ExamplePlugin 实现类看看源码实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ff6e1162a9da6ae8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类实现了 Interceptor 接口，并重写了3个方法，其中就有我们关注的 plugin 方法，该方法内部很简单的调用了 Plugin.wrap(target, this) 方法，参数是 目标对象和自身，返回了和目标对象，我们该方法内部是如何实现的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-758d2d78af88156f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>楼主只截取了一部分方法，该类实现类 JDK 动态代理中一个重要的接口 InvocationHandler 接口，而 wrap 方法是一个静态方法，通过传入的拦截器和目标对象，生成一个动态代理返回，注意，目标对象一定要实现某个接口，否则返回自身，我们看看代码实现。</p>
<ol>
<li>调用自身的 getSignatureMap 方法，该方法获取了 Intercepts 注解上的 key 是 拦截的类型，value 是拦截的方法（多个）数据。并将数据包装成map返回。</li>
<li>获取目标对象的接口，并讲接口放进一个Set中并转成Class 数组返回。</li>
<li>根据上面生成的参数map，拦截器，目标对象，生成一个 puugin对象。</li>
<li>将生成 plugin 对象和接口和类加载器创建一个动态代理对象返回。</li>
</ol>
<p>好了，我们知道了 plugin  方法的作用，也就是说，4 大对象都会调用该方法，都会将这些拦截器把自己包装起来，最后拦截自己。完成切面工作，比如日志。</p>
<p>那么，既然是实现类 JDK 的 InvocationHandler 接口，那么我们就要看看他的invoke 方法是怎么实现的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-36394af712e0331b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invoke 方法实现"></p>
<p>该方法首先从刚刚从拦截器类 Intercepts 注解上取出的参数map中以目标方法的类作为key取出对应的方法集合，如果 invoke 方法和注解上定义的方法匹配，就执行拦截器的 intercept 方法，注意，此时，会创建一个Invocation 对象作为参数传递到 intercept 方法中，而这个对象的创建的参数包括 目标对象，代理拦截的方法，代理的参数。</p>
<p>我们回到 mybatis 中的拦截器例子 ExamplePlugin 类中看看 intercept 方法是如何实现的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-bd17063a013408ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法只是调用了 invocation 的proceed 方法，那么该方法是如何定义的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ae9e45c18e3576bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法只是用反射调用刚刚构造函数中的方法。并没有执行任何的操作。也就是说，在 Plugin 中的 invoke 方法中，调用了拦截器的 intercept 方法，并传入了 Invocation 对象，该对象的作用就是将目标对象，目标方法，目标方法参数传入，让拦截器可以取出这些参数并做加强工作。注意，需要在执行完加强操作和执行 Invocation 的 proceed 方法。也就是执行目标对象真正的方法。</p>
<p>到这里，我们已经弄懂了 mybatis 的拦截器原理，首先拦截器拦截的是 mybatis 的 4 大对象，我们需要在配置文件中配置拦截器，方便mybaits 添加到拦截器链中。mybatis 为我们提供了 Interceptor 接口，我们可以在该接口中实现自己的逻辑，主要需要实现 intercept 方法，在该方法中利用给定的 Invocation 对象来对我们的业务做一些增强。而调用拦截器方法的类就是 JDK 动态代理的接口 InvocationHandler 的实现类 Plugin 的invoke 方法，该方法会根据目标方法是否匹配拦截器注解的值来决定是否调用拦截器的 intercept 方法。并传入封装了目标对象，目标方法，目标方法参数的 Invocation 实例。</p>
<p>知道了拦截器的实现原理，那么我们就写一个例子来体验一下。</p>
<h2 id="2-拦截器的应用"><a href="#2-拦截器的应用" class="headerlink" title="2. 拦截器的应用"></a>2. 拦截器的应用</h2><p>首先编写 mybatis 插件需要遵守几个约定：</p>
<ol>
<li>实现 Interceptor 接口并实现接口中的方法。</li>
<li>在配置文件中配置插件。</li>
<li>在实现 Interceptor 接口的类上加上 @Intercepts 注解。该注解如下：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-de3e0734d79f2a61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<p>仅有一个 Signature 注解集合，我们看看Signature 注解有哪些内容：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7c41d1d3518508fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该注解有3个方法，分别代表着拦截的类型，拦截的哪个方法，拦截的方法的参数（因为可能是重载方法）。也就是说，这是一个方签名注解。</p>
<p>那么我们能拦截哪些类呢？我们前面说，执行 SQL 的是mybatis 4大对象，并且这4大对象也都会调用过滤器链，那么他们的调用过程是怎么样的呢？我们看看他们的方法调用栈：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4f40cb9ce204af3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>最上面的是 BaseStatementHandler 抽象类的构造方法，实现类则是PreparedStatementHandler，在该构造器中，会创建2个包含了插件的 parameterHandler 对象和 resultSetHandler 对象。那么这个方法是什么时候调用的呢？实际上，newExecutor 方法，也就是创建 Executor 代理的方法是第一个创建的，然后再执行 doQuery 方法的时候，会创建 StatementHandler 对象，而再创建 StatementHandler 对象的时候，会创建另外 2 个对象 parameterHandler 和 resultSetHandler。由此完成 4 大对象的代理创建。那么 4 大对象的创建调用是什么顺序呢？楼主写了一个例子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-356538f85222d314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>楼主拦截了 4 大对象个一个方法，也就是说，只要执行这 4 个方法都会进入 intercept 方法，都会答应该对象的引用。我们看看运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2e54ed0a54bc53a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到顺序，首先执行了 executor 的方法，然后执行了 StatementHandler 的拦截方法， 再执行 ParameterHandler 的方法，再执行 ResultSetHandler 的拦截器，最后执行 executor 真正的查询方法。</p>
<p>知道了这个顺序，对我们开发插件是有帮助的。</p>
<p>看着这里，我们应该有个了解了，我们使用插件的目的大部分都是再运行SQL的时候修改SQL，比如分页，比如分表，再原有的SQL上做一些修改，那么怎么才能修改呢？重点就在 MappedStatement 的 sqlSource 属性，该接口的实现类会存储SQL语句，比如其中一个实现类 ：StaticSqlSource，我们看看该类的构造：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-abc4fb7129b9b431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>其中有一个重要的字段 ： sql， 该字段就是存储 SQL 语句的字符串，那么我们的任务就是修改这个字段，从而达到我们自定义 SQL 的目的。</p>
<p>既然知道了怎么使用插件，那么我们就来写一个看看：</p>
<p>首先实现拦截器接口：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8043017a73f395fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们拦截了 StatementHandler 类的 prepare 方法，理论上，我们如果想修改 sql，可以拦截 Executor 和 StatementHandler 都可以。</p>
<p>我们看看 plugin 方法，该方法使用了 mybatis 的 Plugin 的 wrap 方法，基本就是官方默认的写法，没什么可修改的。而 setProperties 方法呢？就是可以在配置文件中配置一些参数，可以在运行的时候获取配置文件的参数。最重要的而是 intercept 方法，该方法步骤如下：</p>
<ol>
<li>获取Invocation 的目标对象，因为我们拦截的是 StatementHandler 对象，那么就可以强转成这个对象，如果你拦截了2个对象，就需要进行判断。</li>
<li>打印该对象的 sql 语句。</li>
<li>使用反射修改sql。</li>
<li>打印修改后的sql 语句。然后运行。</li>
</ol>
<p>我们看看执行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-003e20bb41525544.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从结果中可以看到，我们拦截成功，并且成功执行了 sql 语句，返回了空值。如果不拦截，将返回正常的值。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-80ae776efce585dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>返回了正常结果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2fff49f3ec428f21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>到这里，我们已经知道如何使用mybatis 的插件，虽然这个例子非常的简单，但市面的分页插件基本都是这样设计的。都是通过修改 BoundSql 这个对象来修改Sql，有的可能只修改了这个对象的 Sql 字段，有的直接重新创建一个对象。比如 PageHelper 插件。我们看看该类的关键源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Intercepts(</span></span><br><span class="line"><span class="meta">    &#123;</span></span><br><span class="line"><span class="meta">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span></span><br><span class="line"><span class="meta">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//缓存count查询的ms</span></span><br><span class="line">    <span class="keyword">protected</span> Cache&lt;String, MappedStatement&gt; msCountMap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Dialect dialect;</span><br><span class="line">    <span class="keyword">private</span> String default_dialect_class = <span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Field additionalParametersField;</span><br><span class="line">    <span class="keyword">private</span> String countSuffix = <span class="string">&quot;_COUNT&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args = invocation.getArgs();</span><br><span class="line">            MappedStatement ms = (MappedStatement) args[<span class="number">0</span>];</span><br><span class="line">            Object parameter = args[<span class="number">1</span>];</span><br><span class="line">            RowBounds rowBounds = (RowBounds) args[<span class="number">2</span>];</span><br><span class="line">            ResultHandler resultHandler = (ResultHandler) args[<span class="number">3</span>];</span><br><span class="line">            Executor executor = (Executor) invocation.getTarget();</span><br><span class="line">            CacheKey cacheKey;</span><br><span class="line">            BoundSql boundSql;</span><br><span class="line">            <span class="comment">//由于逻辑关系，只会进入一次</span></span><br><span class="line">            <span class="keyword">if</span>(args.length == <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="comment">//4 个参数时</span></span><br><span class="line">                boundSql = ms.getBoundSql(parameter);</span><br><span class="line">                cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//6 个参数时</span></span><br><span class="line">                cacheKey = (CacheKey) args[<span class="number">4</span>];</span><br><span class="line">                boundSql = (BoundSql) args[<span class="number">5</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            List resultList;</span><br><span class="line">            <span class="comment">//调用方法判断是否需要进行分页，如果不需要，直接返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (!dialect.skip(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                <span class="comment">//反射获取动态参数</span></span><br><span class="line">                String msId = ms.getId();</span><br><span class="line">                Configuration configuration = ms.getConfiguration();</span><br><span class="line">                Map&lt;String, Object&gt; additionalParameters = (Map&lt;String, Object&gt;) additionalParametersField.get(boundSql);</span><br><span class="line">                <span class="comment">//判断是否需要进行 count 查询</span></span><br><span class="line">                <span class="keyword">if</span> (dialect.beforeCount(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                    String countMsId = msId + countSuffix;</span><br><span class="line">                    Long count;</span><br><span class="line">                    <span class="comment">//先判断是否存在手写的 count 查询</span></span><br><span class="line">                    MappedStatement countMs = getExistedMappedStatement(configuration, countMsId);</span><br><span class="line">                    <span class="keyword">if</span>(countMs != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        count = executeManualCount(executor, countMs, parameter, boundSql, resultHandler);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        countMs = msCountMap.get(countMsId);</span><br><span class="line">                        <span class="comment">//自动创建</span></span><br><span class="line">                        <span class="keyword">if</span> (countMs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//根据当前的 ms 创建一个返回值为 Long 类型的 ms</span></span><br><span class="line">                            countMs = MSUtils.newCountMappedStatement(ms, countMsId);</span><br><span class="line">                            msCountMap.put(countMsId, countMs);</span><br><span class="line">                        &#125;</span><br><span class="line">                        count = executeAutoCount(executor, countMs, parameter, boundSql, rowBounds, resultHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//处理查询总数</span></span><br><span class="line">                    <span class="comment">//返回 true 时继续分页查询，false 时直接返回</span></span><br><span class="line">                    <span class="keyword">if</span> (!dialect.afterCount(count, parameter, rowBounds)) &#123;</span><br><span class="line">                        <span class="comment">//当查询总数为 0 时，直接返回空的结果</span></span><br><span class="line">                        <span class="keyword">return</span> dialect.afterPage(<span class="keyword">new</span> ArrayList(), parameter, rowBounds);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断是否需要进行分页查询</span></span><br><span class="line">                <span class="keyword">if</span> (dialect.beforePage(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                    <span class="comment">//生成分页的缓存 key</span></span><br><span class="line">                    CacheKey pageKey = cacheKey;</span><br><span class="line">                    <span class="comment">//处理参数对象</span></span><br><span class="line">                    parameter = dialect.processParameterObject(ms, parameter, boundSql, pageKey);</span><br><span class="line">                    <span class="comment">//调用方言获取分页 sql</span></span><br><span class="line">                    String pageSql = dialect.getPageSql(ms, boundSql, parameter, rowBounds, pageKey);</span><br><span class="line">                    BoundSql pageBoundSql = <span class="keyword">new</span> BoundSql(configuration, pageSql, boundSql.getParameterMappings(), parameter);</span><br><span class="line">                    <span class="comment">//设置动态参数</span></span><br><span class="line">                    <span class="keyword">for</span> (String key : additionalParameters.keySet()) &#123;</span><br><span class="line">                        pageBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//执行分页查询</span></span><br><span class="line">                    resultList = executor.query(ms, parameter, RowBounds.DEFAULT, resultHandler, pageKey, pageBoundSql);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不执行分页的情况下，也不执行内存分页</span></span><br><span class="line">                    resultList = executor.query(ms, parameter, RowBounds.DEFAULT, resultHandler, cacheKey, boundSql);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//rowBounds用参数值，不使用分页插件处理时，仍然支持默认的内存分页</span></span><br><span class="line">                resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dialect.afterPage(resultList, parameter, rowBounds);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            dialect.afterAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该类是国内著名插件 PageHelper 的拦截器。该拦截器拦截了 Executor 的两个重载方法，在 intercept 方法内部，会从 Invocation 对象中取出参数，目标对象，最终会创建一个 pageBoundSql 的 BoundSql 对象，执行 executor 的 query 方法。那么分页参数放在哪里的呢？放在了 PageHelper 的 ThreadLocal 变量中。然后到这个方法中取出该变量。传入 sql 语句中。最后执行。</p>
<p>还有一个注意的地方，就是我们之前的简单 demo 里，只是使用了反射来修改 sql 语句，mybatis 中有一个反射的工具类：MetaObject，他可以快捷的修改某个类的属性，底层是通过反射，而且支持 OGNL 表达式，非常的强大。我们将我们的例子修改一下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-26bec993ace43499.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>查看运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1b85c5c534f2c3dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>使用 mybatis 的工具类 MetaObject ，使用 OGNL 表达式，修改SQL成功。返回了空值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们分析了 mybatis 中常用的插件，知道了他的原理，就是每次创建4大对象的时候，都会将场景封装到对象中，如果有多个，就层层包装。这个是通过动态代理的技术实现的。然后在运行的时候会调用实现了动态代理 InvocationHandler 接口的 Plugin 类的 invoke 方法，而该方法会调用拦截器器的 intercept 方法，并传入封装了目标对象，目标方法，目标方法参数的 Invocation 供使用者修改或加强。</p>
<p>修改 Sql 有多种方式，最终都是修改 StatementHandler 的 BoundSql 中的 sql 字段，无论是直接修改属性，还是重新创建一个  BoundSql 对象。还有一个 mybatis 的 MetaObject 类，该类是 mybatis 提供的一个强大的通过反射修改对象属性的工具类，mybatis 中多次使用该类。</p>
<p>在我们的项目中，通过 mybatis 的拦截器可以实现很多功能，比如分页插件，再比如 分表插件，因为如果一张表中数据过大，会拆分为多个表，这个时候可以通过一些特定的参数，将表的后缀加上去，起到自动分表的效果。而 XML 中的 SQL 是感知不到的。</p>
<p>总之，mybatis 插件可以实现很多功能。但使用他的时候请一定小心，毕竟这修改了 mybatis 底层的逻辑。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之死锁解析</title>
    <url>/2017/12/29/2017/2017-12-29-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在 Java 的并发编程中，有一个问题需要特别注意，那就是死锁，如果发生了死锁，基本就是重启，而重启将会丢失运行中的数据。所以，了解死锁的形成并排查死锁到预防死锁成了一个重要的问题。

<p>我们了解任何一个事情的步骤是：what，how，why，why not。</p>
<h2 id="1-什么是死锁？"><a href="#1-什么是死锁？" class="headerlink" title="1. 什么是死锁？"></a>1. 什么是死锁？</h2><p>我们还是直接写一段代码来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">new</span> DeadLock().resource1();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">new</span> DeadLock().resource2();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resource1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="string">&quot;resource1&quot;</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;获取资源1&quot;</span>);</span><br><span class="line">       <span class="comment">// 等待 1 秒让另一个线程拿到锁</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      resource2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resource2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="string">&quot;resource2&quot;</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;获取资源2&quot;</span>);</span><br><span class="line">      <span class="comment">// 等待 1 秒让另一个线程拿到锁</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      resource1();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们启用了两个线程，分别抢占2个资源，但这两个资源又分别被不同的对象（字符串）锁住了。当第一个线程调用 resource1 方法，进入同步块，拿到锁，并等待 1 秒钟让另一个线程进入 resource2 同步块，当第二个线程进入同步块后，注意：此时， 拿着 resourec1 锁的线程企图拿到 resource2 的锁，但这个时候，拿着 resource2 的线程也想去拿 resource1 的锁。于是就出现了互相僵持的情况，谁也无法拿到对方的锁，整个系统就卡死了。</p>
<p>这种情况就是死锁。</p>
<p>像我们现在写的代码是自己故意造出来的死锁，我们能够发现，那如果是线上环境怎么办，假如我们的系统卡死了，我们怎么知道到底是哪一段代码出现了问题，有没有可能使死锁的问题。也就是如何检测死锁。</p>
<h2 id="2-如何检测死锁？"><a href="#2-如何检测死锁？" class="headerlink" title="2. 如何检测死锁？"></a>2. 如何检测死锁？</h2><p>由于死锁极难通过人工的方式查出来，因此JDK 提供了命令来检测某个java进程中心线程的情况，并排查有没有死锁。上面命令呢？ jps , 用来查看java 程序的进程号，当然在 Linux 中也可以通过别的方式获取，   jstack <code>进程号</code>命令则可以答应对应进程的栈信息，并找到死锁。</p>
<p>我们就刚刚的程序，在 windows 上使用该命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\Users\stateis0&gt;jps</span><br><span class="line"><span class="number">11060</span></span><br><span class="line"><span class="number">2084</span> Launcher</span><br><span class="line"><span class="number">10712</span> RemoteMavenServer</span><br><span class="line"><span class="number">18040</span> Jps</span><br><span class="line"><span class="number">11820</span> DeadLock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\stateis0&gt;jstack <span class="number">11820</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">12</span>-<span class="number">29</span> <span class="number">18</span>:<span class="number">52</span>:<span class="number">38</span></span><br><span class="line"><span class="function">Full thread dump Java <span class="title">HotSpot</span><span class="params">(TM)</span> Client <span class="title">VM</span> <span class="params">(<span class="number">25.131</span>-b11 mixed mode)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;DestroyJavaVM&quot; #11 prio</span>=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x051fe800</span> nid=<span class="number">0x1e0c</span> waiting on condition [<span class="number">0x00000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span> #<span class="number">10</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x18777800</span> nid=<span class="number">0x5664</span> waiting <span class="keyword">for</span> monitor entry [<span class="number">0x18e0f000</span>]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at hello.DeadLock.resource1(DeadLock.java:<span class="number">31</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x07415a50</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.resource2(DeadLock.java:<span class="number">43</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x0742bd18</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.lambda$main$<span class="number">1</span>(DeadLock.java:<span class="number">20</span>)</span><br><span class="line">        at hello.DeadLock$$Lambda$<span class="number">2</span>/<span class="number">4983748.</span>run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span> #<span class="number">9</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x18776c00</span> nid=<span class="number">0x4dc4</span> waiting <span class="keyword">for</span> monitor entry [<span class="number">0x18d7f000</span>]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at hello.DeadLock.resource2(DeadLock.java:<span class="number">41</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x0742bd18</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.resource1(DeadLock.java:<span class="number">33</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x07415a50</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.lambda$main$<span class="number">0</span>(DeadLock.java:<span class="number">11</span>)</span><br><span class="line">        at hello.DeadLock$$Lambda$<span class="number">1</span>/<span class="number">5592464.</span>run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Service Thread&quot;</span> #<span class="number">8</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x186e4c00</span> nid=<span class="number">0x172c</span> runnable [<span class="number">0x00000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;C1 CompilerThread0&quot;</span> #<span class="number">7</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">2</span> tid=<span class="number">0x186af000</span> nid=<span class="number">0x53f8</span> waiting on condition [<span class="number">0x00000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Monitor Ctrl-Break&quot;</span> #<span class="number">6</span> daemon prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x1861e800</span> nid=<span class="number">0x3928</span> runnable [<span class="number">0x18b3f000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="number">116</span>)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">171</span>)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">141</span>)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:<span class="number">284</span>)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:<span class="number">326</span>)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:<span class="number">178</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x07861da0</span>&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.InputStreamReader.read(InputStreamReader.java:<span class="number">184</span>)</span><br><span class="line">        at java.io.BufferedReader.fill(BufferedReader.java:<span class="number">161</span>)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">324</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x07861da0</span>&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">389</span>)</span><br><span class="line">        at com.intellij.rt.execution.application.AppMainV2$<span class="number">1.</span>run(AppMainV2.java:<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Attach Listener&quot;</span> #<span class="number">5</span> daemon prio=<span class="number">5</span> os_prio=<span class="number">2</span> tid=<span class="number">0x179c0800</span> nid=<span class="number">0x40a0</span> waiting on condition [<span class="number">0x00000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Signal Dispatcher&quot;</span> #<span class="number">4</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">2</span> tid=<span class="number">0x17985c00</span> nid=<span class="number">0x5004</span> runnable [<span class="number">0x00000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Finalizer&quot;</span> #<span class="number">3</span> daemon prio=<span class="number">8</span> os_prio=<span class="number">1</span> tid=<span class="number">0x17972400</span> nid=<span class="number">0x41a8</span> in Object.wait() [<span class="number">0x17cff000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;<span class="number">0x0ca1b830</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">143</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x0ca1b830</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">164</span>)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class="number">209</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Reference Handler&quot;</span> #<span class="number">2</span> daemon prio=<span class="number">10</span> os_prio=<span class="number">2</span> tid=<span class="number">0x17960000</span> nid=<span class="number">0x4ef0</span> in Object.wait() [<span class="number">0x17c6f000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;<span class="number">0x0ca1b9d0</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class="number">191</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x0ca1b9d0</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">153</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;VM Thread&quot;</span> os_prio=<span class="number">2</span> tid=<span class="number">0x1795a800</span> nid=<span class="number">0x3f54</span> runnable</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;VM Periodic Task Thread&quot;</span> os_prio=<span class="number">2</span> tid=<span class="number">0x18739400</span> nid=<span class="number">0x4a14</span> waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: <span class="number">229</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到一个死锁</span></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x17978de4</span> (object <span class="number">0x07415a50</span>, a java.lang.String),</span><br><span class="line">  which is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x1797a974</span> (object <span class="number">0x0742bd18</span>, a java.lang.String),</span><br><span class="line">  which is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">        at hello.DeadLock.resource1(DeadLock.java:<span class="number">31</span>)</span><br><span class="line">         <span class="comment">// 等待 0x07415a50 锁</span></span><br><span class="line">        - waiting to lock &lt;<span class="number">0x07415a50</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.resource2(DeadLock.java:<span class="number">43</span>)</span><br><span class="line">        <span class="comment">// 持有 0x0742bd18</span></span><br><span class="line">        - locked &lt;<span class="number">0x0742bd18</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.lambda$main$<span class="number">1</span>(DeadLock.java:<span class="number">20</span>)</span><br><span class="line">        at hello.DeadLock$$Lambda$<span class="number">2</span>/<span class="number">4983748.</span>run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">        at hello.DeadLock.resource2(DeadLock.java:<span class="number">41</span>)</span><br><span class="line">        <span class="comment">// 等待 0x0742bd18 锁</span></span><br><span class="line">        - waiting to lock &lt;<span class="number">0x0742bd18</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.resource1(DeadLock.java:<span class="number">33</span>)</span><br><span class="line">        <span class="comment">// 持有 0x07415a50</span></span><br><span class="line">        - locked &lt;<span class="number">0x07415a50</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.lambda$main$<span class="number">0</span>(DeadLock.java:<span class="number">11</span>)</span><br><span class="line">        at hello.DeadLock$$Lambda$<span class="number">1</span>/<span class="number">5592464.</span>run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发现了一个死锁</span></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\stateis0&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Thread-1  waiting to lock &lt;0x07415a50&gt;      locked &lt;0x0742bd18&gt;<br>Thread-0  waiting to lock &lt;0x0742bd18&gt;       locked &lt;0x07415a50&gt; </p>
</blockquote>
<p>我们首先使用 jps 命令找到 java 进程号，然后使用 jstack <code>进程号</code> 打印进程栈的信息，其中，在最后的部分，jstack 告诉我们，他找到了一个死锁，其中又详细的信息：Thread-1 线程（这里我们没有给线程其合适的名字，如果在线上，给线程起一个合适的名字将更有利于排查）持有 String 类型的编号为 0x07415a50 的锁，等待编号为 0x07415a50 的锁 ， 但这个锁由 Thread-0 持有，于此同时，Thread-0 和 Thread-1 相反。Thread-0 线程持有 0x07415a50 的锁，等待 0x07415a50 的锁。我们的注释里也写上了。</p>
<p>那么发生了死锁，该怎么办呢？最简单的办法就是重启，重启之后，对 jstack 中打印的堆栈信息中的代码进行修改。重新发布。当然还有一些高级策略，比如让进程回滚到死锁前的状态，然后让他们顺序进入同步块。</p>
<h2 id="3-死锁有哪些形成的原因"><a href="#3-死锁有哪些形成的原因" class="headerlink" title="3. 死锁有哪些形成的原因"></a>3. 死锁有哪些形成的原因</h2><p>一般来说，要出现死锁问题需要满足以下条件：</p>
<ol>
<li><p>互斥条件：一个资源每次只能被一个线程使用。</p>
</li>
<li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</p>
</li>
<li><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ol>
<p>死锁是由四个必要条件导致的，所以一般来说，只要破坏这四个必要条件中的一个条件，死锁情况就应该不会发生。</p>
<p>如果想要打破互斥条件，我们需要允许进程同时访问某些资源，这种方法受制于实际场景，不太容易实现条件；</p>
<p>打破不可抢占条件，这样需要允许进程强行从占有者那里夺取某些资源，或者简单一点理解，占有资源的进程不能再申请占有其他资源，必须释放手上的资源之后才能发起申请，这个其实也很难找到适用场景；</p>
<p>进程在运行前申请得到所有的资源，否则该进程不能进入准备执行状态。这个方法看似有点用处，但是它的缺点是可能导致资源利用率和进程并发性降低；</p>
<p>避免出现资源申请环路，即对资源事先分类编号，按号分配。这种方式可以有效提高资源的利用率和系统吞吐量，但是增加了系统开销，增大了进程对资源的占用时间。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>并发编程中的坑很多，尤其死锁，造成的问题基本只能靠重启来解决，如果遇到了数据保存在内存中但没有持久化的话，那么重启将出现很大的问题。因此我们在用锁的时候，一定要小心。避免出现死锁，如果出现了死锁，则可以使用 jstack 命令查看线程是否有死锁。用以排查问题。</p>
<p>总之并发的坑很多，楼主以后将会多多分析。</p>
<p>good luck  ！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-Hashcode-和-Hash-算法</title>
    <url>/2017/12/30/2017/2017-12-30-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-hashcode-%E5%92%8C-hash-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 摘要

<ol>
<li>二进制计算的一些基础知识</li>
<li>为什么使用 hashcode</li>
<li>String 类型的 hashcode 方法</li>
<li>为什么大部分 hashcode 方法使用 31</li>
<li>HashMap 的 hash 算法的实现原理（为什么右移 16 位，为什么要使用 ^ 位异或）</li>
<li>HashMap 为什么使用 &amp; 与运算代替模运算？</li>
<li>HashMap 的容量为什么建议是 2的幂次方？</li>
<li>我们自定义 HashMap 容量最好是多少？</li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个有抱负的 Java 程序员，在经过长期的CRUD 和 HTML 填空之后必须有所思考，因为好奇心是驱动人类进步的动力之一，我们好奇，比如我们常用的 HashMap 到底是如何实现的？我想，说到这里，稍微有点经验的大佬都会说：擦，面试必问好嘛？怎么可能不知道？ </p>
<p>但是，我们真的了解他吗？</p>
<p>我们知道 HashMap 依赖的 hashcode 和 hash 算法到底是怎么实现的嘛？如果大佬说：早他么知道了。那就装不知道，听楼主吹吹牛逼好不啦。。。。</p>
<p>今天楼主不会讲 HashMap 的 put 方法实现和 get 方法实现，楼主要讲的是 HashMap 高度依赖的 hashcode 和 hash 算法，虽然在很多书里面，都说这是数学家应该去研究的事情，但我想，程序员也应该了解他是怎么实现的。为什么这么做？就像娶老婆，你可能做不到创造老婆，但是你得知道你老婆是怎么来的？家是哪的？为什么喜欢你？扯远了，回来，那么今天我们就开始吧！</p>
<h2 id="1-二进制计算的一些基础知识"><a href="#1-二进制计算的一些基础知识" class="headerlink" title="1. 二进制计算的一些基础知识"></a>1. 二进制计算的一些基础知识</h2><p>首先，因为今天的文章会涉及到一些位运算，因此楼主怕大家忘了（其实楼主自己也忘了），因此贴出一些位运算符号的意思，以免看代码的时候懵逼。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;&lt; : 左移运算符，num &lt;&lt; <span class="number">1</span>,相当于num乘以<span class="number">2</span>  低位补<span class="number">0</span></span><br><span class="line">&gt;&gt; : 右移运算符，num &gt;&gt; <span class="number">1</span>,相当于num除以<span class="number">2</span>  高位补<span class="number">0</span></span><br><span class="line">&gt;&gt;&gt; : 无符号右移，忽略符号位，空位都以<span class="number">0</span>补齐</span><br><span class="line"> % : 模运算 取余</span><br><span class="line">^ :   位异或 第一个操作数的的第n位于第二个操作数的第n位相反，那么结果的第n为也为<span class="number">1</span>，否则为<span class="number">0</span></span><br><span class="line"> &amp; : 与运算 第一个操作数的的第n位于第二个操作数的第n位如果都是<span class="number">1</span>，那么结果的第n为也为<span class="number">1</span>，否则为<span class="number">0</span></span><br><span class="line"> | :  或运算 第一个操作数的的第n位于第二个操作数的第n位 只要有一个是<span class="number">1</span>，那么结果的第n为也为<span class="number">1</span>，否则为<span class="number">0</span></span><br><span class="line"> ~ : 非运算 操作数的第n位为<span class="number">1</span>，那么结果的第n位为<span class="number">0</span>，反之，也就是取反运算（一元操作符：只操作一个数）</span><br></pre></td></tr></table></figure>

<p>好了，大概了解一下就好了，因为位运算平时在项目里真的用不上，在我们普通的业务项目里，代码易读性比这点位运算性能要重要的多。但是，在框架中，位运算的必要性就显示出来的了。因为需要服务大量的运算，性能要求也极高，如果性能渣渣，谁还用你？</p>
<h2 id="2-为什么使用-hashcode"><a href="#2-为什么使用-hashcode" class="headerlink" title="2. 为什么使用 hashcode"></a>2. 为什么使用 hashcode</h2><p>那么我们就说说为什么使用 hashcode ，hashCode 存在的第一重要的原因就是在 HashMap(HashSet 其实就是HashMap) 中使用（其实Object 类的 hashCode 方法注释已经说明了 ），我知道，HashMap 之所以速度快，因为他使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）。</p>
<h2 id="3-String-类型的-hashcode-方法"><a href="#3-String-类型的-hashcode-方法" class="headerlink" title="3. String 类型的 hashcode 方法"></a>3. String 类型的 hashcode 方法</h2><p>在 JDK 中，Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。这么做会有说明问题呢？我们用代码看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;Test1, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> Test1(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    String hello = map.get(<span class="keyword">new</span> Test1(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println(hello);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码打印出来的会是什么呢？ 答： null。因为我们没有重写 hashCode 方法，所有，HashMap 内部使用的是该对象的内存地址，那么肯定不一样。我们第一个对象根本就没有存，因此，返回就是 null。这里就可以看出来重写 hashCode 的重要性。</p>
<p>JDK 中，我们经常把 String 类型作为 key，那么 String 类型是如何重写 hashCode 方法的呢？</p>
<p>我们看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码非常简单，就是使用 String 的 char 数组的数字每次乘以 31 再叠加最后返回，因此，每个不同的字符串，返回的 hashCode 肯定不一样。那么为什么使用 31 呢？</p>
<h2 id="4-为什么大部分-hashcode-方法使用-31"><a href="#4-为什么大部分-hashcode-方法使用-31" class="headerlink" title="4. 为什么大部分 hashcode 方法使用 31"></a>4. 为什么大部分 hashcode 方法使用 31</h2><p>如果有使用 eclipse 的同学肯定知道，该工具默认生成的 hashCode 方法实现也和 String 类型差不多。都是使用的 31 ，那么有没有想过：为什么要使用 31 呢？</p>
<p>在名著 《Effective Java》第 42 页就有对 hashCode 为什么采用 31 做了说明：</p>
<blockquote>
<p>之所以使用 31， 是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代替乘法，可以得到更好的性能： 31 * i == (i &lt;&lt; 5） - i， 现代的 VM 可以自动完成这种优化。这个公式可以很简单的推导出来。</p>
</blockquote>
<p>这个问题在 SO 上也有讨论： <a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier%EF%BC%89">https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier%EF%BC%89</a></p>
<p>可以看到，使用 31 最主要的还是为了性能。当然用 63 也可以。但是 63 的溢出风险就更大了。那么15 呢？仔细想想也可以。</p>
<p>在《Effective Java》也说道：编写这种散列函数是个研究课题，最好留给数学家和理论方面的计算机科学家来完成。我们此次最重要的是知道了为什么使用31。</p>
<h2 id="5-HashMap-的-hash-算法的实现原理（为什么右移-16-位，为什么要使用-位异或）"><a href="#5-HashMap-的-hash-算法的实现原理（为什么右移-16-位，为什么要使用-位异或）" class="headerlink" title="5. HashMap 的 hash 算法的实现原理（为什么右移 16 位，为什么要使用 ^ 位异或）"></a>5. HashMap 的 hash 算法的实现原理（为什么右移 16 位，为什么要使用 ^ 位异或）</h2><p>好了，知道了 hashCode 的生成原理了，我们要看看今天的主角，hash 算法。</p>
<p>其实，这个也是数学的范畴，从我们的角度来讲，只要知道这是为了更好的均匀散列表的下标就好了，但是，就是耐不住好奇心啊！ 能多知道一点就是一点，我们来看看 HashMap 的 hash 算法（JDK 8）.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>乍看一下就是简单的异或运算和右移运算，但是为什么要异或呢？为什么要移位呢？而且移位16？</p>
<p>在分析这个问题之前，我们需要先看看另一个事情，什么呢？就是 HashMap 如何根据 hash 值找到数组种的对象，我们看看 get 方法的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 我们需要关注下面这一行</span></span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看代码中注释下方的一行代码：first = tab[(n - 1) &amp; hash])。</p>
<p>使用数组长度减一 与运算 hash 值。这行代码就是为什么要让前面的 hash 方法移位并异或。</p>
<p>我们分析一下：</p>
<p>首先，假设有一种情况，对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000。</p>
<p>如果数组长度是16，也就是 15 与运算这两个数， 你会发现结果都是0。这样的散列结果太让人失望了。很明显不是一个好的散列算法。</p>
<p>但是如果我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免我们上面的情况的发生。</p>
<p>总的来说，使用位移 16 位和 异或 就是防止这种极端情况。但是，该方法在一些极端情况下还是有问题，比如：10000000000000000000000000 和 1000000000100000000000000 这两个数，如果数组长度是16，那么即使右移16位，在异或，hash 值还是会重复。但是为了性能，对这种极端情况，JDK 的作者选择了性能。毕竟这是少数情况，为了这种情况去增加 hash 时间，性价比不高。</p>
<h2 id="6-HashMap-为什么使用-amp-与运算代替模运算？"><a href="#6-HashMap-为什么使用-amp-与运算代替模运算？" class="headerlink" title="6. HashMap 为什么使用 &amp; 与运算代替模运算？"></a>6. HashMap 为什么使用 &amp; 与运算代替模运算？</h2><p>好了，知道了 hash 算法的实现原理还有他的一些取舍，我们再看看刚刚说的那个根据hash计算下标的方法：</p>
<p>tab[(n - 1) &amp; hash]；</p>
<p>其中 n 是数组的长度。其实该算法的结果和模运算的结果是相同的。但是，对于现代的处理器来说，除法和求余数（模运算）是最慢的动作。</p>
<p>上面情况下和模运算相同呢？</p>
<p>a % b == (b-1) &amp; a   ,当b是2的指数时，等式成立。</p>
<p>我们说 &amp; 与运算的定义：与运算 第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0；</p>
<p>当 n 为 16 时， 与运算 101010100101001001101 时，也就是<br>1111 &amp; 101010100101001001000  结果：1000 = 8<br>1111 &amp; 101000101101001001001   结果：1001 = 9<br>1111 &amp; 101010101101101001010   结果： 1010 = 10<br>1111 &amp; 101100100111001101100   结果：  1100 = 12</p>
<p>可以看到，当 n 为 2 的幂次方的时候，减一之后就会得到 1111* 的数字，这个数字正好可以掩码。并且得到的结果取决于 hash 值。因为 hash 值是1，那么最终的结果也是1 ，hash 值是0，最终的结果也是0。</p>
<h2 id="7-HashMap-的容量为什么建议是-2的幂次方？"><a href="#7-HashMap-的容量为什么建议是-2的幂次方？" class="headerlink" title="7. HashMap 的容量为什么建议是 2的幂次方？"></a>7. HashMap 的容量为什么建议是 2的幂次方？</h2><p>到这里，我们提了一个关键的问题： HashMap 的容量为什么建议是 2的幂次方？正好可以和上面的话题接上。楼主就是这么设计的。</p>
<p>为什么要 2 的幂次方呢？</p>
<p>我们说，hash 算法的目的是为了让hash值均匀的分布在桶中（数组），那么，如何做到呢？试想一下，如果不使用 2 的幂次方作为数组的长度会怎么样？</p>
<p>假设我们的数组长度是10，还是上面的公式：<br>1010 &amp; 101010100101001001000  结果：1000 = 8<br>1010 &amp; 101000101101001001001   结果：1000 = 8<br>1010 &amp; 101010101101101001010   结果： 1010 = 10<br>1010 &amp; 101100100111001101100   结果：  1000 =  8</p>
<p>看到结果我们惊呆了，这种散列结果，会导致这些不同的key值全部进入到相同的插槽中，形成链表，性能急剧下降。</p>
<p>所以说，我们一定要保证 &amp; 中的二进制位全为 1，才能最大限度的利用 hash 值，并更好的散列，只有全是1 ，才能有更多的散列结果。如果是 1010，有的散列结果是永远都不会出现的，比如 0111，0101，1111，1110…….，只要 &amp; 之前的数有 0， 对应的 1 肯定就不会出现（因为只有都是1才会为1）。大大限制了散列的范围。</p>
<h2 id="8-我们自定义-HashMap-容量最好是多少？"><a href="#8-我们自定义-HashMap-容量最好是多少？" class="headerlink" title="8. 我们自定义 HashMap 容量最好是多少？"></a>8. 我们自定义 HashMap 容量最好是多少？</h2><p>那我们如何自定义呢？自从有了阿里的规约插件，每次楼主都要初始化容量，如果我们预计我们的散列表中有2个数据，那么我就初始化容量为2嘛？</p>
<p>绝对不行，如果大家看过源码就会发现，如果Map中已有数据的容量达到了初始容量的 75%，那么散列表就会扩容，而扩容将会重新将所有的数据重新散列，性能损失严重，所以，我们可以必须要大于我们预计数据量的 1.34 倍，如果是2个数据的话，就需要初始化 2.68 个容量。当然这是开玩笑的，2.68 不可以，3 可不可以呢？肯定也是不可以的，我前面说了，如果不是2的幂次方，散列结果将会大大下降。导致出现大量链表。那么我可以将初始化容量设置为4。 当然了，如果你预计大概会插入 12 条数据的话，那么初始容量为16简直是完美，一点不浪费，而且也不会扩容。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，分析完了 hashCode 和 hash 算法，让我们对 HashMap 又有了全新的认识。当然，HashMap 中还有很多有趣的东西值得挖掘，楼主会继续写下去。争取将 HashMap 的衣服扒光。</p>
<p>总的来说，通过今天的分析，对我们今后使用 HashMap 有了更多的把握，也能够排查一些问题，比如链表数很多，肯定是数组初始化长度不对，如果某个map很大，注意，肯定是事先没有定义好初始化长度，假设，某个Map存储了10000个数据，那么他会扩容到 20000，实际上，根本不用 20000，只需要 10000* 1.34= 13400 个，然后向上找到一个2 的幂次方，也就是 16384 初始容量足够。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-Wait-Notify-方法剖析</title>
    <url>/2018/01/01/2018/2018-01-01-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-wait-notify-%E6%96%B9%E6%B3%95%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>2018 元旦快乐。</p>
<p>摘要：</p>
<ol>
<li>notify wait 如何使用？</li>
<li>为什么必须在同步块中？</li>
<li>使用 notify wait 实现一个简单的生产者消费者模型</li>
<li>底层实现原理 </li>
</ol>
<h2 id="1-notify-wait-如何使用？"><a href="#1-notify-wait-如何使用？" class="headerlink" title="1. notify wait 如何使用？"></a>1. notify wait 如何使用？</h2><p>今天我们要学习或者说分析的是 Object 类中的 wait notify 这两个方法，其实说是两个方法，这两个方法包括他们的重载方法一共有5个，而Object 类中一共才 12 个方法，可见这2个方法的重要性。我们先看看 JDK 中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是这五个方法。其中有3个方法是 native 的，也就是由虚拟机本地的c代码执行的。有2个 wait 重载方法最终还是调用了 wait（long） 方法。</p>
<p>首先还是 know how。来一个最简单的例子，看看如何使用这两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 A 等待拿锁&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A 拿到锁了&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 A 开始等待并放弃锁&quot;</span>);</span><br><span class="line">            lock.wait();</span><br><span class="line">            System.out.println(<span class="string">&quot;被通知可以继续执行 则 继续运行至结束&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 B 等待锁&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;线程 B 拿到锁了&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          lock.notify();</span><br><span class="line">          System.out.println(<span class="string">&quot;线程 B 随机通知 Lock 对象的某个线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;线程 B&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>线程 A 等待拿锁<br>线程 B 等待锁<br>线程 A 拿到锁了<br>线程 A 开始等待并放弃锁<br>线程 B 拿到锁了<br>线程 B 随机通知 Lock 对象的某个线程<br>被通知可以继续执行 则 继续运行至结束</p>
</blockquote>
<p>在上面的代码中，线程 A 和 B 都会抢这个 lock 对象的锁，A 的运气比较好（也可能使 B 拿到锁），他先拿到了锁，然后调用了 wait 方法，放弃了锁，并挂起了自己，这个时候等待锁的 B 就拿到了锁，然后通知了A，但是请注意，通知完毕之后，B 线程并没有执行完同步代码块中的代码，因此，A 还是拿不到锁的，因此无法运行，等到B线程执行完毕，出了同步块，这个时候 A 线程才被激活得以继续执行。</p>
<p>使用 wait 方法和 notify 方法可以使 2 个无关的线程进行通信。也就是面试题中常提到的线程之间如何通信。</p>
<p>如果没有 wait 方法和 noitfy 方法，我们如何让两个线程通信呢？简单的办法就是让某个线程循环去检查某个标记变量，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> （value != flag） &#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">doSomeing();</span><br></pre></td></tr></table></figure>
<p>上面的这段代码在条件不满足使就睡眠一段时间，这样做到目的是防止过快的”无效尝试“，这种方式看似能够实现所需的功能，但是却存在如下问题：</p>
<ol>
<li>难以确保及时性。因为等待的1000时间会导致时间差。</li>
<li>难以降低开销，如果确保了及时性，休眠时间缩短，将大大消耗CPU。</li>
</ol>
<p>但是有了Java 自带的 wait 方法 和 notify 方法，一切迎刃而解。官方说法是等待/通知机制。一个线程在等待，另一个线程可以通知这个线程，实现了线程之间的通信。</p>
<h2 id="2-为什么必须在同步块中？"><a href="#2-为什么必须在同步块中？" class="headerlink" title="2. 为什么必须在同步块中？"></a>2. 为什么必须在同步块中？</h2><p>注意，这两个方法的使用必须是在 synchroized 同步块中，并且在当前对象的同步块中，如果在 A 对象的方法中调用 B 对象的 wait 或者 notify 方法，虚拟机会抛出 IllegalMonitorStateException，非法的监视器异常，因为你这个线程持有的监视器和你调用的监视器的不是一个对象。</p>
<p>那么为什么这两个方法一定要在同步块中呢？</p>
<p>这里要说一个专业名词：竞态条件。什么是竞太条件呢？</p>
<blockquote>
<p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p>
</blockquote>
<p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，这是因为线程间会随机竞争。</p>
<p>假设有2个线程，分别是生产者和消费者，他们有各自的任务。</p>
<p>1.1生产者检查条件（如缓存满了）-&gt; 1.2生产者必须等待<br>2.1消费者消费了一个单位的缓存 -&gt; 2.2重新设置了条件（如缓存没满） -&gt; 2.3调用notifyAll()唤醒生产者</p>
<p>我们希望的顺序是： 1.1-&gt;1.2-&gt;2.1-&gt;2.2-&gt;2.3<br>但是由于CPU执行是随机的，可能会导致 2.3 先执行，1.2 后执行，这样就会导致生产者永远也醒不过来了！</p>
<p>所以我们必须对流程进行管理，也就是同步，通过在同步块中并结合 wait 和 notify 方法，我们可以手动对线程的执行顺序进行调整。</p>
<h2 id="3-使用-notify-wait-实现一个简单的生产者消费者模型"><a href="#3-使用-notify-wait-实现一个简单的生产者消费者模型" class="headerlink" title="3. 使用 notify wait 实现一个简单的生产者消费者模型"></a>3. 使用 notify wait 实现一个简单的生产者消费者模型</h2><p>虽然很多书中都不建议我们直接使用 notify 和 wait 方法进行并发编程，但仍然需要我们重点掌握。楼主写了一个简单的生产者消费者例子：</p>
<h4 id="简单的缓存类："><a href="#简单的缓存类：" class="headerlink" title="简单的缓存类："></a>简单的缓存类：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">final</span> List&lt;String&gt; list;</span><br><span class="line">  <span class="keyword">boolean</span> isFull = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">    <span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFull) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;putThread 暂停了，让出了锁&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">        System.out.println(<span class="string">&quot;putThread 被唤醒了，拿到了锁&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      list.add(value);</span><br><span class="line">      System.out.println(<span class="string">&quot;putThread 放入了&quot;</span> + value);</span><br><span class="line">      <span class="keyword">if</span> (list.size() &gt;= num) &#123;</span><br><span class="line">        isFull = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isEmpty) &#123;</span><br><span class="line">        isEmpty = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;putThread 通知 getThread&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isEmpty) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;getThread 暂停了，并让出了锁&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">        System.err.println(<span class="string">&quot;getThread 被唤醒了，拿到了锁&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String value = list.get(index);</span><br><span class="line">      System.err.println(<span class="string">&quot;getThread 获取到了&quot;</span> + value);</span><br><span class="line">      list.remove(index);</span><br><span class="line"></span><br><span class="line">      Random random = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">int</span> randomInt = random.nextInt(<span class="number">5</span>);</span><br><span class="line">      <span class="keyword">if</span> (randomInt == <span class="number">1</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;随机数等于1， 清空集合&quot;</span>);</span><br><span class="line">        list.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (getSize() &lt; num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getSize() == <span class="number">0</span>) &#123;</span><br><span class="line">          isEmpty = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFull) &#123;</span><br><span class="line">          isFull = <span class="keyword">false</span>;</span><br><span class="line">          System.err.println(<span class="string">&quot;getThread 通知 putThread 可以添加了&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">10</span>);</span><br><span class="line">          <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">#### 生产者线程：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Queue queue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      queue.put(i + <span class="string">&quot;号&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="消费者线程："><a href="#消费者线程：" class="headerlink" title="消费者线程："></a>消费者线程：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Queue queue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GetThread</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queue.getSize(); i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String value = queue.get(i);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大家有兴趣可以跑跑看，能够加深这两个方法的理解，实际上，JDK 内部的阻塞队列也是类似这种实现，但是，不是用的 synchronized ，而是使用的重入锁。</p>
<p>基本上经典的生产者消费者模式的有着如下规则：</p>
<p>等待方遵循如下规则：</p>
<ol>
<li>获取对象的锁。</li>
<li>如果条件不满足，那么调用对象的 wait 方法，被通知后仍要检查条件。</li>
<li>条件满足则执行相应的逻辑。</li>
</ol>
<p>对应的伪代码入下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">synchroize( 对象 )&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">      对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知方遵循如下规则：</p>
<ol>
<li>获得对象的锁。</li>
<li>改变条件。</li>
<li>通知所有等待在对象上的线程。</li>
</ol>
<p>对应的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（对象）&#123;</span><br><span class="line">  改变条件</span><br><span class="line">  对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-底层实现原理"><a href="#4-底层实现原理" class="headerlink" title="4. 底层实现原理"></a>4. 底层实现原理</h2><p>知道了如何使用，就得知道他的原理到底是什么？</p>
<p>首先我们看，使用这两个方法的顺序一般是什么？</p>
<ol>
<li>使用 wait ，notify 和 notifyAll 时需要先对调用对象加锁。</li>
<li>调用 wait 方法后，线程状态有 Running 变为 Waiting，并将当前线程放置到对象的 <strong>等待队列</strong>。</li>
<li>notify 或者 notifyAll 方法调用后， 等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回。</li>
<li>notify 方法将等待队列的一个等待线程从等待队列种移到<strong>同步队列</strong>中，而 notifyAll 方法则是将<strong>等待队列</strong>种所有的线程全部移到<strong>同步队列</strong>，被移动的线程状态由 Waiting 变为 Blocked。</li>
<li>从 wait 方法返回的前提是获得了调用对象的锁。</li>
</ol>
<p>从上述细节可以看到，等待/通知机制依托于同步机制，其目的就是确保等待线程从 wait 方法返回后能够感知到通知线程对变量做出的修改。</p>
<p>该图描述了上面的步骤：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c7c4441dc7ea979b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>WaitThread 获得了对象的锁，调用对象的 wait 方法，放弃了锁，进入的等待队列，然后 NotifyThread 拿到了对象的锁，然后调用对象的 notify 方法，将 WatiThread 移动到同步队列中，最后，NotifyThread 执行完毕，释放锁， WaitThread 再次获得锁并从 wait 方法返回继续执行。</p>
<p>到这里，关于应用层面的 wait 和 notify 基本就差不多了，后面的是关于虚拟机层面的抛砖引玉，涉及到 Java 的内置锁实现，synchronized 关键字底层实现，JVM 源码。算是本文的扩展吧。</p>
<p>注意：我们看到图中出现了 Monitor 这个词，也就是监视器，实际上，在 JDK 的注释中，也有 The current thread must own this object’s monitor 这句话，当前线程必须拥有该对象的监视器。</p>
<p>如果我们编译这段含有 synchronized 关键字的代码，就会发现有一段代码被 monitorenter 指令和 monitorexit 指令括住了，这就是 synchronized 在编译期间做的事情，那么，在字节码被执行的时侯，该指令对应的 c 代码将会被执行。这里，我们必须打住，这里已经开始涉及到 synchronized 的相关原理了，本篇文章不会讨论这个。</p>
<p>wait noitfy 的答案都在 Java HotSpot 虚拟机的 C 代码中。但 R 大告诉我们不要轻易阅读虚拟机源码，众多细节可能会掩盖抽象，导致学习效率不高。如果同学们有兴趣，有大神写了3篇文章专门从 HotSpot 中解析源码，地址：</p>
<p><a href="http://blog.csdn.net/boling_cavalry/article/details/77793224">Java的wait()、notify()学习三部曲之一：JVM源码分析</a>，<br> <a href="http://blog.csdn.net/boling_cavalry/article/details/77897108">Java的wait()、notify()学习三部曲之二：修改JVM源码看参数</a>，<br><a href="http://blog.csdn.net/boling_cavalry/article/details/77995069">Java的wait()、notify()学习三部曲之三：修改JVM源码控制抢锁顺序</a>，<br>还有狼哥的 <a href="https://www.jianshu.com/p/f4454164c017">JVM源码分析之Object.wait/notify实现</a>.</p>
<p>上面四篇文章都从 JVM 的源码层面解析了 wait ，notify 的实现原理，非常清楚。</p>
<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><ol>
<li>wait(long) 方法，该方法参数是毫秒，也就是说，如果线程等待了指定的毫秒数，就会自动返回该线程。</li>
<li>wait（long, int）方法，该方法增加了纳秒级别的设置，算法是，前面的毫秒加上后面的纳秒，注意，是直接加一毫秒。</li>
<li>notify 方法调用后，如果等待的线程很多，JDK 源码中说将会随机找一个，但是 JVM 的源码中实际上是找第一个。</li>
<li>notifyAll 和 notify 不会立即生效，必须等到调用方执行完同步代码块，放弃锁之后才起作用。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，关于 wait noitfy 的使用和基本原理就介绍到这里，不知道大家发现没有，并发和虚拟机高度相关。因此，可以说，学习并发的过程就是学习虚拟机的过程。而阅读虚拟机里的 openjdk 代码让人头大，但不管怎么样，丑媳妇迟早见公婆，openjdk 代码是一定要看的，加油！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-Thread-类过期方法和常用方法</title>
    <url>/2018/01/02/2018/2018-01-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Thread-%E7%B1%BB%E8%BF%87%E6%9C%9F%E6%96%B9%E6%B3%95%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在 Java 刚诞生时，Thread 类就已经有了很多方法，但这些方法由于一些原因（有一些明显的bug或者设计不合理）有些已经废弃了，但是他们的方法名却是非常的好，真的是浪费。我们在进行并发必编程的时候一定要注意这些。

<ol>
<li>过期方法1—– stop 方法</li>
<li>过期方法2——suspend 方法和 resume 方法</li>
<li>常用方法1——线程中断方法 interrupt，isInterrupted，static interrupted </li>
<li>常用方法2——等待线程结束 join 方法</li>
<li>常用方法3——线程让出时间片 yield 方法</li>
</ol>
<h2 id="1-过期方法1—–-stop-方法"><a href="#1-过期方法1—–-stop-方法" class="headerlink" title="1. 过期方法1—– stop 方法"></a>1. 过期方法1—– stop 方法</h2><p>JDK 源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-cd0cc34e4bbf0260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法被定义了 @Deprecated 注解，并在注释中说明了为什么废弃：</p>
<blockquote>
<p>该方法具有固有的不安全性。用 Thread.stop 来终止线程将释放它已经锁定的所有监视器（作为沿堆栈向上传播的未检查 ThreadDeath 异常的一个自然后果）。如果以前受这些监视器保护的任何对象都处于一种不一致的状态，则损坏的对象将对其他线程可见，这有可能导致任意的行为。stop 的许多使用都应由只修改某些变量以指示目标线程应该停止运行的代码来取代。目标线程应定期检查该变量，并且如果该变量指示它要停止运行，则从其运行方法依次返回。如果目标线程等待很长时间（例如基于一个条件变量），则应使用 interrupt 方法来中断该等待。</p>
</blockquote>
<p>很官方对不对？还是用楼主的话来解释一下吧。最重要的原因就i是 stop 太粗鲁了，强行把执行到一半的线程终止，引起数据不一致。比如有些数据处理到一半，该方法就强行停止线程，导致数据不一致。</p>
<p>可使用一个条件判断来代替此功能，比如设置一个变量，如果这个变量是ture 则跳出循环，结束线程的执行。反正不要使用该方法就对了。</p>
<h2 id="2-过期方法2——suspend-方法和-resume-方法"><a href="#2-过期方法2——suspend-方法和-resume-方法" class="headerlink" title="2. 过期方法2——suspend 方法和 resume 方法"></a>2. 过期方法2——suspend 方法和 resume 方法</h2><p>JDK 源码：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-f427201ddec26aea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="suspend 方法 "></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f9a6cba2c26e9331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="resume 方法 "></p>
<p>这两个方法都被标注为过期，楼主解释一下为什么不能使用。</p>
<p>suspend 方法的作用是挂起方法，而 resume 方法的作用是继续执行，可以说这两个方法是对应的，先挂起，然后继续执行。这两个动作是相反的。但是为什么不建议使用呢？原因就似乎 suspend 方法在导致线程暂停的同时，并不会释放任何锁资源。此时，其他任何线程想要访问被他暂用的锁时，都会被牵连，导致无法正常运行。知道对应的 resume 方法被调用，被挂起的线程才能继续。但是，请注意，这里严格要求 resume 方法在 suspend 方法后面执行，如果 resume 方法意外的在suspend 方法之前执行了，就会导致死锁，该线程拥有不会恢复。</p>
<p>最坑的是，当产生死锁的时候，你肯定会使用 jps 命令和 jstack 命令去查看死锁。但是你会发现你根本找不到，因为这个线程的状态是 Rannable。你根本无法判断是哪个线程被挂起了，所以，该方法一定要废弃。</p>
<p>比如楼主写了一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadSuspend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;in &quot;</span> + getName());</span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        Thread.currentThread().suspend();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 此时 t1 已经暂停</span></span><br><span class="line">    t2.start();</span><br><span class="line">    <span class="comment">// t1 恢复</span></span><br><span class="line">    t1.resume();</span><br><span class="line">    <span class="comment">// t2 这时恢复，但是 t2在恢复之后进入了暂停，导致死锁。</span></span><br><span class="line">    <span class="comment">// 除非使用 sleep 让 t2 先暂停就可以。</span></span><br><span class="line"><span class="comment">//    Thread.sleep(100);</span></span><br><span class="line">    t2.resume();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法会发生死锁。然而我们在命令行中使用 jstack 命令查看时，会发现该线程状态是  Rannable。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-393876f58c61921f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="死锁 状态 却是 Rannable "></p>
<p>因此在以后的并发编程一定不要使用该方法。</p>
<h2 id="3-常用方法1——线程中断方法-interrupt，isInterrupted，static-interrupted"><a href="#3-常用方法1——线程中断方法-interrupt，isInterrupted，static-interrupted" class="headerlink" title="3. 常用方法1——线程中断方法 interrupt，isInterrupted，static interrupted"></a>3. 常用方法1——线程中断方法 interrupt，isInterrupted，static interrupted</h2><p>关于线程中断还有3个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>public void interrupt()  作用：中断线程，也就是设置中断标记，注意，是设置标记，不会中断。<br>public boolean isInterrupted() 作用：判断线程是否中断<br>static boolean Thread interrupted 作用：判断是否中断，并清除当前中断状态。</p>
<p>我们解释解释这三个方法： 在 java 中，线程中断是一种重要的线程协作机制。可以用来代替 stop方法，严格来讲， 线程中断并不会使线程立即退出，  而是给线程发一个通知，告知目标线程，有人希望你退出了。而什么时候退出，完全由线程自己自行决定，避免了stop 的问题。但是该方法只是设置标记，所以需要自己判断状态然后跳出循环之类的结束线程运行。</p>
<p>那么我们怎么使用这三个方法进行并发编程呢？下面楼主写了一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  t1.start();</span><br><span class="line">  Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="comment">// 不会起任何作用，所以需要判断他的中断位状态</span></span><br><span class="line">  t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该测试方法在死循环了一个线程，然后启动 interrupt 方法，根本不会起任何作用，所以各位不要这样使用该方法。那么如何使用呢？示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  t1.start();</span><br><span class="line">  Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">  t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 isInterrupted 方法进行判断，如果返回 ture ，表示有中断标记，那么则 break 循环。结束运行。</p>
<p>还有一个需要注意的地方就是，如果线程在 sleep 或者 wait 状态，如果你调用  interrput 方法就会导致InterruptedException 异常，但是，抛出异常时会清除中断标记，因此，线程也就中断不了了，如果你想在异常后仍然中断线程，那么你需要在 catch 中 继续设置状态，也就是调用 interrupt 方法。我们来个例子看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.err.println(<span class="string">&quot;Interrupt When Sleep&quot;</span>);</span><br><span class="line">          <span class="comment">// 由于在 sleep 之间中断线程导致抛出异常，此时，他会清楚中断位，所以需要在这里重新设置中断位，下次循环则会直接判断中断标记，从而break。</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">          <span class="comment">// 该方法会清除中断状态，导致上面的一行代码失效</span></span><br><span class="line"><span class="comment">//          boolean isInterrupt = Thread.interrupted();</span></span><br><span class="line"><span class="comment">//          System.out.println(isInterrupt);</span></span><br><span class="line">        &#125;</span><br><span class="line">        Thread.yield();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>interrupt<br>Interrupt When Sleep</p>
</blockquote>
<p>该测试方法中，在线程中调用了 sleep 方法，并在 main 线程中调用了 interrupt 方法，因此导致该线程异常，但是，如果我们不在 catch 中重新设置中断位，该线程永远不会停止。这个时需要注意的。</p>
<p>还有一个静态方法，Thread.interrupted()，其实我们上面的例子也测试了，该方法会返回线程是否中断，并且会清除状态，使用的时候需要注意。</p>
<h2 id="4-常用方法2——等待线程结束-join-方法"><a href="#4-常用方法2——等待线程结束-join-方法" class="headerlink" title="4. 常用方法2——等待线程结束 join 方法"></a>4. 常用方法2——等待线程结束 join 方法</h2><p>JDK 源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4accfeb4d9b49b81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="join 方法 "></p>
<p>该方法注释写到：等待该线程直到死。。。。还真是痴情啊。说正经的的。该方法实际上时等待线程结束。说明意思呢？</p>
<p>假如你有2个线程，A线程在算 1+1 ，而B线程需要 A线程算出的结果，那么B线程就需要等待A线程，那么这时候，B线程就需要调用 A线程的 join 方法，调用该方法后， B线程就会被挂起，直到A线程死亡，B线程才会被唤醒。实际上，如果看 join 的源码，会发现内部调用了A线程的 wait 方法。也就是说，B 线程 wait 在了 A 线程上。A 线程执行完毕会调用 notifyAll 方法，唤醒B线程。</p>
<p>我们写个demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    AddThread addThread = <span class="keyword">new</span> AddThread();</span><br><span class="line">    addThread.start();</span><br><span class="line">    <span class="comment">// 主函数等待 addThread</span></span><br><span class="line">    <span class="comment">// join 的本质是调用了 wait方法，让调用线程 wait 在当前线程对象实例上。也就是main线程 wait 在 addThread 线程实例上。</span></span><br><span class="line">    <span class="comment">// 当 addThread 执行结束后，会调用 notifyAll 方法，注意，不要再程序中调用线程的 wait 或者 notify 方法，</span></span><br><span class="line">    <span class="comment">// 可能会影响系统API 的工作。</span></span><br><span class="line">    addThread.join();<span class="comment">// 重载方法 join（long） 如果达到给定的毫秒数，则不等了</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该测试方法运行了一个对变量 i 自增运算的线程，并且主线程在等待  addThread 线程执行完才打印 i 的结果。如果不使用 join ， 那么 ，打印 i 的值永远会小于10000。</p>
<p>而 join 的内部实现，我们刚刚说了，使用 wait 方法，我们看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法时同步的，同时内部调用了自身的 wait 方法。注意：我们最好不要调用线程的 wait 方法和 notify 方法，可能会导致系统 api 出现问题。</p>
<h2 id="5-常用方法3——线程让出时间片-yield-方法"><a href="#5-常用方法3——线程让出时间片-yield-方法" class="headerlink" title="5. 常用方法3——线程让出时间片 yield 方法"></a>5. 常用方法3——线程让出时间片 yield 方法</h2><p>这个方法就比较简单了。这是一个静态方法，yield 谦让出CPU时间片；</p>
<p> yieid 会让出时间片，但是是随机的。如果你觉得一个线程不是很重要，那就可以适当的调用该方法，给予其他线程更多的机会。</p>
<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><h5 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep 方法"></a>sleep 方法</h5><p>虽然用的很多，但有必要说一下，该方法不会释放当前线程的锁。面试中常有该问题，wait 方法和 sleep 方法有什么不同，<strong>wait 方法会释放锁，sleep 方法不会释放锁。</strong></p>
<h5 id="holdsLock-方法："><a href="#holdsLock-方法：" class="headerlink" title="holdsLock 方法："></a>holdsLock 方法：</h5><p>仅当当前线程在指定的对象上保持监视器锁时，才返回  true。该方法旨在使程序能够断言当前线程已经保持一个指定的锁。<br><strong>参数：</strong><br>obj - 用于测试锁所属权的对象<br><strong>返回：</strong><br>如果当前线程在指定的对象上保持监视器锁，则返回 true。</p>
<h5 id="setContextClassLoader-方法："><a href="#setContextClassLoader-方法：" class="headerlink" title="setContextClassLoader 方法："></a>setContextClassLoader 方法：</h5><p>设置该线程的上下文 ClassLoader。上下文 ClassLoader 可以在创建线程设置，并允许创建者在加载类和资源时向该线程中运行的代码提供适当的类加载器。<br>首先，如果有安全管理器，则通过 RuntimePermission(“setContextClassLoader”) 权限调用其 checkPermission`方法，查看是否可以设置上下文 ClassLoader。该方法在违反 JDK 默认的类加载模型时能起到很大作用。</p>
<p><strong>参数：</strong><br>该线程的上下文 ClassLoader</p>
<p><strong>抛出：</strong><br>SecurityException - 如果当前线程无法设置上下文 ClassLoader。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之Java内存模型+volatile关键字+HappenBefore规则</title>
    <url>/2018/01/03/2018/2018-01-03-bfbcjavancmx/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       楼主这个标题其实有一种作死的味道，为什么呢，这三个东西其实可以分开为三篇文章来写，但是，楼主认为这三个东西又都是高度相关的，应当在一个知识点中。在一次学习中去理解这些东西。才能更好的理解 Java 内存模型和 volatile 关键字还有 HB 原则。

<p>楼主今天就尝试着在一篇文章中讲述这三个问题，最后总结。</p>
<ol>
<li>讲并发知识前必须复习的硬件知识。</li>
<li>Java 内存模型到底是什么玩意？</li>
<li>Java 内存模型定义了哪些东西？</li>
<li>Java内存模型引出的 Happen-Before 原则是什么？</li>
<li>Happen-Before 引出的 volatile 又是什么？</li>
<li>总结这三者。</li>
</ol>
<h2 id="1-讲并发知识前必须复习的硬件知识。"><a href="#1-讲并发知识前必须复习的硬件知识。" class="headerlink" title="1. 讲并发知识前必须复习的硬件知识。"></a>1. 讲并发知识前必须复习的硬件知识。</h2><p>首先，因为我们需要了解 Java 虚拟机的并发，而物理硬件的并发和虚拟机的并发很相似，而且虚拟机的并发很多看着奇怪的设计都是因为物理机的设计导致的。</p>
<p>什么是并发？多个CPU同时执行。但请注意：只有CPU是不行的，CPU 只能计算数据，那么数据从哪里来？</p>
<p>答案：内存。 数据从内存中来。需要读取数据，存储计算结果。有的同学可能会说，不是有寄存器和多级缓存吗？但是那是静态随机访问内存（Static Random Access Memory），太贵了，SRAM 在设计上使用的晶体管数量较多，价格较高，且不易做成大容量，只能用很小的部分集成的CPU中成为CPU的高速缓存。而正常使用的都是都是动态随机访问内存（Dynamic Random Access Memory）。intel 的 CPU 外频 需要从北桥经过访问内存，而AMD 的没有设计北桥，他与 Intel 不同的地方在于，内存是直接与CPU通信而不通过北桥，也就是将内存控制组件集成到CPU中。理论上这样可以加速CPU和内存的传输速度。</p>
<p>好了，不管哪一家的CPU，都需要从内存中读取数据，并且自己都有高速缓存或者说寄存器。缓存作什么用呢？由于CPU的速度很快，内存根本跟不上CPU，因此，需要在内存和CPU直接加一层高速缓存让他们缓冲CPU的数据：将运算需要使用到的数据复制到缓存中，让运算能够快速执行，当运算结束后再从缓存同步到内存之中。这样处理器就无需等待缓慢的内存读写了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7278ade00fabdc15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CPU 和缓存"></p>
<p>但是这样引出了另一个问题：缓存一致性（Cache Coherence）。什么意思呢？</p>
<p>在多处理器中，每个处理器都有自己的高速缓存，而他们又共享同一个主内存（Main Memory），当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致。如果真的发生这种情况，拿同步到主内存时以谁的缓存数据为准呢？</p>
<p>在早期的CPU当中，可以通过在总线上加 LOCK# 锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。</p>
<p>现在的 CPU 为了解决一致性问题，需要各个CPU访问（读或者写）缓存的时候遵循一些协议：MSI，MESI，MOSI，Synapse，Firefly，Dragon Protocol，这些都是缓存一致性协议。</p>
<p>那么，这个时候需要说一个名词：内存模型。</p>
<p>什么是内存模型呢？</p>
<blockquote>
<p>内存模型可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的CPU 有不同的内存模型，而 Java 虚拟机屏蔽了不同CPU内存模型的差异，这就是Java 的内存模型。</p>
</blockquote>
<p>那么 Java 的内存模型的结构是什么样子的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a5c9a6acadf4eef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java 内存模型（Java Memory Model）"></p>
<p>好了，关于为什么会有内存模型这件事，我们已经说的差不多了，总体来说就是因为多个CPU的多级缓存访问同一个内存条可能会导致数据不一致。所以需要一个协议，让这些处理器在访问内存的时候遵守这些协议保证数据的一致性。</p>
<h5 id="还有一个问题。CPU-的流水线执行和乱序执行"><a href="#还有一个问题。CPU-的流水线执行和乱序执行" class="headerlink" title="还有一个问题。CPU 的流水线执行和乱序执行"></a>还有一个问题。CPU 的流水线执行和乱序执行</h5><p>我们假设我们现在有一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码我们能不能不顺序动一下并且结果不变呢？可以，第一行和第二行调换没有任何问题。</p>
<p>实际上，CPU 有时候为了优化性能，也会对代码顺序进行调换（在保证结果的前提下），专业术语叫重排序。为什么重排序会优化性能呢？</p>
<p>这个就有点复杂了，我们慢慢说。</p>
<p>我们知道，一条指令的执行可以分为很多步骤的，简单的说，可以分为以下几步：</p>
<ol>
<li>取指 IF</li>
<li>译码和取寄存器操作数 ID</li>
<li>执行或者有效地址计算 EX</li>
<li>存储器返回 MEM</li>
<li>写回 WB</li>
</ol>
<p>我们的汇编指令也不是一步就可以执行完毕的，在CPU 中实际工作时，他还需要分为多个步骤依次执行，每个步骤涉及到的硬件也可能不同，比如，取指时会用到 PC 寄存器和存储器，译码时会用到指令寄存器组，执行时会使用 ALU，写回时需要寄存器组。</p>
<p>也就是说，由于每一个步骤都可能使用不同的硬件完成，因此，CPU 工程师们就发明了流水线技术来执行指令。什么意思呢？</p>
<p>假如你需要洗车，那么洗车店会执行 “洗车” 这个命令，但是，洗车店会分开操作，比如冲水，打泡沫，洗刷，擦干，打蜡等，这写动作都可以由不同的员工来做，不需要一个员工依次取执行，其余的员工在那干等着，因此，每个员工都被分配一个任务，执行完就交给下一个员工，就像工厂里的流水线一样。</p>
<p>CPU 在执行指令的时候也是这么做的。</p>
<p>既然是流水线执行，那么流水线肯定不能中断，否则，一个地方中断会影响下游所有的组件执行效率，性能损失很大。</p>
<p>那么怎么办呢？打个比方，1冲水，2打泡沫，3洗刷，4擦干，5打蜡 本来是按照顺序执行的。如果这个时候，水没有了，那么冲水后面的动作都会收到影响，但是呢，其实我们可以让冲水先去打水，和打泡沫的换个位置，这样，我们就先打泡沫，冲水的会在这个时候取接水，等到第一辆车的泡沫打完了，冲水的就回来了，继续赶回，不影响工作。这个时候顺序就变成了：</p>
<p> 1打泡沫 ，2冲水，3洗刷，4擦干，5打蜡.</p>
<p>但是工作丝毫不受影响。流水线也没有断。CPU 中的乱序执行其实也跟这个道理差不多。其最终的目的，还是为了压榨 CPU 的性能。</p>
<p>好了，对于今天的文章需要的硬件知识，我们已经复习的差不多了。总结一下，主要是2点：</p>
<ol>
<li>CPU 的多级缓存访问主存的时候需要配合缓存一致性协议。这个过程可以抽象为内存模型。</li>
<li>CPU 为了性能会让指令流水线执行，并且会在单个 CPU 的执行结构不混乱的情况下乱序执行。</li>
</ol>
<p>那么，接下来就要好好说说Java 的内存模型了。</p>
<h2 id="2-Java-内存模型到底是什么玩意？"><a href="#2-Java-内存模型到底是什么玩意？" class="headerlink" title="2. Java 内存模型到底是什么玩意？"></a>2. Java 内存模型到底是什么玩意？</h2><p>回忆下上面的内容，我们说从硬件的层面什么是内存模型？</p>
<blockquote>
<p> 内存模型可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的CPU 有不同的内存模型。</p>
</blockquote>
<p>Java 作为跨平台语言，肯定要屏蔽不同CPU内存模型的差异，构造自己的内存模型，这就是Java 的内存模型。实际上，根源来自硬件的内存模型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a5c9a6acadf4eef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java 内存模型（Java Memory Model）"></p>
<p>还是看这个图片，Java 的内存模型和硬件的内存模型几乎一样，每个线程都有自己的工作内存，类似CPU的高速缓存，而  java 的主内存相当于硬件的内存条。</p>
<p>Java 内存模型也是抽象了线程访问内存的过程。</p>
<p>JMM（Java 内存模型）规定了所有的变量都存储在主内存（这个很重要）中，包括实例字段，静态字段，和构成数据对象的元素，但不包括局部变量和方法参数，因为后者是线程私有的。不会被共享。自然就没有竞争问题。</p>
<p>什么是工作内存呢？每个线程都有自己的工作内存（这个很重要），线程的工作内存保存了该线程使用到的变量和主内存副本拷贝，线程对变量的所有操作（读写）都必须在工作内存中进行。而不能直接读写主内存中的变量。不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。</p>
<p>总结一下，Java 内存模型定义了两个重要的东西，1.主内存，2.工作内存。每个线程的工作内存都是独立的，线程操作数据只能在工作内存中计算，然后刷入到主存。这是 Java 内存模型定义的线程基本工作方式。</p>
<h2 id="3-Java-内存模型定义了哪些东西？"><a href="#3-Java-内存模型定义了哪些东西？" class="headerlink" title="3. Java 内存模型定义了哪些东西？"></a>3. Java 内存模型定义了哪些东西？</h2><p>实际上，整个 Java 内存模型围绕了3个特征建立起来的。这三个特征是整个Java并发的基础。</p>
<p>原子性，可见性，有序性。</p>
<h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>什么是原子性，其实这个原子性和事务处理中的原子性定义基本是一样的。指的是一个操作是不可中断的，不可分割的。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>我们大致可以认为基本数据类型的访问读写是具备原子性的（但是，如果你在32位虚拟机上计算 long 和 double 就不一样了），因为 java 虚拟机规范中，对 long 和 double 的操作没有强制定义要原子性的，但是强烈建议使用原子性的。因此，大部分商用的虚拟机基本都实现了原子性。</p>
<p>如果用户需要操作一个更到的范围保证原子性，那么，Java 内存模型提供了 lock 和 unlock （这是8种内存操操作中的2种）操作来满足这种需求，但是没有提供给程序员这两个操作，提供了更抽象的 monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。</p>
<h4 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h4><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改，Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值，这种依赖主内存作为传递媒介的方式来实习那可见性的。无论是普通变量还是 volatile 变量都是如此。他们的区别在于：volatile 的特殊规则保证了新值能立即同步到主内存，以及每次是使用前都能从主内存刷新，因此，可以说 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
<p>除了 volatile 之外， synchronized 和 final 也能实现可见性。同步块的可见性是由 <strong>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存种（执行 store， write 操作）</strong>。</p>
<h4 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h4><p>有序性这个问题我们在最上面说硬件的时候说过，CPU 会调整指令顺序，同样的 Java 虚拟机同样也会调整字节码顺序，但这种调整在单线程里时感知不到的，除非在多线程程序中，这种调整会带来一些意想不到的错误。</p>
<p>Java 提过了两个关键字来保证多个线程之间操作的有序性，volatile 关键字本身就包含了禁止重排序的语义，而 synchronized 则是由 “一个变量同一时刻只允许一条线程对其进行 lock 操作”这个规则获得的。这条规则决定了同一个锁的两个同步块只能串行的进入。</p>
<p>好了，介绍完了 JMM 的三种基本特征。不知道大家有没有发现，volatile 保证了可见性和有序性，synchronized  则3个特性都保证了，堪称万能。而且 synchronized 使用方便。但是，仍然要警惕他对性能的影响。</p>
<h2 id="4-Java内存模型引出的-Happen-Before-原则是什么？"><a href="#4-Java内存模型引出的-Happen-Before-原则是什么？" class="headerlink" title="4. Java内存模型引出的 Happen-Before 原则是什么？"></a>4. Java内存模型引出的 Happen-Before 原则是什么？</h2><p>说到有序性，注意，我们说有序性可以通过 volatile 和 synchronized 来实现，但是我们不可能所有的代码都靠这两个关键字。实际上，Java 语言已对重排序或者说有序性做了规定，这些规定在虚拟机优化的时候是不能违背的。</p>
<ol>
<li>程序次序原则：一个线程内，按照程序代码顺序，书写在前面的操作先发生于书写在后面的操作。</li>
<li>volatile 规则：volatile 变量的写，先发生于读，这保证了 volatile 变量的可见性。</li>
<li>锁规则：解锁（unlock） 必然发生在随后的加锁（lock）前。</li>
<li>传递性：A先于B，B先于C，那么A必然先于C。</li>
<li>线程的 start 方法先于他的每一个动作。</li>
<li>线程的所有操作先于线程的终结。</li>
<li>线程的中断（interrupt（））先于被中断的代码。</li>
<li>对象的构造函数，结束先于 finalize 方法。</li>
</ol>
<h2 id="5-Happen-Before-引出的-volatile-又是什么？"><a href="#5-Happen-Before-引出的-volatile-又是什么？" class="headerlink" title="5. Happen-Before 引出的 volatile 又是什么？"></a>5. Happen-Before 引出的 volatile 又是什么？</h2><p>我们在前面，说了很多的 volatile 关键字，可见这个关键字非常的重要，但似乎他的使用频率比 synchronized<br> 少多了，我们知道了这个关键字可以做什么呢？</p>
<p>volatile 可以实现线程的可见性，还可以实现线程的有序性。但是不能实现原子性。</p>
<p>我们还是直接写一段代码吧！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile 不能保证原子性，只能遵守 hp 原则 保证单线程的有序性和可见性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultitudeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      threads[j] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PlusTask());</span><br><span class="line">      threads[j].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      threads[j].join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们启动了10个线程分别对一个 int 变量进行 ++ 操作，注意，++ 符号不是原子的。然后，主线程等待在这10个线程上，执行结束后打印 int 值。你会发现，无论怎么运行都到不了10000，因为他不是原子的。怎么理解呢？ </p>
<p>i++ 等于 i = i + 1；</p>
<p>虚拟机首先读取 i 的值，然后在 i 的基础上加1，请注意，volatile 保证了线程读取的值是最新的，当线程读取 i 的时候，该值确实是最新的，但是有10个线程都去读了，他们读到的都是最新的，并且同时加1，这些操作不违法 volatile 的定义。最终出现错误，可以说是我们使用不当。</p>
<p>楼主也在测试代码中加入了一个同步方法，同步方法能够保证原子性。当for循环中执行的不是i++，而是 plusI 方法，那么结果就会准确了。</p>
<p>那么，什么时候用 volatile 呢？</p>
<p><strong>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</strong> </p>
<p>我们程序的情况就是，运算结果依赖 i 当前的值，如果改为 原子操作： i = j，那么结果就会是正确的 9999.</p>
<p>比如下面这个程序就是使用 volatile 的范例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java 内存模型：</span></span><br><span class="line"><span class="comment"> * 单线程下会重排序。</span></span><br><span class="line"><span class="comment"> * 下面这段程序再 -server 模式下会优化代码（重排序），导致永远死循环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMMDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  static boolean ready;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    num = <span class="number">32</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Thread.yield();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这段程序很有意思，我们使用 volatile 变量来控制流程，最终的正确结果是32，但是请注意，如果你没有使用 volatile 关键字，并且虚拟机启动的时候加入了 -server参数，这段程序将永远不会结束，因为他会被 JIT 优化并且另一个线程永远无法看到变量的修改（JIT 会忽略他认为无效的代码）。当然，当你修改为 volatile 就没有任何问题了。</p>
<p>通过上面的代码，我们知道了，volatile 确实不能保证原子性，但是能保证有序性和可见性。那么是怎么实现的呢？</p>
<p>怎么保证有序性呢？实际上，在操作 volatile 关键字变量前后的汇编代码中，会有一个 lock 前缀，根据 <a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-manual-325462.html">intel IA32 手册</a>，lock 的作用是 使得 本 CPU 的Cache 写入了内存，该写入动作也会引起别的CPU或者别的内核无效化其Cache，别的CPU需要重新获取Cache。这样就实现了可见性。可见底层还是使用的 CPU 的指令。</p>
<p>如何实现有序性呢？同样是lock 指令，这个指令还相当于一个内存屏障（<code>大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障</code>），指的是，重排序时不能把后面的指令重排序到内存屏障之前的位置。只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或者更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证了。</p>
<p>因此请不要随意使用 volatile 变量，这会导致 JIT 无法优化代码，并且会插入很多的内存屏障指令，降低性能。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>首先 JMM 是抽象化了硬件的内存模型（使用了多级缓存导致出现缓存一致性协议），屏蔽了各个 CPU 和操作系统的差异。</p>
<p>Java 内存模型指的是：在特定的协议下对内存的访问过程。也就是线程的工作内存和主存直接的操作顺序。</p>
<p>JMM 主要围绕着原子性，可见性，有序性来设置规范。</p>
<p>synchronized 可以实现这3个功能，而 volatile 只能实现可见性和有序性。final 也能是实现可见性。</p>
<p>Happen-Before 原则规定了哪些是虚拟机不能重排序的，其中包括了锁的规定，volatile 变量的读与写规定。</p>
<p>而 volatile 我们也说了，不能保证原子性，所以使用的时候需要注意。volatile 底层的实现还是 CPU 的 lock 指令，通过刷新其余的CPU  的Cache 保证可见性，通过内存栅栏保证了有序性。</p>
<p>总的来说，这3个概念可以说息息相关。他们之间互相依赖。所以楼主放在了一篇来写，但这可能会导致有所疏漏，但不妨碍我们了解整个的概念。可以说，JMM 是所有并发编程的基础，如果不了解 JMM，根本不可能高效并发。</p>
<p>当然，我们这篇文章还是不够底层，并没有剖析 JVM 内部是怎么实现的，今天已经很晚了，有机会，我们一起进入 JVM 源码查看他们的底层实现。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>深入剖析-Mybatis-原理（二）</title>
    <url>/2017/12/17/2017/2017-12-17-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-mybatis-%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在上篇文章中我们分析了 sqlSession.selectOne("org.apache.ibatis.mybatis.UserInfoMapper.selectById", parameter) 代码的执行过程，我们说，这种方式虽然更接近 mybaits 的底层，但不够面向对象，也不利于 IDEA 工具的编译期排错。

<p>而mybatis 还有另一种写法，我们在测试代码也写过，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserInfoMapper userInfoMapper = sqlSession.getMapper(UserInfoMapper.class);</span><br><span class="line">UserInfo userInfo2 = userInfoMapper.selectById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码非常的面向对象，也非常的利于IDE工具在编译期间排错。实际上这是mybait 为我们做的工作，是对第一种的方式的一种更抽象的封装。同时，这种方式也是我们现在开发常用的一种方式，所以，我们必须剖析的原理，看看他到底是如何实现的。想必有经验的大佬都能猜测到，肯定用动态代理的技术。不过，我们还是从源码看个究竟吧!</p>
<h2 id="1-从-getMapper-方法进入源码"><a href="#1-从-getMapper-方法进入源码" class="headerlink" title="1. 从 getMapper 方法进入源码"></a>1. 从 getMapper 方法进入源码</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-ff694d625cc85828.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>实际上调用了 configuration 的 getMapper方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-da3aa1ec0a3d0302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>configuration  实际上调用了 mapperRegistry.getMapper：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-19bfd6f8d9a4ffc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意，要停下来，看看 mapperRegistry 是什么，从名字上看出来，该对象是Mapper 映射器注册容器，我们看看该对象中有什么？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c31c196e39e8f7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-529c24e1aa81540e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是该类的属性，有一个 Configuration 对象，有一个 Map，Map 存放什么数据呢，key 是 class 类型， value是 MapperProxyFactory 类型，MapperProxyFactory  又是什么呢，看名字是映射器代理对象工厂，我们看看该类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a386a3c180617e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是该类的结构图，有一个Class 对象，表示 映射器的接口，有一个Map 表示映射方法的缓存。并且由2 个newInstance 方法，看名字肯定是创建代理对象啦。我们看看这2个方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f73fe5a113d6772c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>调用了动态的技术，根据给定的接口和SqlSession 和方法缓存，创建一个代理对象 MapperProxy ，该类实现了 InvocationHandler 接口，因此我们需要看看他的 invoke 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-34f1449343bb4e42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是  MapperProxy 的 invoke 方法，该方法首先判断方法的class 是否继承 Object ，如果是，就不使用代理，直接执行，如果该方法是默认的，那么就执行默认方法（该方法是针对Java7以上版本对动态类型语言的支持，不进行详述）。我们这里肯定不是，执行下面的 cachedMapperMethod 方法 并调用返回对象 MapperMethod 的execute 方法。</p>
<p>我们看看 cachedMapperMethod  方法，该方法应该是跟缓存相关，我们看看实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-afbebcdf7a8cd59f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法首先从缓存中取出，如果没有，便创建一个，并放入缓存并返回。我们关注一下 MapperMethod 的构造方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-909387fc49bc21b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该构造方法拿着这三个参数创建了两个对象，一个是SQL命令对象，一个方法签名对象，这两个类都是MapperMethod 的静态内部类。我们来看看这两个类。</p>
<p>SqlCommand 类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c4b930d3f264359f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类由2个属性，一个是name，表示sql语句的名称，一个是type 自动，表示sql语句的类型，sql语句的名称是怎么来的呢？我们从代码中看到是从 resolveMappedStatement 方法返回的 MappedStatement 对象中得到的。而 SqlCommandType 也是从该方法中得到的。那么我重点关注该方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1bc1b3da65e133b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们刚刚说，name 是怎么来的，是调用了 MappedStatement 对象的getId 方法来的，而 id 是怎么来的呢？是mapperInterface.getName() + “.” + methodName 拼起来的，也就是接口名称和方法名称成为了一个id，素以注意，该方法不能重载。因为他不关注参数。根据id从 configuration 获取解析好的MappedStatement（存放在hashmap中）。如果没有这个id的话，注意，该方法最后还会递归调用该接口的所有父接口的 resolveMappedStatement ，确保找到给定 id 的 MappedStatement。</p>
<p>那么 SqlCommandType  是什么呢？是个枚举，我们看看该枚举：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-95e50440f6556558.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该枚举定义我们在xml中的标签。是不是很亲切？</p>
<p>那么 MethodSignature 是什么呢？我们看看该类由哪些属性：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8edcdfeaff0995dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>看该类名字知道是方法的签名，因此包含方法的很多信息，是否返回多值，是否返回map，是否返回游标，返回值类型等等，这些属性都是在构造方法中注入的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e24af4c4c1d7a32a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>看完了内部类，回到 MapperProxy 的invoke 方法，现在有了 MapperMethod 对象，就要执行该对象的execute 方法，该方法是如何执行的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName() </span><br><span class="line">          + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要是判断方法的类型，也就是我们的insert select 标签，根据不同的标签执行不同的方法，如果是 SELECT 标签就还要再判断他的返回值，根据不同的返回值类型执行不同的方法。默认执行 sqlSession 的 selectOne 方法，看到这里，是不是一目了然了呢？也就是说getMapper 最终还是调用 SqlSession 的 selectOne 方法，只不过通过动态代理封装了一遍，让mybatis 来管理这些字符串样式的key，而不是让用户来手动管理。</p>
<p>我们回到 MapperRegistry 的 getMapper 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d4f49f5e2013655a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先根据接口类型从缓存中取出，如果没有，则抛出异常，因为这些缓存都是在解析配置文件的时候放入的。根据返回的映射代理工厂，调用该工厂的方法，传入 SqlSession 返回一个接口代理：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1a6e9732af592d7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这段代码其实我们已经看过了，创建一个实现类 InvocationHandler 接口的对象，然后使用JDK动态代理创建实例返回，而 InvocationHandler  的实现类 MapperProxy 的代码我们刚刚也看过了。主要逻辑在invoke中，在该方法中调用 SqlSession 的 selectOne 方法。后面的我们就不说了，和上一篇文章的逻辑一样，就不赘述了。</p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>大家可能注意到了，这篇文章不长，因为主要逻辑在上篇文章中，这里只不过将 Mybatis 如何封装代理的过程解析了一遍。主要实现这个功能是的是 mybatis 的binding 包下的几个类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a9585665c511ff4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这几个类完成了对代理的封装和对目标方法的调用。当然还有 SqlSession，可以看出，mybatis 的模块化做的非常好。</p>
<p>我们也来看看这几个类的UML图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-dbd37c59a70f1dd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，所有的类都关联着SqlSession，由此可以看出SqlSession的重要性。而我们今天解析的代码只不过在SqlSession外面封装了一层，便于开发者使用，否则，配置这些字符串，就太难以维护了。</p>
<p>好了，今天的Mybatis 分析就到这里了。我们通过一个demo知道了mybatis 的运行原理，由此，在以后的开发中，遇到错误时，再也不是黑盒操作了。可以深入源码去找真正的原因。当然，阅读源码带来的好处肯定不止这些。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-线程协作工具类</title>
    <url>/2018/01/03/2018/2018-01-03-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在并发编程的时候，Doug Lea 大师为我们准备了很多的工具，都在 JDK 1.5 版本后的java.util.concurrent 包下，今天楼主就和大家分享一些常用的线程协作的工具。

<ol>
<li>Semaphore 信号量</li>
<li>CountDownLatch 倒计时器</li>
<li>CyclicBarrier 循环栅栏</li>
<li>Exchanger 交换器</li>
</ol>
<h2 id="1-Semaphore-信号量"><a href="#1-Semaphore-信号量" class="headerlink" title="1. Semaphore 信号量"></a><strong>1. Semaphore 信号量</strong></h2><p>我们在上一篇文章中说到了3把锁，无论是 synchronized 还是 重入锁还是读写锁，一次只能允许一个线程进行访问。当然这是为了保证线程的安全。但是，如果我们有的时候想一次让多个线程访问同一个代码呢？并且指定线程数量。</p>
<p>在 JDK 1.5 中，doug lea 大师已经为我们写好了这个工具类，什么呢？就是 Semephore，信号量。信号量为多线程协作提供了更为强大的控制方法。从某种程度上说：信号量是对锁的扩展。信号量可以指定多个线程，同时访问某一个资源。</p>
<p>该类有2个构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>permits 表示的是信号量的数量，简单点说就是指定了同时又多少个线程可以同时访问某一个资源。而 fair 参数表示的是否是公平的。那么信号量还有哪些方法呢？</p>
<p> 下面是阻塞方法，也就是会无限等待的方法：</p>
<ol>
<li>public void acquire() throws InterruptedException {  }     //获取一个许可</li>
<li> public void acquire(int permits) throws InterruptedException { }    //获取permits个许可</li>
<li>public void release() { }          //释放一个许可</li>
<li>public void release(int permits) { }    //释放permits个许可</li>
</ol>
<p> 下面是非阻塞方法：</p>
<ol>
<li>public boolean tryAcquire() { };    //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</li>
<li> public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { };  //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</li>
<li> public boolean tryAcquire(int permits) { }; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</li>
<li>public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException { }; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</li>
</ol>
<p>如何使用呢？我们还是来个例子吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要指定信号量的准入数，相当于指定了同时有多少个线程可以同时访问某一个资源</span></span><br><span class="line">  <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      semaphore.acquire();</span><br><span class="line">      <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getId() + <span class="string">&quot;:done!&quot;</span>);</span><br><span class="line">      semaphore.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">final</span> SemaphoreTest test = <span class="keyword">new</span> SemaphoreTest();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      exec.execute(test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们指定了可以有5个信号量的实例，在线程池中被20个线程执行，打印的结果都是5个一组，5个一组，说明，的确是每5个线程同时访问该段代码。</p>
<p>其实信号量就是一种限制策略，在 web 服务器中，信号量就是一种限流策略，限制多少线程执行，和这个模式差不多。</p>
<h2 id="2-CountDownLatch-倒计时器"><a href="#2-CountDownLatch-倒计时器" class="headerlink" title="2. CountDownLatch 倒计时器"></a><strong>2. CountDownLatch 倒计时器</strong></h2><p>从名字上来看，可以翻译成倒计时门闩，但我们其实不必管门闩，他其实就是个倒计时器。门闩的含义是什么呢？把们锁起来，不让里面的线程跑出来，因此，这个工具常用来控制线程等待，有点像我们的 join 方法，可以让某一个线程等待知道倒计时结束，再开始执行。</p>
<p>CountDownLatch 的构造函数：</p>
<p>public CountDownLatch(int count)  其中 int 类型的参数表示当前这个计时器的计数个数。</p>
<p>我们还是直接来个例子吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相当于join功能，让调用  await 方法的线程等待 countdownlatch 的线程执行完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 表示需要10个线程完成任务，等待在倒计时上的线程才能继续运行。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchTest test = <span class="keyword">new</span> CountDownLatchTest();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟检查任务</span></span><br><span class="line">      Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;check complete&quot;</span>);</span><br><span class="line">      end.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      exec.submit(test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end.await();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Fire&quot;</span>);</span><br><span class="line"></span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们模拟了火箭发射的场景，火箭发射前，都需要做一些检查任务，等到所有的检查任务完成了才能反射。那我们这里怎么实现的呢？开启20个线程执行 检查任务，注意，任务中，调用了 CountdownLatch 的 countDown 方法，就是倒计时方法，每个线程执行到这里，都会让该倒计时减一，直到为0.</p>
<p>而再完美的main 线程中，有一行则是 await 方法，该方法让 main 线程等待 countdown 的线程都执行完毕。当20个线程全都成功调用了 run 方法，并且调用了 countdown 的 countdown 方法，countdown 此时为0，main 线程就可以执行  “发射” 了。所以该方法的使用就是让 调用 await 方法的线程等待 调用 countdown 方法的线程，和 join 很相似，join 是调用方等待被调用方。 </p>
<h2 id="3-CyclicBarrier-循环栅栏"><a href="#3-CyclicBarrier-循环栅栏" class="headerlink" title="3. CyclicBarrier 循环栅栏"></a><strong>3. CyclicBarrier 循环栅栏</strong></h2><p>循环栅栏也是控制多线程并发的工具。和 CountDownLatch 非常类似，但是比 CountdDownLatch 复杂，强大。</p>
<p>看名字也很奇怪，CyclicBarrier，循环栅栏。栅栏是用来拦住别人不要进来的，在我们这里，其实就是拦住线程不要进来，而且可以循环使用。</p>
<p>加入有一个场景：司令下达命令，要求10个士兵一起去完成一项任务，这是，就会要求10个士兵先集合报道，接着，再一起去执行任务，当10个士兵的任务都完成了，司令对外宣布，任务完成。</p>
<p>我们是不是想到了使用 coundownLatch 来完成，注意，我们这里需要两次计数，而 countdown 是无法实现的，这就是循环栅栏比倒计时器强大的地方—–可以循环。</p>
<p>如何使用呢？</p>
<p>CyclicBarrier 循环栅栏提供了2 个构造方法：</p>
<p> public CyclicBarrier(int parties) int 类型表示计数的数量</p>
<p>public CyclicBarrier(int parties, Runnable barrierAction) Runnable 表示每次计数结束需要执行的任务（执行一次）</p>
<p>我们就各个司令士兵的例子写一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 军人</span></span><br><span class="line">    String soldier;</span><br><span class="line">    <span class="comment">// 循环栅栏</span></span><br><span class="line">    <span class="keyword">final</span> CyclicBarrier cyclic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(CyclicBarrier cyclic, String soldier)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.cyclic = cyclic;</span><br><span class="line">      <span class="keyword">this</span>.soldier = soldier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 等待所有士兵到齐</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备&quot;</span>);</span><br><span class="line">        cyclic.await();<span class="comment">// 到了 10 才开始走，否则线程等待</span></span><br><span class="line"></span><br><span class="line">        doWork();</span><br><span class="line">        <span class="comment">// 等待所有士兵完成工作</span></span><br><span class="line">        cyclic.await();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(Math.abs(<span class="keyword">new</span> Random().nextInt() % <span class="number">10000</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(soldier + <span class="string">&quot;: 任务完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当计数器一次计数完成后，系统会派一个线程执行的这个线程的run方法。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.flag = flag;</span><br><span class="line">      N = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;司令：【士兵 &quot;</span> + N + <span class="string">&quot;个， 任务完成！】&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;司令：【士兵 &quot;</span> + N + <span class="string">&quot;个， 集合完毕！】&quot;</span>);</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Thread[] allSoldier = <span class="keyword">new</span> Thread[n];</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// parties 表示计数总数，也就是参与的线程总数， barrierAction 就是当计数器一次计数完成后，系统会执行的动作</span></span><br><span class="line">    CyclicBarrier cyclic = <span class="keyword">new</span> CyclicBarrier(n, <span class="keyword">new</span> BarrierRun(<span class="keyword">false</span>, n));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置屏障点，主要是为了执行这个方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;集合队伍&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;士兵&quot;</span> + i + <span class="string">&quot;报道&quot;</span>);</span><br><span class="line">      allSoldier[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclic, <span class="string">&quot;士兵&quot;</span> + i));</span><br><span class="line">      allSoldier[i].start();</span><br><span class="line"><span class="comment">//      if (i== 5)&#123; // 会导致所有的线程全部停止 BrokenBarrierException * 9 + InterruptedException * 1</span></span><br><span class="line"><span class="comment">//        allSoldier[i].interrupt();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码不少，我们场景10个士兵线程，每个士兵线程都含有同一个循环栅栏，再士兵调用run方法的时候，需要调用循环栅栏的 await  方法，此时，线程就开始等待，直到栅栏的数字变成了0，因为我们在创建的时候设置的是10，因此，需要10个线程触发此方法，当10个线程全部都触发了该方法，也就是计数器归零了，注意，此时循环栅栏会随机调用一个线程执行栅栏处发生的行动。就是我们的 BarrierRun 任务。在执行完该任务后，所有的士兵执行 doWork 方法，下面又开始 执行栅栏的 await 方法，所有的士兵又开始等待，等待所有的士兵都执行完毕，可以看到，该栅栏被循环使用了，而 countdown 是做不到的。等到所有的士兵都是调用了 await 方法，循环栅栏再次随机抽取一个线程调用 BarrierRun  的 run 方法。最后完成了所有的任务。</p>
<p>可以说，CyclicBarrier 和 CountDownLatch 还有 Samephore 类都是协作多个线程同时工作的工具。什么时候使用什么工具，各位可以自己思考。</p>
<p>只需要记住：countDown 和 CyclicBarrier 很相似，但不能循环，而 Samephore 可以控制每次又多少个线程进入某个代码块。相当于多线程的锁。具体使用场景自己看。</p>
<h2 id="4-Exchanger-交换器"><a href="#4-Exchanger-交换器" class="headerlink" title="4. Exchanger 交换器"></a><strong>4. Exchanger 交换器</strong></h2><p>Exchanger 是要给交换器，也是用于线程间协作的工具类。什么用处呢？假如现在有一个需求，需要你将两个线程的数据进行狡猾，你该怎么做？</p>
<p>我猜测大家肯定使用类似 wait notify 之类的方法进行线程之间的通信，或者使用消息机制。但 Doug Lea  为我们提供另外一种选择：交换器，直接交换两个线程的数据。6不6？</p>
<p>两个线程可以通过 exchange 方法交换数据，如果第一个线程先执行 exchange 方法，他会一直等待第二个线程也执行 exchange 方法， 当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<p>写个例子大家看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          String a = <span class="string">&quot;银行流水A&quot;</span>;</span><br><span class="line">          String b = exgr.exchange(a);</span><br><span class="line">          System.err.println(<span class="string">&quot;A 和 B 数据是否一致： &quot;</span> + a.equals(b) + <span class="string">&quot;, A 录入的是：&quot;</span> + a + <span class="string">&quot;, B 录入的是：&quot;</span> + b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          String b = <span class="string">&quot;银行流水B&quot;</span>;</span><br><span class="line">          String a = exgr.exchange(b);</span><br><span class="line">          System.out.println(<span class="string">&quot;A 和 B 数据是否一致： &quot;</span> + a.equals(b) + <span class="string">&quot;, A 录入的是：&quot;</span> + a + <span class="string">&quot;, B 录入的是：&quot;</span> + b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ac3e18520c56572c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行结果"></p>
<p>可以看到，两个线程都得到了对方的数据，可以说非常的牛逼。如果两个线程有一个没有执行 exchange 方法，另一个则会一直等待，如果担心 exchanger 时间过长，可以设置过长时间  exchange(V x, long timeout, TimeUnit unit)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>好了，我们今天介绍了 java.util.concurrent 包下的4个多线程协作工具类，让我们在今后并发编程中可以有更顺手的工具，有些业务场景完全可以使用这些现成的工具。比如 Samephore，CountDownLatch， CyclicBarrier，Exchanger，每个工具都有自己的应用场景。</p>
<p>好了，今天的并发工具使用就介绍到这里。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-Java-三把锁</title>
    <url>/2018/01/03/2018/2018-01-03-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Java-%E4%B8%89%E6%8A%8A%E9%94%81/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       今天我们继续学习并发。在之前我们学习了 JMM 的知识，知道了在并发编程中，为了保证线程的安全性，需要保证线程的原子性，可见性，有序性。其中，synchronized 高频出现，因为他既保证了原子性，也保证了可见性和有序性。为什么，因为 synchronized 是锁。通过锁，可以让原本并行的任务变成串行。然而如你所见，这也导致了严重的性能受损。因此，不到万不得已，不要使用锁，特别是吞吐量要求特别高的 WEB 服务器。如果锁住，性能将呈几何级下降。

<p>但我们仍然需要锁，在某些操作共享变量的时刻，仍然需要锁来保证数据的准确性。而Java 世界有 3 把锁，今天我们主要说说这 3 把锁的用法。</p>
<ol>
<li>synchronized 关键字</li>
<li>ReentrantLock 重入锁</li>
<li>ReadWriteLock 读写锁</li>
</ol>
<h2 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h2><p>synchronized 可以说是我们学习并发的时候第一个学习的关键字，该关键字粗鲁有效，通常是初级程序员最爱使用的，也因此会经常导致一些性能损失和死锁问题。</p>
<p>下面是 synchronized 的 3 个用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resource1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="string">&quot;resource1&quot;</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;作用在同步块中&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">resource3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;作用在实例方法上&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">resource2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;作用在静态方法上&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整理以下这个关键字的用法：</p>
<ol>
<li>指定加锁对象（代码块）：对给定对象加锁，进入同步代码前要获得给定对象的锁。</li>
<li>直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。</li>
<li>直接作用于静态方法：相当于对当前类加锁，进入同步代码块前要获得当前类的锁。</li>
</ol>
<p>synchronized 在发生异常的时候会释放锁，这点需要注意一下。</p>
<p>synchronized 修饰的代码在生产字节码的时候会有 monitorenter 和 monitorexit 指令，而这两个指令在底层调用了虚拟机8大指令中其中两个指令—–lock 和 unlock。</p>
<p>synchronized 虽然万能，但是还是有很多局限性，比如使用它经常会发生死锁，且无法处理，所以 Java 在 1.5版本的时候，加入了另一个锁 Lock 接口。我们看看该接口下的有什么。</p>
<h2 id="2-ReentrantLock-重入锁"><a href="#2-ReentrantLock-重入锁" class="headerlink" title="2. ReentrantLock 重入锁"></a>2. ReentrantLock 重入锁</h2><p>JDK 在 1.5 版本新增了java.util.concurrent 包，有并发大师 Doug Lea 编写，其中代码鬼斧神工。值得我们好好学习，包括今天说的 Lock。</p>
<p>Lock 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>void lock();  获得锁</p>
<p>void lockInterruptibly() ;</p>
<p>boolean tryLock(); 尝试获取锁，如果获取不到，立刻返回false。</p>
<p>boolean tryLock(long time, TimeUnit unit) 在</p>
<p>void unlock(); 在给定的时间里等待锁，超过时间则自动放弃</p>
<p>Condition newCondition(); 获取一个重入锁的好搭档，搭配重入锁使用</p>
<p>上面说了Lock的机构抽象方法，那么 Lock 的实现是什么呢？标准实现了 ReentrantLock， ReadWriteLock。也就是我们今天讲的重入锁和读写锁。我们先讲重入锁。</p>
<p>先来一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockText</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Re - entrant - Lock</span></span><br><span class="line"><span class="comment">   * 重入锁，表示在单个线程内，这个锁可以反复进入，也就是说，一个线程可以连续两次获得同一把锁。</span></span><br><span class="line"><span class="comment">   * 如果你不允许重入，将导致死锁。注意，lock 和 unlock 次数一定要相同，如果不同，就会导致死锁和监视器异常。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * synchronized 只有2种情况：1继续执行，2保持等待。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    LockText lockText = <span class="keyword">new</span> LockText();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(lockText);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(lockText);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 因为lock 如果发生了异常，是不会释放锁的，所以必须在 finally 块中释放锁</span></span><br><span class="line">        <span class="comment">// synchronized 发生异常会主动释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用了try 块中保护了临界资源 i 的操作。可以看到， 重入锁不管是开启锁还是释放锁都是显示的，其中需要注意的一点是，重入锁运行时如果发生了异常，不会像 synchronized 释放锁，因此需要在 finally 中释放锁。否则将产生死锁。</p>
<p>什么是重入锁？锁就是锁呗，为什么叫重入锁？之所以这么叫，那是因为这种锁是可以反复进入的（一个线程），大家看看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line">tyr&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这种情况下，一个线程连续两次获得两把锁，这是允许的。如果不允许这么操作，那么同一个线程咋i第二次获得锁是，将会和自己产生死锁。当然，需要注意的是，如果你多次获得了锁，那么也要相同的释放多次，如果释放锁的次数多了，就会得到一个 IllegalMonitorStateException 异常，反之，如果释放锁的次数少了，那么相当于这个线程还没有释放锁，其他线程也就无法进入临界区。</p>
<p>重入锁能够实现 synchronized 的所有功能，而且功能更为强大，我们看看有哪些功能。</p>
<p><strong>中断响应</strong></p>
<p>对于 synchronized 来说，如果一个线程在等待锁，那么结果只有2种，要么他获得这把锁继续运行，要么他就保持等待。没有第三种可能，那如果我有一个需求：需要线程在等待的时候中断线程，synchronizded 是做不到的。而重入锁可以做到，就是 lockInterruptibly 方法，该方法可以获取锁，并且在获取锁的过程种支持线程中断，也就是说，如果调用了线程中断方法，那么就会抛出异常。相对于 lock 方法，是不是更为强大？还是写个例子吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock(重入锁)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Condition(条件)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ReadWriteLock(读写锁)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认是不公平的锁，设置为 true 为公平锁</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 公平：在多个线程的争用下，这些锁倾向于将访问权授予等待时间最长的线程；</span></span><br><span class="line"><span class="comment">   * 使用公平锁的程序在许多线程访问时表现为很低的总体吞吐量（即速度很慢，常常极其慢）</span></span><br><span class="line"><span class="comment">   * 还要注意的是，未定时的 tryLock 方法并没有使用公平设置</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 不公平：此锁将无法保证任何特定访问顺序</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 拾遗：1 该类的序列化与内置锁的行为方式相同：一个反序列化的锁处于解除锁定状态，不管它被序列化时的状态是怎样的。</span></span><br><span class="line"><span class="comment">   *      2.此锁最多支持同一个线程发起的 2147483648 个递归锁。试图超过此限制会导致由锁方法抛出的 Error。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 控制加锁顺序，方便制造死锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> lock</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IntLock</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * lockInterruptibly 方法： 获得锁，但优先响应中断</span></span><br><span class="line"><span class="comment">   * tryLock 尝试获得锁，不等待</span></span><br><span class="line"><span class="comment">   * tryLock(long time , TimeUnit unit) 尝试获得锁，等待给定的时间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程未被中断，则获取锁。</span></span><br><span class="line">        lock1.lockInterruptibly();<span class="comment">// 即在等待锁的过程中，可以响应中断。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 试图获取 lock 2 的锁</span></span><br><span class="line">        lock2.lockInterruptibly();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        lock2.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该线程在企图获取 lock1 的时候，会死锁，但被调用了 thread.interrupt 方法，导致中断。中断会放弃锁。</span></span><br><span class="line">        lock1.lockInterruptibly();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">        lock1.unlock();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 查询当前线程是否保持此锁。</span></span><br><span class="line">      <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) &#123;</span><br><span class="line">        lock2.unlock();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(Thread.currentThread().getId() + <span class="string">&quot;: 线程退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这部分代码主要是针对 lockInterruptibly 方法，该方法在线程发生死锁的时候可以中断线程。让线程放弃锁。</span></span><br><span class="line"><span class="comment">     * 而 synchronized 是没有这个功能的， 他要么获得锁继续执行，要么继续等待锁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    IntLock r1 = <span class="keyword">new</span> IntLock(<span class="number">1</span>);</span><br><span class="line">    IntLock r2 = <span class="keyword">new</span> IntLock(<span class="number">2</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 中断其中一个线程（只有线程在等待锁的过程中才有效）</span></span><br><span class="line">    <span class="comment">// 如果线程已经拿到了锁，中断是不起任何作用的。</span></span><br><span class="line">    <span class="comment">// 注意：这点 synchronized 是不能实现此功能的，synchronized 在等待过程中无法中断</span></span><br><span class="line">    t2.interrupt();</span><br><span class="line">    <span class="comment">// t2 线程中断，抛出异常，并放开锁。没有完成任务</span></span><br><span class="line">    <span class="comment">// t1 顺利完成任务。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码种，我们分别启动两个线程，制造了一个死锁，如果是 synchronized 是无法解除这个死锁的，这个时候重入锁的威力就出来了，我们调用线程的 interrupt 方法，中断线程，我们说，这个方法在线程 sleep，join ，wait 的时候，都会导致异常，这里也一羊，由于我们使用的 lock 的 lockInterruptibly 方法，该方法就像我们刚说的那样，在等待锁的时候，如果线程被中断了，就会出现异常，同时调用了 finally 种的 unlock 方法，注意，我们在 finally 中用 isHeldByCurrentThread 判断当前线程是否持有此锁，这是一种预防措施，放置线程没有持有此锁，导致出现 monitorState 异常。</p>
<p><strong>锁申请</strong></p>
<p>除了等待通知之外，避免死锁还有另一种方法，就是超时等待，如果超过这个时间，线程就放弃获取这把锁，这点 ，synchronized 也是不支持的。那么，如何使用呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 最多等待5秒，超过5秒返回false，若获得锁，则返回true</span></span><br><span class="line">      <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 锁住 6 秒，让下一个线程无法获取锁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;锁住 6 秒，让下一个线程无法获取锁&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get lock failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TimeLock tl = <span class="keyword">new</span> TimeLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(tl);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们设置锁的等待时间是5秒，但是在同步块中，我们设置了6秒暂停，锁外面的线程等待了5面发现还是不能获取锁，就会放弃。走 else 逻辑，结束执行，注意，这里，我们在 finally 块中依然做了判断，如果不做判断，就会出现 IllegalMonitorStateException 异常。</p>
<p>当然了，tryLock 方法也可以不带时间参数，如果获取不到锁，立刻返回false，否则返回 true。该方法也是应对死锁的一个好办法。我们还是写个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TryLock</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程1</span></span><br><span class="line">    <span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取1的锁</span></span><br><span class="line">        <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取2的锁</span></span><br><span class="line">            <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId() + <span class="string">&quot; : My Job done&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock2.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock1.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 线程2</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取2的锁</span></span><br><span class="line">        <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取1的锁</span></span><br><span class="line">            <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId() + <span class="string">&quot;: My Job done&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock2.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这段代码如果使用 synchronized 肯定会引起死锁，但是由于使用 tryLock，他会不断的尝试， 当第一次失败了，他会放弃，然后执行完毕，并释放外层的锁，这个时候就是</span></span><br><span class="line"><span class="comment">   * 另一个线程抢锁的好时机。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TryLock r1 = <span class="keyword">new</span> TryLock(<span class="number">1</span>);</span><br><span class="line">    TryLock r2 = <span class="keyword">new</span> TryLock(<span class="number">2</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码如果使用 synchronized 肯定会引起死锁，但是由于使用 tryLock，他会不断的尝试， 当第一次失败了，他会放弃，然后执行完毕，并释放外层的锁，这个时候就是另一个线程抢锁的好时机。</p>
<p><strong>公平锁和非公平锁</strong></p>
<p>大多数情况下，为了效率，锁都是不公平的。系统在选择锁的时候都是随机的，不会按照某种顺序，比如时间顺序，公平锁的一大特点：他不会产生饥饿现象。只要你排队 ，最终还是可以得到资源的。如果我们使用 synchronized ，得到的锁就是不公平的。因此，这也是重入锁比 synchronized 强大的一个优势。我们同样写个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公平锁和非公平锁的结果完全不同</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 10 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    ======================下面是公平锁，上面是非公平锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得锁</span></span><br><span class="line"><span class="comment">    9 获得锁</span></span><br><span class="line"><span class="comment">    10 获得</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">  <span class="keyword">static</span> ReentrantLock unFairLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">static</span> ReentrantLock fairLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fairLock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">&quot; 获得锁&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fairLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认是不公平的锁，设置为 true 为公平锁</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 公平：在多个线程的争用下，这些锁倾向于将访问权授予等待时间最长的线程；</span></span><br><span class="line"><span class="comment">   * 使用公平锁的程序在许多线程访问时表现为很低的总体吞吐量（即速度很慢，常常极其慢）</span></span><br><span class="line"><span class="comment">   * 还要注意的是，未定时的 tryLock 方法并没有使用公平设置</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 不公平：此锁将无法保证任何特定访问顺序，但是效率很高</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FairLock fairLock = <span class="keyword">new</span> FairLock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(fairLock, <span class="string">&quot;cxs - t1&quot;</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(fairLock, <span class="string">&quot;cxs - t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重入锁的构造函数有一个  boolean 参数，ture 表示公平，false 表示不公平，默认是不公平的，公平锁会降低性能。代码中由运行结果，可以看到，公平锁的打印顺序是完全交替运行，而不公平锁的顺序完全是随机的。注意：如果没有特殊需求，请不要使用公平锁，会大大降低吞吐量。</p>
<p>到这里，我们总结一下重入锁相比 synchronized 有哪些优势：</p>
<ol>
<li>可以在线程等待锁的时候中断线程，synchronized 是做不到的。</li>
<li>可以尝试获取锁，如果获取不到就放弃，或者设置一定的时间，这也是 synchroized 做不到的。</li>
<li>可以设置公平锁，synchronized 默认是非公平锁，无法实现公平锁。</li>
</ol>
<p>当然，大家会说， synchronized 可以通过 Object 的 wait 方法和 notify 方法实现线程之间的通信，重入锁可以做到吗？楼主告诉大家，当然可以了！ JDK 中的阻塞队列就是用重入锁加 他的搭档 condition 实现的。</p>
<p><strong>重入锁的好搭档—–Condition</strong></p>
<p>还记的刚开始说 Lock 接口有一个newCondition 方法吗，该方法就是获取 Condition 的。该 Condition 绑定了该锁。Condition 有哪些方法呢？我们看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看着是不是特别属性，Condition 为了不和 Object 类的 wait 方法冲突，使用 await 方法，而 signal 方法对应的就是 notify 方法。signalAll 方法对应的就是 notifyAll 方法。其中还有一些时间限制的 await 方法，和 Object 的 wait 方法的作用相同。注意，其中有一个 awaitUninterruptibly 方法，该方法从名字可以看出，并不会响应线程的中断，而 Object 的 wait 方法是会响应的。而 awaitUntil 方法就是等待到一个给定的绝对时间。除非调用了 signal 或者中断了。如何使用呢？来一段代码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.lock.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重入锁的好搭档</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * await 使当前线程等待，同时释放当前锁，当其他线程中使用 signal 或者 signalAll 方法时，线程会重新获得锁并继续执行。</span></span><br><span class="line"><span class="comment"> *       或者当线程被中断时，也能跳出等待，这和 Object.wait 方法很相似。</span></span><br><span class="line"><span class="comment"> * awaitUninterruptibly() 方法与 await 方法基本相同，但是它并不会在等待过程中响应中断。</span></span><br><span class="line"><span class="comment"> * singal（） 该方法用于唤醒一个在等待中的线程，相对的 singalAll 方法会唤醒所有在等待的线程，这和 Object.notify 方法很类似。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="comment">// 该线程会释放 lock 的锁，也就是说，一个线程想调用 condition 的方法，必须先获取 lock 的锁。</span></span><br><span class="line">      <span class="comment">// 否则就会像 object 的 wait 方法一样，监视器异常</span></span><br><span class="line">      condition.await();</span><br><span class="line">      System.out.println(<span class="string">&quot;Thread is going on&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ConditionTest t = <span class="keyword">new</span> ConditionTest();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 通知 t1 继续执行</span></span><br><span class="line">    <span class="comment">// main 线程必须获取 lock 的锁，才能调用 condition 的方法。否则就是监视器异常，这点和 object 的 wait 方法是一样的。</span></span><br><span class="line">    lock.lock(); <span class="comment">// IllegalMonitorStateException</span></span><br><span class="line">    <span class="comment">// 从 condition 的等待队列中，唤醒一个线程。</span></span><br><span class="line">    condition.signal();</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以说，condition 的使用方式和 Object 类的 wait 方法的使用方式很相似，无论在哪一个线程中调用 await 或者 signal 方法，都必须获取对应的锁，否则会出现 IllegalMonitorStateException 异常。</p>
<p>到这里，我们可以说， Condition 的实现比 Object 的 wait 和 notify 还是强一点，其中就包括了等待到指定的绝对时间，并且还有一个不受线程中断影响的  awaitUninterruptibly 方法。因此，我们说，只要允许，请使用重入锁，尽量不要使用无脑的 synchronized 。虽然在 JDK 1.6 后， synchronized 被优化了，但仍然建议使用 重入锁。</p>
<h2 id="3-ReadWriteLock-读写锁"><a href="#3-ReadWriteLock-读写锁" class="headerlink" title="3. ReadWriteLock 读写锁"></a>3. ReadWriteLock 读写锁</h2><p>伟大的 Doug Lea 不仅仅创造了 重入锁，还创造了 读写锁。什么是读写锁呢？我们知道，线程不安全的原因来自于多线程对数据的修改，如果你不修改数据，根本不需要锁。我们完全可以将读写分离，提高性能，在读的时候不使用锁，在写的时候才加入锁。这就是 ReadWriteLock 的设计原理。</p>
<p>那么，如何使用呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">static</span> ReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Lock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">  <span class="keyword">static</span> Lock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="comment">// 模拟读操作，读操作的耗时越多，读写锁的优势就越明显</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(Lock lock, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟写操作</span></span><br><span class="line">      value = index;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">    Runnable readRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          demo.handleRead(readLock);</span><br><span class="line"><span class="comment">//          demo.handleRead(lock);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Runnable writeRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          demo.handleWrite(writeLock, <span class="keyword">new</span> Random().nextInt());</span><br><span class="line"><span class="comment">//          demo.handleWrite(lock, new Random().nextInt());</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用读写锁，这段程序只需要2秒左右</span></span><br><span class="line"><span class="comment">     * 使用普通的锁，这段程序需要20秒左右。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(readRunnable).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(writeRunnable).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 ReentrantReadWriteLock 的 readLock（）方法可以返回读锁，writeLock 可以返回写锁，我们使用普通的的重入锁和读写锁进行测试，怎么测试呢？</p>
<p>两个循环：一个循环开启18个线程去读数据，一个循环开启两个线程去写。如果使用普通的重入锁，将耗时20秒，因为普通的重入锁在读的时候依然是串行的。而如果使用读写锁，只需要2秒，也就是写的时候是串行的。读的时候是并行的，极大的提高了性能。</p>
<p>注意：只要涉及到写都是串行的。比如读写操作，写写操作，都是串行的，只有读读操作是并行的。</p>
<p>读写锁 ReadWriteLock 接口只有 2个方法: </p>
<p>Lock readLock(); 返回一个读锁<br>Lock writeLock(); 返回一个写锁</p>
<p>他的标准实现类是 ReentrantReadWriteLock 类，该类和普通重入锁一样，也能实现公平锁，中断响应，锁申请等特性。因为他们返回的读锁或者写锁都实现了 Lock 接口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我们已经将 Java 世界的三把锁的使用弄清楚了，从分析的过程中我们知道了，JDK 1.5 的重入锁完全可以代替关键字 synchronized ，能实现很多 synchronized 没有的功能。比如中断响应，锁申请，公平锁等，而重入锁的搭档 Condition 也比 Object 的wait 和notify 强大，比如有设置绝对时间的等待，还有忽略线程中断的 await 方法，这些都是 synchronized 无法实现的。还有优化读性能的 读写锁，在读的时候完全是并行的，在某些场景下，比如读很多，写很少，性能将是几何级别的提升。</p>
<p>所以，以后，能不用 synchronzed 就不要用，用的不好就会导致死锁。</p>
<p>今天的Java 三把锁就介绍到这里。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-线程协作工具-LockSupport</title>
    <url>/2018/01/04/2018/2018-01-04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%E5%B7%A5%E5%85%B7-LockSupport/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在前面的文章中，我们介绍了并发工具中的4个，Samephore，CyclicBarrier，CountDownLatch，Exchanger，但是我们漏了一个，非常的好用的工具，楼主在这里必须加上。

<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport 是一个非常方便实用的线程<strong>阻塞</strong>工具，他可以在任意位置让线程阻塞。并且是静态的方法。是不是很心动？</p>
<p>LockSupport 的静态方法 park（）可以阻塞当前线程，类似的还有 parkNanos()，parkUntil(）等，他们实现了一个限时的等待。</p>
<p>同样的，有阻塞的方法，当然有唤醒的方法，什么呢？unpark（Thread） 方法。该方法可以将指定线程唤醒。</p>
<p>我们还是来一个例子吧，看看到底有多好用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportInterruptDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;in &quot;</span> + getName());</span><br><span class="line">        <span class="comment">// wait</span></span><br><span class="line">        LockSupport.park();</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">          System.err.println(getName() + <span class="string">&quot;被中断了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(getName() + <span class="string">&quot;执行结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    t1.interrupt();</span><br><span class="line">    <span class="comment">// notify</span></span><br><span class="line">    LockSupport.unpark(t2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c3437f99e0b59709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>完全实现了 wait notify 的功能，但是，请注意，park 方法和 wait 方法相比，不需要获取某个对象的锁，也不会抛出 InterruptedException 异常，因此，你需要像我们的例子一样，使用静态方法进行判断。</p>
<p>如果你将 park 方法改成 park（this）/park（Thread），那么在打印 线程dump 信息的时候会打印阻塞对象的详细信息。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ff56d22a18d12cf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法和 Lock 接口一样都是使用的 sun.misc.Unsafe 的 park 方法实现的阻塞。</p>
<p>还有一个需要注意的是：park 方法和 unpark 方法执行顺序不是那么的严格。比如我们在 Thread 类中提到的 suspend 方法 和resume 方法，如果顺序错误，将导致永远无法唤醒，但 park 方法和 unpark 方法则不会，我们测试一下，将 unpark 方法紧跟着 start 方法后面执行，那么也就是说，unpark 方法在 线程2 的park 方法之前执行，但结果相同。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ea2b09a428891c44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们将 unpark 方法移动到了 start 方法后面，依然正确执行。</p>
<p>什么原因呢？这是因为 LockSupport 使用了类似信号量的机制。他为每一个线程准备了一个许可（默认不可用），如果许可能用，那么 park 函数会立即返回，并且消费这个许可（也就是将许可<strong>变为不可用</strong>），如果许可不可用，将会阻塞。而 unpark 方法则使得一个许可<strong>变为可用</strong>（但是和信号量不同的是，许可不能累加，你不可能拥有超过要给许可，他永远只有一个）。</p>
<p>下面是JDK文档：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-666a10cfddb4be6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="park"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4cdaf955622609ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unpark"></p>
<p>这个特定使得：即使 unpark 方法在 park 方法之前执行，他也可以使下一次的 park 操作立即返回。这也使上面的代码能正确执行的原因。</p>
<p>好了，到这里，LockSupport 就介绍完了，可以说，该方法可以替代 wait ，notify ，Condition 的 await ，signal 方法。注意，这里的 park 方法底层和 Lock 的底层实现是一致的。都是掉哟个 sun.misc.Unsafe。这个类可以说很牛逼。</p>
<p>good luck ！！！！ </p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解-HashMap-Put-方法（JDK-8逐行剖析）</title>
    <url>/2017/12/31/2017/2017-12-31-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-HashMap-put-%E6%96%B9%E6%B3%95%EF%BC%88JDK-8%E9%80%90%E8%A1%8C%E5%89%96%E6%9E%90%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## **前言**

<p>注意：我们今天所有的一切都是基于 JDK 8，JDK 8 的实现和 JDK 7 有重大区别。</p>
<p>前面我们分析了 hashCode 和 hash 算法的原理，其实都是为我们解析 HashMap 做铺垫，因为 HashMap 确实比较复杂（如果你每一行代码都看的话，每个位移都纠结的话），虽然总的来说，HashMap 不过是 Node 数组加 链表和红黑树。但是里面的细节确是无比的优雅和有趣。楼主为什么选择 put 方法来讲呢？因为从楼主看来，HashMap 的精髓就在 put 方法中。</p>
<p>HashMap 的解析从楼主来看，主要可以分为几个部分：</p>
<ol>
<li>hash 算法（这个我们之前说过了，今天就不再赘述了）</li>
<li>初始化数组。</li>
<li>通过 hash 计算下标并检查 hash 是否冲突，也就是对应的下标是否已存在元素。</li>
<li>通过判断是否含有元素，决定是否创建还是追加链表或树。</li>
<li>判断已有元素的类型，决定是追加树还是追加链表。</li>
<li>判断是否超过阀值，如果超过，则重新散列数组。</li>
<li>Java 8 重新散列时是如何优化的。</li>
</ol>
<p>开始吧！！！</p>
<h2 id="1-初始化数组"><a href="#1-初始化数组" class="headerlink" title="1. 初始化数组"></a><strong>1. 初始化数组</strong></h2><p>首先我们来一个测试例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    hashMap.put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    Integer one = hashMap.get(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    System.out.println(one);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个简单的不能再简单的使用 HashMap 的例子，其中包含了对于 HashMap 来说关键的 3 个步骤，初始化，put 元素，get 元素。</p>
<p>由于我们预计会放入一个元素，出于性能考虑，我们将容量设置为 2，既保证了性能，也节约了空间（置于为什么，我们在之前的文章中讲过）。</p>
<p>那么我们就看看 new 操作的时候做了些什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================================================================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面是 HashMap 的两个构造方法，其中，我们设置了初始容量为 2， 而默认的加载因子我们之前说过：0.75，当然也可以自己设置，但 0.75 是最均衡的设置，没有特殊要求不要修改该值，加载因子过小，理论上能减少 hash 冲突，加载因子过大可以节约空间，减少 HashMap 中最耗性能的操作：reHash。</p>
<p>从代码中我可以看到，如果我们设置的初始化容量小于0，将会抛出异常，如果加载因子小于0也会抛出异常。同时，如果初始容量大于最大容量，则重新设置为最大容量。</p>
<p>我们开最后两行代码，首先，对负载因子进行赋值，这个没什么可说的。<br>牛逼的是下面一行代码：this.threshold = tableSizeFor(initialCapacity); 可以看的出来这个动作是计算阀值，上面是阀值呢？阀值就是，如果容器中的元素大于阀值了，就需要进行扩容，那么这里的这行代码，就是根据初始容量进行阀值的计算。</p>
<p>我们进入到该方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一通或运算和无符号右移运算，那么这个运算的的最后结果是什么呢？这里其实就是如果用户输入的值不是2的幂次方（我们通过之前的分析，应该直到初始容量如果不是2的幂次方会有多么不好的结果）。通过位移运算和或运算，最后得到一定是2的幂次方，并且是那个离那个数最近的数字，我们仔细看看该方法：</p>
<blockquote>
<p>| : 或运算，第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0</p>
</blockquote>
<p>首先，将容量减1，我们后面就知道了。然后将该数字无符号右移1，2，4，8，16，总共移了32位，刚好是一个int类型的长度。在移动的过程中，还对该数字进行或运算，为了方便查看，楼主写一下2进制的运算过程，假如我输入的是10，明显不是2的幂次方。我们看看会怎么样：</p>
<p>10 = 1010；<br>n = 9;</p>
<p>1001 == 9；</p>
<p>1001 &gt;&gt;&gt; 1 = 0100;<br>1001 或 0100 = 1101；</p>
<p>1101 &gt;&gt;&gt; 2 = 0011;<br>110 或 0011 = 1111；</p>
<p>1111 &gt;&gt;&gt; 4 = 0000;<br>1111 或 0000 = 1111；</p>
<p>1111 &gt;&gt;&gt; 8 = 0000;<br>1111 或 0000 = 1111；</p>
<p>1111 &gt;&gt;&gt; 16 = 0000；<br>1111 或 0000 = 1111；</p>
<p>最后，1111 也就是 15 ，15 + 1 = 16，刚好就是距离10 最近的并且没有变小的2的幂次方数。可以说这个算法非常的牛逼。楼主五体投地。</p>
<p>但是如果是 16 呢，并且没有不减一，我们看看什么结果：</p>
<p>16 = 10000； </p>
<p>10000 &gt;&gt;&gt; 1 = 01000;<br>10000 或 01000 = 11000；</p>
<p>11000 &gt;&gt;&gt; 2 = 00110;<br>11000 或 00110 = 11110；</p>
<p>11110 &gt;&gt;&gt; 4 = 00001;<br>11110 或 00001 = 11111；</p>
<p>11111 &gt;&gt;&gt; 8 = 00000;<br>11111 或 00000 = 11111；</p>
<p>11111 &gt;&gt;&gt; 16 = 00000；<br>11111 或 00000 = 11111；</p>
<p>最后的数字就是31 ，31+ 1 = 32，同样也是上升到了更大的2次幂的数字。但是这不是我想要的结果，所以，JDK 的作者在之前先减去了1. 防止出现这样的问题。</p>
<p>我们仔细观察其算法的过程，可以说，任何一个int  数字，都能找到离他最近的 2 的幂次方数字（并且比他大）。</p>
<p>好了。到这里就完成了初始化，不过请注意，这里设置的阀值并不是最终的阀值，最终的阀值我们会在后面详细说明。这里我们更加关注这个算法。真的牛逼啊。</p>
<h2 id="2-通过-hash-计算下标并检查-hash-是否冲突，也就是对应的下标是否已存在元素。"><a href="#2-通过-hash-计算下标并检查-hash-是否冲突，也就是对应的下标是否已存在元素。" class="headerlink" title="2. 通过 hash 计算下标并检查 hash 是否冲突，也就是对应的下标是否已存在元素。"></a><strong>2. 通过 hash 计算下标并检查 hash 是否冲突，也就是对应的下标是否已存在元素。</strong></h2><p>初始化好了 HashMap，我们接着就调用了 put 方法，该方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中调用 hash 方法，该方法我们之前已经深入讨论过，今天就不赘述了，如果有同学没有看过，也不要紧，看完这篇 再去看 或者 看完那篇 再来 看这篇都可以。有点绕。好，然后调用了 puVal 方法，我们看看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 当前对象的数组是null 或者数组长度时0时，则需要初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 得到数组的长度 16</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 如果通过hash值计算出的下标的地方没有元素，则根据给定的key 和 value 创建一个元素</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果hash冲突了</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果给定的hash和冲突下标中的 hash 值相等并且 （已有的key和给定的key相等（地址相同，或者equals相同）），说明该key和已有的key相同</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 那么就将已存在的值赋给上面定义的e变量</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 如果以存在的值是个树类型的，则将给定的键值对和该值关联。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 如果key不相同，只是hash冲突，并且不是树，则是链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 循环，直到链表中的某个节点为null，或者某个节点hash值和给定的hash值一致且key也相同，则停止循环。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 如果next属性是空</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 那么创建新的节点赋值给已有的next 属性</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 如果树的阀值大于等于7，也就是，链表长度达到了8（从0开始）。</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">// 如果链表长度达到了8，且数组长度小于64，那么就重新散列，如果大于64，则创建红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="comment">// 结束循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果hash值和next的hash值相同且（key也相同）</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="comment">// 结束循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 如果给定的hash值不同或者key不同。</span></span><br><span class="line">                    <span class="comment">// 将next 值赋给 p，为下次循环做铺垫</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过上面的逻辑，如果e不是null，表示：该元素存在了(也就是他们呢key相等)</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">// 取出该元素的值</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// 如果 onlyIfAbsent 是 true，就不要改变已有的值，这里我们是false。</span></span><br><span class="line">                <span class="comment">// 如果是false，或者 value 是null</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 将新的值替换老的值</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">// HashMap 中什么都不做</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">// 返回之前的旧值</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果e== null，需要增加 modeCount 变量，为迭代器服务。</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 如果数组长度大于了阀值</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">// 重新散列</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// HashMap 中什么都不做</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="comment">// 返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以说是 HashMap 的核心方法，楼主已经在该方法中写满了注释。楼主说一下该方法的步骤：</p>
<ol>
<li>判断数组是否为空，如果是空，则创建默认长度位 16 的数组。</li>
<li>通过与运算计算对应 hash 值的下标，如果对应下标的位置没有元素，则直接创建一个。</li>
<li>如果有元素，说明 hash 冲突了，则再次进行 3 种判断。<ol>
<li>判断两个冲突的key是否相等，equals 方法的价值在这里体现了。如果相等，则将已经存在的值赋给变量e。最后更新e的value，也就是替换操作。</li>
<li>如果key不相等，则判断是否是红黑树类型，如果是红黑树，则交给红黑树追加此元素。</li>
<li>如果key既不相等，也不是红黑树，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果，链表的长度大于等于8了，则将链表改为红黑树，这是Java8 的一个新的优化。</li>
</ol>
</li>
<li>最后，如果这三个判断返回的 e 不为null，则说明key重复，则更新key对应的value的值。</li>
<li>对维护着迭代器的modCount 变量加一。</li>
<li>最后判断，如果当前数组的长度已经大于阀值了。则重新hash。</li>
</ol>
<h2 id="3-通过判断是否含有元素，决定是否创建还是追加链表或树。"><a href="#3-通过判断是否含有元素，决定是否创建还是追加链表或树。" class="headerlink" title="3. 通过判断是否含有元素，决定是否创建还是追加链表或树。"></a><strong>3. 通过判断是否含有元素，决定是否创建还是追加链表或树。</strong></h2><p>首先判断是否含有元素，通过什么判断呢？ </p>
<p>tab[i = (n - 1) &amp; hash]；</p>
<p>这个算式根据 hash 值获取对应的下标，具体是什么原理，我们在上一篇文章已经说了原因。这里也不在赘述了。如果 hash 值没有冲突，则创建一个 Node 对象，参数是hash值，key，value，还有为null 的next 属性。下面是构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>如果没有冲突，后面紧接着就走 ++modCount，然后，判断容量是否大于阀值（默认是12）。如果大于，则调用 resize 方法，重新散列。resize 方法我们后面详细分析。</p>
<h2 id="4-判断已有元素的类型，决定是追加树还是追加链表。"><a href="#4-判断已有元素的类型，决定是追加树还是追加链表。" class="headerlink" title="4. 判断已有元素的类型，决定是追加树还是追加链表。"></a><strong>4. 判断已有元素的类型，决定是追加树还是追加链表。</strong></h2><p>如果 hash 冲突了怎么办？我们刚刚说会有3种判断：</p>
<ol>
<li>判断两个冲突的key是否相等，equals 方法的价值在这里体现了。如果相等，则将已经存在的值赋给变量e。最后更新e的value，也就是替换操作。</li>
<li>如果key不相等，则判断是否是红黑树类型，如果是红黑树，则交给红黑树追加此元素。</li>
<li>如果key既不相等，也不是红黑树，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果，链表的长度大于等于8了，则将链表改为红黑树，这是Java8 的一个新的优化。</li>
</ol>
<p>注意：在链表的循环中，有一个方法 treeifyBin，这个方法在链表长度大于等于8 的时候会调用，那么该方法的内容是什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="comment">// 如果数组是null 或者数组的长度小于 64</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           <span class="comment">// 重新散列</span></span><br><span class="line">           resize();</span><br><span class="line">       <span class="comment">// 如果给定的hash冲突了，则创建红黑树结构</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                   hd = p;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法虽然主要功能是替换链表结构为红黑树，但是在替换前，会先判断，如果数组是 null 或者数组的长度小于 64，则重新散列，因为重新散列会拆分链表，使得链表的长度变短。提高性能。如果长度大于64了。就只能将链表变为红黑树了。</p>
<h2 id="5-判断是否超过阀值，如果超过，则重新散列数组。"><a href="#5-判断是否超过阀值，如果超过，则重新散列数组。" class="headerlink" title="5. 判断是否超过阀值，如果超过，则重新散列数组。"></a><strong>5. 判断是否超过阀值，如果超过，则重新散列数组。</strong></h2><p>最后，判断是否阀值，如果超过则进行散列；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 e == null，需要增加 modeCount 变量，为迭代器服务。</span></span><br><span class="line">++modCount;</span><br><span class="line"><span class="comment">// 如果数组长度大于了阀值</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    <span class="comment">// 重新散列</span></span><br><span class="line">    resize();</span><br><span class="line"><span class="comment">// HashMap 中什么都不做</span></span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="comment">// 返回null</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道，阀值默认是16，那么 resize 方法就是重新散列的核心方法，我们看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果老的容量大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果容量大于容器最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 阀值设为int最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 返回老的数组，不再扩充</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;<span class="comment">// 如果老的容量*2 小于最大容量并且老的容量大于等于默认容量</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 新的阀值也再老的阀值基础上*2</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;<span class="comment">// 如果老的阀值大于0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 新容量等于老阀值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 如果容量是0，阀值也是0，认为这是一个新的数组，使用默认的容量16和默认的阀值12           </span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的阀值是0，重新计算阀值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用新的容量 * 负载因子（0.75）</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 如果新的容量小于最大容量 且 阀值小于最大 则新阀值等于刚刚计算的阀值，否则新阀值为 int 最大值</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 将新阀值赋值给当前对象的阀值。</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">// 创建一个Node 数组，容量是新数组的容量（新容量要么是老的容量，要么是老容量*2，要么是16）</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 将新数组赋值给当前对象的数组属性</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果老的数组不是null</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 循环老数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 定义一个节点</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果老数组对应下标的值不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置为空</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果老数组没有链表</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 将该值散列到新数组中</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果该节点是树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 调用红黑树 的split 方法，传入当前对象，新数组，当前下标，老数组的容量，目的是将树的数据重新散列到数组中</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 如果既不是树，next 节点也不为空，则是链表，注意，这里将优化链表重新散列（java 8 的改进）</span></span><br><span class="line">                  <span class="comment">// Java8 之前，这里曾是并发操作会出现环状链表的情况，但是Java8 优化了算法。此bug不再出现，但并发时仍然不建议HashMap</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 这里的判断需要引出一些东西：oldCap 假如是16，那么二进制为 10000，扩容变成 100000，也就是32.</span></span><br><span class="line">                        <span class="comment">// 当旧的hash值 与运算 10000，结果是0的话，那么hash值的右起第五位肯定也是0，那么该于元素的下标位置也就不变。</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 第一次进来时给链头赋值</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">// 给链尾赋值</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// 重置该变量</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果不是0，那么就是1，也就是说，如果原始容量是16，那么该元素新的下标就是：原下标 + 16（10000b）</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 同上</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 理想情况下，可将原有的链表拆成2组，提高查询性能。</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 销毁实例，等待GC回收</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 置入bucket中</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法可以说还是比较复杂的。初始的时候也是调用的这个方法，当链表数超过8的时候同时数组长度小于64的时候也是调用的这个方法。该方法步骤如下：</p>
<ol>
<li>判断容量是否大于0，如果大于0，并且容量已将大于最大值，则设置阀值为 int 最大值，并返回，如果老的容量乘以 2 小于最大容量，且老的容量大于等于16，则更新阀值。也就是乘以2.</li>
<li>如果老的阀值大于0，则新的容量等于老的阀值。注意：这里很重要。还记的我们之前使用new 操作符的时候，会设置阀值为 2 的幂次方，那么这里就用上了那个计算出来的数字，也就是说，就算我们设置的不是2的幂次方，HashMap 也会自动将你的容量设置为2的幂次方。</li>
<li>如果老的阀值和容量都不大于0，则认为是一个新的数组，默认初始容量为16，阀值为 16 * 0.75f，也就是 12。</li>
<li>如果，新的阀值还是0，那么就使用我们刚刚设置的容量（HashMap 帮我们算的），通过乘以 0.75，得到一个阀值，然后判断算出的阀值是否合法：如果容量小于最大容量并且阀值小于最大容量，那么则使用该阀值，否则使用 int 最大值。</li>
<li>将刚刚的阀值设置打当前Map实例的阀值属性中。</li>
<li>将刚刚的数组设置到当前Map实例的数组属性中。</li>
<li>如果老的数组不是null，则将老数组中的值重新散列到新数组中。如果是null，直接返回新数组。</li>
</ol>
<p>那么，将老鼠组重新散列的过程到底是怎么样的呢？</p>
<h2 id="6-Java-8-重新散列时是如何优化的。"><a href="#6-Java-8-重新散列时是如何优化的。" class="headerlink" title="6. Java 8 重新散列时是如何优化的。"></a><strong>6. Java 8 重新散列时是如何优化的。</strong></h2><p>重新散列的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果老的数组不是null</span></span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 循环老数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        <span class="comment">// 定义一个节点</span></span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">// 如果老数组对应下标的值不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置为空</span></span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果老数组没有链表</span></span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 将该值散列到新数组中</span></span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="comment">// 如果该节点是树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 调用红黑树 的split 方法，传入当前对象，新数组，当前下标，老数组的容量，目的是将树的数据重新散列到数组中</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果既不是树，next 节点也不为空，则是链表，注意，这里将优化链表重新散列（java 8 的改进）</span></span><br><span class="line">              <span class="comment">// Java8 之前，这里曾是并发操作会出现环状链表的情况，但是Java8 优化了算法。此bug不再出现，但并发时仍然不建议HashMap</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="comment">// 这里的判断需要引出一些东西：oldCap 假如是16，那么二进制为 10000，扩容变成 100000，也就是32.</span></span><br><span class="line">                    <span class="comment">// 当旧的hash值 与运算 10000，结果是0的话，那么hash值的右起第五位肯定也是0，那么该于元素的下标位置也就不变。</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 第一次进来时给链头赋值</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="comment">// 给链尾赋值</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        <span class="comment">// 重置该变量</span></span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果不是0，那么就是1，也就是说，如果原始容量是16，那么该元素新的下标就是：原下标 + 16（10000b）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 同上</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 理想情况下，可将原有的链表拆成2组，提高查询性能。</span></span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 销毁实例，等待GC回收</span></span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 置入bucket中</span></span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里楼主重新贴了上面的代码，因为这段代码比较重要。还是说一下该部分代码的步骤。</p>
<ol>
<li>首先循环老数组。下标从0开始，如果对应下标的值不是null，则判断该值有没有next 节点，也就是判断是否是链表。</li>
<li>如果不是链表，则根据新的数组长度重新hash该元素。</li>
<li>如果该节点是树，则调用红黑树的 split 方法，传入当前对象和新数组还有下标，该方法会重新计算红黑树中的每个hash值，如果重新计算后，树中元素的hash值不同，则重新散列到不同的下标中。达到拆分红黑树的目的，提高性能。具体如何拆分下面再说。</li>
<li>之后的判断就是链表，在Java8中，该部分代码不是简单的将旧链表中的数据拷贝到新数组中的链表就完了，而是会对旧的链表进行重新 hash，如果 hash 得到的值和之前不同，则会从旧的链表中拆出，放到另一个下标中去，提高性能，刚刚的红黑树也是这么做的。</li>
</ol>
<p>这里的重新hash 不是使用的 [e.hash &amp; (newCap - 1)]  方法，而是使用更加效率的方法，直接 hash 老的数组容量，就没有了减一的操作，可见 JDK 的作者为了性能可以说是无所不用其极了。</p>
<p>其实我们的注释已经写了，但是楼主还是再解释一遍吧：</p>
<p>仔细阅读下面这段话：</p>
<p>oldCap 假如是16，那么二进制为 10000，扩容变成 100000，也就是32.当旧的hash值 与运算 10000，结果是0的话，那么hash值的右起第五位肯定也是0，那么该于元素的下标位置也就不变。但如果不是0是1的话，说明该hash值变化了，那么就需要对这个元素重新散列放置。那么应该放哪里呢？如果是16，那么最左边是1的话，说明hash值变大了16，那么只需要在原有的基础上加上16便好了。</p>
<p>这段代码还有一个需要注意的地方：在JDK 7 中，这里的的代码是不同的，在并发情况下会链表会变成环状，形成死锁。而JDK 8 已经修复了该问题，但是仍然不建议使用 HashMap 并发编程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>截至到这里，我们的 HashMap 的 put 方法已经剖析完了，此次可以说收获不小：</p>
<p>我们知道了，无论我们如何设置初始容量，HashMap 都会将我们改成2的幂次方，也就是说，HashMap 的容量百分之百是 2的幂次方，因为HashMap 太依赖他了。但是，请注意：如果我们预计插入7条数据，那么我们写入7，HashMap 会设置为 8，虽然是2的幂次方，但是，<strong>请注意</strong>，当我们放入第7条数据的时候，就会引起扩容，造成性能损失，所以，知晓了原理，我们以后在设置容量的时候还是自己算一下，比如放7条数据，我们还是都是设置成16，这样就不会扩容了。</p>
<p>HashMap 的默认加载因子是 0.75，虽然可以修改，但是出于安全考虑，除非你经过大量测试，请不要修改此值，HashMap 使用此值基本是平衡了性能和空间的取舍。</p>
<p>HashMap 扩容的时机是，容器中的元素数量  &gt; 负载因此 * 容量，如果负载因子是0.75，容量是16，那么当容器中数量达到13 的时候就会扩容。还有，如果某个链表长度达到了8，并且容量小于64，则也会用扩容代替红黑树。</p>
<p>HashMap 在 JDK 7 中并发扩容的时候是非常危险的，非常容易导致链表成环状。但 JDK 8 中已经修改了此bug。但还是不建议使用。强烈推荐并发容器 ConcurrentHashMap。</p>
<p>HashMap 扩容的时候，不管是链表还是红黑树，都会对这些数据进行重新的散列计算，然后缩短他们的长度，优化性能。在进行散列计算的时候，会进一步优化性能，减少减一的操作，直接使用&amp; 运算。可谓神来之笔。</p>
<p>总之，HashMap 中的优秀的设计思想值得我们去学习，最让楼主震惊的就是那个将任意一个数变成了2的幂次方的数，并且该数字很合理，说实话，如果让楼主写，楼主是写不出来的。</p>
<p>所以，请努力吧，现在做不到，不代表以后做不到，通过学习优秀的源码，一定能够提高我们的编码能力。</p>
<p>加油加油！！！！！！</p>
<p>对了，今天是 2017年的最后一天，明天就是2018 年了，借这篇文章祝大家新年快乐。每个人都能实现自己的新年愿望。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-源码剖析-线程池-实现原理</title>
    <url>/2018/01/05/2018/2018-01-05-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       在上一篇文章中我们介绍了线程池的使用，那么现在我们有个疑问：线程池到底是怎么实现的？毕竟好奇是人类的天性。那我们今天就来看看吧，扒开 他的源码，一探究竟。

<h2 id="1-从-Demo-入手"><a href="#1-从-Demo-入手" class="headerlink" title="1. 从 Demo 入手"></a>1. 从 Demo 入手</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-949e805bf8642a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图是个最简单的demo，我们从这个 demo 开始看源码，首先一步一步来看。</p>
<p>首先我们手动创建了线程池，使用了有数量限制的阻塞队列，使用了线程池工厂提供的默认线程工厂，和一个默认的拒绝策略，我们看看默认的线程工厂是如何创建的？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ed51d424fa5ea7e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-912795ee963d4f4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>默认的线程工厂从当前线程中获取线程组，设置了默认的线程名字前缀 pool-xxx-thread-xxx，强制设置为非守护线程，强制设置为默认优先级。</p>
<p>然后我们看看ThreadPoolExecutor 的构造方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ce568d2da4345871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>没有什么特殊的东西，主要是一些判断。</p>
<p>好了，那么我们看看 execute 方法是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// c = -536870911</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//  工作线程数量小于核心线程池设定数，则创建线程。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 如果添加成功则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 否则再次获取活动线程数量</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池正在运行，并且添加进队列成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次对线程池状态检查， 因为上面 addWorker 过了并且失败了，所以需要检查</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果状态不是运行状态，且从队列删除该任务成功并尝试停止线程池</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 拒绝任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果当前工作线程数量为0（线程池已关闭），则添加一个 null 到队列中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 添加个空的任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果添加队列失败，则创建一个任务线程，如果失败，则拒绝</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 拒绝</span></span><br><span class="line">        reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，空判断。</p>
<p>然后判断，如果正在工作的线程小于设置的核心线程，则创建线程并返回，如果正在工作的线程数量大于等于核心线程数量，则试图将任务放入队列，如果失败，则尝试创建一个 maximumPoolSize 的任务。注意，在remove 方法中，该方法已经试图停止线程池的运行。</p>
<p>从这段代码中，可以看到，最重要的方法就是 addWorker 和 workQueue.offer(command) 这段代码，一个是创建线程，一个是放入队列。后者就是将任务添加到阻塞队列中。</p>
<p>那么我们就看看 addWorker 方法。</p>
<h2 id="2-addWorker-方法—–创建线程池"><a href="#2-addWorker-方法—–创建线程池" class="headerlink" title="2. addWorker 方法—–创建线程池"></a>2. addWorker 方法—–创建线程池</h2><p>private boolean addWorker(Runnable firstTask, boolean core)</p>
<p>该方法很长，楼主说一下这个方法的两个参数，第一个参数为 Runnable 类型，表示线程池中某个线程的第一个任务，第二个参数是如果是 true，则创建 core 核心线程，如果是 false ，则创建 maximumPoolSize 线程。这两个线程的生命周期是不同的。</p>
<p>楼主截取该方法中最终的代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5acf0ebbb6ade295.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>其中，在该方法中，创建一个 Worker 对象，该对象代理了任务对象，我们看看该类的构造方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-18f53ffe983616e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>通过线程工厂创建线程，注意，传递的是 this ，因此，在上面的代码中国，调用了 worker 对象的 thread 属性的 start 方法，实际上就是调用了该类的 run 方法。那么改类的 run 方法是怎么实现的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2199e01f35524889.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>调用了自身的 runWorker 方法。这个方法非常的重要。</p>
<h2 id="3-Worker-runWorker-Worker-w-方法——-线程池的最核心方法"><a href="#3-Worker-runWorker-Worker-w-方法——-线程池的最核心方法" class="headerlink" title="3. Worker.runWorker(Worker w) 方法——-线程池的最核心方法"></a>3. Worker.runWorker(Worker w) 方法——-线程池的最核心方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先说该方法的主要逻辑：</p>
<ol>
<li>首先执行 firstTask 的 run 方法。</li>
<li>然后循环获取阻塞队列中的任务，并调用他们的 run 方法。</li>
<li>如果线程池中的任务异常，就抛出异常并停止运行线程池。</li>
</ol>
<p>这个方法可以说就是线程池的核心，在最开始的设定的核心任务数都是直接调用 start 方法启动线程的，启动之后，这个线程并不关闭，而是一直在阻塞队列上等待，如果有任务就执行任务的run 方法，而不是 start 方法，这点很重要。</p>
<p>而该方法中有几个注意的地方就是线程池留给我们扩展的，在执行任务之前，会执行 beforeExecute 方法，该方法默认为空，我们可以实现该方法，在任务执行结束后，在 finally 块中有 afterExecute 方法，同样也是空的，我们可以扩展。</p>
<p>楼主看到这里的代码后，大为赞叹，Doug Lea 可以说神一般的人物。</p>
<p>那么，线程池还有一个方法， submit 是如何实现的呢？其实核心逻辑也是 runWorker 方法，不然楼主也不会说这个方法是线程池的核心。</p>
<p>那我们看看 submit 方法是如何实现的。</p>
<h2 id="4-submit-方法实现原理。"><a href="#4-submit-方法实现原理。" class="headerlink" title="4. submit 方法实现原理。"></a>4. submit 方法实现原理。</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-675163f0bf1a0a02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法最终也是走 execute 方法的，因此逻辑基本相同，不同的是什么呢？我们看看。我们看到，第二行代码创建了 一个 RunnableFuture 对象，RunnableFuture 是一个接口，具体的实现是什么呢？我们看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7c725853248a3f5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FutureTask "></p>
<p>FutureTask 对象，该对象也是一个线程对象：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8bb60a3d51b44412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>那我们就看看该方法的 run 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0bdc22fde7a15b74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法核心逻辑楼主已经框起来了，其中调用了 call 方法，返回一个返回值，并在set 方法中，将返回值设置在一个变量中，如果是异常，则将异常设置在变量中。我们看看set方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6d9a00b0ca834d9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法通过CAS将任务状态状态从new变成 COMPLETING，然后，设置 outcome 变量，也就是返回值。最后，调用 finishCompletion 方法，完成一些变量的清理工作。</p>
<p>那么，如果从submit 中获得返回值呢？这要看get方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-fe99316fac59b618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法会判断状态，如果状态还没有完成，那么就调用  awaitDone 方法等待，如果完成了，调用 report 返回值结果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-975dbf7d534f9c7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>看见了刚刚设置的 outcome 变量，如果状态正常，则直接返回，如果状态为取消，则抛出异常，其余情况也抛出异常。</p>
<p>我们回到 awaitDone 方法，看看该方法如何等待的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-695e75b79482558e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法有一个死循环，直到有一个确定的状态返回，如果状态大于 COMPLETING ，也就是 成功了，就返回该状态，如果正在进行中，则让出CPU时间片进行等待。如果都不是，则让该线程阻塞等待。在哪里唤醒呢？在 finishCompletion 方法中会唤醒该线程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3ccaa542a17cd88c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法循环了等待线程链表的链表，并唤醒链表中的每个线程。</p>
<p>还有一个需要的注意的地方就是，在任务执行完毕会执行 done 方法，JDK 默认是空的，我们可以扩展该方法。比如 Spring 的并发包 org.springframework.util.concurrent 就有2个类重写了该方法。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>好了，到这里，线程池的基本实现原理我们知道了，也解开了楼主一直以来的疑惑，可以说，线程池的核心方法就是 runWorker 方法 配合 阻塞队列，当线程启动后，就从队列中取出队列中的任务，执行任务的 run 方法。可以说设计的非常巧妙。而回调线程 callback 也是通过该方法，JDK 封装了 FutureTask 类来执行他们的 call 方法。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-CAS-的原理</title>
    <url>/2018/01/07/2018/2018-01-07-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-CAS-%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       在并发编程中，锁是消耗性能的操作，同一时间只能有一个线程进入同步块修改变量的值，比如下面的代码

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  a = a + b；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不加 synchronized 的话，多线程修改 a 的值就会导致结果不正确，出现线程安全问题。但锁又是要给耗费性能的操作。不论是拿锁，解锁，还是等待锁，阻塞，都是非常耗费性能的。那么能不能不加锁呢？</p>
<p>可以。</p>
<p>什么意思呢？我们看上面的代码，分为几个步骤：</p>
<ol>
<li>读取a</li>
<li>将 a 和 b 相加</li>
<li>将计算的值赋值给a。</li>
</ol>
<p>我们知道，这不是一个原子的操作，多线程上面时候会出问题：当两个线程同时访问 a ，都得到了a 的值，并且通知对a 加  1，然后同时将计算的值赋值给a，这样就会导致 a 的值只增加了1，但实际上我们想加 2. </p>
<p>问题出在哪里？第三步，对 a 赋值操作，如果有一种判断，判断 a 已经别的线程修改，你需要重新计算。比如下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> backup = a;</span><br><span class="line">   <span class="keyword">int</span> c = a + b;</span><br><span class="line">   compareAndSwap(a, backup, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> backup ,<span class="keyword">int</span> c )</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (a == backup) &#123;</span><br><span class="line">           a = c;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中，我们看到，我们备份了 a 的值，并且对 a 进行计算，如果 a 的值和备份的值一致，说明 a 没有被别的线程更改过，这个时候就可以进行修改了。</p>
<p>这里有个问题：compareAndSwap 方法有多步操作，不是原子的，并且没有使用锁，如何保证线程安全。其实楼主这里只是伪代码。下面就要好好说说什么是 CAS (compareAndSwap);</p>
<h2 id="1-什么是-CAS"><a href="#1-什么是-CAS" class="headerlink" title="1. 什么是 CAS"></a>1. 什么是 CAS</h2><p>CAS （compareAndSwap），中文叫比较交换，一种无锁原子算法。过程是这样：它包含 3 个参数 CAS（V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后，CAS 返回当前V的真实值。CAS 操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。</p>
<p>当多个线程同时使用CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。</p>
<p>与锁相比，使用CAS会使程序看起来更加复杂一些，但由于其非阻塞的，它对死锁问题天生免疫，并且，线程间的相互影响也非常小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，他要比基于锁的方式拥有更优越的性能。</p>
<p>简单的说，CAS 需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，哪说明它已经被别人修改过了。你就需要重新读取，再次尝试修改就好了。</p>
<p>那么这个CAS 是如何实现的呢？也就是说，比较和交换实际上是两个操作，如何变成一个原子操作呢？</p>
<h2 id="2-CAS-底层原理"><a href="#2-CAS-底层原理" class="headerlink" title="2. CAS 底层原理"></a>2. CAS 底层原理</h2><p>这样归功于硬件指令集的发展，实际上，我们可以使用同步将这两个操作变成原子的，但是这么做就没有意义了。所以我们只能靠硬件来完成，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。这类指令常用的有：</p>
<ol>
<li>测试并设置（Tetst-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap）</li>
<li>加载链接/条件存储（Load-Linked/Store-Conditional）</li>
</ol>
<p>其中，前面的3条是20世纪时，大部分处理器已经有了，后面的2条是现代处理器新增的。而且这两条指令的目的和功能是类似的，在IA64，x86 指令集中有 cmpxchg 指令完成 CAS 功能，在 sparc-TSO 也有 casa 指令实现，而在 ARM 和 PowerPC 架构下，则需要使用一对 ldrex/strex 指令来完成 LL/SC 的功能。</p>
<p>CPU 实现原子指令有2种方式：</p>
<ol>
<li><p>通过总线锁定来保证原子性。<br>总线锁定其实就是处理器使用了总线锁，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器咋总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。但是该方法成本太大。因此有了下面的方式。</p>
</li>
<li><p>通过缓存锁定来保证原子性。<br>所谓 缓存锁定 是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当他执行锁操作写回到内存时，处理器不在总线上声言 LOCK# 信号，而时修改内部的内存地址，并允许他的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
</li>
</ol>
<p>注意：有两种情况下处理器不会使用缓存锁定。</p>
<ol>
<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用<strong>总线锁定</strong>。</li>
<li>有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。</li>
</ol>
<h2 id="3-Java-如何实现原子操作"><a href="#3-Java-如何实现原子操作" class="headerlink" title="3. Java 如何实现原子操作"></a>3. Java 如何实现原子操作</h2><p>java 在 1.5 版本中提供了 java.util.concurrent.atomic 包，该包下所有的类都是原子操作：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6bf9d7a6505bb43e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java.util.concurrent.atomic 包"></p>
<p>如何使用呢？看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    AtomicInteger integer = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    System.out.println(integer.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">      threads[j] = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">          integer.incrementAndGet()</span><br><span class="line">      );</span><br><span class="line">      threads[j].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">      threads[j].join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(integer.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，我们启动了1000个线程对 AtomicInteger 变量做了自增操作。结果是我们预期的1000，表示没有发生同步问题。</p>
<p>我们看看他的内部实现，我们找到该类的 compareAndSet 方法，也就是比较并且设置。我们看看该方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f1b8697b61f89c7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该方法调用了 unsafe 类的 compareAndSwapInt 方法，有几个参数，一个是该变量的内存地址，一个是期望值，一个是更新值，一个是对象自身。完全符合我们之前CAS 的定义。那么 ，这个 unsafe 又是什么呢？</p>
<p>该类在 rt.jar 包中，但不在我们熟悉的 java 包下，而是 sun.misc 包下。并且都是 class 文件，注释都没有，符合他的名字：不安全。</p>
<p>我们能构造他吗？不能，除非反射。</p>
<p>我们看看他的源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5ab914579599ef93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c66a404014d95e94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>getUnsafe 方法中，会检查调用 getUnsafe 方法的类，如果这个类的 ClassLoader 不为null ，就直接抛出异常，什么情况下会为null呢？当类加载器是 Bootstrap 加载器的时候，Bootstrap 加载器是没有对象的，也就是说，加载这个类极有可能是 rt.jar 下的。</p>
<p>而在最新的 Java 9 当中，该类已经被隐藏。因为该类使用了指针。但指针的缺点就是不安全。</p>
<h2 id="4-CAS-的缺点"><a href="#4-CAS-的缺点" class="headerlink" title="4. CAS 的缺点"></a>4. CAS 的缺点</h2><p>CAS 看起来非常的吊，但是，他仍然有缺点，最著名的就是 ABA 问题，假设一个变量 A ，修改为 B之后又修改为 A，CAS 的机制是无法察觉的，但实际上已经被修改过了。如果在基本类型上是没有问题的，但是如果是引用类型呢？这个对象中有多个变量，我怎么知道有没有被改过？聪明的你一定想到了，加个版本号啊。每次修改就检查版本号，如果版本号变了，说明改过，就算你还是 A，也不行。</p>
<p>在 java.util.concurrent.atomic 包中，就有 AtomicReference 来保证引用的原子性，但楼主觉得有点鸡肋，不如使用同步加互斥，可能会更加高效。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们从各种角度理解了CAS 的原理，该算法特别的重要，从CPU 都特别的设计一条指令来实现可见一斑。而JDK的源码中，到处都 unSafe 的 CAS 算法，可以说，如果没有CAS ，就没有 1.5 的并发容器。好，今天就到这里。</p>
<p>good luck ！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-锁的优化有哪些</title>
    <url>/2018/01/07/2018/2018-01-07-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在 JDK 1.6 之前，synchronized 性能令人担忧，但是 1.6 之后，JVM 团队针对 synchronized 做了很多的优化，让 synchroized 在性能层面相比较 ReentrantLock 不相上下。那么，JVM 团队做了哪些优化呢？


<p>首先说，怎么才能优化？我们知道，“锁” 其实是互斥同步的具体实现，而互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要用户态转到内核态来完成。这些操作给系统的并发性能带来了很大的压力。</p>
<p>所以，优化的方向就是减少线程的阻塞，因为挂起线程和恢复线程需要切换到操作系统的内核状态。</p>
<p>Java 1.6 为了减少获得锁和释放锁带来的性能损耗，引入了 “偏向锁“ 和 ”轻量级锁“ ，在 Java SE 1.6 中，锁一共有4个状态，从低到高依次是：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态。这几个状态会随着竞争情况逐渐升级（即膨胀）。注意：锁升级之后不能降级（具体原因后面讲）。</p>
<ol>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
<li>锁消除</li>
<li>锁粗化</li>
<li>除了虚拟机，程序员自己如何优化锁</li>
</ol>
<h2 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1. 偏向锁"></a><strong>1. 偏向锁</strong></h2><p>虚拟机的团队根据经验发现，大多数情况下，锁不仅不存在多线程竞争，而且总是有同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单的测试一下对象头的 “Mark Word” 里是否存储着指向当前线程的偏向锁。</p>
<p>如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置了1（表示当前还是偏向锁）：如果没有设置，则使用CAS 竞争锁；如果设置了，则尝试使用CAS 将对象头的偏向锁指向当前线程。</p>
<p>可以说，偏向锁的 “偏”，就是偏心的 “偏”，他的意思就是这个锁会偏向于第一个获得他的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将<strong>永远不需要同步</strong>。</p>
<p>当有另外要给线程去尝试获取这个锁时，偏向模式宣告结束，后续的操作将升级为轻量级锁。</p>
<p>注意：偏向锁可以提高有同步但无竞争的程序性能，他同样有缺陷：如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。1.6之后的虚拟机默认启用偏向锁，可以使用JVM参数来关闭：-XX：-UseBiasedLocking=false；程序将默认进入轻量级锁状态。</p>
<p>可以看到，Mark Word 是实现偏向锁的关键。而后面的轻量级锁也是通过这个实现的。</p>
<h2 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2. 轻量级锁"></a><strong>2. 轻量级锁</strong></h2><p>什么是轻量级锁呢？ “轻量级” 是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制称为 “重量级” 锁。 首先需要强调一点，轻量级锁并不是用来代替重量级锁的，他的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗。</p>
<p>线程在执行同步块之前，JVM 会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word. 然后线程尝试使用CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。</p>
<p>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便会尝试使用自旋来获取锁，注意：这里线程并没有挂起自己，而是通过一定次数的自旋（默认10次，可以使用 -XX：PreBlockSpin 修改），防止切换到内核态导致的开销。</p>
<p>如果有2个以上的线程争用同一把锁，那么轻量级锁将会失效，升级到重量级锁。</p>
<p>那么为什么升级到重量级锁之后不能降级呢？假设一下：如果锁升级到重量级之后，拿到锁的某个线程被阻塞了，等待了很久，那么轻量级线程将会一直自旋等待，消耗CPU性能。所以，在升级到重量级锁后，就不能降级了，防止轻量级锁自旋消耗CPU。</p>
<p>可以看到偏向锁和轻量级锁的差别，偏向锁在第一个线程拿到锁之后，将把线程ID 存储在对象头中，后面的所有操作都不是同步的，相当于无锁。而轻量级锁，每次获取锁的时候还是需要使用CAS来修改对象头的记录，在没有线程竞争的情况下，这个操作是很轻量的，不需要使用操作系统的互斥机制。</p>
<h2 id="3-重量级锁"><a href="#3-重量级锁" class="headerlink" title="3. 重量级锁"></a><strong>3. 重量级锁</strong></h2><p>相比较轻量级锁是通过自旋来获取锁的，重量级锁则是通过操作系统将线程切换到内核态并阻塞来实现的。代价十分高昂。</p>
<p>下面看看各个锁的优缺点对比：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行时间较长</td>
</tr>
</tbody></table>
<p>什么时候使用什么锁，大家可以看看。</p>
<h2 id="4-锁消除"><a href="#4-锁消除" class="headerlink" title="4. 锁消除"></a><strong>4. 锁消除</strong></h2><p>什么是锁消除呢？指的是 JIT 编译器在运行时，对一些没有必要同步的代码却同步了的锁进行消除。可以说时一种彻底的锁优化。通过锁消除，可以节省毫无意义的请求锁时间。</p>
<p>那么你们一定会问，谁会这么傻，不需要同步还去同步啊？</p>
<p>请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] createStrings(String[] args) &#123;</span><br><span class="line">  Vector&lt;String&gt; v = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    v.add(Integer.toString(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v.toArray(<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：v 变量只在这一个方法中使用，只是一个单纯的局部变量，分配在栈中，也就没有线程安全的说法，任何同步都是没有必要的，而Vector 的add 操作都是同步的。所以虚拟机检测到这个情况，会将锁去除。</p>
<p>锁消除涉及一个技术：逃逸分析。所谓逃逸分析就是观察某一个变量十分会逃出某一个作用域。在本例中，变量v没有逃出函数外，如果函数返回的不是 string 数组，而是 v 本身，那么就任务 v 逃逸出了当前函数。也就是说 v 可能被其他线程访问。如果是这样，虚拟机就不能消除 v 的锁操作。</p>
<h2 id="5-锁粗化"><a href="#5-锁粗化" class="headerlink" title="5. 锁粗化"></a><strong>5. 锁粗化</strong></h2><p>原则上，我们在编写代码的时候，总是推荐将同步块尽可能的小。这样是为了使得需要同步的操作数量小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况下，这个原则是正确的。如果如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁的同步操作也会导致不必要的性能损耗。</p>
<p>如果虚拟机探测到很多零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。即加大了同步块。</p>
<h2 id="6-除了虚拟机，程序员自己如何优化锁"><a href="#6-除了虚拟机，程序员自己如何优化锁" class="headerlink" title="6. 除了虚拟机，程序员自己如何优化锁"></a><strong>6. 除了虚拟机，程序员自己如何优化锁</strong></h2><ol>
<li>减小锁的持有时间。</li>
<li>减小锁的粒度。</li>
<li>使用读写锁替换独占锁</li>
<li>锁分离</li>
</ol>
<ol>
<li>减小锁的持有时间。</li>
</ol>
<p>其实这个很简单，你的锁持有的时间长，后面的线程等待的时间就长，一个线程等待1秒，10000个线程就多等待了10000秒，因此，只在必要时进行同步，这样就能明显减少线程持有锁的时间。提高系统的吞吐量。</p>
<ol start="2">
<li>减小锁的粒度。</li>
</ol>
<p>这个和我们上面说的虚拟机帮助我们粗化时反的。但是，我们说，大部分情况下，减小锁的粒度也削弱多线程竞争的有效手段，比如 ConcurrentHashMap，他只锁住了 Hash 桶中的某一个桶，不像HashTable 一样锁住整个对象。</p>
<ol start="3">
<li>使用读写锁替换独占锁</li>
</ol>
<p>我们之前在说 Java 世界的三把锁的时候说哪三把锁，内置锁，重入锁，读写锁，就是我们现在说的读写锁 ReadWriteLock，使用读写锁来替代独占锁是减小锁粒度的一种特殊情况，在读多写少的场合，读写锁对系统性能是有好处的。可以有效提高系统的并发能力。因为读操作不会影响数据的完整性和一致性，就像 ConcurrentHashMap 的 get 方法一样，根本不需要加锁，这个时候又要说说 HashTable ，该容器连 get 方法都加锁。你可以想象一下。</p>
<ol start="4">
<li>锁分离</li>
</ol>
<p>如果将读写锁进一步延伸，就是锁分离，读写锁根据读写操作功能的不同，进行了有效的分离。而 JDK 的 LinkedBlockingQueue 则是锁分离的最佳实践。在进行 take 操作和 put 操作使用了两把不同的锁。因为他们之间根本没有竞争关系，或者说，使用队列的数据结构，将原本耦合的业务分离了。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h2><p>今天我们总结了一些锁的优化，有虚拟机的优化，比如偏向锁，轻量级锁，自旋锁，锁粗化，锁消除， 也有我们自己的优化策略，需要平时写代码的时候注意，比如减少锁的持有时间，减小锁的粒度，在读多写少的场合使用读写锁，尽量通过合理的设计分离锁。</p>
<p>总之，并发是门艺术。如何提高并发的性能是每个高级程序员的追求。</p>
<p>good luck ！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-ConcurrentHashMap（JDK-1-8）-putVal-源码分析</title>
    <url>/2018/01/07/2018/2018-01-07-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-ConcurrentHashMap%EF%BC%88JDK-1-8%EF%BC%89-putVal-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       我们之前分析了Hash的源码，主要是 put 方法。同时，我们知道，HashMap 在并发的时候是不安全的，为什么呢？因为当多个线程对 Map 进行扩容会导致链表成环。不单单是这个问题，当多个线程相同一个槽中插入数据，也是不安全的。而在这之后，我们学习了并发编程，而并发编程中有一个重要的东西，就是JDK 自带的并发容器，提供了线程安全的特性且比同步容器性能好出很多。一个典型的代表就是 ConcurrentHashMap，对，又是 HashMap ，但是这个 Map 是线程安全的，那么同样的，我们今天就看看该类的 put 方法是如何实现线程安全的。

<h2 id="源码加注释分析-putVal-方法"><a href="#源码加注释分析-putVal-方法" class="headerlink" title="源码加注释分析 putVal 方法"></a>源码加注释分析 putVal 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">       <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 死循环执行</span></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">               <span class="comment">// 初始化</span></span><br><span class="line">               tab = initTable();</span><br><span class="line">           <span class="comment">// 获取对应下标节点，如果是kong，直接插入</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// CAS 进行插入</span></span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果 hash 冲突了，且 hash 值为 -1，说明是 ForwardingNode 对象（这是一个占位符对象，保存了扩容后的容器）</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="comment">// 如果 hash 冲突了，且 hash 值不为 -1</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               V oldVal = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">// 同步 f 节点，防止增加链表的时候导致链表成环</span></span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="comment">// 如果对应的下标位置 的节点没有改变</span></span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       <span class="comment">// 并且 f 节点的hash 值 不是大于0</span></span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">// 链表初始长度</span></span><br><span class="line">                           binCount = <span class="number">1</span>;</span><br><span class="line">                           <span class="comment">// 死循环，直到将值添加到链表尾部，并计算链表的长度</span></span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, <span class="keyword">null</span>);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 如果 f 节点的 hasj 小于0 并且f 是 树类型</span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 链表长度大于等于8时，将该节点改成红黑树树</span></span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">       addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>楼主在代码中写了很多注释，但是还是说一下步骤（该方法和HashMap 的高度相似，但是多了很多同步操作）。</p>
<ol>
<li>校验key value 值，都不能是null。这点和 HashMap 不同。</li>
<li>得到 key 的 hash 值。</li>
<li>死循环并更新 tab 变量的值。</li>
<li> 如果容器没有初始化，则初始化。调用 initTable 方法。该方法通过一个变量 + CAS 来控制并发。稍后我们分析源码。</li>
<li>根据 hash 值找到数组下标，如果对应的位置为空，就创建一个 Node 对象用CAS方式添加到容器。并跳出循环。</li>
<li>如果 hash 冲突，也就是对应的位置不为 null，则判断该槽是否被扩容了（-1 表示被扩容了），如果被扩容了，返回新的数组。</li>
<li>如果 hash 冲突 且 hash 值不是 -1，表示没有被扩容。则进行链表操作或者红黑树操作，注意，这里的 f 头节点被锁住了，保证了同时只有一个线程修改链表。防止出现链表成环。</li>
<li>和 HashMap 一样，如果链表树超过8，则修改链表为红黑树。</li>
<li>将数组加1（CAS方式），如果需要扩容，则调用 transfer 方法（非常复杂，以后再详解）进行移动和重新散列，该方法中，如果是槽中只有单个节点，则使用CAS直接插入，如果不是，则使用 synchronized 进行同步，防止并发成环。</li>
</ol>
<p>这里说一说 initTable 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 小于0说明被其他线程改了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 修改 sizeCtl 的值为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// sc 在初始化的时候用户可能会自定义，如果没有自定义，则是默认的</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 创建数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// sizeCtl 计算后作为扩容的阀值</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法为了在并发环境下的安全，加入了一个 sizeCtl 变量来进行判断，只有当一个线程通过CAS修改该变量成功后（默认为0，改成 -1），该线程才能初始化数组。保证了初始化数组时的安全性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ConcurrentHashMap 是并发大师 Doug Lea 的杰作，可以说鬼斧神工，总的来说，使用了 CAS 加 synchronized 来保证了 put 操作并发时的危险（特别是链表），相比 同步容器 hashTable 来说，如果容器大小是16，并发的性能是他的16倍，注意，读的时候是没有锁的，完全并发，而 HashTable 在 get 方法上直接加上了 synchronized 关键字，性能差距不言而喻。</p>
<p>当然，楼主这篇文章可能之写到了 ConcurrentHashMap 的皮毛，关于如何扩容，楼主没有详细介绍，而楼主在阅读源码的收获也很多，发现了很多有趣的东西，比如 ThreadLocalRandom 类在 addCount 方法中的应用，大家可以看看该类，非常的实用。</p>
<p>注意：这篇文章仅仅是 ConcurrentHashMap 的开头，关于 ConcurrentHashMap 里面的精华太多，值得我们好好学习。</p>
<p>good luck ！！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-LinkedBolckingQueue-源码剖析</title>
    <url>/2018/01/08/2018/2018-01-08-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-LinkedBolckingQueue-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       JDK 1.5 之后，Doug Lea 大神为我们写了很多的工具，整个 concurrent 包基本都是他写的。也为我们程序员写好了很多工具，包括我们之前说的线程池，重入锁，线程协作工具，ConcurrentHashMap 等等，今天我们要讲的是和 ConcurrentHashMap 类似的数据结构，LinkedBolckingQueue，阻塞队列。在生产者消费者模型中，该类可以帮助我们快速的实现业务功能。

<ol>
<li>如何使用？</li>
<li>源码分析</li>
</ol>
<h2 id="1-如何使用？"><a href="#1-如何使用？" class="headerlink" title="1. 如何使用？"></a>1. 如何使用？</h2><p>我们在生产者消费者模型，生产者向一个数据共享通道存放数据，消费者从相同的数据共享通道获取数据，将生产和消费完全隔离，不仅是生产者消费者，现在流行的消息队列，比如各种MQ，kafka，和这个都差不多。废话不多说，直接来个demo ，看看怎么使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LinkedBlockingQueue linkedBlockingQueue = <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; ; j++) &#123;</span><br><span class="line">          linkedBlockingQueue.put(num + <span class="string">&quot;号线程的&quot;</span> + j + <span class="string">&quot;号商品&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;消费了&quot;</span> + linkedBlockingQueue.take());</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">消费了0号线程的0号商品</span><br><span class="line">消费了3号线程的0号商品</span><br><span class="line">消费了2号线程的0号商品</span><br><span class="line">消费了1号线程的0号商品</span><br><span class="line">消费了4号线程的0号商品</span><br><span class="line">消费了2号线程的1号商品</span><br><span class="line">消费了1号线程的1号商品</span><br><span class="line">消费了0号线程的1号商品</span><br><span class="line">消费了3号线程的1号商品</span><br><span class="line">消费了4号线程的1号商品</span><br><span class="line">消费了1号线程的2号商品</span><br><span class="line">消费了0号线程的2号商品</span><br><span class="line">消费了2号线程的2号商品</span><br><span class="line">消费了3号线程的2号商品</span><br><span class="line">消费了4号线程的2号商品</span><br><span class="line">·········</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们使用了5条线程分别向队列中插入数据，也就是一个字符串，然后让5个线程从队列中取出数据并打印，可以看到，生产者插入的数据从消费者线程中被打印，没有漏掉一个。</p>
<p>注意，这里的 put 方法和 take 方法都是阻塞的，不然就不是阻塞队列了，什么意思呢？如果队列满了，put 方法就会等待，直到队列有空为止，因此该方法使用时需要注意，如果业务即时性很高，那么最好使用带有超时选项的 offer （V，long，TimeUnit），方法，同样， take 方法也是如此，当队列中没有的时候，就会阻塞，直到队列中有数据为止。同样可以使用 poll（long, TimeUnit）方法超时退出。</p>
<p>当然不止这几个方法，楼主将常用的方法总结一下：</p>
<p>插入方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 如果满了，立即返回false</span></span><br><span class="line"><span class="keyword">boolean</span> b = linkedBlockingQueue.offer(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 如果满了，则等待到给定的时间，如果还满，则返回false</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = linkedBlockingQueue.offer(<span class="string">&quot;&quot;</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">// 阻塞直到插入为止</span></span><br><span class="line">linkedBlockingQueue.put(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>取出方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果队列为空，直接返回null</span></span><br><span class="line">Object o3 = linkedBlockingQueue.poll();</span><br><span class="line"><span class="comment">// 如果队列为空，一直阻塞到给定的时间</span></span><br><span class="line">Object o1 = linkedBlockingQueue.poll(<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">// 阻塞，直到取出数据</span></span><br><span class="line">Object o = linkedBlockingQueue.take();</span><br><span class="line"><span class="comment">// 获取但不移除此队列的头；如果此队列为空，则返回 null。</span></span><br><span class="line">Object peek = linkedBlockingQueue.peek();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么这些方法内部是如何实现的呢？</p>
<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>阻塞队列，重点看 put 阻塞方法和 take 阻塞方法。</p>
<h5 id="put-方法："><a href="#put-方法：" class="headerlink" title="put 方法："></a>put 方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">         * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">         * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">         * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">         * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">         * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法步骤如下：</p>
<ol>
<li>根据给定的值创建一个 Node 对象，该对象有2个属性，一个是 item，一个是 Node 类型的 next，是链表结构的节点。</li>
<li>获取 put 的锁，注意，这里，put 锁和 take 锁是分开的。也就是说，当你插入的时候和取出的时候用的不是一把锁，可以高效并发，但是如果两个线程同时插入就会阻塞。</li>
<li>获取链表的长度。</li>
<li>使用中断锁，如果调用了线程的中断方法，那么，处于阻塞中的线程就会抛出异常。</li>
<li>判断如果当前链表长度达到了设置的长度，默认是 int 最大型，就调用 put 锁的伙伴 Condition 对象 notFull 让当前线程挂起等待。 直到 take 方法中会调用 notFull 对象的 signal 方法唤醒。</li>
<li>调用 enqueue 方法，将刚刚创建的 Node 节点连接到链表上。</li>
<li>将链表长度变量 count 加一。 判断如果加一后，链表长度还小于链表规定的容量，那么就唤醒其他等待在 notFull 对象上的线程，告诉他们可以取数据了。</li>
<li>放开锁，让其他线程争夺锁（非公平锁）。</li>
<li>如果c是0，表示队列已经有一个数据了，通知唤醒挂在 notEmpty 的线程，告诉他们可以取数据了。</li>
</ol>
<h5 id="take-方法如下："><a href="#take-方法如下：" class="headerlink" title="take 方法如下："></a>take 方法如下：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>步骤如下：</p>
<ol>
<li>获取链长度，获取 take 锁。</li>
<li>调用可中断的 lock 方法。开始锁住。</li>
<li>如果队列是空，则挂起线程。开始等待。</li>
<li>如果不为空，则调用 dequeue 方法，拿到头节点的数据，并将头节点更新。</li>
<li>将队列长度减一。判断如果队列长度大于1，通知等待在 notEmpty 上的线程，可以拿数据了。</li>
<li>解锁。</li>
<li>如果变量 c 和 容量相同，而刚刚又消费了一个节点，说明队列不满了，则通知生产者可以添加数据了。</li>
<li>返回数据。</li>
</ol>
<h5 id="boolean-offer-E-e-long-timeout-TimeUnit-unit-源码："><a href="#boolean-offer-E-e-long-timeout-TimeUnit-unit-源码：" class="headerlink" title="boolean offer(E e, long timeout, TimeUnit unit)  源码："></a>boolean offer(E e, long timeout, TimeUnit unit)  源码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法会阻塞给定的时间，如果时间到了，则返回false。<br>和 put 方法很相似，步骤如下：</p>
<ol>
<li>将时间转成纳秒。</li>
<li>获取 put 锁。</li>
<li>调用可中断锁方法。</li>
<li>如果容量满了，并且设置的等待时间小于0，返回 false，表示插入失败，反之，调用 notFull 方法等待给定的时间，并返回一个负数，当第二次循环的时候，继续判断，如果还是满的并且小于0，返回false。</li>
<li>如果容量没有满，或者等待过程被唤醒，则调用 enqueue 插入数据。</li>
<li>获取当前链表长度。</li>
<li>判断链表长度+1是否小于设置的容量。如果小于，则链表没有满，通知生产者可以添加数据了。</li>
<li>释放锁。 如果 c 等于 0，表示之前没有数据，但是现在已经加入一个数据了，可以通知其他的消费者来消费了。</li>
<li>返回 true。</li>
</ol>
<h5 id="E-poll-long-timeout-TimeUnit-unit-源码分析"><a href="#E-poll-long-timeout-TimeUnit-unit-源码分析" class="headerlink" title="E poll(long timeout, TimeUnit unit) 源码分析"></a>E poll(long timeout, TimeUnit unit) 源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会阻塞给定的时间，如果取不到数据，返回null。</p>
<p>步骤其实和上面的差不多，楼主偷个懒，就不解释了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从源码分析中，我们可以看到，整个阻塞队列就是由重入锁和Condition 组合实现的，和我们之前用 synchronized  加上 wait 和 notify 实现很相似，只是楼主的那个例子没有使用队列，因此无法将锁分开，也就是我们之前说的锁分离的技术。那么，整体的性能当然不能和 Doug Lea 大神的比了。</p>
<p>好了。今天的并发源码分析，就到这里。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-CopyOnWriteArrayList-源码剖析</title>
    <url>/2018/01/10/2018/2018-01-10-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-CopyOnWriteArrayList-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ArrayList 是一个不安全的容器，在多线程调用 add 方法的时候会出现 ArrayIndexOutOfBoundsException 异常，而 Vector 虽然安全，但由于其 add 方法和 get 方法都使用了 synchronized 关键字，导致在并发时的性能令人担忧，因此，伟大的 Doug Lea 编写了 CopyOnWriteArrayList 并发容器，用于替代并发时的 ArrayList，而该类的类名叫 “写的时候拷贝集合”。也非常符合他的设计，那么，我们就看看他是如何实现的。

<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>既然是 ArrayList ，第一个看的当然是 add 方法。</p>
<p>add 方法源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法步骤如下：</p>
<ol>
<li>使用重入锁锁住代码块。</li>
<li>调用 getArray 方法获取当前数组，调用 Arrays 工具类的 copyof 方法，在原来数组长度的基础上加一创建一个新数组，然后将元素添加到新数组的最后以为，这点和 ArrayList 不同， ArrayList 需要扩容的时候在原有的基础上扩容一半。</li>
<li>调用 setArray 方法，将新数组赋值到成员变量 array 中，注意：该变量是 volatile 的。因此，其他线程可以立即看到他。最后释放锁。</li>
</ol>
<p>再看看 get 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (E) a[index];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到该方法非常简单：获取到成员变量 array，根据下标获取。没有使用锁，完全支持并发。</p>
<p>从 add 方法和 get 方法中，我们看出了作者的意图，Doug Lea 认为容器 get 的操作比 add 的操作频繁，使用了类似读写分离的方式，读读操作完全并发，而写的时候，并不修改原有的内容，这对于保证当前在读线程的数据一致性非常重要，然后对原有的数据进行一次复制，将改写的内容写入到副本中，写完之后，再将修改完的副本替换原来的数据。这样就可以保证写操作不会影响读了。同时使用 volatile 变量，也保证了内存可见性，更新之后立即就能被其他线程看到。</p>
<p>该类保证了并发时的安全，同时，相比于 Vector 性能要高出很多（读读完全并发）。而 Vector 同时只能有一个线程进行读写，简直可怕。</p>
<p>但该类也不是完美的。该类的迭代器不支持 remove 操作，也不支持 set 操作，也不支持 add 操作。在迭代器中调用这 三个方法将抛出 UnsupportedOperationException 异常。</p>
<p>但是该类可以在 for 循环中做删除操作，这点和 ArrayList 也是不一样的，因为该类每次删除之后也都是 拷贝重写赋值。而 ArrayList 使用 for 循环删除实际上使用的迭代器的 next 方法，而迭代器每次都会检查ArrayList 的状态，调用 checkForComodification 方法，因此会抛出 ConcurrentModificationException 异常。ArrayList 必须使用迭代器的 remove 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，并发环境下，强烈建议使用该类代替 ArrayList，该类的读读操作可保证完全并发。支持 for 循环做删除操作。不支持迭代器remove ，set， add。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-ThreadLocal-源码剖析</title>
    <url>/2018/01/10/2018/2018-01-10-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-ThreadLocal-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       首先看看 JDK 文档的描述：

<blockquote>
<p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p>
</blockquote>
<blockquote>
<p>每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）</p>
</blockquote>
<p>例如，以下类生成对每个线程唯一的局部标识符。 线程 ID 是在第一次调用 UniqueThreadIdGenerator.getCur</p>
<p>java.lang.ThreadLocal 不是 1.5 新加入的类，在 1.2 的时候就已经存在 java 类库的类，但该类的作用非常的大，所以我们也要剖析一下他的源码，也要验证关于该类的一些争论，比如内存泄漏。</p>
<h2 id="1-如何使用？"><a href="#1-如何使用？" class="headerlink" title="1. 如何使用？"></a>1. 如何使用？</h2><p>该类有4个方法方法需要关注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>get() : 返回此线程局部变量的当前线程副本中的值。如果变量没有用于当前线程的值，则先将其初始化为调用  initialValue() 方法返回的值。</p>
<p>set()：将此线程局部变量的当前线程副本中的值设置为指定值。大部分子类不需要重写此方法，它们只依靠 initialValue() 方法来设置线程局部变量的值。</p>
<p>remove() ：移除此线程局部变量当前线程的值。如果此线程局部变量随后被当前线程读取， 且这期间当前线程没有设置其值，则将调用其 initialValue() 方法重新初始化其值。这将导致在当前线程多次调用 initialValue 方法。则不会对该线程再调用 initialValue 方法。通常，此方法对每个线程最多调用一次，但如果在调用 get() 后又调用了 remove（） ，则可能再次调用此方法。</p>
<p> initialValue()：返回此线程局部变量的当前线程的“初始值”。线程第一次使用 get() 方法变量时将调用此方法，但如果线程之前调用了 set（T） 方法，</p>
<p>我们还是来个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.think.in.java.lock.tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> MyThreadLocal&lt;&gt;();</span><br><span class="line">    System.out.println(local.get());</span><br><span class="line">    local.set(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(local.get());</span><br><span class="line">    local.remove();</span><br><span class="line">    System.out.println(local.get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">world</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们重写了 ThreadLocal  的 initialValue 方法，返回了一个字符串 “world”，第一次调用 get 方法返回了该值，而我们然后又调用 set 方法设置了 hello 字符串，再次调用 get 方法，此时返回的就是刚刚set 的值 —- hello，然后我们调用remove 方法，删除 hello，再次调用 get 方法，返回了 initialValue 方法中的 world。</p>
<p>从这个流程中，我们已经知道了该类的用法，那么我们就看看源码是如何实现的。</p>
<h2 id="get-源码剖析"><a href="#get-源码剖析" class="headerlink" title="get() 源码剖析"></a>get() 源码剖析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap  对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果map不是null，将 ThreadlLocal 对象作为 key 获取对应的值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 如果该值存在，则返回该值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上面的逻辑没有取到值，则从 initialValue  方法中取值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>楼主在该方法中写了注释，主要逻辑是从 当前线程中取出 一个类似 Map 的对象，<br>map 中 key是 ThreadLocal 对象，value 则是我们设置的值。如果 该 map中没有，则从 initialValue  方法中取。</p>
<p>我们继续看看，map 的真实面目：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ef87994c62636ea3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a6d0201cef876e0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-aea431b644513977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>就是这个map，这个map 持有一个 Entry 数组，Entry 继承了 WeakReference ，也就是弱引用，如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存。这个特性我们之后再说。</p>
<p>总的来说，每个线程对象中都有一个 ThreadLocalMap 属性，该属性存储 ThreadLocal 为 key ，值则是我们调用 ThreadLocal 的 set 方法设置的，也就是说，一个ThreakLocal 对象对应一个 value。</p>
<p>还没完，我们看看 getEntry 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果hash 没有冲突，直接返回 对应的值，如果冲突了，调用 getEntryAfterMiss 方法。</p>
<p>getEntryAfterMiss 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法会循环所有的元素，直到找到 key 对应的 entry，如果发现了某个元素的 key 是 null，顺手调用 expungeStaleEntry 方法清理 所有 key 为 null 的 entry。 </p>
<p>那么 set 方法是怎么样的呢？</p>
<h2 id="3-set-方法源码剖析"><a href="#3-set-方法源码剖析" class="headerlink" title="3. set() 方法源码剖析"></a>3. set() 方法源码剖析</h2><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>该方法同样先得到当前线程，然后根据当前线程得到线程的 ThreadLocalMap 属性，如果 Map 为null， 则创建一个Map ，并将值放置到Map中，否则，直接将值放置到Map中。</p>
<p>先看看 createMap(Thread t, T firstValue) 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY]; <span class="comment">// 默认长度16</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>); <span class="comment">// 得到下标</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue); <span class="comment">// 创建一个entry对象并插入数组</span></span><br><span class="line">        size = <span class="number">1</span>; <span class="comment">// 设置长度属性为1</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY); 设置阀值== <span class="number">16</span> * <span class="number">2</span> / <span class="number">3</span> == <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法很简单，楼主已经写了详细的注释。就是创建一个16长度的entry 数组，设置阀值为10，注意，再resize 的时候，并不是10，而是 10 - 10 / 4，也就是 8，负载因子为 0.5，和 HashMap 是不同的。</p>
<p>我们再看看 map.set(ThreadLocal&lt;?&gt; key, Object value) 方法如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="comment">// 根据 ThreadLocal 的 HashCode 得到对应的下标</span></span><br><span class="line">     <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 首先通过下标找对应的entry对象，如果没有，则创建一个新的 entry对象</span></span><br><span class="line">     <span class="comment">// 如果找到了，但key冲突了或者key是null，则将下标加一（加一后如果小于数组长度则使用该值，否则使用0），</span></span><br><span class="line">     <span class="comment">// 再次尝试获取对应的 entry，如果不为null，则在循环中继续判断key 是否重复或者k是否是null</span></span><br><span class="line">     <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>;  e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">         <span class="comment">// key 相同，则覆盖 value</span></span><br><span class="line">         <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">             e.value = value;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果key被 GC 回收了（因为是软引用），则创建一个新的 entry 对象填充该槽</span></span><br><span class="line">         <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">             replaceStaleEntry(key, value, i);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 创建一个新的 entry 对象</span></span><br><span class="line">     tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">     <span class="comment">// 长度加一</span></span><br><span class="line">     <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="comment">// 如果没有清楚多余的entry 并且数组长度达到了阀值，则扩容</span></span><br><span class="line">     <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">         rehash();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里楼主刚开始有一个奇怪的地方，为什么这里和 HashMap 处理 Hash 冲突的方式不一样，楼主后来查询资料，才明白，HashMap 的Hash冲突方法是拉链法，即用链表来处理，而 ThreadLocalMap 处理Hash冲突采用的是线性探测法，即这个槽不行，就换下一个槽，直到插入为止。但是该方法有一个问题，就是，如果整个数组都冲突了，就会不停的循环，导致死循环，虽然这种几率很小。</p>
<p>我们继续往下。</p>
<p>如果 k == null，表示 ThreadLocal 被GC回收了，那么就调用 replaceStaleEntry 方法重新生成一个 entry，不过该方法没有我说的那么简单，我们来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以说有点复杂，楼主看了很久，真的没想到 ThreadLocal 这么复杂。。。。。如同该方法名称，该方法会删除陈旧的 entyr，什么是陈旧的呢，就是 ThreadLocal 为 null 的 entry，会将 entry  key 为 null 的对象设置为null。核心的方法就是 expungeStaleEntry（int）；</p>
<p>整体逻辑就是，通过线性探测法，找到每个槽位，如果该槽位的key为相同，就替换这个value；如果这个key 是null，则将原来的entry 设置为null，并重新创建一个entry。</p>
<p>不论如何，只要走到了这里，都会清除所有的 key 为null 的entry，也就是说，当hash 冲突的时候并且对应的槽位的key值是null，就会清除所有的key 为null 的entry。</p>
<p>我们回到 set 方法。如果 hash 没有冲突，也会调用 cleanSomeSlots 方法，该方法同样会清除无用的 entry，也就是 key 为null 的节点。我们看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          i = nextIndex(i, len);</span><br><span class="line">          Entry e = tab[i];</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">              n = len;</span><br><span class="line">              removed = <span class="keyword">true</span>;</span><br><span class="line">              i = expungeStaleEntry(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> removed;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法会遍历所有的entry，并判断他们的key，如果key是null，则调用 expungeStaleEntry 方法，也就是清除 entry。最后返回 true。</p>
<p>如果返回了 false ，说明没有清除，并且 size 还 大于等于 10 ，就需要 rahash，该方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">     <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">         resize();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用 expungeStaleEntries 方法，该方法会清除无用的 entry，我们之前说过了，同时，也会对 size 变量做减法，如果减完之后，size 还大于 8，则调用 resize 方法做真正的扩容。</p>
<p>resize 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会直接扩容为原来的2倍，并将老数组的数据都移动到 新数组，size 变量记录了里面有多少数据，最后设置扩容阀值为 2/3。</p>
<p>所以说，扩容分为2个步骤，当长度达到了容量的2/3，就会清理无用的数据，如果清理完之后，长度还大于等于阀值的3/4，那么就做真正的扩容。而不是网上很多人说的达到了 2/3 就扩容。这里的误区就是扩容之前需要清理。清理完之后再做判断。</p>
<p>可以看到，每次调用set 方法都会进行清理工作。实际上，如果使用 get 方法，当对应的 entry 的key为null 的时候，也会进行清理。</p>
<h2 id="4-remove-方法源码剖析"><a href="#4-remove-方法源码剖析" class="headerlink" title="4. remove 方法源码剖析"></a>4. remove 方法源码剖析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过线性探测法找到 key 对应的 entry，调用 clear 方法，将 ThreadLocal 设置为null，调用 expungeStaleEntry 方法，该方法顺便会清理所有的 key 为 null 的 entry。</p>
<h2 id="5-Thread-线程退出时清理-ThreadLocal"><a href="#5-Thread-线程退出时清理-ThreadLocal" class="headerlink" title="5. Thread 线程退出时清理 ThreadLocal"></a>5. Thread 线程退出时清理 ThreadLocal</h2><p>Thread 的exit 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，该方法会将线程相关的所有属性变量全部清除。包括 threadLocals。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>楼主开始以为这个类的代码不会很难，想来楼主太天真了。从源码中我们可以看到，ThreadLocal 类的作者无时无刻都在想着如何去除那些 key 为 null 的 元素，为什么？因为只要线程不退出，这些变量都会一直留在线程中。</p>
<p>但是，Java 中有线程池的技术，也就是说，线程基本不会退出，因此，就需要手动去删除这些变量。如果你在线程中放置了一个大大的对象，使用完几次后没有清除（调用 remove 方法），该对象将会一直留在线程中。造成了内存泄漏。</p>
<p>为什么要使用弱引用呢？我们假设一下，不用弱引用，如果我们使用的 ThreadLocal 的变量是个局部变量，并设置到了线程中，当这个方法结束时，我们没有调用 remove 方法，而 Map 中 key 不是弱引用，那么该变量将会一直存在！！！</p>
<p>如果使用了弱引用，就算你没有调用 remove 方法，GC 也会清除掉 Map 中的引用，同时，ThreadLocal 也会通过对 key 是否为 null 进行判断，从而防止内存泄漏。</p>
<p>这里我们重新总结一下：ThreadLocal 的作者之所以使用弱引用，是担心程序员使用了局部变量的ThreadLocal 并且没有调用 remove 方法，这将导致没有结束的线程发生内存泄漏。使用弱引用，即使程序员没有删除，GC 也会将该变量设置为null，ThrealLocal 通过判断 key 是否为 null 来清除无用数据。防止内存泄漏。</p>
<p>当然，如果你使用的是静态变量，并且使用结束后没有设置为 null， ThrealLocal 是无法自动删除的，因此需要调用 remove 方法。</p>
<p>那么，ThrealLocal 什么时候会自动回收呢？当调用 remove 方法的时候（废话），当调用 get 方法并且 hash 冲突了的时候（情况很少），调用 set 方法时 hash 冲突了，调用 set 方法时正常插入。注意，调用 set 方法时，如果是覆盖操作，则不会执行清理。</p>
<p>我们正常使用 ThreadLocal 都是静态变量，也是 JDK 建议的例子，所以一定要手动调用 remove 方法，或者使用完毕后置为 null。反之，你可以碰运气不好，JDK 可能会帮你删，比如在你 set 的时候（也就是我们上面说的那几种情况），如果运气不好，就会永远存在线程中，导致内存泄漏。</p>
<p>所以，强烈建议手动调用 remove 方法。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程线程通信之管道流</title>
    <url>/2018/01/10/2018/2018-01-10-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93%E6%B5%81/</url>
    <content><![CDATA[<p>在并发编程中，需要处理两个问题：线程之间如何通信及线程之间如何同步。通知是指线程之间以何种机制来交换信息。在命令式编程中，<strong>线程之间的通信机制有两种：共享内存和消息传递</strong>。</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。而子啊消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</p>
<p>Java 的并发才作用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<p>而Java中还有另一种用的比较少的线程间的通信方式：管道流。</p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>管道输入/输入流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
<p>管道输入/输入流主要包括了如下4种具体实现：PipedOutputStream，PipedInputStream，PipedReader 和 PipedWriter，前两种面向字节，而后两种面向字符。</p>
<p>我们先来一个例子看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedStreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PipedWriter writer = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">    PipedReader reader = <span class="keyword">new</span> PipedReader();</span><br><span class="line">    PipedInputStream inputStream = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">    PipedOutputStream outputStream = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输出流和输入流连接</span></span><br><span class="line">    writer.connect(reader);</span><br><span class="line">    Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(reader));</span><br><span class="line"></span><br><span class="line">    printThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> receive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 从main线程写到 print 线程</span></span><br><span class="line">        writer.write(receive);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PipedReader in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> receive;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 读取 main 线程发送过来的数据并打印</span></span><br><span class="line">          System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码种，创建了 printThread，它用来接受 main 线程的输入，任何 main 线程的输入均通过 PipedWriter 写入，而 printThread 在另一端通过 PipedReader 将内容读出并打印。</p>
<p>对于 Piped 类型的流，必须先要进行绑定，也就是调用 connect 方法，如果没有将输入 / 输出流绑定起来，对于该流的访问将会抛出异常。</p>
<p>而作为这两个类连接的重要方法 connect 方法式如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedReader snk)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (snk == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sink != <span class="keyword">null</span> || snk.connected) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Already connected&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snk.closedByReader || closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Pipe closed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sink = snk;</span><br><span class="line">    snk.in = -<span class="number">1</span>;</span><br><span class="line">    snk.out = <span class="number">0</span>;</span><br><span class="line">    snk.connected = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先参数判断，然后将输入流设置为输出流的 sink 属性。这样就将两个流关联了起来。实现了两个线程的通信。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，该类的应用场景并不是很多，只是我们应该知道另一种线程通信的方式。嗯，就酱。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-Fork-Join-分而治之框架</title>
    <url>/2018/01/11/2018/2018-01-11-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Fork-Join-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->“分而治之” 一直是一个有效的处理大量数据的方法。著名的 MapReduce 也是采取了分而治之的思想。简单来说，就是如果你要处理1000个数据，但是你并不具备处理1000个数据的能力，那么你可以只处理其中的10个，然后，分阶段处理100次，将100次的结果进行合成，那就是最终想要的对原始的1000个数据的处理结果。


<h2 id="Fork-amp-Join-的具体含义"><a href="#Fork-amp-Join-的具体含义" class="headerlink" title="Fork &amp; Join 的具体含义"></a>Fork &amp; Join 的具体含义</h2><p>Fork 一词的原始含义是吃饭用的叉子，也有分叉的意思。在Linux 平台中，函数 fork（）用来创建子进程，使得系统进程可以多一个执行分支。在 Java 中也沿用了类似的命名方式。</p>
<p>而 Join（） 的含义和 Thread 类的 join 类似，表示等待。也就是使用 fork（） 后系统多了一个执行分支（线程），所以需要等待这个执行分支执行完毕，才有可能得到最终的结果，因此 join 就是表示等待。</p>
<p>在实际使用中，如果毫无顾忌的使用 fork 开启线程进行处理，那么很有可能导致系统开启过多的线程而严重影响性能。所以，在JDK中，给出一个 ForkJoinPool 线程池，对于 fork（） 方法并不急着开启线程，而是提交给 ForkJoiinPool 线程池进行处理，以节省系统资源。</p>
<p>由于线程池的优化，提交的任务和线程数量并不是一对一的关系。在绝大多数情况下，一个物理线程实际上是需要处理多个逻辑任务的。因此，每个线程必然需要拥有一个任务队列。因此，在实际执行过程中，可能遇到这么一种情况：线程A已经把自己的任务都处理完了，而线程B还有一堆任务等着处理，此时，线程A就会“帮助” 线程B，从线程 B的任务队列中拿一个任务来处理，尽可能的达到平衡。值得注意的是：当线程试图帮助别人时，总是从任务队列的底部开始拿数据，而线程试图执行自己的任务时，则从相反的顶部开始拿。因此这种行为也十分有利于避免数据竞争。</p>
<p>我们看看线程池 ForkJoinPool 的一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Submits a ForkJoinTask for execution.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the task&#x27;s result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment"> *         scheduled for execution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以向 ForkJoinPool 线程池提交一个 ForkJoinTask 任务。所谓 ForkJoinTask 任务就是支持 fork （） 分解以及 join（）等待的任务。 ForkJoinTask 有两个重要的子类，RecursiveAction 和 RecursiveTask。他们粉笔表示没有返回值的任务和可以携带返回值的任务。有点像 Rannable 和 Callable。</p>
<p>下面来要给简单的例子展示 Fork/Join 框架的使用。这里用来计算求和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Fork/Join 核心思想：分而治之</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 著名的 MapReduce 也是这个思想。将任务进行分解，然后合并所有的结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 阀值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">long</span> start;</span><br><span class="line">  <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start = start;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 有返回值的</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当阀值小于10000则不分解了</span></span><br><span class="line">    <span class="keyword">boolean</span> canCompute = (end - start) &lt; THRESHOLD;</span><br><span class="line">    <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2000</span></span><br><span class="line">      <span class="keyword">long</span> step = (start + end) / <span class="number">100</span>;</span><br><span class="line">      ArrayList&lt;CountTask&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">long</span> pos = start;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastOne = pos + step;</span><br><span class="line">        <span class="keyword">if</span> (lastOne &gt; end) &#123;</span><br><span class="line">          lastOne = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//0-2000 个计算任务 * 100</span></span><br><span class="line">        CountTask subTask = <span class="keyword">new</span> CountTask(pos, lastOne);</span><br><span class="line">        pos += step + <span class="number">1</span>;</span><br><span class="line">        subTasks.add(subTask);</span><br><span class="line">        subTask.fork();<span class="comment">// fork</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (CountTask t : subTasks) &#123;</span><br><span class="line">        sum += t.join();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    CountTask task = <span class="keyword">new</span> CountTask(<span class="number">0</span>, <span class="number">200000L</span>);</span><br><span class="line">    <span class="comment">// 将一个大的任务提交到池中</span></span><br><span class="line">    ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task);</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 等待运算结果</span></span><br><span class="line">      res = result.get();</span><br><span class="line">      System.out.println(<span class="string">&quot;sum = &quot;</span> + res);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>由于计算求和必须需要返回值，因此我们选择了 RecursiveTask 作为任务的模型。首先我们构造了一个大任务，提交给线程池，线程池会返回一个携带结果的任务，通过 get 方法可以得到最终结果。如果执行 get 方法时任务没有结束，那么主线程就会在 get 方法等待。</p>
<p>再看看 CountTask 的实现，首先 CountTask 继承自 RecursiveTask ，可以携带返回值，这里的返回值类型设置为 long，定义一个 THRESHOLD 设置了任务分解的规模，也就是如果需要求和的总数大于 THRESHOLD 个，那么任务就需要再次分解，否则就直接执行。 每次分解时，简单的将原有任务划分成100个规模相等的小任务，并使用 fork（） 提交子任务。之后，等待所有的子任务结束，并将结果再次求和。</p>
<p>再使用 ForkJoin的时候注意：如果任务的划分层次很深，一直得不到返回，那么可能出现两种情况： 第一，系统内的线程数量越来越多，导致性能严重下降。第二，函数的调用层次变的很深，最终导致栈溢出。</p>
<p>此外，ForkJoin 线程池使用一个无锁的栈来管理空闲线程，如果一个工作线程暂时取不到可用的任务，则可能会被挂起，挂起的线程将会被压入由线程池维护的栈中，待将来有任务可用时，再从栈中唤醒这些线程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文来源自 《Java 高并发程序设计》，没有什么自己的见解。因为使用场景太少了。不过还是可以看看源码来涨涨姿势的。嘿嘿。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-AQS-源码剖析</title>
    <url>/2018/01/13/2018/2018-01-13-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-AQS-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       JDK 1.5  的 java.util.concurrent.locks 包中都是锁，其中有一个抽象类 AbstractQueuedSynchronizer （抽象队列同步器），也就是 AQS， 我们今天就来看看该类。

<h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-d426e23dff521cfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类结构"></p>
<p>我们看看该类的结构，该类被 CountDown，ThreadPoolExecutor，ReentrantLock，ReentrantReadWriteLock，Semaphore 的内部类所继承，而这些内部类都是这些锁的真正实现，不论是公平锁还是非公平锁。</p>
<p>也就是说，这些锁的真正实现都是该类来实现的。那么，我们就从这些锁开始看看是如何实现从锁到解锁的。</p>
<h2 id="2-重入锁的-lock-方法"><a href="#2-重入锁的-lock-方法" class="headerlink" title="2. 重入锁的 lock 方法"></a>2. 重入锁的 lock 方法</h2><p>我们先看看重入锁 ReentranLock 的 lock 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法调用了内部类的 sync 抽象类的 lock 方法，该方法的实现有公平锁和非公平锁。我们看看公平锁是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用了 acquire 方法，该方法就是 AQS 的的方法，因为 sync 继承了 AQS，而公平锁继承了 Sync，等于间接继承了 AQS，我们看看该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法JDK注释 ：</p>
<blockquote>
<p>以独占模式获取对象，如果被中断则中止。通过先检查中断状态，然后至少调用一次 tryAcquire(int) 来实现此方法，并在成功时返回。否则在成功之前，或者线程被中断之前，一直调用 tryAcquire(int) 将线程加入队列，线程可能重复被阻塞或不被阻塞。可以使用此方法来实现 Lock.lockInterruptibly() 方法。</p>
</blockquote>
<p>楼主来简单说一下该方法的作用：该方法会试图获取锁，如果获取不到，就会被加入等待队列等待被唤醒，这个其实和我们之前分析的 synchronized 是差不多的。</p>
<p>我们仔细看看该方法，首先是 tryAcquire 方法，也就是尝试获取锁，该方法是需要被写的，父类默认的方法是抛出异常。如何重写呢？抽象类定义一个标准：如果返回 true，表示获取锁成功，反之失败。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-56244aab531903bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tryAcquire  "></p>
<p>我们回到 acquire 方法，如果获取锁成功，就直接返回了，如果失败了，则继续后面的操作，也就是将线程放入等待队列中：</p>
<p>acquireQueued(addWaiter(Node.EXCLUSIVE), arg）</p>
<p>我们先看看 addWaiter(Node.EXCLUSIVE) 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法注释：将当前线程放入到队列节点。参数呢？参数有2种，Node.EXCLUSIVE 是独占锁，Node.SHARED 是分享锁。</p>
<p>在 Node 类种定义了这两个常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>独占锁是null，共享锁是空对象。</p>
<p>我们看看该方法的步骤：</p>
<ol>
<li>创建一个当前线程的 Node 对象（nextWaiter 属性为 null， thread 属性为 当前线程）。</li>
<li>获取到末端节点，如果末端节点不为 null，则将末端节点设置为刚刚创建的节点的 prev 属性。<br>2.1. 通过 CAS 设置末端节点为新的节点。如果成功，将刚刚创建的节点设置为老末端节点的next节点。最后返回。</li>
<li>如果 tail 末端节点是null，则调用enq 方法。创建一个末端节点，然后，将刚刚创建的末端节点设置为新节点的 prev 属性（此时的末端节点就是 head 头节点）。最后返回刚刚创建的  node 节点。</li>
</ol>
<p>我们看看 enq 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法步骤如下：</p>
<ol>
<li>死循环，获取到末端节点，如果是null，则使用CAS创建一个头节点（头节点此时也是null），并将头节点赋值末端节点。</li>
<li>由于刚刚CAS 成功，走else 逻辑，将末端节点赋值给新节点的 prev 属性，使用CAS设置新的末端节点为刚刚创建的 node对象。然后返回node 对象。</li>
</ol>
<p>该方法主要就是初始化头节点和末端节点，并将新的节点追加到末端节点并更新末端节点。</p>
<p>我们会到 addWaiter 方法中，该方法主要作用就是根据当前线程创建一个 node 对象，并追加到队列的末端。</p>
<p>我们再回到 acquire 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>addWaiter 方法会返回刚刚创建的node 对象，然后调用 acquireQueued 方法，我们进入该方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法步骤如下：</p>
<ol>
<li>死循环。先获取 node 对象 prev 节点，如果该节点和 head 相等，说明是他是第二个节点，那么此时就可以尝试获取锁了。<br>1.1 如果获取锁成功，就设置当前节点为 head 节点（同时设置当前node的线程为null，prev为null），并设置他的 prev 节点的 next 节点为 null（帮助GC回收）。最后，返回等待过程中是否中断的布尔值。</li>
<li>如果上面的两个条件不成立，则调用  shouldParkAfterFailedAcquire 方法和 parkAndCheckInterrupt 方法。这两个方法的目的就是将当前线程挂起。然后等待被唤醒或者被中断。稍后，我们仔细查看这两个方法。</li>
<li>如果挂起后被当前线程唤醒，则再度循环，判断是该节点的 prev 节点是否是 head，一般来讲，当你被唤醒，说明你别准许去拿锁了，也就是 head 节点完成了任务释放了锁。然后重复步骤 1。最后返回。</li>
</ol>
<p>我们看看 shouldParkAfterFailedAcquire 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法步骤如下：</p>
<ol>
<li>获取去上一个节点的等待状态，如果状态是 SIGNAL -1，就直接返回 true，表示可以挂起并休息。</li>
<li>如果 waitStatus 大于 0， 则循环检查 prev 节点的 prev 的waitStatus，知道遇到一个状态不大于0。该字段有4个状态，分别是 CANCELLED =  1，SIGNAL    = -1， CONDITION = -2， PROPAGATE = -3，也就是说，如果大于 0，就是取消状态。那么，往上找到那个不大于0的节点后怎么办？将当前节点指向 那个节点的 next 节点，也就是说，那些大于0 状态的节点都失效这里，随时会被GC回收。</li>
<li>如果不大于0 也不是 -1，则将上一个节点的状态设置为有效， 也就是 -1.最后返回 false。注意，在acquireQueued 方法中，返回 false 后会继续循环，此时 pred 节点已经是 -1 了，因此最终会返回 true。</li>
</ol>
<p>再看 parkAndCheckInterrupt 方法（挂起并检查是否中断）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>该方法非常的简单，就是将当前线程挂起，等到有别的线程唤醒（通常是 head 节点中线程），然后返回当前线程是否是被中断了，注意，该方法会清除中断状态。</p>
<p>回到  acquireQueued 方法，总结一下该方法，该方法就是将刚刚创建的线程节点挂起，然后等待唤醒，如果被唤醒了，则将自己设置为 head 节点。最后，返回是否被中断。</p>
<p>再回到 acquire 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在该方法中，如果获取锁失败并被唤醒，且被中断了，那么就执行 selfInterrupt 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将当前线程设置中断状态位。 </p>
<p>好了，到这里，整个lock 方法，我们基本就分析完了，可以说，整个方法就是将线程放入到等待队列并挂起然后等待 head 节点唤醒。其中，tryAcquire 方法高频出现，该方法具体实现由子类实现，比如 重入锁，读写锁，线程池的 worker，其中 CountDown 和 Semaphore 实现的是共享模式的 tryAcquire 方法，但原理相同。AQS 如何定义的？就是返回 true 表示拿到锁了，返回 false 表示拿锁失败，具体如何实现AQS管不了。但他们都依赖一个极其重要的字段 ——- state。</p>
<p>楼主有必要说说这个字段，该字段定义了当前同步器的状态，如果大家知道 pv 原语的话，应该很好理解这个字段，该字段在 AQS 中是如何定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<p>volatile。该字段可能会被多个线程修改，因此，需要设置为 volatile ，保证变量的可见性。</p>
<p>我们可以看看 重入锁中的公平锁是如何使用该字段的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法重写了 tryAcquire 方法，步骤如下：</p>
<ol>
<li>获取当前线程，获取锁（同步器）的状态。</li>
<li>如果同步器等于0，就 CAS 设置 state 为 1，表示同步器被占用了，并且设置同步器的持有线程为当前线程（为了判断重入）。最后返回拿锁成功 true。</li>
<li>如果不是0，并且当前线程就是同步器的持有线程，说明是重入。那么就将 state 加1，最后返回 true。所以说，当你重入一次，就需要解锁一次，否则下个线程永远拿不到锁。</li>
<li>如果都不是，返回 false ，表示拿锁失败。</li>
</ol>
<p>从这里，我们可以看到， statei 字段非常的重要，判断锁是否被持有完全根据这个字段来的。这点一定要注意，而这个设计和操作系统的 pv 由异曲同工之妙。</p>
<p>那么看完了拿锁，再看看解锁，我们可以先猜想一下如何设计，首先肯定是要将 state 字段设置为 0，才能让下个线程拿锁，然后呢？唤醒等待队列中的下个线程。让他尝试拿锁。那到底 doug lea 是不是这么设计的呢？我们来看看。</p>
<h2 id="3-重入锁的-unlock-方法"><a href="#3-重入锁的-unlock-方法" class="headerlink" title="3. 重入锁的 unlock 方法"></a>3. 重入锁的 unlock 方法</h2><p>该方法调用了AQS 的 release 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先尝试释放，如果成功，则唤醒下一个线程。</p>
<p>我们先看看 tryRelease 方法 （需要重写）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法步骤如下：</p>
<ol>
<li>计算同步器状态减去1后的值。</li>
<li>判断同步器线程和当前线程是否相同，如果不同，抛出监视器状态异常。</li>
<li>判断状态是否是 0，也就是说，如果是0，表示没有线程持有锁了，那么就是设置 free 为 true，并且设置同步器的 thread 属性为null，</li>
<li>最后设置 state 为 计算的值，这里需要考虑重入。最后返回。</li>
</ol>
<p>可以看到，如果 state 不是 0 的话，就会返回 false ，后面的步骤就没有了，也就是说，重入锁解锁的时候不会唤醒下一个线程。</p>
<p>如果解锁成功，执行下面的步骤，如果 head 头节点不是 null 并且他的状态不是0，说明有线程可以唤醒，执行 unparkSuccessor 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法步骤如下：</p>
<ol>
<li>获取到头节点的状态。</li>
<li>如果小于0，CAS 设置状态为0。</li>
<li>获取到头节点的next 节点，判断是否为null，或者 next 节点是否大于0，如果是null 或者大于0，则从末端节点开始向上查找，直到找到状态小于等于0 的节点。</li>
<li>最后唤醒该节点的线程。</li>
</ol>
<p>这个时候，等待在 acquireQueued 方法中，准确的说是 parkAndCheckInterrupt 方法中的 线程被唤醒，开始继续循环，尝试拿锁（需要修改 state 变量），并设置自己为 head。</p>
<p>这里还有一个漏掉的地方，就是 waitStatus 变量，什么时候会大于等于0? 该变量默认是 0，大于 0 的状态是被取消的状态。什么时候会被取消呢？ 在acquireQueued 方法中，如果方法没有正常结束，则会执行 finally 中的 cancelAcquire 方法，该方法会将状态变成 1，也就是取消状态。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>这次我们分析 AQS，也就是锁的的真正实现，只分析了 lock 方法和 unlock 方法，这两个方法是重入锁的基础。CountDown 和 Semaphore 是共享锁，但是基本原理相同，只是将 state 的数字加大便可以实现。而和重入锁等锁相关联的 Condition 则是通过 LockSupport 工具类直接挂起当前线程，并将当前线程添加到等待队列中，当调用 Condition 的 signal 方法时，则唤醒队列中的第一个线程。具体源码我们有机会再分析。</p>
<p>总之，java 重入锁的实现基于 AQS，而 AQS 主要基于 state 变量和队列来实现。实现原理和 pv原语 类似。 </p>
<p>good luck！！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-ConcurrentLinkedQueue-源码剖析</title>
    <url>/2018/01/14/2018/2018-01-14-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-ConcurrentLinkedQueue-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       今天我们继续分析 java 并发包的源码，今天的主角是谁呢？ConcurrentLinkedQueue，上次我们分析了并发下 ArrayList 的替代 CopyOnWriteArrayList，这次分析则是并发下 LinkedArrayList 的替代 ConcurrentLinkedQueue， 也就是并发链表。

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-f135956c72297b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Demo"></p>
<p>该类继承结构如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-af008a310444c570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继承图"></p>
<p>该类是 Collection 框架下的实现。也就是Java 类库提供的数据结构。</p>
<p>add 方法将指定元素插入此队列的尾部。<br>poll 方法 获取并移除此队列的头，如果此队列为空，则返回 null。<br>peek 方法  获取但不移除此队列的头；如果此队列为空，则返回 null。</p>
<p>那么我们就看看 doug lea 是如何实现并发安全的吧。在这之前，我们可以试想一下，实现并发安全无非两种方式，一种是锁，就像我们之前分析的容器，比如 concurrentHashMap，CopyOnWriteArrayList ， LinkedBolckingQueue，还有一种是 CAS，在这些容器里也用到了。那么，如果是我们来实现这个队列，使用什么方式呢？有趣的问题。</p>
<p>开始看源码吧。</p>
<h2 id="add-方法源码剖析"><a href="#add-方法源码剖析" class="headerlink" title="add 方法源码剖析"></a>add 方法源码剖析</h2><p>实际上是调用 offer 方法，add 方法是 Collection 接口规定的容器方法，而 offer 方法是 Queue 接口的方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ae672d951d966e6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="add方法"></p>
<p>那我们就看看 offer 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否是null，如果是null ，抛出NullPointerException</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 创建一个node 对象，使用  CAS 创建对象</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 轮询链表节点，知道找到节点的 next 为null，才会进行赋值</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到null值之后将刚刚创建的值通过CAS放入</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// 因为 p 遍历在轮询后会变化，因此需要判断，如果不相等，则使用CAS将新节点作为尾部节点。</span></span><br><span class="line">                <span class="keyword">if</span> (p != t)</span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                 <span class="comment">// 放入成功后返回 ture</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 轮询后  p 有可能等于 q，此时，就需要对 p 重新赋值。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// 这里需要注意一下：判断t != t，是因为并发下可能 tail 被改了，如果被改了，则使用新的 t，否则从链表头重新轮询。</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 同样，当 t 不等于 p 时，说明 p 在上面被重新赋值了，并且 tail 也被别的线程改了，则使用新的 tail，否则循环检查p的下个节点</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码行数很少，楼主注释也写了，这里可以看到 doug lea 使用了 CAS 的方式防止并发错误，同时，也看得出对 tail 变量被修改的担忧，通过 t != t 的判断，来检查 tail 是否被其他线程修改了，而这个offer 操作，如果不成功，则永远不会返回，这个队列同时也是无界的。这点在使用的时候需要注意一下。</p>
<p>那么 poll 方法如何实现呢？</p>
<h2 id="poll-方法源码剖析"><a href="#poll-方法源码剖析" class="headerlink" title="poll 方法源码剖析"></a>poll 方法源码剖析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环跳出标记，类似goto</span></span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 死循环，从 head 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            <span class="comment">// 如果 head 不是null 且 将 head 的 item 属性设置为null成功，则返回并更新头节点</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果 p ！= h 说明在 p 轮询时被修改了</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) </span><br><span class="line">                     <span class="comment">// 如果p 的next 属性不是null ，将 p 作为头节点，而 q 将会消失</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 p（head） 的 next 节点 q 也是null，则表示没有数据了，返回null，则将 head 设置为null</span></span><br><span class="line">            <span class="comment">// 注意：  updateHead 方法最后还会将原有的 head 作为自己 next 节点，方便offer 连接。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 p == q，说明别的线程取出了 head，并将 head 更新了。就需要重新开始</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="comment">// 从头开始重新循环</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">           <span class="comment">// 如果都不是，则将 h 的 next 赋给 h，并重新循环。</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面楼主已经写了注释，但是有一个非常困扰哦楼主的疑点，就是 else if （p == q） 这行代码，楼主分析的没有问题，但是再楼主的单线程测试这段代码时，出现了诡异的情况，无法解释，因此， 楼主贴出测试用例，大家一起看看：</p>
<p>测试代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-273a503d07bd092f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>断点代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6003b2d5ea788117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意，断点位置一定要和我的一致。会出现一些奇怪的效果。楼主无法解释，因为这个问题，楼主一直都不敢发这篇文章出来，但楼主觉得有必要说出这个问题，抛砖引玉。</p>
<p>问题在于：单线程怎么会进入这段代码？按道理，但线程是不会出现这个情况的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的源码分析让楼主很痛苦，网上很多的文章也无法解释这是为什么，希望有高人能告诉楼主，到底是怎么回事？</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>JVM-综述</title>
    <url>/2018/02/16/2018/2018-02-16-JVM-%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 概览
从 JVM 的总体上看，它解决了3个问题：
1. Java 程序的内存管理（GC & 运行时数据区）。
2. Java Class 二进制字节流的加载（ClassLoader）。
3. Java 程序的执行（执行引擎）。

<p>如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6ac7141a47ef1258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚拟机基本架构"></p>
<p>在我们的日常开发中，最和我们息息相关的就是1和2了，比如 GC 调优，内存故障排查，再比如使用自定义的类加载器去实现一些特定的逻辑，就如我们之前分析的 tomcat 源码中的类加载器用于隔离不同版本的相同类库，必须要使用自定义的类加载器。</p>
<h2 id="1-Java-程序的内存管理（GC-amp-运行时数据区）"><a href="#1-Java-程序的内存管理（GC-amp-运行时数据区）" class="headerlink" title="1. Java 程序的内存管理（GC &amp; 运行时数据区）"></a>1. Java 程序的内存管理（GC &amp; 运行时数据区）</h2><h4 id="1-1-运行时数据区"><a href="#1-1-运行时数据区" class="headerlink" title="1.1. 运行时数据区"></a>1.1. 运行时数据区</h4><p>从上图中可以看出，虚拟机内存管理主要由几个部分组成：</p>
<ol>
<li>Java 堆（存放对象的地方）</li>
<li>Java 栈（在 HotSpot 实现中，本地方法栈和虚拟机栈合二为一）</li>
<li>PC 寄存器（也称为程序计数器）</li>
<li>方法区（JDK8 中已经将方法区去除，改为元数据区，解决了方法区—-也称为永久代的内存溢出）。</li>
<li>直接内存（大小不限制于 Java 堆，直接向操作系统申请，使用场景于读写频繁的场合，例如 NIO）</li>
</ol>
<h4 id="1-2-垃圾回收系统"><a href="#1-2-垃圾回收系统" class="headerlink" title="1.2. 垃圾回收系统"></a>1.2. 垃圾回收系统</h4><p>Java 程序员之所以不需要显式的释放内存，一切都归功于 GC，GC 解放了 Java 程序员的双手。GC 系统会在后台清除无用的实例对象，释放内存空间。</p>
<p>而 JVM 中的 GC 可谓是一个庞大的系统，其中分为几个部分：</p>
<ol>
<li>判断什么是垃圾对象</li>
<li>垃圾回收算法</li>
<li>各种各样的垃圾收集器</li>
</ol>
<p>我们将会在后面慢慢讲解。</p>
<h2 id="2-Java-Class-二进制字节流的加载（ClassLoader）"><a href="#2-Java-Class-二进制字节流的加载（ClassLoader）" class="headerlink" title="2. Java Class 二进制字节流的加载（ClassLoader）"></a>2. Java Class 二进制字节流的加载（ClassLoader）</h2><h4 id="2-1-类加载器"><a href="#2-1-类加载器" class="headerlink" title="2.1 类加载器"></a>2.1 类加载器</h4><p>对于 Java 虚拟机来说，Class 文件是一个重要的接口，无论使用何种语言进行软件开发，只要能将源文件编译为正确的 Class 文件，那么这种语言就可以在 Java 虚拟机上运行。可以说，Class 文件就是虚拟机的基石。</p>
<p>如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0462adabdf0aac40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各种语言都可以在 JVM 上运行"></p>
<p>从上图可以看出，虚拟机不拘泥于 Java 语言，任何一个源文件只要能编译成 Class 文件的格式，就可以在JVM 上运行！Class 文件格式就像是一个接口，只要遵守这个接口，就能够在 JVM 上运行。</p>
<h4 id="2-2-类加载器的工作流程"><a href="#2-2-类加载器的工作流程" class="headerlink" title="2.2 类加载器的工作流程"></a>2.2 类加载器的工作流程</h4><p>Class 文件通常是以文件的方式存在（任何二进制流都可以是 Class 类型），但只有能被 JVM 加载后才能被使用，才能运行编译后的代码。系统装在 Class 类型可以分为加载，链接和初始化三个步骤。其中，链接也可分为验证，准备和解析3步骤。如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b58c0180435f2e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Class 文件转载过程"></p>
<h4 id="2-3-类装载的条件"><a href="#2-3-类装载的条件" class="headerlink" title="2.3 类装载的条件"></a>2.3 类装载的条件</h4><p>JVM 不会无故装载 Class 文件，只有在必要的时候才装载，哪几个时候呢？</p>
<ol>
<li>当创建一个类的实例是，比如使用 new 关键字，或者通过反射，克隆，反序列化。</li>
<li>当调用类的静态方法时，即当使用字节码 invokstatic 指令。</li>
<li>当使用类或接口的静态字段时（final 常量除外），比如，使用 getstatic 或者 pustatic 指令。</li>
<li>当时用 Java.lang.reflect 包中的方法反射类的方法时。</li>
<li>当初始化子类，要求先初始化父类。</li>
<li>作为启动虚拟机，含有 main（）方法的那个类。</li>
</ol>
<p>以上6种情况属于主动调用，主动调用会触发初始化，还有一种情况是被动调用，则不会引起初始化。</p>
<h4 id="2-4-类加载器的双亲委派模型"><a href="#2-4-类加载器的双亲委派模型" class="headerlink" title="2.4 类加载器的双亲委派模型"></a>2.4 类加载器的双亲委派模型</h4><p>先来看一个著名的图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-eba420d0b83f65a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类加载器双亲委派模型"></p>
<p>虚拟机为了保护应用程序内出现多个类名相同的类对象，因此发明了这个机制：当 JVM 需要适用一个类时，在判断类是否已经被加载时，会先从当前底层类加载器进行判断。当系统需要加载一个类时，会从顶层类开始加载，依次向下尝试，知道成功，否则抛出ClassNotFound 异常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a># 总结</h2><p>这篇文章主要是为了后面的详细文章做一个大纲，因此只是讲述以 JVM 的一些基本的框架和概念，后面讲详细的讲述内部细节。让我们学习虚拟机更加的有条理。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM-运行时数据区</title>
    <url>/2018/02/16/2018/2018-02-16-JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->引自《深入理解Java 虚拟机》

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JVM 运行时数据分为几大部分</p>
<ol>
<li>程序计数器</li>
<li>Java 虚拟机栈</li>
<li>本地方法栈</li>
<li>Java 堆</li>
<li>方法区（永久代）</li>
<li>运行时常量池</li>
<li>直接内存</li>
</ol>
<h2 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="JVM 内存区域"></a>JVM 内存区域</h2><p>Java 虚拟机在执行Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p>根据Java 虚拟机规范，Java 虚拟机管理的内存将会包括以下几个运行时数据区域：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4d70091b9bd81c70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自网络"></p>
<p>可以看到，只有方法区和堆是线程共享的，而两栈一器都是线程独享的，也就是说，并发时这些数据都是安全的。</p>
<p>下面一个一个看看这些区域的解释。</p>
<h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p>程序计数器（Program Counter Register） 是一块<strong>较小的内存空间</strong>，它可以看作是当前线程所执行的字节码的 <strong>行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是通过<strong>改变这个计数器的值</strong>来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数据来完成。</p>
<p>由于 Java 虚拟机的多线程时通过线程轮流切换并分配CPU时间片的方式来实现的，在任何一个确定的时刻，一个处理器都智慧执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为 “线程私有的内存”。</p>
<p>如果线程正在执行的是一个Java 方法，这个计数器记录的时正在执行的虚拟机字节码指令的地址；如果正在执行的时 Native 方法，这个计数器值则为空（Undefined），此内存区域是唯一一个在Java 虚拟机规范中没有规定任何 OOM 情况的区域。</p>
<h2 id="2-Java-虚拟机栈"><a href="#2-Java-虚拟机栈" class="headerlink" title="2. Java 虚拟机栈"></a>2. Java 虚拟机栈</h2><p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈桢用于存储局部变量表，操作数栈，动态链接。方法出口等信息。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机中入栈到出栈的过程。</p>
<p>人们经常把简单的虚拟机分为堆和栈，而这个栈就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p>
<p>局部变量表存放了编译器何止的各种基本类型，对象引用（对象起始地址的引用指针）和 returnAddress 类型（指向了一条字节码指令的地址）。</p>
<p>其中64位的long 和 double 类型的数据会占用2个局部变量空间，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈中分配多大的局部变量时完全确定的。在方法运行期间不会改变局部变量表的大小。</p>
<p>在虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflow 异常；如果虚拟机可以动态扩展（当前大部分的 Java 虚拟机都可以动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法声请到足够的内存，就会抛出OOM异常。</p>
<h2 id="3-本地方法栈-HotSpot-已被融合进虚拟机栈"><a href="#3-本地方法栈-HotSpot-已被融合进虚拟机栈" class="headerlink" title="3. 本地方法栈(HotSpot 已被融合进虚拟机栈)"></a>3. 本地方法栈(HotSpot 已被融合进虚拟机栈)</h2><p>本地方法栈（Native Method Stack） 于虚拟机所返回的作用时非常相似的，他们之间的区别是不过虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。而虚拟机规范中对本地方法栈中方法使用的语言，使用方式与数据结构并<strong>没有强制规定</strong>，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（HotSpot）直接就把<strong>本地方法栈和虚拟机栈合二为一</strong>。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflow 异常和 OOM 异常。</p>
<h2 id="4-Java-堆"><a href="#4-Java-堆" class="headerlink" title="4. Java 堆"></a>4. Java 堆</h2><p>对于大多数应用来说，Java 堆（Java Heap） 是Java 虚拟机所管理的内存中最大的一块。Java堆是被所有洗车共享的一块内存区域，再虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都再这里分配内存。这一点Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称为 “GC 堆（Garbage Collected Heap）”，从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所有Java 堆中还可以细分成：新生代和老年代；再细致一点的有 Eden 空间，From Survivor 空间，To Survivor 空间等。从内存分配的角度来看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Lcoal Allocation Buffer， TLAB）。</p>
<p>不过无论如何划分，都与存放内容无关，无论哪个区域，存储的仍然是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存。</p>
<p>根据虚拟机的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法扩展时，将会抛出 OOM 异常。</p>
<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p>方法区（Method Area ）与 Java 堆一样，时各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即使编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述堆的一个逻辑部分，但是它却有一个别名叫做（Non-Heap 非堆），目的应该是与Java 堆区分开来。</p>
<p>对于习惯在 HotSpot 虚拟机上开发，部署程序的开发者来说，很多人都更愿意把方法区称为 “永久代（Permanent Generation）”，本质上两者并不等价，仅仅是因为 HotSpot 虚拟机的设计团队选择把GC 分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样 HotSpot 的垃圾收集器可以像管理Java 堆衣阿华那个管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。</p>
<p>对于其他虚拟机并不存在永久代这个概念。原则上，如何实现Java 虚拟机属于实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是好主意，因为这样更容易遇到内存溢出（永久代有 -XX：MaxPermSize 的上限）。</p>
<p>因此，对于 HotSpot  虚拟机，已经放弃了永久代并逐步改为 Native Memory 来实现方法区的规划了，在目前的版本中，已经把原本放在永久代的字符串常量池移出。</p>
<p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实习那垃圾回收。相对而言，垃圾收集行为在这个区域是比较少见的，但并非数据进入了方法区就如同永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分的区域的回收确实是由必要的。Sun 有几个Bug 就是应为HotSpot 虚拟机对此区域未完全回收导致内存泄漏。</p>
<h2 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h2><p>运行时常量池是方法区的一部分，Class 文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引，这部分内容在类加载后进入方法区的运行时常量池中存放。</p>
<p>JVM 对 Class 文件每一个部分都有严格规定（包括常量池），每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机任何，装载和执行，但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的厂商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存 Class 文件中描述的符号引用之外，还会把翻译出来的直接应用也存储在运行时常量池中。</p>
<p>运行时常量池相对于 Class 文件常量池的另外一个重要特种是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预制入 Class 文件中常量池的内容才能既然怒方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的便是 String 类的 intern 方法。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OOM 异常。</p>
<h2 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h2><p>直接内存（Direct Memory) 并不是JVM 运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，但是这部分内存也被频繁的使用，而且也可能导致 OOM。</p>
<p>在 JDK 1.4 中新加入了 NIO 类，引用了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场合中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机总参数时，会根据实际内存设置-Xmx 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级别的限制），从而导致动态扩展时出现 OOM 异常。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出-JVM-GC（1）</title>
    <url>/2018/02/17/2018/2018-02-17-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-JVM-GC%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## # 前言

<p>初级 Java 程序员步入中级程序员的有一个无法绕过的阶段——GC（Garbage Collection）。作为 Java 程序员，说实话，很幸福，不用像 C 程序员那样，时刻关心着内存，就像网上有句名言——<strong>生活从来都不容易，只不过是有人替你负重前行！</strong>是的，GC 在替我们做这些脏活累活，GC 像让我们把精力都放在业务上，而不用每时每刻都在想着内存。现在，GC 也是每个语言的标准配置了。不然谁会去使用这个语言呢？</p>
<p>然而，作为一个合格的程序员，对底层的好奇是进步的动力，如果一个程序员失去了好奇心，那就可以说他在程序员这条道路上就结束了。</p>
<p>难道我们不好奇 GC 到底是怎么做的吗？接下来，我们就分析 GC 做了哪些事情。</p>
<p>实际上，GC 主要做3件事情：</p>
<ol>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ol>
<p>说到底，GC 就是做这3件事情，如果你能解决这3个问题，那么你也可以实现一个 GC。</p>
<p>那我们就一个一个问题来看看。</p>
<h2 id="1-哪些内存需要回收"><a href="#1-哪些内存需要回收" class="headerlink" title="1. 哪些内存需要回收"></a>1. 哪些内存需要回收</h2><p>还记得我们之前分享的关于 JVM 运行时数据区吗？有堆，有栈，有方法区（永久代），还有直接内存，还有 PC 寄存器。其中，GC 的主要战场就是堆，当然，方法区也是需要 GC 的。但重点还是堆。</p>
<p>我们知道，堆中内存是共享的，基本所有的对象都是在堆中创建。当一个对象不需要使用了，理论上我们就需要释放他所占用的内存。</p>
<p>问题来了，如何分辨一个对象不需要使用了呢？答案是：不可能被任何途径使用的对象。也就是说他没有了任何引用。我们知道，引用在栈中，实例在堆中，当一个实例没有了指向他的引用，我们认为，这个实例就需要清除并释放他所占用的内存了。</p>
<p>那么 GC 是如何实现的呢？一般而言有2种方法：</p>
<ol>
<li>引用计数法（有缺陷，无法解决循环引用问题，JVM 没有采用）</li>
<li>可达性分析（解决了引用计数的缺陷，被 JVM 采用）</li>
</ol>
<p>什么是引用计数法呢？</p>
<blockquote>
<p>给对象中添加一个引用计数器，每当有一个地方引用他是，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的。</p>
</blockquote>
<p>虽然乍看这个算法简单，效率也高，但有一个问题这个算法无法解决，就是循环引用。试想一下：A 对象引用了 B，B 对象也引用了 A，但 A 和 B 都不被别的地方使用，也就是说，实际上这两个对象是垃圾对象，但是由于他们互相持有引用，导致他们的引用计数器都不为0，因此系统无法判断是垃圾，也无法回收他们。</p>
<p>所以，在现在的 JVM 中，是没有使用这个算法的。我们知道就行。</p>
<p>引用计数法不行，那就再说说可达性分析算法。</p>
<p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，所有所走过的路径称为<strong>引用链（Reference Chain）</strong>，当一个对象到 GC Roots 没有任何引用链相连（也就是对象不可达）时，则证明此对象是不可用的。如下图所示，obj5 , obj6, obj7 虽然互相有关联，但是他们到 GC Roots 是不可达的，所以他们将会判定为是可回收的对象。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3a9d215518f7954c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可达性分析算法"></p>
<p>那么哪些对象可以作为 GC Roots 对象呢？</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI （即 native 方法）引用的对象。</li>
</ol>
<h2 id="2-什么时候回收？"><a href="#2-什么时候回收？" class="headerlink" title="2. 什么时候回收？"></a>2. 什么时候回收？</h2><p>注意：即使是在可达性分析算法中不可达的对象，也并非是”非死不可的”，这时候他们实际上是处于 “缓刑” 阶段。因为要真正宣告一个对象的死亡，至少需要经历两次标记过程：</p>
<blockquote>
<h1 id="如果对象在进行可达性分析后发现没有与-GC-Roots-相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行-finalize-方法。注意：当对象没有覆盖-finalize-方法，或者-finalize-方法已经被虚拟机调用过，虚拟机将这两种情况都视为-“没有必要执行”。也就是说，finalize-方法只会被执行一次。"><a href="#如果对象在进行可达性分析后发现没有与-GC-Roots-相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行-finalize-方法。注意：当对象没有覆盖-finalize-方法，或者-finalize-方法已经被虚拟机调用过，虚拟机将这两种情况都视为-“没有必要执行”。也就是说，finalize-方法只会被执行一次。" class="headerlink" title="如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。注意：当对象没有覆盖 finalize 方法，或者 finalize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”。也就是说，finalize 方法只会被执行一次。"></a>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。注意：<strong>当对象没有覆盖 finalize 方法，或者 finalize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”。也就是说，finalize 方法只会被执行一次。</strong></h1><h1 id="如果这个对象被判定为有必要执行-finalize-方法，那么这个对象将会放置在一个叫做-F-Queue-的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的-Finalizer-线程去执行它。注意：如果一个对象在-finalize-方法中运行缓慢，将会导致队列后的其他对象永远等待，严重时将会导致系统崩溃。"><a href="#如果这个对象被判定为有必要执行-finalize-方法，那么这个对象将会放置在一个叫做-F-Queue-的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的-Finalizer-线程去执行它。注意：如果一个对象在-finalize-方法中运行缓慢，将会导致队列后的其他对象永远等待，严重时将会导致系统崩溃。" class="headerlink" title=" 如果这个对象被判定为有必要执行 finalize 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的 Finalizer 线程去执行它。注意：如果一个对象在 finalize 方法中运行缓慢，将会导致队列后的其他对象永远等待，严重时将会导致系统崩溃。"></a> 如果这个对象被判定为有必要执行 finalize 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的 Finalizer 线程去执行它。<strong>注意：如果一个对象在 finalize 方法中运行缓慢，将会导致队列后的其他对象永远等待，严重时将会导致系统崩溃。</strong></h1><p>finalize 方法是对象逃脱死亡命运的最后一道关卡。稍后 GC 将对队列中的对象进行第二次规模的标记，<strong>如果对象要在 finalize 中 “拯救” 自己，只需要将自己关联到引用上即可，通常是 this。</strong>如果这个对象关联上了引用，那么在第二次标记的时候他将被移除出 “即将回收” 的集合；如果对象这时候还没有逃脱，那基本上就是真的被回收了。</p>
</blockquote>
<p>这里需要注意的一点就是：<strong>一个对象如果重写了 finalize 方法，那么这个方法最多只会被执行一次。</strong></p>
<p>建议：<strong>如非必要，不要重写该方法。</strong>可以使用 try-finally 代替，此方式更好，更及时。同时注意：在 Mysql 的 JDBC 驱动中，com.mysql.jdbc.ConnectionImpl 就实现了 finalize 方法，作用是：当一个 JDBC Connection 被回收时，需要进行连接的关闭，如果开发人员忘记了关闭，则在 finalize 方法中进行关闭。但是，由于其调用的不确定性，这不能单独作为可靠的资源回收手段。</p>
<p>到这里，我们知道了什么时候进行回收：如果一个对象重写了 finalize 方法且这个方法没有被 JVM 调用过，那么这个对象会被放入一个队列等待被一个低优先级的线程执行 finalize 方法，如果在这个方法中对象不能自救，则这个对象在第二次标记过程中就会被标记死亡，等待 GC 回收。</p>
<h2 id="3-如何回收？"><a href="#3-如何回收？" class="headerlink" title="3. 如何回收？"></a>3. 如何回收？</h2><p>如何回收，这个问题非常的大，涉及到各种垃圾回收算法，各种垃圾收集器。限于本篇的篇幅，楼主将不会在这篇文章里深入探讨，这里只会列出一些大纲，这些大纲将是后面文章的摘要，我们将在后面的文章中深入探讨如何回收。</p>
<p>那么，有哪些摘要呢？</p>
<h5 id="3-1-垃圾回收算法"><a href="#3-1-垃圾回收算法" class="headerlink" title="3.1 垃圾回收算法"></a>3.1 垃圾回收算法</h5><ol>
<li>标记清除算法</li>
<li>复制算法</li>
<li>标记整理算法</li>
<li>分代收集算法（堆如何分代）</li>
</ol>
<p>这些算法是 GC 的基础，所有 GC 的实现都是基于这些算法来清除无用对象，然后释放内存空间。我们将会在后面的文章一个一个讲解。</p>
<h5 id="3-2-有哪些垃圾收集器"><a href="#3-2-有哪些垃圾收集器" class="headerlink" title="3.2 有哪些垃圾收集器"></a>3.2 有哪些垃圾收集器</h5><ol>
<li>Serial 串行收集器（只适用于堆内存256m 一下的 JVM ）</li>
<li>ParNew 并行收集器（Serial 收集器的多线程版本）</li>
<li>Parallel Scavenge （PS 收集器，该收集器以吞吐量为主要目的，是1.8的默认 GC）</li>
<li>CMS 收集器（该收集器全称 Concurrent Mark Sweep，是一种关注最短停顿时间的垃圾收集器）</li>
<li>G1 收集器（JDK 9 的默认 GC）</li>
</ol>
<h5 id="3-3-有哪些GC"><a href="#3-3-有哪些GC" class="headerlink" title="3.3 有哪些GC"></a>3.3 有哪些GC</h5><ol>
<li>Young GC（又称 YGC，minor GC，年轻代 GC）</li>
<li>Old GC （老年代 GC，只有 CMS 才会单独回收 Old 区）</li>
<li>Full GC（又称 major GC）</li>
<li>Mixed GC（混合 GC，G1 收集器独有）</li>
</ol>
<p>好，以上就是如何回收的大纲，我们将在后面的文章中慢慢讲解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要总结了什么是 GC ，以及 GC 的作用，GC 主要做了3件事情，哪些内存需要回收，什么时候回收，如何回收。我们知道了 GC 通过可达性分析知道了哪些内存需要回收，那什么时候回收呢？执行 finalize 方法后如果还没有复活，将被回收。第三个问题：如何回收呢？这个问题是一个大课题，我们只是列出了一些大纲，比如有哪些垃圾收集器，有哪些垃圾算法，有哪些 GC 过程。这些细节我们将在后面慢慢讲解，逐步深入。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出-JVM-GC（2）</title>
    <url>/2018/02/18/2018/2018-02-18-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-JVM-GC%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       在 [深入浅出 JVM GC（1）](https://www.jianshu.com/p/f29d013c4f46) 中，限于上篇文章的篇幅，我们留下了一个问题 : 如何回收？ 这篇文章将重点讲述这个问题。

<p>在上篇文章中，我们也列出了一些大纲，今天我们就按照那个大纲来逐个讲解。在此，我将大纲复制过来。</p>
<p><strong>垃圾回收算法</strong></p>
<ol>
<li> 标记清除算法</li>
<li> 复制算法</li>
<li> 标记整理算法</li>
<li> 分代收集算法（堆如何分代）</li>
</ol>
<p><strong>有哪些垃圾收集器</strong></p>
<ol>
<li> Serial 串行收集器（只适用于堆内存256m 以下的 JVM ）</li>
<li> ParNew 并行收集器（Serial 收集器的多线程版本）</li>
<li> Parallel Scavenge （PS 收集器，该收集器以吞吐量为主要目的，是1.8的默认 GC）</li>
<li> CMS 收集器（该收集器全称 Concurrent Mark Sweep，是一种关注最短停顿时间的垃圾收集器）</li>
<li> G1 收集器（JDK 9 的默认 GC）</li>
</ol>
<p><strong>有哪些GC</strong></p>
<ol>
<li> Young GC（又称 YGC，minor GC，年轻代 GC）</li>
<li> Old GC （老年代 GC，只有 CMS 才会单独回收 Old 区）</li>
<li> Full GC（又称 major GC）</li>
<li> Mixed GC（混合 GC，G1 收集器独有）</li>
</ol>
<h2 id="1-有哪些垃圾回收算法"><a href="#1-有哪些垃圾回收算法" class="headerlink" title="1. 有哪些垃圾回收算法"></a>1. 有哪些垃圾回收算法</h2><ol>
<li> 标记清除算法</li>
<li> 复制算法</li>
<li> 标记整理算法</li>
<li> 分代收集算法（堆如何分代）</li>
</ol>
<h5 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1. 标记清除算法"></a>1. 标记清除算法</h5><p>GC 中最基础的算法就是标记-清除算法，所谓标记清除，就是通过可达性分析，标记哪些是垃圾对象，然后清除。之所以说是最简单的算法，是因为后面的几种算法都是基于它的。</p>
<p>但是这个算法有2个不足之处：1. 碎片问题，标记清除之后会导致大量内存不连续的碎片，空间碎片太多会导致分配大对象时无法找到足够的连续内存从而提前触发 Full GC （此 GC 严重影响应用性能）。2. 效率问题，标记和清除这两个过程的效率都不高。我们通过一幅图来看看标记清除的算法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f97668ac64da7381.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标记清除算法示意图"></p>
<p>可以从上图看出，回收后，出现了大量的内存不连续的内存块。</p>
<h5 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h5><p>为了解决效率问题，人们发明了一种复制算法（Coping）。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的用完了，就开始垃圾回收，将有用的对象复制到另一个空闲的内存上，清空之前使用的内存块。这样使得每次都对整个半区回收，而且也不用考虑<strong>内存碎片</strong>问题，只需要移动堆顶指针，按顺序分配即可，实现简单，运行高效。</p>
<p>但是凡事都是有缺点的，复制算法的缺点就是内存缩小到了原来的一半，无法充分利用内存空间。</p>
<p>总是有取舍的。</p>
<p>现代的所有商业虚拟机都是采用这种算法来回收新生代。基于统计学，人们得出99% 的对象都是朝生夕死的，所以不需要留出那么大的空间保存存活的对象，也就是不要1:1 的比例来划分内存。</p>
<p>通常的做法是：</p>
<blockquote>
<p>将内存分为一个较大的Eden（伊甸园）空间和两块较小的 Survivor（幸存区）空间，每次使用 Eden 和其中一块 Survivor ，当回收时，将 Eden 和 Survivor 还存活着的对象一次性的<strong>复制</strong>到另外一块 Survivor 空间，最后清理掉 Eden 和刚刚使用的 Survivor 空间。Hotspot 默认的比例是 8：1：1，也就是说，每次新生代可用内存空间为新生代总空间的90%，只有10%的内存会被浪费，从一定程度上解决了复制算法浪费空间的问题。</p>
</blockquote>
<p>当然，98% 的对象可回收只是一般的情况下，我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时怎么办呢？肯定需要依赖其他内存（老年代）进行所谓的<strong>分配担保（Handle Promotion）。</strong></p>
<p>什么是分配担保呢？</p>
<blockquote>
<p>如果另外一块 Survivor 区域没有足够空间存放上一次新生代手机下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。当然，具体细节这句话无法详细说明，我们将会在之后阐述具体细节。</p>
</blockquote>
<h5 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3. 标记整理算法"></a>3. 标记整理算法</h5><p>从上面我们可以看出，复制算法的效率很高，请注意，该算法只有在对象存活率较低的时候（98% 对象可被回收）才能体现出效率。而如果一次 GC 活动之后，存活对象很多，那么就需要复制大量的对象，很明显，会导致效率不高；更关键的是，还需要额外的空间进行<strong>分配担保</strong>。</p>
<p>所以，存活对象时间很长的老年代一般不使用该算法。</p>
<p>根据老年代的特点，一般使用“标记-整理（Mark-Compact）”算法，标记过程仍然与 “标记清除” 算法一样，但我们知道，标记清除算法会产生大量的内存碎片，对性能影响很大，所以标记整理算法后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象像一个方向移动，然后清理掉边界之外的内存。也就是将那些原来散落的对象移动在一起，让碎片不再存在。</p>
<p>可以说，标记整理算法相对于标记清除算法牺牲了一些性能，但却避免了内存碎片的产生，在大部分场合，可抵消掉整理过程中产生的性能损耗。</p>
<h5 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h5><p>上面我们提到了几个名词，新生代，老年代，这些就是分代算法中名词。分代算法最主要的就是根据对象存活周期的不同将内存分成几块，一般是把 Java 堆分成新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理” 或者 “标记整理” 算法来进行回收。</p>
<h2 id="2-有哪些垃圾收集器"><a href="#2-有哪些垃圾收集器" class="headerlink" title="2. 有哪些垃圾收集器"></a>2. 有哪些垃圾收集器</h2><p>上面说的这些算法都是实现垃圾收集器的基础。</p>
<p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<p>Hotspot 虚拟机所包含的所有收集器如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-4dddb48f13d54c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hotspot 所有 GC 组合"></p>
<p>从上图中看到，一共有6种 GC 组合（忽略 G1 和 为CMS备份的 SerialOld 组合 ）。</p>
<ol>
<li>Serial + Serial Old</li>
<li>Serial + CMS</li>
<li>ParNew + CMS</li>
<li>ParNew + Serial Old</li>
<li>Parallel Scavenge + Serial Old</li>
<li>Parallel Scavenge + Parallel Old</li>
</ol>
<p>大家看到这里，一定有个疑问，为什么需要这么多垃圾收集器？</p>
<p>答案是：没有任何一种垃圾收集器是完美的，没有任何一种垃圾收集器适合所有的应用情况。</p>
<p>每个应用都需要自己的特定垃圾收集器，因此，可以说，GC 调优是门艺术，没有放之四海皆准的 GC。需要工程师们去根据应用的特性不断调优。</p>
<p>这么多 GC ，限于篇幅，我们将在 <a href="https://www.jianshu.com/p/fe70af687bc0">深入浅出 JVM GC（3）</a> 中慢慢解释。<br>这里只是列出一个大纲。</p>
<p>接下来我们将说说关于 GC 的一些概念，方便阅读后面的关于 GC 处理器的文章。</p>
<h2 id="3-有哪些GC"><a href="#3-有哪些GC" class="headerlink" title="3. 有哪些GC"></a>3. 有哪些GC</h2><ol>
<li> Young GC（又称 YGC，minor GC，年轻代 GC）</li>
<li> Old GC （老年代 GC，只有 CMS 才会单独回收 Old 区）</li>
<li> Full GC（又称 major GC）</li>
<li> Mixed GC（混合 GC，G1 收集器独有）</li>
</ol>
<p>关于这些 GC 的分类，R 大一个回答比较清楚：<a href="https://www.zhihu.com/question/41922036">Major GC和Full GC的区别是什么？触发条件呢？</a></p>
<p>从大的方面讲，GC 只分为两种，一种是不收集整个堆，一种是收集整个堆。</p>
<p>Partial GC：并不收集整个GC堆的模式</p>
<ol>
<li>Young GC：只收集young gen的GC</li>
<li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li>
<li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li>
</ol>
<p>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</p>
<h5 id="1-YGC"><a href="#1-YGC" class="headerlink" title="1. YGC"></a>1. YGC</h5><p>YGC 又称 Young GC ，minor GC ，年轻代 GC。顾名思义，该 GC 过程发生在年轻代中。从分代算法中，我们知道，JVM 为了性能考虑，通常将内存区域根据对象生命周期的不同分为年轻代和年老代。</p>
<p>新创建的对象基本上都存放在年轻代（除了一些大对象），因为大多数对象都是很快变成引用不可达，所以大多数对象都在年轻代中创建，然后消失。当对象从这块内存区域消失时，我们称之为 YGC。</p>
<p>什么时候发生 YGC 呢？当 Eden 不够放入新创建的对象时，也就是Eden 区满了，JVM 就会清理Eden 区的空间，将存活的对象放入 to 区，如果 to 区放不下，则直接进入老年代。如果 to 区能放下，则放入 to 区，然后清理掉无用对象，第二次 YGC 时，GC 扫描 Eden 区和 to 区，将这两个区的存活对象放入到 from 区，将 to 区清空（总之一定会保证有一个 Survivor 区是干净的），同样的，如果 from 区放不下，则通过分配担保机制进入老年代。如果 YGC 后，仍放不下新对象，则也通过分配担保进入老年代。</p>
<h5 id="2-Old-GC"><a href="#2-Old-GC" class="headerlink" title="2. Old GC"></a>2. Old GC</h5><p>通常，我们将 Old GC 等同于 Full GC，为什么呢？我们详细解释一下。</p>
<p>什么时候发生 Old GC？ 当老年代空间满了的时候。也就是说通常是 YGC 后有很多对象进入到老年代，而老年代无法放下这些对象，这时候就需要对老年代 GC。而通常的 Old GC 其实就是 Full GC 。</p>
<h5 id="3-Full-GC"><a href="#3-Full-GC" class="headerlink" title="3. Full GC"></a>3. Full GC</h5><p>也就是全 GC ，对整个堆和方法区（如果存在）进行 GC。<br>哪些情况会 Full GC 呢？</p>
<ol>
<li>System.gc() 方法的调用</li>
<li>heap dump 带 GC </li>
<li>永久代（方法区）空间不够</li>
<li>当准备出发 YGC 时，发现之前 YGC 后晋升对象的大小比目前 Old 区的剩余空间大，则不会触发 YGC ，转而直接触发 Full GC。</li>
</ol>
<p>第四条说到晋升，什么是晋升呢？YGC 后，幸存的对象会放入到 Survivor 区，如果一个对象在多次 YGC 后仍然存活，则进入老年代，这个过程叫做晋升。每次 YGC 后，这个对象的年龄加一。当然，晋升的条件比较复杂。我们后面会详细讲述。</p>
<h5 id="4-Mixed-GC"><a href="#4-Mixed-GC" class="headerlink" title="4. Mixed GC"></a>4. Mixed GC</h5><p>G1 专属GC，这里不准备讲述这个 GC。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我们解释了3种垃圾回收算法，第四个不算是算法，而是一种设计。还大致讲了5种收集器，并将这个坑留在了后面的文章里，最后讲了一些 GC 术语，YGC ，Old GC ，Full GC 等。</p>
<p>好了，关于5种垃圾收集器的详细介绍，我们将在 <a href="https://www.jianshu.com/p/fe70af687bc0">深入浅出 JVM GC（3）</a>中详细说明。</p>
<p>good luck！！！</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出-JVM-GC（3）</title>
    <url>/2018/02/18/2018/2018-02-18-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-JVM-GC%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## # 前言

<p>在  <a href="https://www.jianshu.com/p/18931fbdac05">深入浅出 JVM GC（2）</a> 中，我们介绍了一些 GC 算法，GC 名词，同时也留下了一个问题，就是每个 GC 收集器的具体作用。有哪些 GC 收集器呢？</p>
<ol>
<li>Serial 串行收集器（只适用于堆内存 256M 以下的 JVM ）</li>
<li>ParNew 并行收集器（Serial 收集器的多线程版本）</li>
<li>Parallel Scavenge （PS 收集器，该收集器以吞吐量为主要目的，是1.8的默认 GC）</li>
<li>CMS 收集器（该收集器全称 Concurrent Mark Sweep，是一种关注最短停顿时间的垃圾收集器）</li>
<li>G1 收集器（JDK 9 的默认 GC）</li>
</ol>
<p>再回顾一下我们的那张图吧：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4dddb48f13d54c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700"></p>
<p>下面我们就一一介绍这些垃圾收集器吧！</p>
<h2 id="1-Serial-串行收集器（只适用于堆内存256m-以下的-JVM-）"><a href="#1-Serial-串行收集器（只适用于堆内存256m-以下的-JVM-）" class="headerlink" title="1. Serial 串行收集器（只适用于堆内存256m 以下的 JVM ）"></a>1. Serial 串行收集器（只适用于堆内存256m 以下的 JVM ）</h2><p>什么是串行收集器呢？</p>
<blockquote>
<p>串行收集器是指使用单线程进行垃圾回收的回收器。每次回收时，串行收集器只有一个工作线程，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收器和老年代串行回收器。</p>
</blockquote>
<p>串行回收器可以说是最古老的垃圾回收器了，主要由2个特点：</p>
<ol>
<li>他仅仅使用单线程进行垃圾回收。</li>
<li>他是独占式的垃圾回收器。</li>
</ol>
<p>什么是独占式呢？</p>
<blockquote>
<p>在串行收集器金进行垃圾回收时，Java 应用程序中的线程都要暂停，等待垃圾回收的完成。这种现象称之为 “Stop-The-World”，他将造成非常糟糕的用户体验，在实时性较高的应用场景中，这种现象往往是不能接受的。</p>
</blockquote>
<p>即便如此，串行回收期却是一个成熟且经过长时间生产环境考验的极为高效的收集器。<strong>新生代串行收集器使用复制算法</strong>，实现相对简单，且没有线程切换的开销。在单 CPU 环境下性能表现良好。</p>
<p>我们可以使用 -XX：UseSerialGC 参数，指定<strong>使用新生代串行收集器和老年代串行收集器</strong>。注意，当虚拟机在 client 模式下，它是默认的垃圾收集器。</p>
<p>当然还有老年代串行收集器。</p>
<p><strong>老年代串行收集器使用的标记压缩算法</strong>，也是一个独占式的单线程的垃圾收集器。由于老年代的垃圾回收通常比新生代垃圾回收需要更多的时间，因此，一旦老年代垃圾回收期启动，系统将停顿很长时间。</p>
<p>即便如此，Serial 老年代处理器也是大名鼎鼎的 CMS 处理器的备用处理器。</p>
<h2 id="2-ParNew-并行收集器（Serial-收集器的多线程版本）"><a href="#2-ParNew-并行收集器（Serial-收集器的多线程版本）" class="headerlink" title="2. ParNew 并行收集器（Serial 收集器的多线程版本）"></a>2. ParNew 并行收集器（Serial 收集器的多线程版本）</h2><p>上面我们说 Serial 是单线程的处理器，在单核 CPU 情况下，Serial 是个不错的选择，但现代计算机普遍都是多核，因此需要并行的处理器。</p>
<p>ParNew 就是 Serial 的并行版本。多个线程同时回收，有效缩短垃圾回收所需要的实际时间。</p>
<p>ParNew 是一个工作在新生代的垃圾收集器，他只是简单的将串行收集器多线程化，他的回收策略，算法以及参数和新生代串行收集器是相同的。同时也是独占式的收集器，在收集过程总，应用会全部暂停。但由于并行回收期用多线程回收，因此，在并发能力比较强的 CPU 上，他产生的停顿时间要短于串行回收器。反之，如果 CPU 并行能力弱，不如使用串行收集器。</p>
<p>同时，既然是多线程的，虚拟机给我们提供了指定线程数量的参数 -XX:ParallelGCThreads，一般，最好和 CPU 数量相当，默认情况下，当 CPU 数量小于8，ParallelGCThreads 等于 CPU 数量，当 CPU 数量大于 8时，公式是： 3 + （（5 * CPU——Count）/8)。</p>
<h2 id="3-Parallel-Scavenge-（PS-收集器，该收集器以吞吐量为主要目的，是1-8的默认-GC）"><a href="#3-Parallel-Scavenge-（PS-收集器，该收集器以吞吐量为主要目的，是1-8的默认-GC）" class="headerlink" title="3. Parallel Scavenge （PS 收集器，该收集器以吞吐量为主要目的，是1.8的默认 GC）"></a>3. Parallel Scavenge （PS 收集器，该收集器以吞吐量为主要目的，是1.8的默认 GC）</h2><p>Parallel Scavenge 收集器，又称 PS 收集器，也是多线程的，和 ParNew 类似，但是，PS 收集器更关注吞吐量。</p>
<p>因此，PS 处理器特意提供了连个参数用于设置吞吐量相关。<br>-XX:MaxGCPauseMillis ：设置最大垃圾收集停顿时间，他的值是一个大于0的整数，ParallelGC 在工作时，会调整 Java 堆大小或者其他一些参数，尽可能的把停顿时间控制在 XX:MaxGCPauseMillis 以内。如果设置的很小，对应的，PS 收集器会将堆设置的很小（小堆比大堆回收快），导致垃圾回收变得频繁，从而降低了吞吐量。</p>
<p>-XX:GCTimeRatio: 设置吞吐量大小，他的值是一个0 - 100 之间的整数，假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n)的时间用于垃圾收集，比如 n 是 19，则系统用于垃圾收集的时间不超过 1/(1+19) = 5%的时间用于垃圾收集，默认情况下，取值为99，即不超过 1% 的时间用于垃圾收集。</p>
<p>注意：PS 收集器是一个自适应的收集器，使用 -XX：UseAdaptiveSizePolicy 可以打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 Survivor 的比例，晋升老年代的年龄阈值将会别自动调整<br>，以达到在堆大小，吞吐量和停顿时间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆，目标吞吐量（GCTimeTatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</p>
<p>也许大家也看到了，GCTimeRatio 和 MaxGCPauseMillis 两个参数有冲突的，通常如果减少一次垃圾收集的停顿时间，意味着你的吞吐量就会下降，如果吞吐量设置的很高，那么你的垃圾收集停顿时间又会变大。</p>
<h6 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h6><p>有新生代 Parallel Scavenge 收集器，也有老年代 Parallel Old 收集器，他也是一种关注吞吐量的垃圾收集器。故名思意，他是一种工作在 Old 区的垃圾收集器，并且和 Parallel Scavenge 一起使用。Parallel Old 收集器使用的标记压缩算法。</p>
<h2 id="4-CMS-收集器（该收集器全称-Concurrent-Mark-Sweep，是一种关注最短停顿时间的垃圾收集器）"><a href="#4-CMS-收集器（该收集器全称-Concurrent-Mark-Sweep，是一种关注最短停顿时间的垃圾收集器）" class="headerlink" title="4. CMS 收集器（该收集器全称 Concurrent Mark Sweep，是一种关注最短停顿时间的垃圾收集器）"></a>4. CMS 收集器（该收集器全称 Concurrent Mark Sweep，是一种关注最短停顿时间的垃圾收集器）</h2><p>我们上面说  Parallel Scavenge 和 Parallel Old 收集器都是关注吞吐量的，而现在说的 CMS 处理器则是关注停顿时间的。CMS 是 Concurrent Mark Sweep 的缩写，意味并发标记清除，从名称上可以得知，他使用的是标记清除算法（缺点是产生内存碎片），同时他又是一个使用多线程并行回收的垃圾收集器。</p>
<p>相对于 Serial Old, Parallel Old 这两个老年代处理器，CMS 比较复杂，为了实现更短的停顿时间，将 GC 的流程更加的细化。</p>
<p>我们仔细思考，GC 有标记和清理两个过程，事实上，清理的过程是不要 STW（Stop-The-World）的，只有在标记的时候，需要暂停所有应用线程，防止引用关系更改。因此 CMS 做了如下的设计：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-561c63cde0b5272e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CMS 工作过程"></p>
<p>上图有6个步骤，但大部分书中都是4个步骤，也就是绿色方框中的，注意，其中初始标记和重新标记都是要系统停顿的，而并发标记和重并发清理都是和系统应用程序并发执行的，因此，相对于上面的两个收集器，CMS 收集器的停顿时间要小的多。</p>
<p>那么我们就详细说说这几个步骤。</p>
<ol>
<li>初始标记，初始标记仅仅是标记一下 GC Roots 能直接关联到的对象，速度很快。</li>
<li>并发标记阶段就是进行 GC Roots 的跟踪过程。</li>
<li>预处理，由于并发标记阶段是和应用程序并发执行的，因此，极有可能会产生大量新生的对象指向老年代的对象，引用关系发生变化，同时，后续的 remark 阶段是独占式的，如果不处理那些新生对象和老年代对象的关系，那么 remark 阶段将非常耗时，严重影响性能。因此，在预处理阶段，将会尽量处理那些变化的老年代对象，默认5秒之内，在这段时间内，CMS 会尽量处理那些变化的对象，特别是新生代中的对象，其实这5秒，实际上是在等待一次 YGC，希望 YGC 能够把那些新生的对象消除，避免后面的 remark 阶段扫描导致长时间暂停。不过，这个功能可以通过 -XX:-CMSPrecleaningenabled 关闭。当然也可以通过参数 CMSScavengeBeforeRemark 强制在此阶段发生 YGC。注意：虚拟机还会预估下次的 YGC 发生时间，尽量不让 remark 阶段和下一次 YGC 阶段重叠，防止停顿时间过长。</li>
<li>重新标记，为了修正并发标记期间因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段的暂停时间一般会比初始标记时间稍长一些，但远比并发标记的时间短。</li>
<li>并发清理，没啥说的。</li>
<li>重置之前的状态。</li>
</ol>
<p>可以说 CMS 还是比之前的稍微的复杂了一点。同时，CMS 还有3个地方需要注意：</p>
<ol>
<li>CMS 对 CPU 资源敏感，什么意思呢？由于 CMS 是并发执行的，虽然不会导致应用程序暂，但是会抢夺 CPU 的资源，应用程序的性能会受到影响。默认线程数是 （CPU + 3）/ 4。所以需要妥当设定好 ParallelGCThreads 参数。</li>
<li>由于并发清理阶段程序会继续运行，会产生大量的对象，如果内存不够，将会出现 Concurrent Mode Failure 同时 Full GC，并使用备用收集器 Serial ，停顿时间将会非常的长。当出现这种情况的时候，使用 -XX:CMSInitiatingOccupancyFraction 的值来设定老年代的空间使用的百分率来触发 CMS，如果 Old 区内存增长很快，则设置的低一些，防止 Full GC，反之，则可以设置的高一些，尽量减少Old GC。</li>
<li>由于 CMS 基于标记清除算法，肯定会有内存碎片，因此虚拟机提供了 -XX:+UseCMSCompactAtFullCollection 开关参数（默认开启）,用于在 CMS 顶不住要进行 FGC 的最后进行碎片整理，但停顿时间会变长，因此，虚拟机还提供了一个参数 -XX:CMSFullGCsBeforeCompaction ，这个参数是用于设置执行了多少次不压缩的 FGC 后，跟着来一次整理的（默认是0，也就是每次都整理）。</li>
</ol>
<h2 id="5-G1-收集器（Garbage-First，JDK-9-的默认-GC）"><a href="#5-G1-收集器（Garbage-First，JDK-9-的默认-GC）" class="headerlink" title="5. G1 收集器（Garbage-First，JDK 9 的默认 GC）"></a>5. G1 收集器（Garbage-First，JDK 9 的默认 GC）</h2><p>G1 远比 CMS 复杂。</p>
<p>G1 收集器是 Java9 的默认收集器，Oracle 声称 G1 将会替代 CMS。为什么叫 G1 呢，G1 全称 Garbage-First，也就是垃圾优先。这和他的回收策略有关。我们慢慢往下看。</p>
<p>G1有5个特点：</p>
<ol>
<li>并行性，G1在回收期间，可以让多个线程同时工作，这点其实上述几个收集器都可以（除了 Serial）。</li>
<li>并发性，G1 拥有和CMS相同的作用，也就是和应用程序部分并发执行。</li>
<li>分代 GC，G1 最大的区别就是他既工作在年轻代和工作在老年代，和之前的 GC 收集器完全不同。</li>
<li>空间整理，我们上面说 CMS 有一个缺点是内存碎片，虽然可以通过一些参数解决，但还是不够完美，而 G1 从某种角度看不是基于标记清除算法，而是基于复制算法。因此不会产生碎片。</li>
<li>可预测的停顿，由于分区的原因，G1可以只选取部分区域进行内存回收，缩小了范围，相应的减少了系统停顿。</li>
</ol>
<p>那么 G1 到底是怎么做到这些的呢？</p>
<p>在 G1之前，垃圾收集器的工作范围都是整个新生代或者老年代，但它不是。它的内存布局和其他收集器不同，它将整个 Java 堆分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，他们都是一部分 Region 的集合。</p>
<p>G1 只所以可以预测停顿时间，是因为它不再像别的收集器那样收集整个新生代或者老年代，而是回收一部分 Region。</p>
<p>G1 跟踪各个 Region 里面的垃圾的价值大小（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也是 Garbage-First的由来）。这种根据垃圾价值来回收 Region 的方式保证了 G1在有限的时间里回收更多的内存。</p>
<p>这其实就是“化整为零”。</p>
<p>在 JVM 启动时不需要立即指定哪些 Region 属于年轻代，哪些 Region 属于老年代，因为无论是年轻代还是老年代，他们都不需要一大块连续的内存，只是由一系列 Region 组成而已。随着时间的流逝，Region 有时属于新生代，有时属于老年代，来回变动。例如开始的时候，Region A 被分配给年轻代，一个年轻代回收结束后，这个 Region 又被放回了空闲/可用Region 队列，可能下一次就被分配给了一个老年代对象使用。</p>
<p>但是一切并不是那么容易。</p>
<p>Region 不可能是孤立的，一个对象分配在某个 Region 中，他并非只能被本 Region 中的其他对象引用，而是可以与整个 Java 堆任意的对象发生引用关系。在做可达性判断的时候，难道要扫描整个堆吗？也就是说，如果回收新生代的时候同时也扫描老年代，那么 YGC 的效率将会大打折扣。</p>
<p>G1 如何处理这个问题的呢？Region 之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，JVM 都是使用 Remembered Set 来避免全堆扫描的。<strong>G1 中每个 Region 都有一个与之对应的 Remembered Set</strong>。当Region 中的引用发生变化的时候，G1 将会把这些信息记录到一个 CardTable 数据结构中并存到被引用对象所属Region 的 RSet 中。当进行内存回收哦时，在 GC 根节点的枚举范围中加入  RSet 即可保证不对全堆扫描也不会有遗漏。一般来说，RSet 的大小占整个 Java 堆空间的1% - 20%。</p>
<p>G1 把整个 Java 堆划分成若干个Region，每个 Region 大小为2的倍数，范围在 1MB-32MB 之间，可能是1MB，2MB，4MB，8MB，16MB，32MB。所有的 Region 有一样的大小，最多可以有 2048 个 Region，在 JVM 生命周期内都不会改变。</p>
<p><strong># G1 的收集过程</strong></p>
<p>G1  收集过程分为4个阶段：</p>
<ol>
<li>新生代 GC。</li>
<li>并发标记周期</li>
<li>混合收集</li>
<li>如果需要，将进行 FGC</li>
</ol>
<p>G1 YGC 的过程和之前的YGC 基本相同：当 Eden 区占满，YGC 就会启动，YGC 只处理 Eden 和 Survivor 区，回收后，所有的 Eden 区都应该被清空，而 Survivor 区会被收集一部分数据，但是应用至少仍然存在一个 Survivor 区。另外，老年代的 Region 会增多，因为通常YGC 后会有大量的对象晋升到老年代。</p>
<p>当老年代的使用率达到了一定的阈值，则会触发并发标记，而并发标记的主要目的则是为了标记出那些垃圾比例较高的 Region，为后面的混合收集服务，即收集整个新生代和部分老年代。而并发标记的过程和 CMS 相似。可以参考 CMS 的过程。</p>
<p>在之前的并发标记过程中，已经标记出来垃圾比例较高的 Region，此时轮到混合回收出场了，而这也是 G1 的由来，Garbage First ，优先回收垃圾比例较高的 Region。之所以叫混合回收，是因为既执行正常的年轻代 GC，又会选取一些被标记的老年代 Region 进行回收。被清理的区域中的存货对象会被拷贝到其他区域，消除了 CMS 产生的内存碎片。<br>混合 GC 会执行多次，直到回收了足够多的内存空间，然后，他会触发一次 YGC，YGC 后，又可能会发生一次并发周期的处理，最后，又会引起混合 GC 的执行，循环反复。如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2e8ba996a8146c5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="混合 GC 过程"></p>
<p>如果内存增长的很快，而混合 GC 的速度又跟不上，老年代被填满，则进行一次FGC。而 G1 和 FGC 算法是单线程的 Serial GC，因此会造成长时间的停顿，所以，一定要避免 FGC 出现。</p>
<p><strong># 什么时候使用 G1？</strong><br>如果一个应用程序员具有如下特征，那么将 CMS 或 ParallelOldGC 切换到G1将会大大提高性能。否则还请继续使用 CMS。</p>
<ol>
<li>Full GC 次数太频繁或者消耗时间太长。</li>
<li>对象分配的频率或代数（promotion）显著变化。</li>
<li>受够了太长的垃圾回收或内存整理时间（超过0.5s-1s）。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a>#总结</h2><p>到这里，我们的5个垃圾收集器大致也就介绍完了。注意，我们这里只是一些 概念性的介绍，甚至没有贴出 GC 日志和大家一起分析。但 GC 的调优是一门艺术，需要不断的试错，才能针对当前的应用找到一个完美的配置，什么是完美的配置？YGC  时间尽量短，FGC 尽量没有，如果有 CMS 或者 G1，尽量保证停顿时间尽可能的短。</p>
<p>我们将会在后面的文章继续学习 GC 的只是，这里只是抛砖引玉。如果有不对的地方，还请指出。感谢！</p>
<p>good luck!!!</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出-JVM-GC（4）常用-GC-参数介绍</title>
    <url>/2018/02/20/2018/2018-02-20-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-JVM-GC%EF%BC%884%EF%BC%89%E5%B8%B8%E7%94%A8-GC-%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->从前面的3篇文章中，我们分析了5个垃圾收集器，还有一些 GC 的算法，那么，在 GC 调优中，我们肯定会先判断哪里出现的问题，然后再根据出现的问题进行调优，而调优的手段就是 JVM 提供给我们的那些参数或者说选项，这些参数将会改变 GC 的运行方式。因此，他们显得极为重要。

<p>我们将每一个垃圾收集器相关的参数一个一个娓娓道来，注意，楼主推荐一个小程序：前阿里 JVM 大神寒泉子的公众号里面有个小程序——JVM Pocket，这个小程序介绍了所有的 JVM 参数的作用，你可以在里面搜索你想知道的参数，也可以把你了解的参数写上去供大家参考。公众号：lovestblog。</p>
<p>值得注意的一点是，这些参数可能会重复，还记得我们之前的那张图吗，楼主觉得有必要再发一次：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4dddb48f13d54c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700"></p>
<p>可以看到，这些收集器会有一些重复，而且，某些参数也是会作用于所有的处理器，因此，我们下面的介绍可能会有一些重复。</p>
<p>还有一点就是，JVM 为我们设置了很多默认的参数，但是，如果可以的话，还是建议使用显式的声明，这样更能表达意图。否则，别人不一定知道我们是否知道这些默认值。</p>
<p>我们开始我们的参数之旅吧！</p>
<h2 id="1-Serial-收集器参数"><a href="#1-Serial-收集器参数" class="headerlink" title="# 1. Serial 收集器参数"></a># 1. Serial 收集器参数</h2><p>串行收集器，client 的默认收集器，分为年轻代 Serial 和老年代 Serial Old 收集器。</p>
<ol>
<li><p>-XX:+UseSerialGC 这个参数就是可以指定使用新生代串行收集器和老年代串行收集器， “+” 号的意思是ture，开启，反之，如果是 “-”号，则是关闭。</p>
</li>
<li><p>-XX:+UseParNewGC 新生代使用 ParNew 回收器，老年代使用串行收集器。</p>
</li>
<li><p>-XX:+UseParallelGC 新生代私用 ParallelGC 回收器，老年代使用串行收集器。</p>
</li>
</ol>
<p>而 Serial 收集器出现的日志为 DefNew . </p>
<h2 id="2-ParNew-收集器参数"><a href="#2-ParNew-收集器参数" class="headerlink" title="# 2. ParNew 收集器参数"></a># 2. ParNew 收集器参数</h2><p>并行收集器是 Serial 的多线程版本，在 CPU 并行能力强大的计算机上有很大优势。</p>
<p>其中：</p>
<ol>
<li><p>-XX:+UseParNewGC 上面说过了，新生代使用 ParNew 收集器，老年代使用串行收集器。</p>
</li>
<li><p>-XX:+UseConcMarkSweepGC: 新生代使用 ParNew 回收器，老年代使用 CMS。</p>
</li>
<li><p>-XX:ParallelGCThreads={value}  这个参数是指定并行 GC 线程的数量，一般最好和 CPU 核心数量相当。默认情况下，当 CPU 数量小于8， ParallelGCThreads 的值等于 CPU 数量，当 CPU 数量大于 8 时，则使用公式：3+（（5*CPU）/ 8）；同时这个参数只要是并行 GC 都可以使用，不只是 ParNew。</p>
</li>
</ol>
<p>而 ParNew 的 GC 日志则表吸纳出 ParNew。</p>
<h2 id="3-PS-收集器参数"><a href="#3-PS-收集器参数" class="headerlink" title="# 3. PS 收集器参数"></a># 3. PS 收集器参数</h2><p>全称 Parallel Scavenge 收集器，该收集器是 Java 8 的默认收集器，因为它能够根据系统当前状态给出吞吐量最高的GC 配置。所以，在一些手工调优复杂的场合或者对实时性要求不高的场合，可以使用该处理器。</p>
<p>有哪些参数呢？</p>
<ol>
<li><p>-XX:MaxGCPauseMillis 设置最大垃圾收集停顿时间，他的值是一个大于0的整数。ParallelGC 工作时，会调整 Java 堆大小或者其他的一些参数，尽可能的把停顿时间控制在 MaxGCPauseMillis 以内。如果为了将停顿时间设置的很小，将此值也设置的很小，那么 PS 将会把堆设置的也很小，这将会到值频繁 GC ，虽然系统停顿时间小了，但总吞吐量下降了。</p>
</li>
<li><p>-XX:GCTimeRatio 设置吞吐量大小，他的值是一个0 到100之间的整数，假设 GCTimeRatio 的值是 n ，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集，默认 n 是99，即不超过1% 的时间用于垃圾收集。</p>
</li>
<li><p>-XX:+UseParallelGC 新生代使用 ParallelGC 回收器，老年代使用串行回收器。</p>
</li>
<li><p>-XX:+UseParallelOldGC 新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。</p>
</li>
<li><p>-XX:UseAdaptiveSizePolicy: 打开自适应策略。在这种模式下，新生代的大小，eden 和 Survivor 的比例，晋升老年代的对象年龄等参数会被自动调整。以达到堆大小，吞吐量，停顿时间的平衡点。</p>
</li>
</ol>
<p>聪明的同学相比看出来了，1 和 2 两个参数是矛盾的。因为吞吐量和停顿时间就是矛盾的。所以，要根据应用的特性来进行设置，以达到最优水平。</p>
<p>同时，Parallel Old 收集器也是一种关注吞吐量的并行的老年代回收器。</p>
<ol>
<li><p>-XX:+UseParallelOldGC 新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。该参数可以启用 ParallelOldGC。</p>
</li>
<li><p>-XX:ParallelGCGThreads 同时可以指定该参数设置并行线程数量。</p>
</li>
</ol>
<p>而 PS 处理器的 GC 日志则是 PSYoungGen。</p>
<h2 id="4-CMS-收集器参数"><a href="#4-CMS-收集器参数" class="headerlink" title="# 4. CMS 收集器参数"></a># 4. CMS 收集器参数</h2><p>CMS 处理器关注的是停顿时间。全称 Concurrent Mark Sweep。因为该处理器较为复杂，因此可以使用较多参数。</p>
<ol>
<li><p>-XX:-CMSPrecleaningEnabled 不进行预清理，度过我们之前的文章的都知道，CMS 在并发标记和重新标记的这段时间内，会有一个预清理的工作，而这个通过会尝试5秒之内等待来一次 YGC。以免在后面的重新标记阶段耗费大量时间来标记新生代的对象。</p>
</li>
<li><p>-XX:+UseConcMarkSweepGC 此参数将启动 CMS 回收器。默认新生代是 ParNew，也可以设置 Serial 为新生代收集器。该参数等价于 -Xconcgc。</p>
</li>
<li><p>-XX:ParallelGCThreads 由于是并行处理器，当然也可以指定线程数。默认并发线程数是：（ParallelGCThreads + 3）/ 4）。</p>
</li>
<li><p>-XX:ConcGCThreads 或者 -XX:ParallelCMSThreads ；除了上面设置线程的方式，你也可以通过这个两个参数任意一个手工设定 CMS 并发线程数。</p>
</li>
<li><p>-XX:CMSInitiatingOccupancyFraction 由于 CMS 回收器不是独占式的，在垃圾回收的时候应用程序仍在工作，所以需要留出足够的内存给应用程序，否则会触发 FGC。而什么时候运行 CMS GC 呢？通过该参数即可设置，该参数表示的是老年代的内存使用百分比。当达到这个阈值就会执行 CMS。默认是68。 如果老年代内存增长很快，建议降低阈值，避免 FGC，如果增长慢，则可以加大阈值，减少 CMS GC 次数。提高吞吐量。</p>
</li>
<li><p>-XX：+UseCMSCompactAtFullCollection 由于 CMS 使用标记清理算法，内存碎片无法避免。该参数指定每次 CMS 后进行一次碎片整理。</p>
</li>
<li><p>-XX:CMSFullGCsBeforeCompaction 由于每次进行碎片整理将会影响性能，你可以使用该参数设定多少次 CMS 后才进行一次碎片整理，也就是内存压缩。</p>
</li>
<li><p>-XX:+CMSClassUnloadingEnabled 允许对类元数据进行回收。</p>
</li>
<li><p>-XX:CMSInitiatingPermOccupancyFraction 当永久区占用率达到这一百分比时，启动 CMS 回收（前提是 -XX:+CMSClassUnloadingEnabled 激活了）。</p>
</li>
<li><p>-XX:UseCMSInitiatingOccupancyOnly  表示只在到达阈值的时候才进行 CMS 回收。</p>
</li>
<li><p>XX:CMSWaitDuration=2000 由于CMS GC 条件比较简单，JVM有一个线程定时扫描Old区，时间间隔可以通过该参数指定（毫秒单位），默认是2s。</p>
</li>
</ol>
<p>CMS 的 GC 日志 就是 CMS。</p>
<h2 id="5-G1-收集器参数"><a href="#5-G1-收集器参数" class="headerlink" title="# 5. G1 收集器参数"></a># 5. G1 收集器参数</h2><p>作为 Java 9 的默认垃圾收集器，该收集器和之前的收集器大不相同，该收集器可以工作在young 区，也可以工作在 old 区。有哪些参数呢？</p>
<ol>
<li><p>-XX:+UseG1GC 开启 G1 收集器。</p>
</li>
<li><p>-XX:MaxGCPauseMillis 用于指定最大停顿时间，如果任何一次停顿超过这个设置值时，G1 就会尝试调整新生代和老年代的比例，调整堆大小，调整晋升年龄的手段，试图达到目标。和 PS 一样，停顿时间小了，对应的吞吐量也会变小。这点值得注意。</p>
</li>
<li><p>-XX:ParallelGCThreads 由于是并行并发的，可以指定GC 工作线程数量。</p>
</li>
<li><p>-XX:InitiatingHeapOccupancyPercent 该参数可以指定当整个堆使用率达到多少时，触发并发标记周期的执行。默认值时45，即当堆的使用率达到45%，执行并发标记周期，该值一旦设置，始终都不会被 G1修改。也就是说，G1 就算为了满足 MaxGCPauseMillis 也不会修改此值。如果该值设置的很大，导致并发周期迟迟得不到启动，那么引起 FGC 的几率将会变大。如果过小，则会频繁标记，GC 线程抢占应用程序CPU 资源，性能将会下降。</p>
</li>
<li><p>-XX:GCPauseIntervalMillis 设置停顿时间间隔。</p>
</li>
</ol>
<h2 id="6-一些通用参数"><a href="#6-一些通用参数" class="headerlink" title="# 6. 一些通用参数"></a># 6. 一些通用参数</h2><p>在 GC 调优中，还有一些通用的参数。通常是我们的好帮手。</p>
<ol>
<li><p>-XX:-+DisableExplicitGC 禁用 System.gc()，由于该方法默认会触发 FGC，并且忽略参数中的 UseG1GC 和 UseConcMarkSweepGC，因此必要时可以禁用该方法。</p>
</li>
<li><p>-XX:+ExplicitGCInvokesConcurrent 该参数可以改变上面的行为，也就是说，System.gc() 后不使用 FGC ，而是使用配置的并发收集器进行并发收集。注意：使用此选项就不要 使用 上面的选项。</p>
</li>
<li><p>-XX:-ScavengeBeforeFullGC  由于大部分 FGC 之前都会 YGC，减轻了 FGC 的压力，缩短了 FGC 的停顿时间，但也可能你不需要这个特性，那么你可以使用这个参数关闭，默认是 ture 开启。</p>
</li>
<li><p>-XX:MaxTenuringThreshold={value} 新生代 to 区的对象在经过多次 GC 后，如果还没有死亡，则认为他是一个老对象，则可以晋升到老年代，而这个年龄（GC 次数）是可以设置的，有就是这个参数。默认值时15。超过15 则认为是无限大(因为age变量时4个 bit，超过15无法表达)。但该参数不是唯一决定对象晋升的条件。当 to 区不够或者改对象年龄已经达到了平均晋升值或者大对象等等条件。</p>
</li>
<li><p>-XX:TargetSurvivorRatio={value}  决定对何时晋升的不仅只有 XX:MaxTenuringThreshold 参数，如果在 Survivor 空间中相同年龄所有对象大小的总和大鱼 Survivor 空间的一半（默认50%），年龄大于或等于该年龄的对象就可以直接进入老年代。无需在乎 XX:MaxTenuringThreshold参数。因此，MaxTenuringThreshold 只是对象晋升的最大年龄。如果将 TargetSurvivorRatio 设置的很小，对象将晋升的很快。</p>
</li>
<li><p>-XX:PretenureSizeThresholds={value}  除了年龄外，对象的体积也是影响晋升的一个关键，也就是大对象。如果一个对象新生代放不下，只能直接通过分配担保机制进入老年代。该参数是设置对象直接晋升到老年代的阈值，单位是字节。只要对象的大小大于此阈值，就会直接绕过新生代，直接进入老年代。注意：<strong>这个参数只对 Serial 和 ParNew 有效，ParallelGC  无效</strong>，默认情况下该值为0，也就是不指定最大的晋升大小，一切有运行情况决定。</p>
</li>
<li><p>-XX:-UseTLAB 禁用线程本地分配缓存。TLAB 的全称是 Thread LocalAllocation Buffer ，即线程本地线程分配缓存，是一个线程私有的内存区域。该设计是为了加速对象分配速度。由于对象一般都是分配在堆上，而对是线程共享的。因此肯定有锁，虽然使用 CAS 的操作，但性能仍有优化空间。通过为每一个线程分配一个 TLAB 的空间（在 eden 区），可以消除多个线程同步的开销。默认开启。</p>
</li>
<li><p>-XX:TLABSize 指定 TLAB 的大小。</p>
</li>
<li><p>-XX:+PrintTLAB 跟踪 TLAB 的使用情况。用以确定是用多大的 TLABSize。</p>
</li>
<li><p>-XX:+ResizeTLAB 自动调整 TLAB 大小。</p>
</li>
</ol>
<p>同时，对象也可能会在栈上分配，栈上分配，TLAB 分配，堆分配，他们的流程如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-69a16226aa1bd693.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象分配流程"></p>
<p>还有一些开启 GC 日志的参数，是 GC 调优不可或缺的工具。</p>
<ol start="11">
<li><p>-XX:+PrintGCDateStamps 打印 GC 日志时间戳。</p>
</li>
<li><p>-XX:+PrintGCDetails  打印 GC 详情。</p>
</li>
<li><p>-XX:+PrintGCTimeStamps: 打印此次垃圾回收距离jvm开始运行的所耗时间。</p>
</li>
<li><p>-Xloggc:<filename>  将垃圾回收信息输出到指定文件</p>
</li>
<li><p> -verbose:gc 打印 GC 日志</p>
</li>
<li><p>-XX:+PrintGCApplicationStopedTime 查看 gc 造成的应用暂停时间</p>
</li>
<li><p>XX:+PrintTenuringDistribution, 对象晋升的日志</p>
</li>
<li><p>-XX:+HeapDumpOnOutOfMemoryError 内存溢出时输出 dump 文件。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a># 总结</h2><p>好了，我们已经将一些常用的 GC 参数介绍了，当然会有遗漏的，如有遗漏或者介绍有误的，请告知本人。这些参数不仅仅是为了服务大家，同时也是自己做的一个总结，以后就不用到处找了。说白了这就是写博客的好处：总结了自己，也做了备份，同时也可能帮助了别人。</p>
<p>Good Luck！！！</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出-JVM-ClassLoader</title>
    <url>/2018/02/21/2018/2018-02-21-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-JVM-ClassLoader/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## # 前言

<p>在 JVM 综述里面，我们说，JVM 做了三件事情，Java 程序的内存管理，<br>Java Class 二进制字节流的加载（ClassLoader），Java 程序的执行（执行引擎）。我们也说，我们大部分情况下只关注前2个。在前面的文章中，我们已经分析了内存关系相关的，包括运行时数据区，GC 相关。今天我们要讲的就是类加载器。</p>
<p>在 <a href="https://www.jianshu.com/p/70154dc5a9ff">JVM 综述</a> 里，我们已经大致分析了一些概念。而今天的文章将详细的阐述类加载器。</p>
<p>首先，我们要了解类加载器，当然，了解的目的是为了更好的开发，通过对类加载器的解读，看看我们能不能做些什么，比如修改类加载器的加载逻辑，比如加入自定义的类加载器等等功能。</p>
<p>让我们开始吧！</p>
<h2 id="1-类加载器介绍"><a href="#1-类加载器介绍" class="headerlink" title="# 1.  类加载器介绍"></a># 1.  类加载器介绍</h2><p>对于 Java 虚拟机来说，Class 文件是一个重要的接口，无论使用何种语言进行软件开发，只要能将源文件编译为正确的 Class 文件，那么这种语言就可以在 Java 虚拟机上运行。可以说，Class 文件就是虚拟机的基石。</p>
<p>如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0462adabdf0aac40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各种语言都可以在 JVM 上运行"></p>
<p>从上图可以看出，虚拟机不拘泥于 Java 语言，任何一个源文件只要能编译成 Class 文件的格式，就可以在JVM 上运行！Class 文件格式就像是一个接口，只要遵守这个接口，就能够在 JVM 上运行。</p>
<h2 id="2-类加载器的工作流程"><a href="#2-类加载器的工作流程" class="headerlink" title="# 2. 类加载器的工作流程"></a># 2. 类加载器的工作流程</h2><p>Class 文件通常是以文件的方式存在（任何二进制流都可以是 Class 类型），但只有能被 JVM 加载后才能被使用，才能运行编译后的代码。系统装在 Class 类型可以分为加载，链接和初始化三个步骤。其中，链接也可分为验证，准备和解析3步骤。如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b58c0180435f2e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Class 文件转载过程"></p>
<p>其中，只有加载过程是程序员能够控制的，后面的几个步骤都是有虚拟机自动运行的。因此，我们的关注点主要放在加载阶段。</p>
<h2 id="3-类加载流程中的-“加载”"><a href="#3-类加载流程中的-“加载”" class="headerlink" title="# 3.  类加载流程中的 “加载”"></a># 3.  类加载流程中的 “加载”</h2><p>上面说了，类加载器3个流程中，唯一能让程序员 “做手脚” 的就是加载过程，上面是加载过程呢？其主要作用就是从系统外部获得 Class 二进制数据流。</p>
<p>JVM 不会无故装载 Class 文件，只有在必要的时候才装载，哪几个时候呢？</p>
<ol>
<li>当创建一个类的实例是，比如使用 new 关键字，或者通过反射，克隆，反序列化。</li>
<li>当调用类的静态方法时，即当使用字节码 invokstatic 指令。</li>
<li>当使用类或接口的静态字段时（final 常量除外），比如，使用 getstatic 或者 pustatic 指令。</li>
<li>当时用 Java.lang.reflect 包中的方法反射类的方法时。</li>
<li>当初始化子类，要求先初始化父类。</li>
<li>作为启动虚拟机，含有 main（）方法的那个类。</li>
</ol>
<p>以上6种情况属于主动调用，主动调用会触发初始化，还有一种情况是被动调用，则不会引起初始化。</p>
<h4 id="3-1-ClassLoader-抽象类介绍"><a href="#3-1-ClassLoader-抽象类介绍" class="headerlink" title="# 3.1 ClassLoader 抽象类介绍"></a># 3.1 ClassLoader 抽象类介绍</h4><p>Java 类加载器的具体实现就在 java.lang.ClassLoader，该类是一个抽象类，并且提供了一些重要的接口，用于自定义Class 的加载流程和加载方式。主要方法如下：</p>
<ol>
<li><p>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException<br>给定一个类名，加载一个雷，返回代表这个类的 Class 实例，如果找不到类，则返回异常。</p>
</li>
<li><p>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError<br>根据给定的字节码流 b 定义一个类，off 表示位置，len 表示长度。该方法只有子类可以使用。</p>
</li>
<li><p>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException<br>查找一个类，也是只能子类使用，这是重载 ClassLoader 时，最重要的系统扩展点。这个方法会被 loadClass 调用，用于自定义查找类的逻辑，如果不需要修改类加载默认机制，只是想改变类加载的形式，就可以重载该方法。</p>
</li>
<li><p>protected final Class&lt;?&gt; findLoadedClass(String name)<br>同样的，这个方法也只有子类能够使用，他会去寻找已经加载的类，这个方法是 final 方法，无法被修改。</p>
</li>
</ol>
<p>同时，在该类中，还有一个字段非常重要：parent，他也是一个 ClassLoader 的实例，这个字段所表示的 ClassLoader 也称为这个 ClassLoader 的双亲，在类加载的过程中，ClassLoader 可能会将某些请求交给自己的双亲处理。</p>
<h4 id="3-2-类加载器的双亲委派模型"><a href="#3-2-类加载器的双亲委派模型" class="headerlink" title="# 3.2 类加载器的双亲委派模型"></a># 3.2 类加载器的双亲委派模型</h4><p>在标准的 Java 程序中，从虚拟机的角度讲，只有2种类加载器：</p>
<ol>
<li>启动类加载器（BootStrap ClassLoader），C++ 语言实现，虚拟机自身的一部分</li>
<li>另一种就是所有其他的类加载器，由 Java 语言实现，独立于虚拟机外部，并且全部继承自抽身类 java.lang.ClassLoader。</li>
</ol>
<p>从程序员的角度讲，虚拟机会创建 3 中类加载器，分别是：Bootstrap ClassLoader(启动类加载器），Extension ClassLoader（扩展类加载器）和 APPClassLoader（应用类加载器，也称为系统类加载器）。此外，每一个应用程序还可以拥有自定义的 ClassLoader，扩展 Java 虚拟机获取 Class 数据的能力。</p>
<p>而这 3 个类加载器有着层次关系。</p>
<p>先来看一个著名的图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-eba420d0b83f65a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类加载器双亲委派模型"></p>
<p>如图所示：从 ClassLoader 的层次自顶向下为启动类加载器，扩展类加载器，应用类加载器和自定义类加载器，当系统需要适用一个类时，在判断类是否已经被加载时，会先从当前底层类加载器进行判断，但系统需要加载一个类时，会从顶层类开始加载，依次向下尝试，直到成功。</p>
<p>注意，我们无法访问启动类加载器，当试图获取启动类加载器的时候，返回 null，因此，如果返回的是 null，并不意味没有类加载器为它服务，而是指哪个类为启动类加载器。</p>
<p>那么这些类加载路径是哪些呢？</p>
<ol>
<li><p>BootStrap 类加载器负责加载 <JAVA_HOME>/lib 目录中的，或者别-Xbootclasspath 参数指定的路径。并且是被虚拟机识别的，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会加载。</p>
</li>
<li><p>扩展类加载器有 sun.misc.Launcher$ExtClassLoader 实现，负责加载 <JAVA_HOME>/lib/ext 目录中的。或者被 java.ext.dirs 系统变量所指定的路径中的所有类库。</p>
</li>
<li><p>应用类加载器由 sun.misc.Launcher$AppClassLoader 实现，由于这个类是 ClassLoader 中的 getSystemClassLoader 方法的返回值，也称为系统类加载器，负载加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。一般情况下，这个就是程序中默认的类加载器。</p>
</li>
<li><p>自定义类加载器用于加载一些特殊途径的类，一般也是用户程序类。</p>
</li>
</ol>
<p>系统中的 ClassLoader 在协同工作时，默认会使用双亲委托模式，即在类加载的时候，系统会判断当前类是否已经被加载，如果已经加载，则直接返回，否则就尝试加载，在尝试加载时，会先请求双亲处理，如果双亲查找事变，则自己加载。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">           <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                   <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                   <span class="comment">// to find the class.</span></span><br><span class="line">                   <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码中，如果双亲是 null，则使用启动类加载器加载，如果事变，则使用当前类加载器加载。</p>
<p>双亲为 null 一般有2种情况，1. 双亲是启动类加载器。2. 自己就是启动类加载器。</p>
<p>其中加载类的逻辑有2个注意的地方。</p>
<ol>
<li><p>判断是否已经加载？当判断类是否需要加载时，是从底层开始判断，如果底层已经加载了，则不再请求双亲。</p>
</li>
<li><p>当系统准备加载一个类时。会先从双亲加载，也就是最顶层的启动类加载器，逐层向下，直到找到该类。和上面的是相反的。</p>
</li>
</ol>
<h4 id="3-3-类加载器的双亲委派模型缺陷和补充"><a href="#3-3-类加载器的双亲委派模型缺陷和补充" class="headerlink" title="# 3.3 类加载器的双亲委派模型缺陷和补充"></a># 3.3 类加载器的双亲委派模型缺陷和补充</h4><p>双亲模型固然有着优点，能够让整个系统保持了类的唯一性。但在有些场合，却不适合，也就是说，顶层的启动类加载器的代码无法访问到底层的类加载器。如 rt.jar 无法中代码无法访问到应用类加载器。</p>
<p>你肯定要问，为什么需要访问呢？</p>
<p>在 Java 平台中，把核心类（rt.jar)中提供外部服务，可由应用层自行实现的接口，通常可以称为 Service Provider Interface，即 SPI。</p>
<p>在 rt.jar 中的抽象类需要加载继承他们的在应用层的子类实现，但是以目前的双亲机制是无法实现的。</p>
<p>因此 JDK 引用了一个不太优雅的设计，上下文类加载器。也就是讲类加载放在线程上下文变量中。通过     Thread.getContextClassLoader()，    Thread.setContextClassLoader(ClassLoader) 这两个方法获取和设置 ClassLoader，这样，rt.jar 中的代码就可以获取到底层的类加载了。</p>
<h4 id="3-4-突破双亲模式"><a href="#3-4-突破双亲模式" class="headerlink" title="# 3.4 突破双亲模式"></a># 3.4 突破双亲模式</h4><p>双亲模式是虚拟机的默认行为，但并非必须这么做，通过重载 ClassLoader 可以修改该行为。事实上，很多框架和软件都修改了，比如 Tomcat，OSGI。具体实现则是通过重写 loadClass 方法，改变类的加载次序。比如先使用自定义类加载器加载，如果加载不到，则交给双亲加载。</p>
<h2 id="4-类加载的扩展—热替换"><a href="#4-类加载的扩展—热替换" class="headerlink" title="# 4. 类加载的扩展—热替换"></a># 4. 类加载的扩展—热替换</h2><p>我们知道：由不同的 ClassLoader 加载的同名类属于不同的类型，不能相互转化和兼容。</p>
<p>而这个特性就是我们实现热替换的关键。过程如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-dbe5357dffc7d83b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="热替换基本思路"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a># 总结</h2><p>好了，到这里，基本的类加载器就介绍结束了。我们总结了类加载的工作流程，包括加载，连接，初始化。然后我们重点介绍了加载，因为加载阶段是我们程序员唯一有所作为的地方。然后介绍了加载阶段的一些细节，比如双亲委派，然后说了双亲委派的缺点和补充，然后探讨了如何修改默认的类加载方式，最后通过类加载的特性实现了热替换。当然也看了核心类 ClassLoader 的源码。不过，这肯定不是类加载器的全部。我们将在后面的文章中将类加载的其他特性一一解开。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>探秘-Java--热部署二（Java-Agent-Premain）</title>
    <url>/2018/02/25/2018/2018-02-25-%E6%8E%A2%E7%A7%98-Java--%E7%83%AD%E9%83%A8%E7%BD%B2%E4%BA%8C%EF%BC%88Java-agent-premain%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ##  前言

<p>在前文 <a href="https://www.jianshu.com/p/731bc8293365">探秘 Java 热部署</a> 中，我们通过在死循环中重复加载 ClassLoader 和 Class 文件实现了热部署的功能，但我们也指出了缺点—–不够灵活。需要手动修改文件等操作。</p>
<p>如果有那么一种功能，当你需要重新加载类并修改类的时候，有那么一个转换器自动帮你修改已有的 Class 文件变成你设定的 Class 文件，那么就不需要手动修改编译了。</p>
<p>也许你第一想到的就是在自定义类加载器中做文章，比如在 loadClass 中，得到字节码之后，通过 ASM 或者 javassist 修改字节码，然后再调用 defineClass 方法。</p>
<p>确实可行，但是这种侵入性太大。如果JVM 在底层提供一种类似 “类转换器” 的东西，是不是侵入性就不大了呢？</p>
<p>实际上，JVM 确实给我们提供了一个工具，那就是今天的主角——java agent。</p>
<h2 id="1-什么是-Java-agent"><a href="#1-什么是-Java-agent" class="headerlink" title="1. 什么是 Java agent"></a>1. 什么是 Java agent</h2><p>在 JDK 1.5 中，Java 引入了 java.lang.Instrument 包，该包提供了一些工具帮助开发人员在 Java 程序运行时，动态修改系统中的 Class 类型。其中，使用该软件包的一个关键组件就是 Java  agent。从名字上看，似乎是个 Java 代理之类的，而实际上，他的功能更像是一个Class 类型的转换器，他可以在运行时接受重新外部请求，对Class 类型进行修改。</p>
<p>如果在命令行执行 java 命令，会出现一些命令帮助，其中就有 java agent的选项：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7cae3d3d7a6cab7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java 命令"></p>
<h2 id="2-Java-agent-详细介绍"><a href="#2-Java-agent-详细介绍" class="headerlink" title="2. Java agent 详细介绍"></a>2. Java agent 详细介绍</h2><p>参数 javaagent 可以用于指定一个 jar 包，并且对该 java 包有2个要求：</p>
<ol>
<li>这个 jar 包的MANIFEST.MF 文件必须指定 Premain-Class 项。</li>
<li>Premain-Class 指定的那个类必须实现 premain（）方法。</li>
</ol>
<p>重点就在 premain 方法，也就是我们今天的标题。从字面上理解，就是运行在 main 函数之前的的类。当Java 虚拟机启动时，在执行 main 函数之前，JVM 会先运行 -javaagent 所指定 jar 包内 Premain-Class 这个类的 premain 方法，其中，该方法可以签名如下：</p>
<p>1.public static void premain(String agentArgs, Instrumentation inst)<br>2.public static void premain(String agentArgs)</p>
<p>JVM 会优先加载 1 签名的方法，加载成功忽略 2，如果1 没有，加载 2 方法。这个逻辑在sun.instrument.InstrumentationImpl 类中：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-37cfc8c3c42f0986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InstrumentationImpl  类"></p>
<p>参数 agentArgs 时通过命令行传给 Java  Agent 的参数， inst 是 Java Class 字节码转换的工具，Instrumentation 常用方法如下：</p>
<ol>
<li><p> void addTransformer(ClassFileTransformer transformer, boolean canRetransform);<br>增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。</p>
</li>
<li><p>void  redefineClasses(ClassDefinition… definitions) hrows  ClassNotFoundException, UnmodifiableClassException;<br>在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。</p>
</li>
<li><p> boolean removeTransformer(ClassFileTransformer transformer);<br>删除一个类转换器</p>
</li>
<li><p> void  retransformClasses(Class&lt;?&gt;… classes) throws UnmodifiableClassException<br>在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</p>
</li>
</ol>
<h2 id="3-如何使用？"><a href="#3-如何使用？" class="headerlink" title="3. 如何使用？"></a>3. 如何使用？</h2><p>使用 javaagent 需要几个步骤：</p>
<ol>
<li>定义一个 MANIFEST.MF 文件，必须包含 Premain-Class 选项，通常也会加入Can-Redefine-Classes 和 Can-Retransform-Classes 选项。</li>
<li>创建一个Premain-Class 指定的类，类中包含 premain 方法，方法逻辑由用户自己确定。</li>
<li>将 premain 的类和 MANIFEST.MF 文件打成 jar 包。</li>
<li>使用参数 -javaagent:/jar包路径=[agentArgs 参数] 启动要代理的方法。</li>
</ol>
<p>在执行以上步骤后，JVM 会先执行 premain 方法，大部分类加载都会通过该方法，注意：是大部分，不是所有。当然，遗漏的主要是系统类，因为很多系统类先于 agent 执行，而用户类的加载肯定是会被拦截的。</p>
<p>也就是说，这个方法是在 main 方法启动前拦截大部分类的加载活动，注意：是类加载之前。也就是说，我们可以在这个缝隙中做很多文章，比如修改字节码。</p>
<p>让我们来试试：</p>
<p>1 首先定义一个 MANIFEST.MF 文件:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">Manifest-Version</span>: <span class="string">1.0</span></span><br><span class="line"><span class="meta">Can-Redefine-Classes</span>: <span class="string">true</span></span><br><span class="line"><span class="meta">Can-Retransform-Classes</span>: <span class="string">true</span></span><br><span class="line"><span class="meta">Premain-Class</span>: <span class="string">cn.think.in.java.clazz.loader.asm.agent.PreMainTraceAgent</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建一个Premain-Class 指定的类，类中包含 premain 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreMainTraceAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;agentArgs : &quot;</span> + agentArgs);</span><br><span class="line">    inst.addTransformer(<span class="keyword">new</span> ClassFileTransformer() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">          ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer)</span><br><span class="line">          <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;premain load Class     :&quot;</span> + className);</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>将 premain 的类和 MANIFEST.MF 文件打成 jar 包 .<br>使用 IDEA 的 build ，当然你也可以使用 maven。具体请 google。</p>
</li>
<li><p>使用参数 -javaagent:/jar包路径=[agentArgs 参数] 启动要代理的方法。<br>我们当然需要一个测试类：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ClassNotFoundException, InterruptedException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">     Account account = <span class="keyword">new</span> Account();</span><br><span class="line">     account.operation();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;operation....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>VM 参数 -javaagent:/jar包路径=[agentArgs 参数] 。</p>
<p>运行结果：<br><img src="http://upload-images.jianshu.io/upload_images/4236553-0d5f689e096d69f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行结果"></p>
<p>可以看到，我们的 premain 方法确实在 main 方法之前被调用了，并且是在类加载的时候被调用的，而我们重写的 transform 方法其中的 classfileBuffer 参数就是即将被载入虚拟机的字节码，因此，我们可以使用各种字节码库进行修改。具体修改，这里就暂时不表，以后有机会好好写写。</p>
<h2 id="4-和热部署有什么关系？"><a href="#4-和热部署有什么关系？" class="headerlink" title="4. 和热部署有什么关系？"></a>4. 和热部署有什么关系？</h2><p>说了这么多，Java agent 确实可以在 main 方法之前并加载字节码的同时进行代理，有点类似 AOP。但到底和热部署有什么关系呢？</p>
<p>回忆刚开始我们说的，我们如果自己自定义一个类加载器，那么就可以在重新加载类（新的类加载器）的时候对字节码进行修改，但是对业务代码侵入性较大，如果在底层，也就是 JVM 层面，在加载字节码的时候回调某个方法，在该方法中修改字节码，岂不是达到了我们的目的？</p>
<p>我们再看看 premain 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;agentArgs : &quot;</span> + agentArgs);</span><br><span class="line">  inst.addTransformer(<span class="keyword">new</span> ClassFileTransformer() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer)</span><br><span class="line">        <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;premain load Class     :&quot;</span> + className);</span><br><span class="line">      <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中的 Instrumentation 添加了一个类转换器，该转换器是长期有效的，当该转换器被添加之后，只要有类加载的活动，都会被拦截。假设，我们的业务是当某个类需要修改，我们就重新加载（重新创建类加载器的前提）原来的字节码，加载之后，注意：加载之后对该字节码进行修改。而这些操作对业务代码来说，完全是透明的，基本没有侵入性（加入了 VM 参数）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的步骤，我们将 <a href="https://www.jianshu.com/p/731bc8293365">探秘 Java 热部署</a> 的代码进行了优化，原本是直接手动修改字节码，现在通过加载原来的字节码，在原来的字节码基础上进行修改，再重新加载，完成了一次热部署。</p>
<p>而着一切得益于 java agent，虽然使用自定义的类加载也可以做到，但是似乎显得不是很优雅。使用 java agent 能让修改字节码这个动作化于无形，对业务透明，减少侵入性。</p>
<p>实际上，premain 还是有缺点的。什么缺点？竟然还要再命令行加参数？能不能不加参数？可以！ java 1.6 已经为我们准备了这个工具。也就是 agentmain ，可以不加任何参数，就可以修改一个类，甚至不需要重新创建类加载器！神奇吗？我们说，一个类加载器只能加载一个类，要想修改一个类，必须重新创建一个新的类加载器。但是，JVM 为我们做了很多，他在底层直接修改了类定义。使得我们不必重新创建类加载器了。具体我们将在下篇文章中详细介绍。</p>
<p>good luck！！！！！</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM-线上故障排查基本操作</title>
    <url>/2018/02/24/2018/2018-02-24-JVM-%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       对于后端程序员，特别是 Java 程序员来讲，排查线上问题是不可避免的。各种 CPU 飚高，内存溢出，频繁 GC 等等，这些都是令人头疼的问题。楼主同样也遇到过这些问题，那么，遇到这些问题该如何解决呢？

<p>首先，出现问题，肯定要先定位问题所在，然后分析问题原因，再然后解决问题，最后进行总结，防止下次再次出现。</p>
<p>今天的文章，就如我们的题目一样，讲的是基本操作，也就是一些排查线上问题的基本方法。为什么这么说呢？因为线上问题千奇百怪，就算是身经百战的专家也会遇到棘手的问题，因此不可能在一篇文章里说完，还有一个最重要的原因，当然就是楼主的水平不到位。</p>
<p>但不到位归不到位，任何经验都是值得记录的，因此，楼主有必要将这些问题记录一下。</p>
<p>还有，本文的排查环境是 Linux.</p>
<h2 id="1-CPU-飚高"><a href="#1-CPU-飚高" class="headerlink" title="#1. CPU 飚高"></a>#1. CPU 飚高</h2><p>线上 CPU 飚高问题大家应该都遇到过，那么如何定位问题呢？</p>
<p>思路：首先找到 CPU 飚高的那个 Java 进程，因为你的服务器会有多个 JVM 进程。然后找到那个进程中的 “问题线程”，最后根据线程堆栈信息找到问题代码。最后对代码进行排查。</p>
<p>如何操作呢？</p>
<ol>
<li>通过 top  命令找到 CPU 消耗最高的进程，并记住进程 ID。</li>
<li>再次通过 top -Hp [进程 ID] 找到 CPU 消耗最高的线程 ID，并记住线程 ID.</li>
<li>通过 JDK 提供的 jstack 工具 dump 线程堆栈信息到指定文件中。具体命令：jstack -l [进程 ID] &gt;jstack.log。</li>
<li>由于刚刚的线程 ID 是十进制的，而堆栈信息中的线程 ID 是16进制的，因此我们需要将10进制的转换成16进制的，并用这个线程 ID 在堆栈中查找。使用 printf “%x\n” [十进制数字] ，可以将10进制转换成16进制。</li>
<li>通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪。</li>
</ol>
<p>从楼主的经验来看，一般是某个业务死循环没有出口，这种情况可以根据业务进行修复。还有 C2 编译器执行编译时也会抢占 CPU，什么是 C2编译器呢？当 Java 某一段代码执行次数超过10000次（默认）后，就会将该段代码从解释执行改为编译执行，也就是编译成机器码以提高速度。而这个 C2编译器就是做这个的。如何解决呢？项目上线后，可以先通过压测工具进行预热，这样，等用户真正访问的时候，C2编译器就不会干扰应用程序了。如果是 GC 线程导致的，那么极有可能是 Full GC ，那么就要进行 GC 的优化。</p>
<h2 id="2-内存问题排查"><a href="#2-内存问题排查" class="headerlink" title="2. 内存问题排查"></a>2. 内存问题排查</h2><p>说完了 CPU 的问题排查，再说说内存的排查，通常，内存的问题就是 GC 的问题，因为 Java 的内存由 GC 管理。有2种情况，一种是内存溢出了，一种是内存没有溢出，但 GC 不健康。</p>
<p>内存溢出的情况可以通过加上 -XX:+HeapDumpOnOutOfMemoryError 参数，该参数作用是：在程序内存溢出时输出 dump 文件。</p>
<p>有了 dump 文件，就可以通过 dump 分析工具进行分析了，比如常用的MAT，Jprofile，jvisualvm 等工具都可以分析，这些工具都能够看出到底是哪里溢出，哪里创建了大量的对象等等信息。</p>
<p>第二种情况就比较复杂了。GC 的健康问题。</p>
<p>通常一个健康的 GC 是什么状态呢？根据楼主的经验，YGC  5秒一次左右，每次不超过50毫秒，FGC 最好没有，CMS GC 一天一次左右。</p>
<p>而 GC 的优化有2个维度，一是频率，二是时长。</p>
<p>我们看YGC，首先看频率，如果 YGC 超过5秒一次，甚至更长，说明系统内存过大，应该缩小容量，如果频率很高，说明 Eden 区过小，可以将 Eden 区增大，但整个新生代的容量应该在堆的 30% - 40%之间，eden，from 和 to 的比例应该在 8：1：1左右，这个比例可根据对象晋升的大小进行调整。</p>
<p>如果 YGC 时间过长呢？YGC 有2个过程，一个是扫描，一个是复制，通常扫描速度很快，复制速度相比而言要慢一些，如果每次都有大量对象要复制，就会将 STW 时间延长，还有一个情况就是 StringTable ，这个数据结构中存储着 String.intern 方法返回的常连池的引用，YGC 每次都会扫描这个数据结构（HashTable），如果这个数据结构很大，且没有经过 FGC，那么也会拉长 STW 时长，还有一种情况就是操作系统的虚拟内存，当 GC 时正巧操作系统正在交换内存，也会拉长 STW 时长。</p>
<p>再来看看FGC，实际上，FGC 我们只能优化频率，无法优化时长，因为这个时长无法控制。如何优化频率呢？</p>
<p>首先，FGC 的原因有几个，1 是 Old 区内存不够，2 是元数据区内存不够，3 是 System.gc()， 4 是 jmap 或者 jcmd，5 是CMS Promotion failed 或者 concurrent mode failure，6 JVM 基于悲观策略认为这次 YGC  后 Old 区无法容纳晋升的对象，因此取消 YGC，提前 FGC。</p>
<p>通常优化的点是 Old 区内存不够导致 FGC。如果 FGC 后还有大量对象，说明 Old 区过小，应该扩大 Old 区，如果 FGC 后效果很好，说明 Old 区存在了大量短命的对象，优化的点应该是让这些对象在新生代就被 YGC 掉，通常的做法是增大新生代，如果有大而短命的对象，通过参数设置对象的大小，不要让这些对象进入 Old 区，还需要检查晋升年龄是否过小。如果 YGC 后，有大量对象因为无法进入 Survivor 区从而提前晋升，这时应该增大 Survivor 区，但不宜太大。</p>
<p>上面说的都是优化的思路，我们也需要一些工具知道 GC 的状况。</p>
<p>JDK 提供了很多的工具，比如 jmap ，jcmd 等，oracle 官方推荐使用 jcmd 代替 jmap，因为 jcmd 确实能代替 jmap 很多功能。jmap 可以打印对象的分布信息，可以 dump 文件，注意，jmap 和 jcmd dump 文件的时候会触发 FGC ，使用的时候注意场景。</p>
<p>还有一个比较常用的工具是 jstat，该工具可以查看GC 的详细信息，比如eden ，from，to，old 等区域的内存使用情况。</p>
<p>还有一个工具是 jinfo，该工具可以查看当前 jvm 使用了哪些参数，并且也可以在不停机的情况下修改参数。</p>
<p>包括我们上面说的一些分析 dump 文件的可视化工具，MAT，Jprofile，jvisualvm 等，这些工具可以分析 jmap dump 下来的文件，看看哪个对象使用的内存较多，通常是能够查出问题的。</p>
<p>还有很重要的一点就是，线上环境一定要带上 GC 日志！！！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基于文章的标题，我们这个是基本操作，故障排查是说不完的话题，每个故障涉及的知识也都很多，因此，我们在学习了基本的排查之后，还需要学习更多事故排查技术，比如排查 IO，网络，TCP 连接等等。楼主将在后面的文章中将这些基本操作都记录下来。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
  </entry>
  <entry>
    <title>探秘-Java-热部署</title>
    <url>/2018/02/25/2018/2018-02-25-%E6%8E%A2%E7%A7%98-Java-%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       # 前言
在之前的 [深入浅出 JVM ClassLoader](https://www.jianshu.com/p/85eba062b9c1) 一文中，我们说可以通过修改默认的类加载器实现热部署，但在 Java 开发领域，热部署一直是一个难以解决的问题，目前的 Java 虚拟机只能实现方法体的修改热部署，对于整个类的结构修改，仍然需要重启虚拟机，对类重新加载才能完成更新操作。对于某些大型的应用来说，每次的重启都需要花费大量的时间成本，所以，如果能像我们之前说的那样，在不重启虚拟机的情况下更新一个类，在某些业务场景下变得十分重要。比如很多脚本语言就支持热替换，例如 PHP，只要替换了PHP 源文件，这种改动就会立即生效，且无需重启服务器。

<p>今天我们就来一个简单的热部署，注意：不要小看他，这也是 JSP 支持修改的实现方式。</p>
<h1 id="1-怎么实现？"><a href="#1-怎么实现？" class="headerlink" title="1. 怎么实现？"></a>1. 怎么实现？</h1><p>在上篇文章中，我们贴了一幅图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-dbe5357dffc7d83b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="热替换基本思路"></p>
<p>我们知道，一个类加载器只能加载一个同名类，在Java默认的类加载器层面作了判断，如果已经有了该类，则不再重复加载，如果强行绕过判断并使用自定义类加载器重复加载（比如调用 defineClass 方法），JVM 将会抛出 LinkageError：attempted  duplicate class definition for name。</p>
<p>但请注意，我们说同一个类加载器不可以加载两个同名的类，但不同的类加载器是可以加载同名的类的，加载完成之后，这两个类虽然同名，但不是同一个 Class 对象，无法进行转换。</p>
<p>那么我们是否可以利用这个特性，实现热部署呢？如同上图的步骤：使用自定义的类加载器，加载一个类，当需要进行替换类的时候，我们就丢弃之前的类加载器和类，使用新的类加载器去加载新的 Class 文件，然后运行新对象的方法。</p>
<p>让我们按照这个思路写段代码试试吧！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AccountMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ClassNotFoundException, InterruptedException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      ClassLoader loader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line"></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      Class clazz = loader.loadClass(<span class="string">&quot;cn.think.in.java.clazz.loader.asm.Account&quot;</span>);</span><br><span class="line">      Object account = clazz.newInstance();</span><br><span class="line">      account.getClass().getMethod(<span class="string">&quot;operation&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;).invoke(account);</span><br><span class="line">      Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个类是一个 mian 方法类，该方法是一个间隔 20 秒的死循环，步骤如下：</p>
<ol>
<li>创建一个自定义的 ClassLoader 对象，加载类的步骤不遵守双亲委派模型，而是直接加载。</li>
<li>使用刚刚创建的类加载器加载指定的类。</li>
<li>得到刚刚的Class 对象，使用反射创建对象，并调用对象的 operation 方法。</li>
</ol>
<p>为什么间隔20秒呢？因为我们要在启动之后，修改类，并重新编译。因此需要20秒时间。</p>
<p>再看看 Account 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;operation...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该类很简单，只有一个方法，就是打印 operation…字符串。</p>
<p>我们还需要一个类，干什么用呢？我们刚刚说，需要修改 Account 类，然后重新编译，为了方便，我们创建一个类，专门用于执行修改后的 Account 类，因为执行后肯定重新编译了，省的我们去命令行使用 javac 了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReCompileAccount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Account().operation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何测试呢？</p>
<ol>
<li>启动AccountMain main 方法。会立刻打印出  operation… 字符串，并开始等待20秒。</li>
<li>修改 Account 类的字符串为 operation…..new，</li>
<li>启动 ReCompileAccount 类，目的是重新编译 Accoutn类。</li>
<li>等待 AccountMain  类的打印。</li>
</ol>
<p>不出意外的话，最后结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6c4f9504c29305c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印结果"></p>
<p>看到了吧，我们已经成功的把Accout 类修改了，并且是在不重启 JVM 的情况下，实现了热部署。就像我们刚刚说的，JSP 支持修改也是这么实现的，每一个 JSP 页面都对应着一个类加载器，当JSP 页面被修改了，就重新创建类加载器，然后使用新的类加载器加载 JSP （JSP 其实就是 Java 类）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于 ClassLoader 的原理，我们实现了 Java 层面的热部署，但大家如果自己实现一遍的话，还是觉得很麻烦，诚然，JSP 使用这种方式没什么问题，因为他是自动编译的。但如果我们自己的应用的话，难道每次修改一个类，都要重新编译一遍，然后在给定的时间里去替换？我们能不能把这些手工活都交给 JVM 呢？实际上，Tocmat 也已经通过这种方式实现过了。限于篇幅，我们将在下一篇文章中讲述。</p>
<p>good luck！！！！！</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>探秘-Java-热部署三（Java-Agent-Agentmain）</title>
    <url>/2018/02/25/2018/2018-02-25-%E6%8E%A2%E7%A7%98-Java-%E7%83%AD%E9%83%A8%E7%BD%B2%E4%B8%89%EF%BC%88Java-agent-agentmain%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>让我们继续探秘 Java 热部署。在前文 <a href="https://www.jianshu.com/p/0bbd79661080">探秘 Java 热部署二（Java agent premain）</a>中，我们介绍了 Java agent premain。通过在main方法之前通过类似 AOP 的方式添加 premain 方法，我们可以在类加载之前做修改字节码的操作，无论是第一次加载，还是每次新的 ClassLoader 加载，都会经过 ClassFileTransformer 的 transform 方法，也就是说，都可以在这个方法中修改字节码，虽然他的方法名是 premain ，但是我们确实可以利用这个特性做这个事情。</p>
<p>在文章的最后，我们也提到了，虽然相比较在自定义类中修改字节码，premain 没有什么侵入性，对业务透明，但是美中不足的是，他还需要在启动的时候增加参数。</p>
<p>我们还提到了，premain 虽然可以热部署，但是还需要重新创建类加载器，虽然，这的确也符合 JVM 关于类的唯一性的定义。但是，有一种情况，如果使用的是系统类加载器，我们也无法创建新的ClassLoader对象。那么我们也就无法重新加载类了，怎么办呢？还好 Java 6 为我们提供了一种方法，也就是今天的主角 agentmain。</p>
<h2 id="1-什么是-agentmain？"><a href="#1-什么是-agentmain？" class="headerlink" title="1. 什么是 agentmain？"></a>1. 什么是 agentmain？</h2><p>和 premain 师出同门，我们知道，premain 只能在类加载之前修改字节码，类加载之后无能为力，只能通过重新创建ClassLoader 这种方式重新加载。而 agentmain 就是为了弥补这种缺点而诞生的。简而言之，agentmain 可以在类加载之后再次加载一个类，也就是重定义，你就可以通过在重定义的时候进行修改类了，甚至不需要创建新的类加载器，JVM 已经在内部对类进行了重定义（重定义的过程相当复杂）。</p>
<p>但是这种方式对类的修改是由限制的，对比原来的老类，由如下要求：</p>
<p>1.父类是同一个；<br>2. 实习那的接口数也要相同；<br>3. 类访问符必须一致；<br>4. 字段数和字段名必须一致；<br>5. 新增的方法必须是 private static/final 的；<br>6. 可以删除修改方法；</p>
<p>可以看的出来，相比较重新创建类加载器，限制还是挺多的，最重要的字段是无法修改的。因此，使用的时候要注意。</p>
<p>但是，agentmain 还有一个强大的特点，就是目标程序什么都不需要管，就能够被代理。还记得 premain 是如何使用的吗？需要在目标应用启动的时候增加 -javaagent 参数。虽说没有侵入性，但相比 agentmain 而言，还是有侵入性的，毕竟 agentmain 什么都不要。目标程序独立运行，什么都不用管。</p>
<p>那我们就来试试吧！</p>
<h2 id="2-如何使用？"><a href="#2-如何使用？" class="headerlink" title="2. 如何使用？"></a>2. 如何使用？</h2><p>agentmain 使用步骤如下：</p>
<ol>
<li>定义一个MANIFEST.MF 文件，文件中必须包含 Agent-Class;</li>
<li>创建一个 Agent-Class 指定的类，该类必须包含 agentmain 方法（参数和 premian 相同）。</li>
<li>将MANIFEST.MF 和 Agent 类打成 jar 包;</li>
<li>将 jar 包载入目标虚拟机。目标虚拟机将会自动执行 agentmain 方法执行方法逻辑，同时，ClassFileTransformer 也会长期有效，在每一个类加载器加载 Class 的时候都会拦截。</li>
</ol>
<p>让我们按着步骤来一遍吧！</p>
<ol>
<li>定义一个MANIFEST.MF 文件，文件中必须包含 Agent-Class;</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">Manifest-Version</span>: <span class="string">1.0</span></span><br><span class="line"><span class="meta">Can-Redefine-Classes</span>: <span class="string">true</span></span><br><span class="line"><span class="meta">Agent-Class</span>: <span class="string">cn.think.in.java.clazz.loader.asm.agent.AgentMainTraceAgent </span></span><br><span class="line"><span class="meta">Can-Retransform-Classes</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个 Agent-Class 指定的类，该类必须包含 agentmain 方法（参数和 premian 相同）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentMainTraceAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Agent Main called&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;agentArgs : &quot;</span> + agentArgs);</span><br><span class="line">    inst.addTransformer(<span class="keyword">new</span> ClassFileTransformer() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">          ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer)</span><br><span class="line">          <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;agentmain load Class  :&quot;</span> + className);</span><br><span class="line">          <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">    inst.retransformClasses(Account.class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的类逻辑很简单，打印 Agent Main called，并打印参数，然后添加一个类转换器，转换器中的逻辑只是打印字符串，为了简单起见，并没有修改字节码（各位可自行使用ASM 等类库修改）。最后一点很重要，执行了 inst.retransformClasses(Account.class); 这段代码的意思是，重新转换目标类，也就是 Account 类。也就是说，你需要重新定义哪个类，需要指定，否则 JVM 不可能知道。还有一个类似的方法 redefineClasses ，注意，这个方法是在类加载前使用的。类加载后需要使用 retransformClasses 方法。</p>
<ol start="3">
<li>将MANIFEST.MF 和 Agent 类打成 jar 包;<br>这个请自行 google。maven 或者 ide 都可以。</li>
<li>将 jar 包载入目标虚拟机。目标虚拟机将会自动执行 agentmain 方法执行方法逻辑，同时，ClassFileTransformer 也会长期有效，在每一个类加载器加载 Class 的时候都会拦截。</li>
</ol>
<p>这段代码很重要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JVMTIThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException </span>&#123;</span><br><span class="line">    List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">    <span class="keyword">for</span> (VirtualMachineDescriptor vmd : list) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vmd.displayName().endsWith(<span class="string">&quot;AccountMain&quot;</span>)) &#123;</span><br><span class="line">        VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());</span><br><span class="line">        virtualMachine.loadAgent(<span class="string">&quot;E:\\self\\demo\\out\\artifacts\\test\\test.jar &quot;</span>, <span class="string">&quot;cxs&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        virtualMachine.detach();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：写这段代码的时候 IDE 可能提示找不到 jar 包，这时候将 jdk/lib/tools.jar 添加的项目的 classpath 中，具体请自行 google。<br>该main方法步骤如下：</p>
<ol>
<li>获取当前系统所有的虚拟机，类似 jps 命令。</li>
<li>循环所有虚拟机，找到 AccountMain 虚拟机。</li>
<li>将当前JVM 链接上目标JVM，并加载 loadAgent jar 包且传递参数。</li>
<li> 卸载虚拟机。</li>
</ol>
<p>如何测试呢？</p>
<p>首先看测试类，也就是AccountMain类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">new</span> Account().operation();</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们一切准备就绪，启动 AccountMain 后，再启动 JVMTIThread 类，结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1f2f3490a5aa6516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>可以看到，执行了1遍 operation方法后，我们启动了 attach jvm，随后，agentmain 方法就被执行了，并打印了我们我们传递的字符串参数，同时也进入到了 ClassFileTransformer 方法中，表示重新加载了 Account 类。有点遗憾的是，限于篇幅，我们没有修改字节码。不过楼主还是展示一下楼主修改字节码的结果吧，假设楼主想统计 operation 方法的时长，楼主将使用 ASM 增加一段统计时长的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeStat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadLocal.set(System.currentTimeMillis());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis() - threadLocal.get();</span><br><span class="line">    System.out.print(Thread.currentThread().getStackTrace()[<span class="number">2</span>] + <span class="string">&quot;方法耗费时间: &quot;</span>);</span><br><span class="line">    System.out.println(time + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后修改 agentmain 方法中ClassFileTransformer 的transform 逻辑，也就是在这里修改字节码。<br>运行结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-bd3209028def98ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成功修改字节码"></p>
<p>可以看到，首先重定义了 Account 类，又主动加载了 TimeStat 类，然后生效，在 operation 字符串后面打印了方法的耗时。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对 agentmain 的使用，我们感受到了他的强大，在目标程序丝毫不改动的，甚至连启动参数都不加的情况下，可以修改类，并且是运行后修改，而且不重新创建类加载器。其主要得益于 JVM 底层的对类的重定义，关于底层代码解释，Jvm 大神寒泉子有篇文章 <a href="http://www.infoq.com/cn/articles/javaagent-illustrated">JVM源码分析之javaagent原理完全解读</a> ，详细分析了 javaagent 的原理。但 agentmain 有一些功能上的限制，比如字段不能修改增减。所以，使用的时候需要权衡，到底使用哪种方式实现热部署。</p>
<p>说了这么久的热部署，其实就是动态或者说运行时修改类，大的方向说有2种方式：</p>
<ol>
<li>使用 agentmain，不需要重新创建类加载器，可直接修改类，但是有很多限制。</li>
<li>使用 premain 可以在类第一次加载之前修改，加载之后修改需要重新创建类加载器。或者在自定义的类加载器种修改，但这种方式比较耦合。</li>
</ol>
<p>无论是哪种，都需要字节码修改的库，比如ASM，javassist ，cglib 等，很多。总之，通过java.lang.instrument 包配合字节码库，可以很方便的动态修改类，或者进行热部署。</p>
<p>good luck！！！！！</p>
<p>参考: <a href="http://www.infoq.com/cn/articles/javaagent-illustrated">JVM源码分析之javaagent原理完全解读</a><br>《实战Java 虚拟机》<br><a href="https://liuzhengyang.github.io/2017/03/15/javaagent/">javaagent</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html">Instrumentation 新功能</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-启动过程源码分析-（本文超长慎读）(基于4-1-23)</title>
    <url>/2018/03/09/2018/2018-03-09-Netty-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%EF%BC%88%E6%9C%AC%E6%96%87%E8%B6%85%E9%95%BF%E6%85%8E%E8%AF%BB%EF%BC%89(%E5%9F%BA%E4%BA%8E4-1-23)/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>作为一个 Java 程序员，必须知道Java社区最强网络框架——-Netty，且必须看过源码，才能说是了解这个框架，否则都是无稽之谈。今天楼主不会讲什么理论和概念，而是使用debug 的方式，走一遍 Netty （服务器）的启动过程。</p>
<h2 id="1-demo-源码"><a href="#1-demo-源码" class="headerlink" title="1. demo 源码"></a>1. demo 源码</h2><p>楼主 clone 的 netty 的源码，值得一提的是，netty 提供了大量的 demo 供用户使用和测试。今天我们就通过netty的例子，来逐步 debug。ok ，开始吧。</p>
<p><strong>启动类源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SSL = System.getProperty(<span class="string">&quot;ssl&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> io.netty.channel.nio.NioEventLoop</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Configure SSL.</span></span><br><span class="line">        <span class="keyword">final</span> SslContext sslCtx;</span><br><span class="line">        <span class="keyword">if</span> (SSL) &#123;</span><br><span class="line">            SelfSignedCertificate ssc = <span class="keyword">new</span> SelfSignedCertificate();</span><br><span class="line">            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sslCtx = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)<span class="comment">//new ReflectiveChannelFactory&lt;C&gt;(channelClass)</span></span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">             .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))<span class="comment">// ServerSocketChannel 专属</span></span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">// SocketChannel 专属</span></span><br><span class="line">                     ChannelPipeline p = ch.pipeline();</span><br><span class="line">                     <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">           <span class="comment">// Start the server.</span></span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>处理器源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">      ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">      <span class="keyword">byte</span>[] req = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">      buf.readBytes(req);</span><br><span class="line">      String body = <span class="keyword">new</span> String(req,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.err.println(body);</span><br><span class="line"></span><br><span class="line">      String reqString = <span class="string">&quot;Hello I am Server&quot;</span>;</span><br><span class="line">      ByteBuf resp = Unpooled.copiedBuffer(reqString.getBytes());</span><br><span class="line">      ctx.writeAndFlush(resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个源码都在 io.netty.example.echo 包下，大家可以自行下载。</p>
<h2 id="2-demo-分析"><a href="#2-demo-分析" class="headerlink" title="2. demo 分析"></a>2. demo 分析</h2><p>我们先分析一下我们的 demo 源码，知道他们有哪些作用。</p>
<p><strong>先看启动类</strong>：</p>
<p>main 方法中，首先创建了关于SSL 的配置类，这个不是我们今天的重点。略过。</p>
<p>重点来了，创建了两个EventLoopGroup 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configure the server.</span></span><br><span class="line">  EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">  EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这两个对象是整个 Netty 的核心对象，可以说，整个 Netty 的运作都依赖于他们。bossGroup 用于接受 Tcp 请求，他会将请求交给 workerGroup ，workerGroup 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p>
<p>try 块中创建了一个 ServerBootstrap 对象，他是一个引导类，用于启动服务器和引导整个程序的初始化。<br>随后，变量 b 调用了 group 方法将两个 group 放入了自己的字段中，用于后期引导使用。<br>然后添加了一个 channel，其中参数一个Class对象，引导类将通过这个 Class 对象反射创建 Channel。<br>然后添加了一些TCP的参数。<br>再添加了一个服务器专属的日志处理器 handler。<br>再添加一个 SocketChannel（不是 ServerSocketChannel）的 handler。<br>然后绑定端口并阻塞至连接成功。<br>最后main线程阻塞等待关闭。<br>finally 块中的代码将在服务器关闭时优雅关闭所有资源。</p>
<p><strong>再看 EchoServerHandler 类</strong></p>
<p>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</p>
<p>好，我们已经大致讲解了我们的 demo 源码的作用。当然，这里讲的很简单，我们将在后面的debug 的时候详细介绍他们的作用。</p>
<h2 id="3-首先看创建-EventLoopGroup-的过程："><a href="#3-首先看创建-EventLoopGroup-的过程：" class="headerlink" title="3. 首先看创建 EventLoopGroup 的过程："></a>3. 首先看创建 EventLoopGroup 的过程：</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-80ed1a2ac7a3ea8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5fa7323513fe5a24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-37f1334e2f65e804.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-51b56aa96988bd7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c9333eb0f82228bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-389283876db4d980.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-cf92f68233afe3f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上面的这些都是一些重载的构造方法，并加入了一些默认值，比如为null 的 executor，还有熟悉的 NIO 的 SelectorProvider.provider()，也有一个单例的选择策略工厂，还有一个默认的线程池拒绝策略，最后还有一个线程的默认数量：CPU 核心数 * 2。最后还有一个默认的线程选择策略工厂。</p>
<p>最后，才是 NioEventLoopGroup 真正的构造方法，在抽象父类MultithreadEventExecutorGroup中，这里我们看到了模板模式，代码如下 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.默认0，2executor 默认null， 3.nio provider，4.new DefaultSelectStrategyFactory() 是个单例，5.默认拒绝策略：抛出异常</span></span><br><span class="line"><span class="comment">// args : 3-5, 线程数默认: NettyRuntime.availableProcessors() * 2，也就是 CPU core * 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.默认 core *2， 2.null， 3. 单例new DefaultEventExecutorChooserFactory()， 4， 3-5</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 类名为名称的线程工厂</span></span><br><span class="line">        <span class="comment">// 该线程池没有任何队列，提交任务后，创建任何线程类型都是 FastThreadLocalRunnable, 并且立即start。</span></span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个事件执行组</span></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line">    <span class="comment">// 初始化线程数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 new NioEventLoop</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果创建失败，优雅关闭</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    EventExecutor e = children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然代码很长，实际上就那么几件事情，我们拆分来看：</p>
<ol>
<li>如果 executor 是null，创建一个默认的 ThreadPerTaskExecutor，使用 Netty 默认的线程工厂。</li>
<li>根据传入的线程数（CPU*2）创建一个线程池（单例线程池）数组。</li>
<li>循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</li>
<li>根据线程选择工厂创建一个 <code>线程选择器</code>，默认是对2取余（位运算），也可以顺序获取。</li>
<li>为每一个单例线程池添加一个关闭监听器。</li>
<li>将所有的单例线程池添加到一个 HashSet 中。</li>
</ol>
<p>本篇先于篇幅，不会再继续拆解这些步骤，后面我们找机会继续拆解。</p>
<h2 id="4-再看-ServerBootstrap-创建和构造过程"><a href="#4-再看-ServerBootstrap-创建和构造过程" class="headerlink" title="4. 再看 ServerBootstrap 创建和构造过程"></a>4. 再看 ServerBootstrap 创建和构造过程</h2><p>ServerBootstrap 是个空构造，什么都没有，但注意，有默认的变量：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-008aa29b53fb29b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意其中的 ServerBootstrapConfig 对象，这个对象将会在后面起很大作用。</p>
<p>再看后面的链式调用：group 方法，将 boss 和 worker 传入，boss 赋值给 group 属性，worker 赋值给 childGroup 属性。</p>
<p>channel 方法传入 NioServerSocketChannel class 对象。会根据这个 class 创建 channel 对象。</p>
<p>option 方法传入 TCP 参数，放在一个LinkedHashMap 中。</p>
<p>handler 方法传入一个 handler 中，这个hanlder 只专属于 ServerSocketChannel 而不是 SocketChannel。</p>
<p>childHandler 传入一个 hanlder ，这个handler 将会在每个客户端连接的时候调用。供 SocketChannel 使用。</p>
<h2 id="5-再看-bind-方法"><a href="#5-再看-bind-方法" class="headerlink" title="5. 再看 bind 方法"></a>5. 再看 bind 方法</h2><p><strong>注意，整个服务器就是在这个方法里启动完成的，从这里开始，将会是一段跳来跳去的过程（因为是异步的），我们将使用强大的 IDEA 编辑器进行调试。</strong></p>
<p>开始吧!</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0d8cb4229b958ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-24bbfcd282522368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上面很简单，创建了一个端口对象，并做了一些空判断，就不讲了，最重要的是下面的 doBind 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">       <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">       <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> regFuture;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">           <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">           ChannelPromise promise = ((NioServerSocketChannel)channel).newPromise();</span><br><span class="line">           doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">           <span class="keyword">return</span> promise;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span></span><br><span class="line">           <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">           regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   Throwable cause = future.cause();</span><br><span class="line">                   <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                       <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                       promise.setFailure(cause);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                       <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                       promise.registered();</span><br><span class="line"></span><br><span class="line">                       doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> promise;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p> ServerBootstrap 的这个方法不长也不短，但经过我们的拆解，可以分为以下  2  部分：</p>
<ol>
<li>initAndRegister 初始化 NioServerSocketChannel 通道并注册各个 handler，返回一个 future。</li>
<li>执行 doBind0 方法，完成对端口的绑定。</li>
</ol>
<p>看着很简单，就两个步骤。</p>
<p>但实际上，这两个步骤蜿蜒曲折，各种异步跳转，请做好准备。</p>
<h2 id="6-initAndRegister-方法"><a href="#6-initAndRegister-方法" class="headerlink" title="6. initAndRegister 方法"></a>6. initAndRegister 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Channel channel = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           channel = channelFactory.newChannel();<span class="comment">//NioServerSocketChannel</span></span><br><span class="line">           init(channel);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">               channel.unsafe().closeForcibly();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">       &#125;</span><br><span class="line">       ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">       <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">               channel.close();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               channel.unsafe().closeForcibly();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> regFuture;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>同样的，先进行拆解：</p>
<ol>
<li>通过 ServerBootstrap 的通道工厂反射创建一个 NioServerSocketChannel。</li>
<li>init 初始化这个 NioServerSocketChannel。</li>
<li>config().group().register(channel)  通过 ServerBootstrap 的 bossGroup 注册 NioServerSocketChannel。</li>
<li>最后，返回这个异步执行的占位符。</li>
</ol>
<p>4个步骤，调用层次极深，非战斗人员请注意安全。</p>
<p>第 1 个步骤，反射创建。</p>
<h4 id="channelFactory-newChannel-方法"><a href="#channelFactory-newChannel-方法" class="headerlink" title="channelFactory.newChannel() 方法"></a>channelFactory.newChannel() 方法</h4><p><img src="http://upload-images.jianshu.io/upload_images/4236553-da7adf8da0d59572.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反射创建。"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1ad8fdc0b0870fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传入一个 NIO 的 provider 实例并调用 newSocket 方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-486fae2e5149f7da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可以看到这个静态变量且是 final 的"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ac23abfffa0b5fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="熟悉的 NIO，创建了一个 ServerSocketChannel 实例"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-1092cbc530504623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用父类的构造器，并传入 ACCEPT，并创建了一个 config 对象用于展示自己"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-56e8f5f3baf1d2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继续调用父类"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3f7527b105d7227c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里也很熟悉了，调用父类，设置非阻塞，设置感兴趣的事件，设置 Channel 属性，也就是 JDK 的 ServerSocketChannelImpl ，Netty 的 NioServerSocketChannel 代理了 JDK 的 Socket。"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c2205d4605c895a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里继续给父类赋值， 通过 debug 看到，parent 是 null， id 是通过算法生成唯一ID， 并创建了一个 unsafe和 pipeline "></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-0524efa6c477411e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个工厂"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f8c9ee94943d1553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建 channelID "></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2712e75382d548c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回到创建 unsafe 的过程，NIO 的 message 的操作类，是 Netty 的核心组件"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-244dc0d13669a540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-e97f90a7b2083a77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回到创建 pipeline 的方法，一个默认的 pipeline ，参数是 this ，即 NioServerSocketChannel "></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c669666e9451e70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DefaultChannelPipeline 的构造方法，是一个双向链表，并将 NioServerSocketChannel 设置为自己的属性"></p>
<p>回到 NioServerSocketChannel 的构造方法，还有 config 的构造方法没看。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f9e69e5e2e1388b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-2c8e1fc7963f5d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里返回的是我们各个设置的 JDK 的 ServerSocketChannel "></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6de03df6e10b9d3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d2ed4effe6e88044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继续调用父类，但是，限于篇幅，我们不再深入，我们只需知道，这个 config 对象用于配置这个 NioServerSocketChannel ，用于外部获取参数和配置"></p>
<p>到此为止，我们看到了整个 NioServerSocketChannel  的构造过程，可谓非常的复杂，尽管我们贴了很多图，但仍然没有到底。但这不妨碍我们这次的主体内容。我们总结一下构造过程：</p>
<ol>
<li>通过 NIO 的SelectorProvider 的 openServerSocketChannel 方法得到JDK 的 channel。目的是让 Netty 包装 JDK 的 channel。同时设置刚兴趣的事件为 ACCEPT和非阻塞</li>
<li> 创建了一个唯一的 ChannelId，创建了一个 NioMessageUnsafe，用于操作消息，创建了一个 DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。</li>
<li>创建了一个 NioServerSocketChannelConfig 对象，用于对外展示一些配置。</li>
</ol>
<p>好，NioServerSocketChannel 对象创建完了， 现在进入到第二个步骤，init 方法，这是个抽象方法，由 ServerBootstrap 自己实现。</p>
<h4 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h4><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">       <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">           setChannelOptions(channel, options, logger);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">       <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">               channel.attr(key).set(e.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ChannelPipeline p = ((NioServerSocketChannel)channel).pipeline();<span class="comment">//NioServerSocketChannel</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">       <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">       <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">       <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">       <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">           currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">           currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       (p).addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">               ChannelHandler handler = config.handler();<span class="comment">// ServerBootstrapConfig</span></span><br><span class="line">               <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   pipeline.addLast(handler);</span><br><span class="line">               &#125;</span><br><span class="line">               ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                               ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样的，该方法不长也不短，继续拆解，不能陷入细节中：</p>
<ol>
<li>设置 NioServerSocketChannel 的 TCP 属性。</li>
<li>由于 LinkedHashMap 是非线程安全的，使用同步进行处理。</li>
<li>对 NioServerSocketChannel 的 ChannelPipeline 添加 ChannelInitializer 处理器。</li>
</ol>
<p>从上面的步骤可以看出， init 的方法的精华在和 ChannelPipeline 相关。</p>
<p>从 NioServerSocketChannel  的初始化过程中，我们知道，pipeline 是一个双向链表，并且，他本身就初始化了 head 和 tail，这里调用了他的 addLast 方法，也就是将整个 handler 插入到 tail 的前面，因为 tail 永远会在后面，需要做一些系统的固定工作。</p>
<p>我们进入到 addLast 方法内查看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7dd4c6c6bd5805b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-088df32989c8d9e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="循环添加 "></p>
<p>addLast（EventExecutorGroup group, String name, ChannelHandler handler） 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           checkMultiplicity(handler);</span><br><span class="line">           newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">           addLast0(newCtx);</span><br><span class="line">           <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">               newCtx.setAddPending();</span><br><span class="line">               callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           EventExecutor executor = newCtx.executor();</span><br><span class="line">           <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">               newCtx.setAddPending();</span><br><span class="line">               executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       callHandlerAdded0(newCtx);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       callHandlerAdded0(newCtx);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就是 pipeline 方法的精髓了，拆解如下：</p>
<ol>
<li>检查该 handler 是否符合标准，如果没有 Sharable 注解且已经被使用过了，就抛出异常。</li>
<li>创建一个 AbstractChannelHandlerContext 对象，这里说一下，ChannelHandlerContext 对象是 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 Pipeline 中时，都会创建 Context。Context 的主要功能是管理他所关联的 Handler 和同一个 Pipeline 中的其他 Handler 之间的交互。</li>
<li>然后将 Context 添加到链表中。也就是追加到 tail 节点的前面。</li>
<li>最后，同步或者异步或者晚点异步的调用 callHandlerAdded0 方法，在该方法中，调用之前的 handler 的 handlerAdded 方法，而该方法内部调用了之前的 ChannelInitializer 匿名类的  initChannel 方法，并且参数就是 context 的 channel（通过 pipeline 获取），也就是 NioServerSocketChannel。这个 Context 的标准实现就是 DefaultChannelHandlerContext。这个 Context 内部会包含一些重要的属性，比如 pipeline，handler，属于出站类型还是入站类型等。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d86242075d69083d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终调用 initChannel 方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6068aa6ca9c01543.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传入NioServerSocketChannel "></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c6d168e9a15c533a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取 pipeline 的 NioServerSocketChannel"></p>
<p>从上面的分析我们可以看出，pipeline 的 addLast 方法，实际上创建一个 Context 对象包装了 pipeline 和 handler，然后通过同步或者异步的方式，间接执行 handler 的 自定义方法——-initChannel 方法。而这个 context 也加入到了 pipeline 的链表节点中。</p>
<p>好了，针对 addLast 方法，我们暂且就分析到这里。</p>
<h4 id="config-group-register-channel-方法"><a href="#config-group-register-channel-方法" class="headerlink" title="config().group().register(channel)  方法"></a>config().group().register(channel)  方法</h4><p>回到 initAndRegister 方法中，继续看 config().group().register(channel) 这行代码，config 方法返回了 ServerBootstrapConfig，这个 ServerBootstrapConfig 调用了 group 方法，实际上就是 bossGroup。bossGroup 调用了 register 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d9959cd0165f33ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这个 next 方法调用的是 EventExecutorChooser 的 next 方法，我们看看该方法的实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-14378a519e3df79b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意，这里是著名的 Netty 对性能压榨的一个例子，Netty 对于选取数组中的线程有着2套策略。</p>
<ol>
<li>如果数组是偶数，则使用位运算获取下一个EventLoop（单例线程池）（效率高）。</li>
<li>如果是奇数，使用取余（效率低）。</li>
</ol>
<p>所以，如果是自定义数组长度的话，最好是偶数，默认的就是CPU 核心的2倍，即偶数。</p>
<p>并且，在判断数组是否是偶数的算法中，也没有使用取余，而是位运算。如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7fda109c2e66315d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="isPowerTwo 方法"></p>
<p>回到正题。拿到下一个单例线程池后，调用他的 register 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3fabdb8f514a1d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>this 就是 EventLoop（单例线程池），这里多次提到单例线程池，为什么使用单例线程池呢？一个线程还使用线程池有什么意义呢？答：需要任务队列，有很多任务需要进行调度，所以需要线程池的特性。但为了多线程的切换导致的性能损耗和为了消除同步，所以使用单个线程。</p>
<p>继续，这里创建了一个 DefaultChannelPromise ，这里需要说一下 Promise 的作用，其实类似 Future，事实上也继承了 JDK 的 Future，但增加了很多功能，比如 JDK 的 Future 虽然是异步的，但仍需要 get 方法 阻塞获取结果才能坐之后的事情，而 Promise 可以通过设置监听器的方式，在方法执行成功或者失败的情况下无需等待，就能执行监听器中的任务，效率币 Future 高很多。从某种程度上说，Future 是非阻塞，而Promise 才是正在的异步。</p>
<p>他的构造方法也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultChannelPromise</span><span class="params">(Channel channel, EventExecutor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(executor);</span><br><span class="line">    <span class="keyword">this</span>.channel = checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 父构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultPromise</span><span class="params">(EventExecutor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executor = checkNotNull(executor, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>好了，回到 register 方法，有了刚刚创建的 Promise，EventLoop 继续调用自己的 register 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3141f3625c521229.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="register"></p>
<p>通过调用 promise 的 channel 方法获取了 NioServerSocketChannel ，然后再调用 NioServerSocketChannel 的 unsafe方法获取创建NioServerSocketChannel对象时同时创建的 NioMessageUnsafe 对象，最后调用 NioMessageUnsafe  的 register 方法，参数时 promise 和 NioEventLoop。最后返回了这个 promise 方法。</p>
<p>我们可以先思考一下，之所以使用 promise ，register 内部肯定时异步执行了某个方法，让 promise 立刻返回。执行完毕后再执行设置的监听器的方法。</p>
<p>我们去看个究竟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">          promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">          promise.setFailure(</span><br><span class="line">                  <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">          register0(promise);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;<span class="comment">// 开始真正的异步，boss 线程开始启动</span></span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                      register0(promise);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              logger.warn(</span><br><span class="line">                      <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                      AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">              closeForcibly();</span><br><span class="line">              closeFuture.setClosed();</span><br><span class="line">              safeSetFailure(promise, t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>该方法不长也不短，我们拆解一下：</p>
<ol>
<li>先是一系列的判断。</li>
<li>判断当前线程是否是给定的 eventLoop 线程。注意：这点很重要，Netty 线程模型的高性能取决于对于当前执行的Thread 的身份的确定。如果不在当前线程，那么就需要很多同步措施（比如加锁），上下文切换等耗费性能的操作。</li>
<li>异步（因为我们这里直到现在还是 main 线程在执行，不属于当前线程）的执行 register0 方法。</li>
</ol>
<p>实际上，聪明如你，一定知道 register0（promise） 才是最重要的方法。我们来看看该方法逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">                doRegister();</span><br><span class="line">                neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">                registered = <span class="keyword">true</span>;</span><br><span class="line">                pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">                safeSetSuccess(promise);</span><br><span class="line">                pipeline.fireChannelRegistered();</span><br><span class="line">                <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                        pipeline.fireChannelActive();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                        beginRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                closeForcibly();</span><br><span class="line">                closeFuture.setClosed();</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>继续拆解：</p>
<ol>
<li>首先状态判断。</li>
<li>执行 doRegister 方法。</li>
<li>执行 pipeline.invokeHandlerAddedIfNeeded() 方法。</li>
<li>执行 pipeline.fireChannelRegistered() 方法。</li>
</ol>
<p>可以看到 doRegister 应该就是真正的执行方法，而后面的就是管道开始调用 handller 的一些注册成功之后的回调方法。先看doRegister 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                <span class="comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span></span><br><span class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>是不是很熟悉？该方法在一个死循环中向 JDK 中注册感兴趣的事件。如果成功，则直接结束，如果失败，则 调用 EventLoop 内部的 JDK 的 select 的 selectNow 方法立即返回，然后尝试第二次注册，如果还是报错，则抛出异常。注意，这里同时还把自己（NioServerSocketChannel）作为attach 绑定了该 selectKey 上。大家可能奇怪，为什么注册的是0，而不是16 Accpet 事件呢？楼主也不知道。但是最后还是会删除这个读事件，重新注册 accpet 事件的。netty 不知道是怎么想的。</p>
<p>好了，回到 register0 方法，还有2个步骤，分别是执行 pipeline 的 invokeHandlerAddedIfNeeded 方法和 fireChannelRegistered 方法，同时设置 promise 为成功，这个时候，promise就会执行监听器的方法。</p>
<p>invokeHandlerAddedIfNeeded  方法是做什么的呢？还记得我们之前在 pipeline 的 addLast 方法中，添加了一个 handler 吗？我们说该方法可能会晚点执行，因为这个方法被包装成了 task，这里就会执行该方法。这个方法的意思就是，如果管道中有需要执行的任务，就去执行。我们回忆一下那个方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9fdf901fd49c9e2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="addLast 方法，added 属性为true "></p>
<p>callHandlerCallbackLater 方法会根据 added 属性包装成一个 task（add 任务或 removed 任务），成为任务链表上的一个节点。</p>
<p>而 add 任务和 removed 任务的不同在于，add 任务是pipeline 初始化之后调用的任务（通过 Channel 的handlerAdded 方法），removed 是pipeline 结束后执行（通过 Handler 的 handlerRemoved 方法）。</p>
<p>回到 register0 方法，在执行完 invokeHandlerAddedIfNeeded 方法后，也就是我们刚开始的init 方法里的 ChannelInitializer 匿名类的 initChannel 方法。</p>
<p>safeSetSuccess(promise) 方法就是通知 promise 已经成功了，你可以执行监听器的方法了，而这里的监听器则是我们的 dobind 方法中设置的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-ecfc151be241141b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="doBind方法"></p>
<p>至于内部执行，我们稍后再说，先回到我们的 register0 方法中，在 safeSetSuccess 方法执行后，执行  pipeline.fireChannelRegistered() 方法。看名字是执行 handler 的注册成功之后的回调方法。我们跟进去看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-bc4d8be313f717ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pipeline 中的 静态方法，并传入了 head Context"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6bbd5ce1c432f885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取 head 的 执行器EventLoop，用于判断是否在当前线程，如果在当前线程，则立即执行 invokeChannelRegistered 方法，否则异步执行，我们这里当然是在当前线程。所以同步执行"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9547e717094eb1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里执行 Context 对应的 handler 的 channelRegistered 方法，"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-22ba90511c9dc504.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="和之前一样，会检查通道中是否有需要延迟执行的任务，如果有，就执行，然后调用 Context 的 fireChannelRegistered 方法，而不是 pipeline  的 fireChannelRegistered 方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-158b30bceb4c644d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="该方法调用的是 head Context 的 invokeChannelRegistered 静态方法，注意，这里的参数很重要，我们进入 findContextInbound 方法内部查看"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f38baef839f2b336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意，我们说 pipeline 是一个双向链表，这里链表起作用了，通过找到当前节点的下一个节点，并返回，但这判断的是：必须是入站类型的 "></p>
<p>回到  fireChannelRegistered 方法，看看 invokeChannelRegistered 是如何调用的？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-48cc91e5f914827c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意到了吗，next 节点就是我设置的 LoggingHandler 对应的 Context，获取对应的 EventLoop。从这里我们总结一下 netty 的 Handler 设计：<strong>Netty 初始了一个 pipeline，pipeline 内部维护着一个 ChannelContextContext 双向链表，Context 是对 Handler 的封装，是 pipeline 和 Handler 沟通的关键，每次信息入站，从 head 节点开始，执行 context 的 handler 的对应方法，执行结束通过 findContextInbound() 方法找到下一个节点，继续执行</strong>。</p>
<p>tail 节点的 channelRegistered 什么都不做。</p>
<p>好，终于可以回到我们 ServerBootStrap 的 initAndRegister 方法中了。</p>
<p>还没有完。我们上面对于第三个步骤 <code>对 NioServerSocketChannel 的 ChannelPipeline 添加 ChannelInitializer 处理器。</code> 只是一笔带过。也就是说，我们从NioServerSocketChannel  的pipeline 的的addLast 方法中一直分析到现在。我们再回头看看该方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-3492dd70b89fd724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServerBootStrap init 方法"></p>
<p>我们分析了 addLast 方法，但下面还有一个回调方法，什么呢？想 NioServerSocketChannel 的 EventLoop 提交了一个任务，也就是 pipeline 的 addLast 方法。是一个 ServerBootstrapAcceptor 对象，而这个 ServerBootstrapAcceptor 也是一个 handler，你可以想到了吧，从该 handler 名字就可以看出来，该 handler 是用于处理 accept 事件的。我们看看他的构造方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6f36a307ea3ec2d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上面没有上面好说的，下面有一个 task，任务内容是 设置 该 channel 的autoread 属性为 true，这里我们记一下。还要注意一点，有一个 childHandler 属性，是什么呢？就是我们 main 方法中的 ChannelInitializer 匿名内部类，聪明的你应该想到了，既然该 handler 是接受 accept 事件的，那么，肯定需要初始化管道等操作，不然我们怎么在管道中操作我们的逻辑呢？所以就需要这个 ChannelInitializer 通道初始化对象了。</p>
<p>好了，到这里，我们的 initAndRegister 方法终于算是结束了。</p>
<p>回到我们的 doBind 方法。</p>
<h2 id="7-回到-doBind-方法"><a href="#7-回到-doBind-方法" class="headerlink" title="7. 回到 doBind 方法"></a>7. 回到 doBind 方法</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-14739afb72000570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="doBind 方法"></p>
<p>终于回来了，继续分析，我们上面说完了 dobind 方法有2个重要的步骤，initAndRegister 说完了，接下来看 doBind0 方法，该方法的参数为 initAndRegister  的 future，NioServerSocketChannel，端口地址，NioServerSocketChannel 的 promise。我们进入看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法想 NioServerSocketChannel 的 eventLoop 提交了一个任务，当 future(其实就是 promise) 成功后执行<br>NioServerSocketChannel 的 bind 方法，并添加一个关闭监听器。我们主要关注 bind 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-35a66ee3f293f2eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-c901532a12a4ccad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-69a4301031f57789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>层层调用来到了 NioServerSocketChannel 的 pipeline 的 tail 节点的 bind 方法，该方法首先找到出站节点，然后执行出站节点的 invokeBind 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-63011ac6f24eff82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="寻找 tail 节点的上一个节点，且必须是出站类型的，根据我们的设置，tail 的上一个节点应该是 LoggingHandler 因为他既是是出站类型也是入站类型"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b3a03dc9abd67dc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="根据 UML 可知 LoggingHandler 类型 "></p>
<p>接下来，将调用 LoggingHandler  的 invokeBind 方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9efee2e7739f6efe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" context 调用 handler 的 bind 方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-437c4931681389b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="当然就是打印日志而已"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a2ed754240dc3ffc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继续循环，ctx 的 bind 方法就是先寻找下一个节点或者下一个节点，然后调用节点的 invokeBind 方法，然后调用 handler 的 bind 方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-9789719ec851e091.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来到了head 节点的bind方法，这里调用了 unsafe 的 bind方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6732abda22cb329f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里的 unsafe 来自 NioServerSocketChannel 的 unsafe "></p>
<p>我们看看 unsafe 的 bind 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">     assertEventLoop();</span><br><span class="line">     <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class="line">         localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class="line">         !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class="line">         !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class="line">  </span><br><span class="line">         logger.warn(</span><br><span class="line">                 <span class="string">&quot;A non-root user can&#x27;t receive a broadcast packet if the socket &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;is not bound to a wildcard address; binding to a non-wildcard &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;address (&quot;</span> + localAddress + <span class="string">&quot;) anyway as requested.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         doBind(localAddress);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">         safeSetFailure(promise, t);</span><br><span class="line">         closeIfClosed();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">         invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 pipeline.fireChannelActive();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     safeSetSuccess(promise);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里最终的方法就是 doBind 方法，执行成功后，执行通道的 fireChannelActive 方法，告诉所有的 handler，已经成功绑定。那我们就进入 doBind 方法查看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-8b09900bd1eea687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>很熟悉，获取 JDK 的channel 进行绑定。</p>
<p>回到 bind 方法，然后调用 invokeLater 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeLater</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventLoop().execute(task);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Can&#x27;t invoke task later as EventLoop rejected it&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将这个任务提交。而这个 fireChannelActive 和之前 pipeline 的所有方法都类似，遍历所有节点，执行 ChannelActive 方法。</p>
<p>回到 bind 方法，最后一步：safeSetSuccess(promise)，告诉 promise 任务成功了。其可以执行监听器的方法了。虽然这个 promise 没有任何监听方法。</p>
<p>如果到这里，楼主告诉你，整个启动过程已经结束了，你肯定和诧异，什么？服务器不应该是监听 Accept 事件吗，我们分析了这么多，只发现在 doRegister 方法中注册了 0 （read） 事件，竟然没有监听 Accept 事件，和我们平时写的 Nio 代码不同啊？</p>
<p>是的，如果你想到了这里，说明你思考了。</p>
<p>一切就在上面的 fireChannelActive  方法中。该方法回先调用 head 节点的 channelActive 方法，而 head 节点的 channelActive 代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-123ab889fa97c537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>readIfIsAutoRead 默认返回 true。然后像之前的 pipeline 一样，继续在链表中调用。最后，来到了一个关键的地方：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7b66ba06c58d84c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Head 节点 的read 方法"></p>
<p>调用的是 NioServerSocketChannel 的 unsafe 的 beginRead 方法。继续查看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-d25bb33097590534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="http://upload-images.jianshu.io/upload_images/4236553-a1eb91fc8daabbdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="http://upload-images.jianshu.io/upload_images/4236553-231d546e2634d337.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最后来到了这里"></p>
<p>我们看看 NioServerSocketChannel  的 doBeginRead 方法。<br>拿到 selectionKey ，如果 key 的监听事件是0 的话，就改为 readInterestOp ，也就是我们初始化NioServerSocketChannel 时设置的值：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-b5667da705a5be63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>好了，到这里，整个服务器就完整的启动了，可谓艰难。但整体而言，Netty 的结构设计还是很紧凑的。虽然调用层次很深，但这是所有源码的特点。</p>
<h2 id="8-总结启动过程"><a href="#8-总结启动过程" class="headerlink" title="8. 总结启动过程"></a>8. 总结启动过程</h2><p>好了，从源码层面已经分析完了，我们来总结一下启动的过程。</p>
<ol>
<li>首先创建2个 EventLoopGroup 线程池数组。数组默认大小CPU*2，方便chooser选择线程池时提高性能。</li>
<li>BootStrap 将 boss 设置为 group属性，将 worker 设置为 childer 属性。</li>
<li>通过 bind 方法启动，内部重要方法为  initAndRegister 和 dobind 方法。</li>
<li>initAndRegister 方法会反射创建 NioServerSocketChannel  及其相关的 NIO 的对象， pipeline ， unsafe，同时也为 pipeline 初始了 head 节点和 tail 节点。同时也含有 NioServerSocketChannelConfig 对象。然后向 pipeline 添加自定义的处理器和 ServerBootstrapAcceptor 处理器。这个处理器用于分配接受的 请求给 worker 线程池。每次添加处理器都会创建一个相对应的 Context 作为 pipeline 的节点并包装 handler 对象。注册过程中会调用  NioServerSocketChannel   的 doRegister 方法注册读事件。</li>
<li>在register0  方法成功以后调用在 dobind 方法中调用 doBind0 方法，该方法会 调用 NioServerSocketChannel 的 doBind 方法对 JDK 的 channel 和端口进行绑定，之后在调用 pipeline 的fireChannelActive 最后会调用 NioServerSocketChannel 的 doBeginRead 方法，将感兴趣的事件设置为Accept，完成 Netty 服务器的所有启动，并开始监听连接事件。</li>
</ol>
<p>好了，时间不早了，good luck！ 请期待后续关于 Netty 源码分析的文章！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-接受请求过程源码分析-(基于4-1-23)</title>
    <url>/2018/03/10/2018/2018-03-10-Netty-%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-(%E5%9F%BA%E4%BA%8E4-1-23)/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>在前文中，我们分析了服务器是如何启动的。而服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，否则要你服务器干啥子呢？所以，我们今天就分析分析 Netty 在启动之后是如何接受客户端请求的。</p>
<p>开始吧！</p>
<h2 id="1-从源头开始"><a href="#1-从源头开始" class="headerlink" title="1.  从源头开始"></a>1.  从源头开始</h2><p>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 Accept 事件等待客户端的连接。我们也知道，NioServerSocketChannel 将自己注册到了 boss 单例线程池（reactor 线程）上，也就是 EventLoop 。<br>楼主还没有仔细介绍 EventLoop ，但楼主这里先稍微讲一下他的逻辑：</p>
<p>EventLoop 的作用是一个死循环，而这个循环中做3件事情：</p>
<ol>
<li>有条件的等待 Nio 事件。</li>
<li>处理 Nio 事件。</li>
<li>处理消息队列中的任务。 </li>
</ol>
<p>而我们今天看的就是第二个步骤。</p>
<p>首先需要进入到 NioEventLoop 源码中。</p>
<h2 id="2-开始-debug"><a href="#2-开始-debug" class="headerlink" title="2. 开始 debug"></a>2. 开始 debug</h2><p>进入到 NioEventLoop 源码中后，找到  private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) 方法 ，断点打在下方：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-57b2aa670af17d69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="断点处"></p>
<p>debug 启动我们的 EchoServer 的 main 方法。在浏览器键入 <a href="http://localhost:8007/%EF%BC%8C%E5%BC%80%E5%A7%8B%E8%AE%BF%E9%97%AE%E6%88%91%E4%BB%AC%E7%9A%84">http://localhost:8007/，开始访问我们的</a> Netty 服务器，这时候，断点开始卡住。</p>
<p>从上图中的断点我们可以看到， readyOps 是16 ，也就是  Accept 事件。说明浏览器的请求已经进来了。那么这个 unsafe 是谁呢？就是 boss 线程中 <code>NioServerSocketChannel 的AbstractNioMessageChannel$NioMessageUnsafe 对象。</code> 我们进入到 AbstractNioMessageChannel$NioMessageUnsafe 的read 方法中。</p>
<p>AbstractNioMessageChannel$NioMessageUnsafe # read 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">            &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>楼主限于篇幅，精简了很多代码，我们拆解一下代码：</p>
<ol>
<li>检查该 eventloop  线程是否是当前线程。</li>
<li>执行 doReadMessages 方法，并传入一个 readBuf 变量，这个变量是一个 List，也就是容器。</li>
<li>循环容器，执行 pipeline.fireChannelRead(readBuf.get(i)); </li>
</ol>
<p>我们分析一下上面的步骤：doReadMessages 肯定是读取 boss 线程中的 NioServerSocketChannel 接受到的请求。并把这些请求放进容器，然后呢？循环容器中的所有请求，调用 pipeline 的 fireChannelRead 方法，用于处理这些接受的请求或者其他事件。</p>
<p>那么我们就来验证一下。进入 doReadMessages 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">     buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>楼主精简了代码，可以看到，和我们猜的不差，该方法很简单，通过工具类，调用 NioServerSocketChannel  内部封装的 serverSocketChannel 的 accept 方法，熟悉的 Nio 做法。然后获取到一个 JDK 的 SocketChannel，然后，使用 NioSocketChannel 进行封装。最后添加到容器中。</p>
<h2 id="3-NioSocketChannel-是如何创建的？"><a href="#3-NioSocketChannel-是如何创建的？" class="headerlink" title="3.   NioSocketChannel 是如何创建的？"></a>3.   NioSocketChannel 是如何创建的？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">     buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们另起一段研究这段代码，先看  SocketUtils.accept(javaChannel());</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">accept</span><span class="params">(<span class="keyword">final</span> ServerSocketChannel serverSocketChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> SocketChannel <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> serverSocketChannel.accept();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) e.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用了 NioServerSocketChannel   中的 serverSocketChannel.accept() 方法。返回了一个 Nio 的通道，注意：这个通道，就是我们刚刚 Boss 线程监听到的 Accept 事件，相当于一个 Tcp 连接。</p>
<p>然后我们看 NioSocketChannel 的创建过程，其中参数 this 是 NioServerSocketChannel ，这个就是 SocketChannel 的 parent 属性，ch 是 SocketChannel 。构造方法如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-cc51909b7da6c1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NioSocketChannel 构造方法"></p>
<p>和 ServerSocket 类似，还记得 ServerSocket 是怎么创建的吗：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1431875665a93509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServerSocket 构造方法"></p>
<p>还是很相似的。</p>
<p>我们先略过 config 的创建过程，先看 super。<br><img src="https://upload-images.jianshu.io/upload_images/4236553-ad91e2564c63f657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AbstractNioByteChannel ， 注册读事件 "></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f9730952a0386aa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里和 NioServerSocketChannel 一摸一样"></p>
<p>这里设置了 SelectableChannel 属性为 JDK 的 Nio 的 SocketChannel 和 感兴趣的事件。设置非阻塞。</p>
<p>进入到 super 构造方法中：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-ea37ab383afbb666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>也是和 ServerSocket 一样了，注意：这里的 unsafe 就和 ServerSocket 不同了，此方法被重写了，返回的是<br>NioSocketChannel$NioSocketChannelUnsafe， 是 NioSocketChannel 的内部类。再看 pipeline ，是相同的 DefaultChannelPipeline。同样 pipeline 也会自己创建自己的 head 节点和 tail 节点。</p>
<p>好了，到这里，NioSocketChannel 就创建完毕了。</p>
<p>回到 最初的 read 方法中。</p>
<h2 id="4-循环执行-pipeline-fireChannelRead-方法"><a href="#4-循环执行-pipeline-fireChannelRead-方法" class="headerlink" title="4.  循环执行 pipeline.fireChannelRead 方法"></a>4.  循环执行 pipeline.fireChannelRead 方法</h2><p>从上面我们可以看到，doReadMessages 方法的作用是通过 ServerSocket 的 accept 方法获取到 Tcp 连接，然后封装成 Netty 的 NioSocketChannel 对象。最后添加到 容器中。</p>
<p>然后再 read 方法中，循环调用 ServerSocket 的 pipeline 的 fireChannelRead 方法。从这个方法的名字可以感受到：开始执行 管道中的 handler 的 ChannelRead 方法。</p>
<p>那么我们就看看：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-9f9d5d8e1e6fc58a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内部调用了静态方法invokeChannelRead并传入了 head 节点，msg 就是 容器中的  Socket "></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a969056e05352c12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里和我们之前分析的 pipeline 是一样的"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ff38e7360f512088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="也是一样"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3acdd06bf8f76d8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="也是一样"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4500aa7b32b988a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="找到下一个 handler，如果没记错，应该是 LoggingHandler"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-068293922ab54f27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继续"></p>
<p>到这里，楼主就不一个一个 dubug 了，实际上，我们知道，pipeline 里面又 4 个 handler ，分别是 Head，LoggingHandler，ServerBootstrapAcceptor，Tail。我们重点关注 ServerBootstrapAcceptor。debug 之后，断点会进入到 ServerBootstrapAcceptor 中来。我们来看看 ServerBootstrapAcceptor 的 channelRead 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">// 将客户端连接注册到 worker 线程池</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们讲该方法拆解：</p>
<ol>
<li>msg 强转成 Channel ，实际上就是 NioSocketChannel 。</li>
<li>添加 NioSocketChannel 的 pipeline 的 handler ，就是我们 main 方法里面设置的 childHandler 方法里的。</li>
<li>设置 NioSocketChannel 的各种属性。</li>
<li>最重要的，将该 NioSocketChannel 注册到 childGroup 中的一个 EventLoop 上，并添加一个监听器。</li>
</ol>
<p>我们重点看最后一步，这个 childGroup 就是我们 main 方法创建的数组大小为 16 的 workerGroup。在创建 ServerBootstrapAcceptor 添加进来的。</p>
<p>进入 register 方法查看：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-e2cb19285f60af67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="register 方法，这里的 this 是 NioEventLoopGroup，也就是 workerGroup"></p>
<p>这里的 next 方法我们之前介绍过了，使用位运算获取数组中的EventLoop。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-441fc21248600f5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EventLoop 的 register 方法"></p>
<p>这里创建 DefaultChannelPromise 我们之前也看过了，最后该方法返回的就是这个 DefaultChannelPromise。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-2ba8a5d278dfd6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EventLoop 的 register 重载方法"></p>
<p>这里链式调用说明一下：</p>
<ol>
<li>premise 的 channel 方法返回的是 NioSocketChannel。</li>
<li>promise.channel().unsafe() 返回的是 NioSocketChannel$NioSocketChannelUnsafe。</li>
</ol>
<p>所以最终调用的是 NioSocketChannel 的内部类的 register 方法。参数是当前的 EventLoop 和 promise。<br>查看这个 register 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">            <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;<span class="comment">// 开始真正的异步，boss 线程开始启动</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            register0(promise);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>楼主精简了一下代码逻辑，其实就是同步或者异步的调用 register0 方法。大家可以向一下到底是异步还是同步？应该是异步的。应为此时的线程是 boss 线程，而不是 worder 线程，所以肯定无法通过 inEventLoop 判断。</p>
<p>进入到异步线程中查看 register0 方法。其实和我们之前分析的注册 ServerSocket 的过程是一样的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-81e1b60a9bd4474d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="register0 方法"></p>
<p>其中最核心的就是 doRegister 方法。</p>
<h3 id="doRegister-方法"><a href="#doRegister-方法" class="headerlink" title="doRegister 方法"></a><strong>doRegister 方法</strong></h3><p><img src="https://upload-images.jianshu.io/upload_images/4236553-f6933c8d950aa9e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将当前的 SocketChannel 注册到 selector 中，并注册读事件，最后将自身也就是 NioSocketChannel 挂载到这个 key 上，方便下次取出 "></p>
<h3 id="pipeline-invokeHandlerAddedIfNeeded-方法"><a href="#pipeline-invokeHandlerAddedIfNeeded-方法" class="headerlink" title="pipeline.invokeHandlerAddedIfNeeded() 方法"></a><strong>pipeline.invokeHandlerAddedIfNeeded() 方法</strong></h3><p>回到 register0 中，该方法在成功注册到 selector 的读事件后，继续执行管道中可能存在的任务。那么管道中会存在什么任务呢？我们来看看：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7aaf04a5438eba0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pipeline 的 invokeHandlerAddedIfNeeded 方法"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-938d0c3373139adf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" pipeline 的 callHandlerAddedForAllHandlers 方法"></p>
<p>到这里，我们发出疑问，这个 task 从哪里来的？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-cd762044e47cb594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>经过查找，我们发现，这个 pendingHandlerCallbackHead 变量来自我们 addLast 的时候，如果该 pipeline 还没有注册到这个 eventLoop 上，则将这个包装过 handler 的 context 放进变量 pendingHandlerCallbackHead 中，事实上，这个 pendingHandlerCallbackHead 就是个链表的表头，后面的 Context 会被包装成一个任务，追加到链表的尾部。</p>
<p>那么这个 execute 方法如何执行呢？<br><img src="https://upload-images.jianshu.io/upload_images/4236553-866c2f41ef183b9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="execute方法"></p>
<p>主要是执行 callHandlerAdded0 方法，并且传入这个 Context：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-23535fa73351ec3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="callHandlerAdded0  方法"></p>
<p>注意：这里调用了包装了自定义 handler 的 Context 的 handlerAdded 方法，并且传入了这个 Context。然后这个方法我们并没有重写，我们看父类中方法逻辑：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-cc2d8e8b13c9d57c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="handlerAdded 方法"></p>
<p>完美，调用了 initChannel 方法。但注意，这里调用的并不是我们重写的 initChannel  方法，因为参数不是同一个类型，我们重写的方法的参数是 SocketChannel，而不是ChannelHandlerContext，所以，肯定还需要再调用一层。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1b92c3bd765581f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里才是调用用户代码的地方。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4f90bd4594b1e6fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="initChannel  方法"></p>
<p>我们的用户代码添加了两个处理器，还有一个自定义的处理器。当然，现在添加处理器不会再添加到那个 pendingHandlerCallbackHead 任务链表里了，因为已经注册过了，if 判断过不了。</p>
<p>####<strong>operationComplete 方法</strong></p>
<p>然后设置promise 的 operationComplete 方法。还记得我们在ServerBootstrap 的 channelRead 方法中的代码吗？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-bf0179fac06a4dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ServerBootstrap$ServerBootstrapAcceptor 的  channelRead 方法"></p>
<p>在这里调用了我们之前的设置的监听器的 operationComplete 方法。</p>
<h3 id="pipeline-fireChannelRegistered-方法"><a href="#pipeline-fireChannelRegistered-方法" class="headerlink" title="pipeline.fireChannelRegistered() 方法"></a><strong>pipeline.fireChannelRegistered() 方法</strong></h3><p>好，再然后调用 pipeline.fireChannelRegistered() 的方法。大家可以按照之前的 pipeline 的路子想一下，会如何执行？pipeline 作为管道，其中有我们设置的 handler 链表，这里，肯定会顺序执行我们的 handler，比如 main 方法中的 childerHandler。我们继续验证一下。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-2b576bd853a1b2e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fireChannelRegistered 方法 ChannelInboundHandlerAdapter 的 channelRegistered 方法"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9e9bb7be404dba7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行了我们 childHandler 父类 "></p>
<p>该方法会继续调用桥梁 Context 的 fireChannelRegistered 方法，Context 包装的就是我们自定义的 handler。当然我们没有重写该方法。我们只重写了 initChannel 方法。</p>
<h3 id="pipeline-fireChannelActive-方法"><a href="#pipeline-fireChannelActive-方法" class="headerlink" title="pipeline.fireChannelActive() 方法"></a><strong>pipeline.fireChannelActive() 方法</strong></h3><p>回到 register0 方法中，我们继续向下走，如果是第一次注册的话，执行pipeline.fireChannelActive()代码，也就是执行 pipeline 管道中的 handler 的 ChannelActive 方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-bf88dd2bfea29819.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>同样，我们也没有重写该方法，父类会继续回调 fireChannelActive 方法。而这个方法里会继续寻找下一个 Context，然后继续调用，直到遇到 pipeline 的 channelActive(ChannelHandlerContext ctx) 方法：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1900b0624c66b21f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="channelActive 方法"></p>
<p>这里有一行 readIfIsAutoRead 方法，我们注意一下，上面的 ChannelActive 方法都执行结束后，也就是已经连接已经成功后，便开始调用read方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9ce82c28cb6a1cdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d234970d6a456fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="默认自动读取"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b906afb496f35471.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开始调用 SocketChannel 的read 方法"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-52ea03e85a3b43e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="判断 config 中的是否自动读取"></p>
<p>同样的，如果熟悉服务器启动过程的同学肯定看出来了，这里最终会调用 doBeginRead 方法，也就是 AbstractNioChannel 类的方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-38c334df6efcfd7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在之前的 doRegister 方法中，只是注册了0，为什么呢？如果直接注册1，也就是读事件，但系统还没有准备好读取，现在一切都初始化了，就可以读取了。而这里是管道的 head 节点调用 unsafe 方法的。</p>
<p>到这里，针对于这个客户端的连接就完成了，接下来就可以监听读事件了。</p>
<h2 id="总结：服务器接受客户端过程"><a href="#总结：服务器接受客户端过程" class="headerlink" title="总结：服务器接受客户端过程"></a>总结：服务器接受客户端过程</h2><ol>
<li>服务器轮询 Accept 事件，获取事件后调用 unsafe 的 read 方法，这个 unsafe 是 ServerSocket 的内部类，该方法内部由2部分组成。</li>
<li>doReadMessages 用于创建 NioSocketChannel 对象，该对象包装 JDK 的 Nio Channel 客户端。该方法会像创建 ServerSocketChanel 类似创建相关的 pipeline ， unsafe，config。</li>
<li>随后执行 执行 pipeline.fireChannelRead 方法，并将自己绑定到一个 chooser 选择器选择的 workerGroup 中的一个 EventLoop。并且注册一个0，表示注册成功，但并没有注册读（1）事件.</li>
<li>在注册的同时，调用用户程序中设置的 ChannelInitializer handler，向管道中添加一个自定义的处理器，随后立即删除这个 ChannelInitializer handler，为什么呢？因为初始化好了，不再需要。</li>
<li>其中再调用管道的 channelActive 方法中，会将曾经注册过的 Nio 事件改成读事件，开始真正的读监听。到此完成所有客户端连接的读前准备。</li>
</ol>
<p>总的来说就是：接受连接—–&gt;创建一个新的NioSocketChannel———–&gt;注册到一个 worker EventLoop 上——–&gt; 注册selecot Read 事件。</p>
<p>当然，关于，获取到读事件后该怎么处理还没有说，限于篇幅，留在下篇文章中。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-核心组件-EventLoop-源码解析</title>
    <url>/2018/03/11/2018/2018-03-11-Netty-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>在前文 <a href="https://www.jianshu.com/p/46861a05ce1e">Netty 启动过程源码分析 （本文超长慎读）(基于4.1.23)</a> 中，我们分析了整个服务器端的启动过程。在那篇文章中，我们重点关注了启动过程，而在启动过程中对核心组件并没有进行详细介绍，比如 EventLoop ，Pipeline，Unsafe 等。实际上，Netty 的大部分组件都可以拿出来好好说道，因为每个组件都经过了精心的设计，就像 <code>《Netty 实战》</code> 的作者所说：</p>
<blockquote>
<p>Netty 终究是一个框架，他的架构方法和设计原则是：每个小点和它的技术性内容一样重要，穷奇精妙。</p>
</blockquote>
<p><strong>如果仔细看过 Netty ，真的会觉得如作者所说，每个小点都穷奇精妙</strong>。</p>
<p>而今天，我们将分析其最最核心的组件 EventLoop。</p>
<h2 id="1-EventLoop-介绍"><a href="#1-EventLoop-介绍" class="headerlink" title="1. EventLoop 介绍"></a>1. EventLoop 介绍</h2><p>在上篇文章 <a href="https://www.jianshu.com/p/46861a05ce1e">Netty 启动过程源码分析 （本文超长慎读）(基于4.1.23)</a> 中，我们基于 Netty 示例代码进行了剖析，其中，第一行代码就是 ：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(8);</code> 同时我们也说该组件和核心中的核心。</p>
<p>首先看看 NioEventLoop 的继承图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3e7c165ac61a7b12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UML 继承图"></p>
<p>使用红框标出了重点部分：</p>
<ol>
<li>ScheduledExecutorService 接口表示是一个定时任务接口，EventLoop 可以接受定时任务。</li>
<li>EventLoop 接口：Netty 接口文档说明该接口作用：一旦 Channel 注册了，就处理该Channel对应的所有I/O 操作。</li>
<li>SingleThreadEventExecutor 表示这是一个单个线程的线程池。</li>
</ol>
<p>再来看看 EventLoop 接口：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6189a7342be0df48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>只定义了一个方法，就是parent，返回值类型是 EventLoopGroup。</p>
<blockquote>
<p>注意：一个 EventLoop 将由一个永远都不会改变的Thread 驱动，同时任务（Runnable 或者 Callable）可以直接提交给 EventLoop 实现，以立即执行或者调度执行。根据配置和可用核心的不同，可能会创建多个 EventLoop 实例用以优化资源的使用，并且单个 EventLoop 可能会被指派用于服务多个 Channel。</p>
</blockquote>
<p>现在我们可以通俗的解释一下 EventLoop 了，EventLoop 就是一个单例的线程池，里面含有一个死循环的线程不断的做着3件事情：监听端口，处理端口事件，处理队列事件。每个 EventLoop 都可以绑定多个 Channel，而每个 Channel 始终只能由一个 EventLoop 来处理。</p>
<h2 id="2-NioEventLoop-的使用-execute-方法"><a href="#2-NioEventLoop-的使用-execute-方法" class="headerlink" title="2. NioEventLoop 的使用 execute 方法"></a>2. NioEventLoop 的使用 execute 方法</h2><p>在前面的源码分析中，我们大量的看到了 EventLoop 的使用，一般就是 eventloop.execute(task);<br>那我就来看 execute 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">        addTask(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        addTask(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断该 EventLoop 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</p>
<p>如果 addTaskWakesUp 是 false，并且任务不是 NonWakeupRunnable 类型的，就尝试唤醒 selector。这个时候，阻塞在 selecor 的线程就会立即返回。</p>
<p>我们需要关注一下 addTask 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">        reject(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看 offerTask 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">offerTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意这个 taskQueue 是什么类型的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">askQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This event loop never calls takeTask()</span></span><br><span class="line">        <span class="keyword">return</span> maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.&lt;Runnable&gt;newMpscQueue()</span><br><span class="line">                                                    : PlatformDependent.&lt;Runnable&gt;newMpscQueue(maxPendingTasks);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个 maxPendingTasks 变量默认是 int 最大值，21 亿，所以，后面的默认就是返回 PlatformDependent.<Runnable>newMpscQueue()。</p>
<p>那么这个 PlatformDependent.<Runnable>newMpscQueue() 到底是什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> Queue&#125; which is safe to use for multiple producers (different threads) and a single</span></span><br><span class="line"><span class="comment"> * consumer (one thread!).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A MPSC queue which may be unbounded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Queue&lt;T&gt; <span class="title">newMpscQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Mpsc.newMpscQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释上看，这是一个可以安全的用于多个生产者（多个线程）和一个单独的消费者（一个线程）的无界队列。这个类不是 Netty 的，而是 Netty 引入的 jctools 包。此队列可以被多个线程写入，但只能有一个线程取出。</p>
<p>我们回到 execute 方法，再看看 startThread() 方法。</p>
<h2 id="3-NioEventLoop-的父类-SingleThreadEventExecutor-的-startThread-方法"><a href="#3-NioEventLoop-的父类-SingleThreadEventExecutor-的-startThread-方法" class="headerlink" title="3.  NioEventLoop  的父类 SingleThreadEventExecutor 的 startThread 方法"></a>3.  NioEventLoop  的父类 SingleThreadEventExecutor 的 startThread 方法</h2><p>当执行 execute 方法的时候，如果当前线程不是 EventLoop 所属线程，则尝试启动线程，也就是 startThread 方法，我们来看该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                STATE_UPDATER.set(<span class="keyword">this</span>, ST_NOT_STARTED);</span><br><span class="line">                PlatformDependent.throwException(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先判断是否启动过了，保证 EventLoop 只有一个线程，如果没有启动过，则尝试使用 Cas 将 state 状态改为 ST_STARTED，也就是已启动。然后调用 doStartThread 方法。如果失败，则进行回滚。</p>
<p>那么就来看 doStartThread 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> oldState = state;</span><br><span class="line">                    <span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line">                            SingleThreadEventExecutor.<span class="keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cleanup();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="keyword">this</span>, ST_TERMINATED);</span><br><span class="line">                        threadLock.release();</span><br><span class="line">                        terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>楼主精简了部分代码，拆解步骤如下：</p>
<ol>
<li>首先调用 executor 的 execute 方法，这个 executor 就是在创建 Event LoopGroup 的时候创建的 ThreadPerTaskExecutor 类。该 execute 方法会讲 Runnable 包装成Netty 的 FastThreadLocalThread。该类后面我们将会详细介绍。</li>
<li>任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</li>
<li>执行当前 NioEventLoop 的 run 方法，注意：这个方法是个死循环，是整个 EventLoop 的核心，不然怎么叫 Loop 呢？</li>
<li>在 finally 块中，使用CAS 不断修改 state 状态，改成 ST_SHUTTING_DOWN。也就是当线程 Loop 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 break。然后，执行 cleanup 操作，更新状态为<br>ST_TERMINATED，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 terminationFuture 方法。</li>
</ol>
<p>从上面的步骤中，我们直到，其实最核心的就是  Event Loop自身的 run 方法。再继续深入 run 方法，一起探究 Loop 到底是什么？</p>
<h2 id="4-EventLoop-中的-Loop-到底是什么？"><a href="#4-EventLoop-中的-Loop-到底是什么？" class="headerlink" title="4. EventLoop 中的 Loop 到底是什么？"></a>4. EventLoop 中的 Loop 到底是什么？</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                   <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                       <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                           selector.wakeup();</span><br><span class="line">                       &#125;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               cancelledKeys = <span class="number">0</span>;</span><br><span class="line">               needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">               <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       processSelectedKeys();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                       runAllTasks();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       processSelectedKeys();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                       runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               handleLoopException(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                   closeAll();</span><br><span class="line">                   <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               handleLoopException(t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法很长，我们拆解一下：</p>
<ol>
<li>默认的，如果任务队列中有任务，就立即唤醒 selector ，并返回 selector 的 selecotrNow 方法的返回值。如果没有任务，直接返回 -1，这个策略在 DefaultSelectStrategy 中。</li>
<li>如果返回的是 -2， 则继续循环。如果返回的是 -1，也就是没有任务，则调用 selector 的 select 方法，并且设置 wakenUp 为 false。 具体再详细讲。</li>
<li>selector 返回后， 当 ioRatio 变量为100的时候（默认50），处理 select 事件，处理完之后执行任务队列中的所有任务。  反之当不是 100 的时候，处理 selecotr 事件，之后给定一个时间内执行任务队列中的任务。可以看到，ioRatio 的作用就是限制执行任务队列的时间。 关于 ioRatio , Netty 是这解释的，在 Netty 中，有2种任务，一种是 IO 任务，一种是非 IO 任务，如果 ioRatio 比例是100 的话，则这个比例无作用。公式则是建立在 IO 时间上的，公式为 ioTime * (100 - ioRatio) / ioRatio ; 也就是说，当 ioRatio 是 10 的时候，IO 任务执行了 100 纳秒，则非IO任务将会执行 900 纳秒，直到没有任务可执行。</li>
</ol>
<p>从上面的步骤可以看出，整个 run 方法做了3件事情：</p>
<ol>
<li>selector 获取感兴趣的事件。</li>
<li>processSelectedKeys 处理事件。</li>
<li>runAllTasks 执行队列中的任务。</li>
</ol>
<p>我们将继续深入这3个方法。</p>
<h2 id="5-核心-select-方法解析"><a href="#5-核心-select-方法解析" class="headerlink" title="5. 核心 select 方法解析"></a>5. 核心 select 方法解析</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;<span class="comment">// 无任务则超时事件为1秒</span></span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;<span class="comment">// 含有任务 &amp;&amp; 唤醒 selector 成功； 则立即返回</span></span><br><span class="line">                selector.selectNow(); <span class="comment">// 立即返回</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis); <span class="comment">// 否则阻塞给定时间，默认一秒</span></span><br><span class="line">            selectCnt ++;</span><br><span class="line">            <span class="comment">// 如果1秒后返回，有返回值 || select 被用户唤醒 || 任务队列有任务 || 有定时任务即将被执行； 则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 避开 JDK bug</span></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;<span class="comment">// 没有持续 timeoutMillis 且超过 512次，则认为触发了 JDK 空轮询Bug</span></span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">// 重建 selector</span></span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = <span class="keyword">this</span>.selector;</span><br><span class="line">                <span class="comment">// 并立即返回</span></span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法也挺长的，我们来好好拆解该方法：</p>
<ol>
<li>使用<code>当前时间</code>加上<code>定时任务即将执行的剩余时间（如果没有定时任务，默认1秒）</code>。得到 selectDeadLineNanos。</li>
<li>selectDeadLineNanos 减去当前时间并加上一个缓冲值 0.5秒，得到一个 selecotr 阻塞超时时间。</li>
<li>如果这个值小于1秒，则立即 selecotNow 返回。</li>
<li>如果大于0（默认是1秒），如果任务队列中有任务，并且 CAS 唤醒 selector 能够成功。立即返回。</li>
<li><code>int selectedKeys = selector.select(timeoutMillis)</code>，开始真正的阻塞（默认一秒钟），调用的是 SelectedSelectionKeySetSelector 的 select 方法，感兴趣的可以看看该方法。</li>
<li>select 方法一秒钟返回后，如果有事件，或者 selector 被唤醒了，或者 任务队列有任务，或者定时任务即将被执行，跳出循环。</li>
<li>如果上述条件不满足，线程被中断了，则跳出循环。</li>
<li><strong>注意</strong>：如果一切正常，开始判断这次 select 的阻塞时候是否大于等于给定的 timeoutMillis 时间，如果没有，且循环了超过 512 次(默认)，则认为触发了 JDK 的 epoll 空轮询 Bug，调用 rebuildSelector 方法重新创建 selector，并 selectorNow 立即返回。</li>
</ol>
<p>以上9步基本就是 selector 方法的所有。该方法穷奇所有，压榨CPU性能，并避免了 JDK 的 bug。那么，selector 的阻塞时间有哪些地方可以干扰呢？</p>
<ol>
<li>selecotr 返回了事件。</li>
<li>任务队列有任务了。</li>
<li>定时任务即将执行了。</li>
<li>线程被中断了。 </li>
<li>定时任务剩余时间小于 1 秒。</li>
<li>触发了 JDK 的bug。</li>
</ol>
<p>以上 6 种操作都会让 select 立即返回，不会再这里死循环。</p>
<p>我们继续看看当触发 JDK bug 后重建 selector 的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebuildSelector0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector oldSelector = selector;</span><br><span class="line">    <span class="keyword">final</span> SelectorTuple newSelectorTuple;</span><br><span class="line"></span><br><span class="line">    newSelectorTuple = openSelector();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> nChannels = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (SelectionKey key: oldSelector.keys()) &#123;</span><br><span class="line">        Object a = key.attachment();</span><br><span class="line">        <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">        key.cancel();</span><br><span class="line">        SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            <span class="comment">// Update SelectionKey</span></span><br><span class="line">            ((AbstractNioChannel) a).selectionKey = newKey;</span><br><span class="line">        &#125;</span><br><span class="line">        nChannels ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selector = newSelectorTuple.selector;</span><br><span class="line">    unwrappedSelector = newSelectorTuple.unwrappedSelector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>楼主精简了很多异常和日志代码，让我们来拆解一下：</p>
<ol>
<li>调用 openSelector 方法重新创建一个 Selector，并用 SelectorTuple 包装返回。</li>
<li>循环老的 Selector 的所有注册事件，注册到新的 Selector 上。</li>
</ol>
<p>这里就是 Netty 解决 JDK bug 的所有核心。</p>
<p><strong>好了，看完了 selector 方法，我们回到 run 方法。</strong></p>
<h2 id="6-核心-processSelectedKeys-方法解析"><a href="#6-核心-processSelectedKeys-方法解析" class="headerlink" title="6. 核心 processSelectedKeys 方法解析"></a>6. 核心 processSelectedKeys 方法解析</h2><p>当 selector 返回的时候，我们直到，有可能有事件发生，也有可能是别的原因让他返回了。而处理事件的方法就是 processSelectedKeys，我们进入到该方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断 selectedKeys 这个变量，这个变量是一个 Set 类型，但 Netty 内部使用了 SelectionKey 类型的数组，而不是 Map 实现。这个变量什么作用呢？答：当 selector 方法有返回值的时候，JDK 的 Nio 会向这个 set 添加 SelectionKey。通过上面的代码我们看到，如果不是 null（默认开启优化） ，使用优化过的 SelectionKey，也就是数组，如果没有开启优化，则使用 JDK 默认的。</p>
<p>我们看看默认优化的是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line">            selectAgain();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法还是比较简单的，步骤如下：</p>
<ol>
<li>循环所有 selectedKeys，拿到该 Key attach 的 Channel，判断是否是 Netty 的 AbstractNioChannel 类型。</li>
<li>如果 needsToSelectAgain 是 true ，则将数组中 start 下标加1 之后的 key 全部设置成null。然后，调用<br>selectAgain 方法，该方法会将 needsToSelectAgain 设置成 false，并调用 selectorNow 方法返回。同时也会将循环变量 i 改成 -1，再次重新循环。那么，这个 needsToSelectAgain 默认是 false ，什么时候是 true 呢？答：当调用 cancel 方法的时候，也就是 eventLoop close 的时候，取消这个 key 的事件监听。当取消次数达到了256次，needsToSelectAgain 设置成 true。而这么做的目的是什么呢？结合 Netty 的注释：当 EventLoop close 次数达到 256 次，说明了曾经的 Channel 无效了，Netty 就需要清空数组，方便 GC 回收，然后再次 selectNow ，装填新的 key。</li>
</ol>
<p>好了，该方法的重点应该是 processSelectedKey 方法，而判断则是 a instanceof AbstractNioChannel ，还记得 Channel 注册的时候吗：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-78bf24285a1c4020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AbstractNioChannel doRegister 方法 "></p>
<p>从上面的代码中可以看出，Netty 会将 Channel 绑定到 key 上，然后在循环到事件处理的时候，拿出来直接使用。</p>
<p>那我们就看看 processSelectedKey 内部逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();<span class="comment">// NioMessageUnsafe</span></span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        <span class="keyword">final</span> EventLoop eventLoop = ch.eventLoop();</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">        ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">        k.interestOps(ops);</span><br><span class="line">        unsafe.finishConnect();</span><br><span class="line">    &#125;</span><br><span class="line">    .</span><br><span class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">        ch.unsafe().forceFlush();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">        unsafe.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里的代码，相信大家肯定很亲切，这不就是 Nio 的标准做法吗？</p>
<p>注意：这里的 unsafe 是每个 key 所对应的 Channel 对应的 unsafe。因此处理逻辑也是不同的。</p>
<p>可以说，run 方法中的 processSelectedKeys 方法的核心就是，拿到 selector 返回的所有 key 进行循环调用 processSelectedKey 方法， processSelectedKey 方法中会调用每个 Channel 的 unsafe 的对应方法。</p>
<p>好了， processSelectedKeys 方法到此为止。</p>
<h2 id="7-核心-runAllTasks-解析"><a href="#7-核心-runAllTasks-解析" class="headerlink" title="7. 核心 runAllTasks 解析"></a>7. 核心 runAllTasks 解析</h2><p>再看看 runAllTasks ，Task 里面都是一些非 IO 任务。就是通过 execute 提交的那些任务，都会添加的 task 中。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">    Runnable task = pollTask();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line">    <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        safeExecute(task);</span><br><span class="line"></span><br><span class="line">        runTasks ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check timeout every 64 tasks because nanoTime() is relatively expensive.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">XXX:</span> Hard-coded value - will make it configurable if it is really a problem.</span></span><br><span class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    afterRunningAllTasks();</span><br><span class="line">    <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们来拆解一下该方法：</p>
<ol>
<li>将定时任务队列（PriorityQueue 类型的 scheduledTaskQueue）中即将执行的任务都添加到普通的 Mpsc 队列中。</li>
<li>从 Mpsc 队列中取出任务，如果是空的，则执行 tailTasks（Mpsc 无界队列） 中的任务，然后直接结束该方法。</li>
<li>如果不是空，则进入死循环，跳出条件有2个，1是给定的时间到了，2是没有任务了。有一个需要注意的地方就是，这个时间的检查不是每一次都检查的，而是64次循环执行一次检查，因为获取纳米时间的开销较大。</li>
<li>最后执行 tailTasks 中的任务，并更新 lastExecutionTime 最后执行时间。</li>
</ol>
<p>从上面的分析看出，有3种队列，分别是普通的 taskQueue，定时任务的 scheduledTaskQueue， Mpsc 的 tailQueue。</p>
<ol>
<li><p>taskQueue，这个我们很熟悉，基本上，我们现在遇到的都是执行 execute 方法，通过 addTask 方法添加进去的。</p>
</li>
<li><p>定时任务的 scheduledTaskQueue，通常在第一次调用 schedule 方法的时候会创建这个队列。同时这个任务是一般是调用 schedule 方法的时候添加进去的。主要当然是定时任务，同时也是异步的，会返回一个 ScheduledFuture 异步对象。这个对象可以添加监听器或者做一些回调，类似 permise。刚刚在上面也说了，这个队列是一个优先级队列，那么这个队列的优先级是怎么比较的呢？他的默认比较器是 SCHEDULED_FUTURE_TASK_COMPARATOR 对象，比较策略是调用 ScheduledFutureTask 的 compareTo 方法，首先任务队列的剩余时间，然后比较 id，每个任务创建时都会生成一个唯一ID，也就是加入时间的顺序。在每次 poll 之后，都会比较所有的任务，让优先级最高的任务排在数组第一位。</p>
</li>
<li><p>tailQueue 针对这个任务，Netty 在 executeAfterEventLoopIteration 方法的注释上意思是，添加一个任务，在 EnentLoop 下个周期运行，就像我们源码中的，每次在运行任务之后，如果还有时间的话就会运行这个队列中的任务，一般这个队列中放一些优先级不高的任务。但楼主在源码中没有找到应用他的地方。多说一句，该 Queue 也是一个 Mpsc 队列。</p>
</li>
</ol>
<p>最后对 lastExecutionTime  进行赋值，有什么作用呢？在 confirmShutdown 方法中，会对该变量进行判断：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b95093bb91f820ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="判断"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8f367362b57a6cce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通常该方法都在死循环中"></p>
<p>在 EventLoop 的父类 SingleThreadEventExecutor 的 doStartThread 方法的 finally 块中，也就是如果 run 方法结束了，会执行这里的逻辑，确认是否关闭了，如果定时任务最后一次的执行时间距离现在的时间 小于等于 <code>优雅关闭的静默期时间（默认2秒）</code>，则唤醒 selector，并睡眠 0.1 秒，返回 false，表示还没有关闭呢？并继续循环，在 confirmShutdown 的上方逻辑上回继续调用 runAllTasks 方法。此处应该时担心关闭的时候还有尚未完成的定时任务吧。</p>
<p>好，到这里，关于 runAllTasks 方法就解释的差不多了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总上面的分析中，我们看到了 EventLoop 作为 Netty 的核心是如何处理，每次执行 ececute 方法都是向队列中添加任务。当第一次添加时就回启动线程，执行 run 方法，而 run 方法是整个 EventLoop 的核心，就像 EventLoop 的名字一样，Loop Loop ，不停的 Loop ，Loop 做什么呢？做3件事情。</p>
<ol>
<li>调用 selecotr 的 select 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上0.5秒进行阻塞。当执行 execute 方法的时候，也就是添加任务的时候，回唤醒 selecor，防止 selecotr 阻塞时间过长。</li>
<li>当 selector 返回的时候，回调用 processSelectedKeys 方法对 selectKey 进行处理。</li>
<li>当 processSelectedKeys 方法执行结束后，则按照 iaRatio 的比例执行 runAllTasks 方法，默认是 IO 任务时间和非 IO 任务时间是相同的，你也可以根据你的应用特点进行调优 。比如 非 IO 任务比较多，那么你就讲 ioRatio 调小一点，这样非 IO 任务就能执行的长一点。防止队列钟积攒过多的任务。</li>
</ol>
<p>好，关于 EventLoop 的分析就到这里，水平不高，能力有限，有疏忽的地方请指出。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-高性能之道-FastThreadLocal-源码分析（快且安全）</title>
    <url>/2018/03/12/2018/2018-03-12-Netty-%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93-FastThreadLocal-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%BF%AB%E4%B8%94%E5%AE%89%E5%85%A8%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>Netty 作为高性能框架，对 JDK 中的很多类都进行了封装了和优化，例如 Thread 类，Netty 使用了 FastThreadLocalRunnable 对所有 DefaultThreadFactory 创建出来的 Runnable 都进行了包装。包装的目的是 run 方法的不同，看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        FastThreadLocal.removeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，多了一行  FastThreadLocal.removeAll()，众所周知，JDK 中自带的 ThreadLocal 在线程池使用环境中，有内存泄漏的风险，很明显，Netty 为了避免这个 bug，重新进行了封装，而且这个封装线程的名字叫做 FastThreadLocalRunnable，语义很明显：快速的 ThreadLocal！意思说 JDK 自带的慢喽？那我们今天就来看看到底快在哪里？对 ThreadLocal 内存泄漏不清楚或者对 ThreadLoca 不清楚的可以移步 <a href="https://www.jianshu.com/p/80284438bb97">并发编程之 ThreadLocal 源码剖析</a>。</p>
<h2 id="1-如何使用？"><a href="#1-如何使用？" class="headerlink" title="1. 如何使用？"></a>1. 如何使用？</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-12c253f98742f4b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试用例"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-7ec7f64c3cbf86f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<h2 id="2-构造方法解析"><a href="#2-构造方法解析" class="headerlink" title="2. 构造方法解析"></a>2. 构造方法解析</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-852af1ffc45a7a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构造方法"></p>
<p>构造方法中定义了两个变量。 index 和 cleanerFlagIndex，这两个变量且都是 int final 的。且都是通过<br>InternalThreadLocalMap.nextVariableIndex() 方法而来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-266a99ac72429da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InternalThreadLocalMap.nextVariableIndex() 方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-5cdca30965ae3c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nextIndex 变量"></p>
<p>该方法通过一个原子 int 变量自增得到。也就是说，cleanerFlagIndex 变量比 index 大1，这两个变量的作用稍后我们会看到他们如何使用。这里暂且不表。</p>
<h2 id="3-set-方法解析"><a href="#3-set-方法解析" class="headerlink" title="3. set 方法解析"></a>3. set 方法解析</h2><p><img src="http://upload-images.jianshu.io/upload_images/4236553-30ec041c29b4c55d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="set（） 方法"></p>
<p>该方法步骤如下：</p>
<ol>
<li>判断设置的 value 值是否是缺省值，如果是，则调用 remove 方法。</li>
<li>如果不是，则获取道当前线程的 InternalThreadLocalMap。然后将该 FastThreadLocal 对应的 index 下标的 value 替换成新的 value。老的 value 设置成缺省值。</li>
</ol>
<p><strong>小小的一个 set 方法，内部可是非常的复杂，非战斗人员请尽快撤离！</strong></p>
<p>实际上，这里调用了4个方法：</p>
<ol>
<li>InternalThreadLocalMap.get()；</li>
<li>setKnownNotUnset(threadLocalMap, value);</li>
<li>registerCleaner(threadLocalMap);</li>
<li>remove();</li>
</ol>
<p>让我们慢慢说道说道。</p>
<h4 id="1-InternalThreadLocalMap-get-；"><a href="#1-InternalThreadLocalMap-get-；" class="headerlink" title="1. InternalThreadLocalMap.get()；"></a>1. InternalThreadLocalMap.get()；</h4><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">        <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> slowGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是 InternalThreadLocalMap 的静态方法，方法逻辑很简单，主要是根据当前线程是否是 Netty 的 FastThreadLocalThread 来调用不同的方法，一个是 fast 的，一个 是 slow 的（不是 Netty 的线程就是 slow 的）。哈哈哈，Netty 的作者命名还真是犀利。那我们就看看 fastGet 方法是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line">    InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很简单，获取当前线程的 InternalThreadLocalMap，如果没有，就创建一个。我们看看他的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNSET = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">InternalThreadLocalMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(newIndexedVariableTable());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object[] newIndexedVariableTable() &#123;</span><br><span class="line">    Object[] array = <span class="keyword">new</span> Object[<span class="number">32</span>];</span><br><span class="line">    Arrays.fill(array, UNSET);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UnpaddedInternalThreadLocalMap(Object[] indexedVariables) &#123;</span><br><span class="line">    <span class="keyword">this</span>.indexedVariables = indexedVariables;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>楼主将 3 个关联的方法都放在一起了，方便查看，首先，InternalThreadLocalMap 调用的父类 UnpaddedInternalThreadLocalMap 的构造方法，并传入了一个数组，而这个数组默认大小是 32，里面填充32 个空对象的引用。</p>
<p>那 slowGet 方法又是什么样子的呢？代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = <span class="keyword">new</span> ThreadLocal&lt;InternalThreadLocalMap&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line">    InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">        slowThreadLocalMap.set(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码还是很简单的，我们分析一下：首先使用 JDK 的 ThreadLocal 获取一个 Netty 的 InternalThreadLocalMap，如果没有就创建一个，并将这个 InternalThreadLocalMap 设置到 JDK 的 ThreadLocal 中，然后返回这个 InternalThreadLocalMap。从这里可以看出，为了提高性能，Netty 还是避免使用了JDK 的 threadLocalMap，他的方式是曲线救国：在JDK 的 threadLocal 中设置 Netty 的 InternalThreadLocalMap ，然后，这个 InternalThreadLocalMap 中设置 Netty 的 FastThreadLcoal。</p>
<p>好，到这里，我们的 InternalThreadLocalMap.get() 方法就看完了，主要是获取当前线程的 InternalThreadLocalMap，如果没有，就创建一个，这个 Map 内部维护的是一个数组，和 JDK 不同，JDK<br>维护的是一个使用线性探测法的 Map，可见，从底层数据结构上，JDK 就已经输了，他们的读取速度相差很大，特别是当数据量很大的时候，Netty 的数据结构速度依然不变，而 JDK 由于使用线性探测法，速度会相应的下降。</p>
<h4 id="2-setKnownNotUnset-threadLocalMap-value"><a href="#2-setKnownNotUnset-threadLocalMap-value" class="headerlink" title="2. setKnownNotUnset(threadLocalMap, value);"></a>2. setKnownNotUnset(threadLocalMap, value);</h4><p>当 InternalThreadLocalMap.get() 返回了 一个 InternalThreadLocalMap，这个时候调用 setKnownNotUnset(threadLocalMap, value); 方法进行操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setKnownNotUnset</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;</span><br><span class="line">        addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看方法名称，是设置一个值，但不是 unset，也就是那个空对象。通过 threadLocalMap.setIndexedVariable(index, value) 进行设置。如果返回 true，则调用 addToVariablesToRemove(threadLocalMap, this) 。这两个方法，我们一起看看。先看第一个：</p>
<p>setIndexedVariable 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">    Object[] lookup = indexedVariables;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line">        Object oldValue = lookup[index];</span><br><span class="line">        lookup[index] = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue == UNSET;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        expandIndexedVariableTableAndSet(index, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，拿到那个 32 长度的数组，如果 FastThreadLocal 的 index 属性小于数组长度，则将值设定到指定槽位。将原来槽位的值设置为空对象。如果原来的对象也是空对象，则返回 true，否则返回 false。</p>
<p>如果不够呢？调用 expandIndexedVariableTableAndSet(index, value) 方法。进入该方法查看。看方法名称是扩大索引并设置值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandIndexedVariableTableAndSet</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">    Object[] oldArray = indexedVariables;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = oldArray.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = index;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">1</span>;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">2</span>;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">4</span>;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">8</span>;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    newCapacity ++;</span><br><span class="line"></span><br><span class="line">    Object[] newArray = Arrays.copyOf(oldArray, newCapacity);</span><br><span class="line">    Arrays.fill(newArray, oldCapacity, newArray.length, UNSET);</span><br><span class="line">    newArray[index] = value;</span><br><span class="line">    indexedVariables = newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码很熟悉，HashMap 中也有这样的代码，我们去看看：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-bb4c10b59073c4f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HashMap 中的 tableSizeFor 方法"></p>
<p>这段代码的作用就是按原来的容量扩容2倍。并且保证结果是2的幂次方。这里 Netty 的做法和 HashMap 一样，按照原来的容量扩容到最近的 2 的幂次方大小，比如原来32，就扩容到64，然后，将原来数组的内容填充到新数组中，剩余的填充<code>空对象</code>，然后将新数组赋值给成员变量 indexedVariables。完成了一次扩容。</p>
<p>回到 setKnownNotUnset 方法中，setIndexedVariable 方法什么情况下会返回 ture 呢？扩容了，或者没扩容，但插入的对象没有替换掉别的对象，也就是原槽位是空对象。换句话说，只有更新了对象才会返回 false。</p>
<p>也就是说，当新增了对象的时候，会调用 addToVariablesToRemove 方法，如同方法名，添加变量然后删除。我们看看 addToVariablesToRemove(threadLocalMap, this) 方法逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToVariablesToRemove</span><span class="params">(InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该变量是 static final 的，因此通常是 0</span></span><br><span class="line">    Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">    Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;</span><br><span class="line">    <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个基于 IdentityHashMap 的 Set，泛型是 FastThreadLocal</span></span><br><span class="line">        variablesToRemove = Collections.newSetFromMap(<span class="keyword">new</span> IdentityHashMap&lt;FastThreadLocal&lt;?&gt;, Boolean&gt;());</span><br><span class="line">        <span class="comment">// 将这个 Set 放到这个 Map 数组的下标 0 处</span></span><br><span class="line">        threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果拿到的不是 UNSET ，说明这是第二次操作了，因此可以强转为 Set</span></span><br><span class="line">        variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后的目的就是将 FastThreadLocal 放置到 Set 中</span></span><br><span class="line">    variablesToRemove.add(variable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的目的是将 FastThreadLocal 对象保存到一个 Set 中，因为 Netty 的 Map 只是一个数组，没有键，所以保存到一个 Set 中，这样就可以判断是否 set 过这个 map，例如 Netty 的 isSet 方法就是根据这个判断的。</p>
<p>说完了 setKnownNotUnset 方法，我们再说说 registerCleaner 方法。</p>
<h4 id="3-registerCleaner-threadLocalMap"><a href="#3-registerCleaner-threadLocalMap" class="headerlink" title="3. registerCleaner(threadLocalMap);"></a>3. registerCleaner(threadLocalMap);</h4><p>这个方法可以说有点复杂了，请耐住性子，这里是 ftl（FastThreadLocal） 的精髓。</p>
<p>首先说下该方法的作用：将这个 ftl 注册到一个 <code>清理线程</code> 中，当 thread 对象被 gc 的时候，则会自动清理掉 ftl，防止 JDK 的内存泄漏问题。</p>
<p>让我们进入该方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerCleaner</span><span class="params">(<span class="keyword">final</span> InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (FastThreadLocalThread.willCleanupFastThreadLocals(current) ||</span><br><span class="line">        threadLocalMap.indexedVariable(cleanerFlagIndex) != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    threadLocalMap.setIndexedVariable(cleanerFlagIndex, Boolean.TRUE);</span><br><span class="line">    ObjectCleaner.register(current, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            remove(threadLocalMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>楼主删除了源码中的注释，我们来好好说说这个方法：</p>
<ol>
<li><p>获取当前线程，如果当前线程是 FastThreadLocalThread 类型 且 cleanupFastThreadLocals 是 true，则返回 true，直接return。也就是说，Netty 线程池里面创建的线程都符合这条件，只有用户自定义的线程池不符合。<br>当然还有一个条件：如果这个 ftl 的 index + 1 在 map 中的值不是空对象，则已经注册过了，也直接 return，不再重复注册。</p>
</li>
<li><p>当不符合上面的条件的时候，将 Map 中对应的 ftl 的 index  + 1 位置的值设置为 TRUE。根据上面的判断，防止重复注册。</p>
</li>
<li><p>调用 ObjectCleaner 的 register 方法，注册一个任务，任务的内容就是调用 remove 方法，删除 ftl 在 map 中的对象和相应的内容。</p>
</li>
</ol>
<p>问题来了，怎么注册的呢？为什么还带着一个 current 当前线程呢？</p>
<p>我们看看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object, Runnable cleanupTask)</span> </span>&#123;</span><br><span class="line">    AutomaticCleanerReference reference = <span class="keyword">new</span> AutomaticCleanerReference(object,</span><br><span class="line">            ObjectUtil.checkNotNull(cleanupTask, <span class="string">&quot;cleanupTask&quot;</span>));</span><br><span class="line">    LIVE_SET.add(reference);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if there is already a cleaner running.</span></span><br><span class="line">    <span class="keyword">if</span> (CLEANER_RUNNING.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Thread cleanupThread = <span class="keyword">new</span> FastThreadLocalThread(CLEANER_TASK);</span><br><span class="line">        cleanupThread.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                cleanupThread.setContextClassLoader(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cleanupThread.setName(CLEANER_THREAD_NAME);</span><br><span class="line">        cleanupThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        cleanupThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建一个 AutomaticCleanerReference 自动清洁对象，继承了 WeakReference，先不看他的构造方法，先看下面，将这个构造好的实例放入到 LIVE_SET 中，实际上，这是一个 Netty 封装的 ConcurrentSet，然后判断清除线程是否在运行。如果没有，并且CAS改状态成功。就创建一个线程，任务是 定义好的 CLEANER_TASK，线程优先级是最低，上下位类加载器是null，名字是 objectCleanerThread，并且是后台线程。然后启动这个线程。运行 CLEANER_TASK。</p>
<p>一步一步来看看。</p>
<p>首先 AutomaticCleanerReference  的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; REFERENCE_QUEUE = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">AutomaticCleanerReference(Object referent, Runnable cleanupTask) &#123;</span><br><span class="line">    <span class="keyword">super</span>(referent, REFERENCE_QUEUE);</span><br><span class="line">    <span class="keyword">this</span>.cleanupTask = cleanupTask;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cleanupTask.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReferenceQueue 的作用是，当对象被回收的时候，会将这个对象添加进这个队列，就可以跟踪这个对象。设置可以复活这个对象。也就是说，当这个 Thread 对象被回收的时候，会将这个对象放进这个引用队列，放进入干嘛呢？什么时候取出来呢？我们看看什么时候取出来：</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable CLEANER_TASK = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!LIVE_SET.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">final</span> AutomaticCleanerReference reference = (AutomaticCleanerReference) REFERENCE_QUEUE.remove(REFERENCE_QUEUE_POLL_TIMEOUT_MS);</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">if</span> (reference != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        reference.cleanup();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    LIVE_SET.remove(reference);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            CLEANER_RUNNING.set(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (LIVE_SET.isEmpty() || !CLEANER_RUNNING.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>巧了 ！！！！正是 CLEANER_TASK 在使用这个 ReferenceQueue！！！！别激动，我们还是慢慢看看这个任务到底是做什么的：</p>
<ol>
<li>死循环，如果 ConcurrentSet 不是空（还记得我们将 AutomaticCleanerReference 放进这里吗），尝试从 REFERENCE_QUEUE 中取出 AutomaticCleanerReference，也就是我们刚刚放进入的。这是标准的跟踪 GC 对象的做法。因为当一个对象被 GC 时，会将保证这个对象的 Reference 放进指定的引用队列，这是 JVM 做的。</li>
<li>如果不是空，就调用应用的 cleanUp 方法，也就是我们传进去的任务，什么任务？就是那个调用 ftl 的 remove 方法的任务。随后从 Set 中删除这个引用。</li>
<li>如果 Set 是空的话，将清理线程状态（原子变量） 设置成 fasle。</li>
<li>继续判断，如果Set 还是空，或者 Set 不是空 且 设置 CAS 设置状态为true 失败（说明其他线程改了这个状态）则跳出循环，结束线程。</li>
</ol>
<p>有点懵？那我们就好好总结这里为什么这么做：</p>
<blockquote>
<p>当我们在一个非 Netty 线程池创建的线程中使用 ftl 的时候，Netty 会注册一个垃圾清理线程（因为 Netty 线程池创建的线程最终都会执行 removeAll 方法，不会出现内存泄漏） ，用于清理这个线程这个 ftl 变量，从上面的代码中，我们知道，非 Netty 线程如果使用 ftl，Netty 仍然会借助 JDK 的 ThreadLocal，只是只借用一个槽位，放置 Netty 的 Map， Map 中再放置 Netty 的 ftl 。所以，在使用线程池的情况下可能会出现内存泄漏。<strong>Netty 为了解决这个问题，在每次使用新的 ftl 的时候，都将这个 ftl 注册到和线程对象绑定到一个 GC 引用上， 当这个线程对象被回收的时候，也会顺便清理掉他的 Map 中的 所有 ftl，解决了该问题，就像解决 JDK Nio bug 一样。</strong></p>
</blockquote>
<p>好，到这里，Netty 的 FastThreadLocal 的精华我们基本就全部吸取了。ftl 不仅快，而且安全。快在使用数组代替线性探测法的 Map，安全在每次线程回收的时候都清理 ftl，不用担心内存泄漏。</p>
<p>剩下的方法都是很简单的。我们一起看完吧</p>
<h4 id="4-remove"><a href="#4-remove" class="headerlink" title="4. remove();"></a>4. remove();</h4><p>每次 Set 一个空对象的时候，就是调用remove 方法，我们看看该方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     remove(InternalThreadLocalMap.getIfSet());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">getIfSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Thread thread = Thread.currentThread();</span><br><span class="line">     <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">         <span class="keyword">return</span> ((FastThreadLocalThread) thread).threadLocalMap();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> slowThreadLocalMap.get();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 删除并返回 Map 数组中当前 ThreadLocal index 对应的 value</span></span><br><span class="line">     Object v = threadLocalMap.removeIndexedVariable(index);</span><br><span class="line">     <span class="comment">// 从 Map 数组下标 0 的位置取出 Set ，并删除当前的 ThreadLocal</span></span><br><span class="line">     removeFromVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 默认啥也不做，用户可以继承 FastThreadLocal 重定义这个方法。</span></span><br><span class="line">             onRemoval((V) v);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             PlatformDependent.throwException(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>楼主将这3个方法都合并在一起了，首先获取当前线程的 threadLocalMap，然后就像注释中写的：删除 ftl 对应下标中 map 的 value，然后删除 map 下标0 处 Set 中的 ftl。防止 isSet 方法误判。最后，如果用户重写了 onRemoval 方法，就调用，默认是个空方法。用户可以重写 onRemoval 方法和 initialize 方法。</p>
<h2 id="4-get-方法解析"><a href="#4-get-方法解析" class="headerlink" title="4. get 方法解析"></a>4. get 方法解析</h2><p>get 方法就更简单了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line">    Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">    <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">        <span class="keyword">return</span> (V) v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V value = initialize(threadLocalMap);</span><br><span class="line">    registerCleaner(threadLocalMap);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取当前线程的map，然后根据 ftl 的 index 获取 value，然后返回，如果是空对象，也就是没有设置，则通过 initialize 返回，initialize 方法会将返回值设置到 map 的槽位中，并放进 Set 中。最后，尝试注册一个清洁器。</p>
<h2 id="5-remove-All方法解析"><a href="#5-remove-All方法解析" class="headerlink" title="5. remove All方法解析"></a>5. remove All方法解析</h2><p>这个方法在 Netty 的默认线程的 finally 块中调用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();</span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">            FastThreadLocal&lt;?&gt;[] variablesToRemoveArray =</span><br><span class="line">                    variablesToRemove.toArray(<span class="keyword">new</span> FastThreadLocal[variablesToRemove.size()]);</span><br><span class="line">            <span class="keyword">for</span> (FastThreadLocal&lt;?&gt; tlv: variablesToRemoveArray) &#123;</span><br><span class="line">                tlv.remove(threadLocalMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        InternalThreadLocalMap.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非常简单，首先获取当前线程map，然后获取 Set，将 Set 转成数组，遍历数组，调用 ftl 的 remove 方法。最后，删除线程中 的 map 属性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们来总结一下 FastThreadLocal 。</p>
<p>之所以称之为 Fast，因为没有使用 JDK 的使用线性探测法的 Map，如果你使用的是Netty 线程池工厂创建的线程，搭配 Netty 的 ftl，性能非常好，如果你使用自定义的线程，搭配 ftl，性能也会比 JDK 的好，注意： ftl 没有 JDK 的内存泄露的风险。</p>
<p>但做到这些不是没有代价的，由于每一个 ftl 都是一个唯一的下标，而这个下标是每次创建一个 ftl 对象都是递增 2，当你的下标很大，你的线程中的 Map 相应的也要增大，可以想象，如果创建了海量的 ftl 对象，这个数组的浪费是非常客观的。很明显，这是一种空间换时间的做法。</p>
<p>通常，ftl 都是静态对象，所以不会有我们假设的那么多。如果使用不当，确实会浪费大量内存。</p>
<p>但这个风险带来的好处是明显的，在楼主的机器上测试，ftl 的读取性能是 JDK 的 5 倍左右，写入的速度也要快 20% 左右。</p>
<p>FastThreadLocal 人如其名，快且安全！</p>
<p>今天就到这里，good luck！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-核心组件-Pipeline-源码分析（一）之剖析-Pipeline-三巨头</title>
    <url>/2018/03/14/2018/2018-03-14-Netty-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-Pipeline-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%89%96%E6%9E%90-pipeline-%E4%B8%89%E5%B7%A8%E5%A4%B4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->目录大纲：
0. 前言
1. ChannelPipeline | ChannelHandler | ChannelHandlerContext 三巨头介绍
2. 三巨头编织过程（创建过程）
3. ChannelPipeline 是如何调度 handler 的
4. 总结

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信对 Netty 熟悉的同学对 pipeline 都非常的熟悉，肯定也有不熟悉的，不管怎样，楼主今天的目的就是将 pipeline 从头撸到尾，彻彻底底的理解 pipeline 的每一步操作。</p>
<p>当然，文章还是一如既往的长。请非战斗人员尽快撤离！！！！</p>
<p>让我们开始吧！</p>
<h2 id="1-ChannelPipeline-ChannelHandler-ChannelHandlerContext-三巨头介绍"><a href="#1-ChannelPipeline-ChannelHandler-ChannelHandlerContext-三巨头介绍" class="headerlink" title="1.  ChannelPipeline | ChannelHandler | ChannelHandlerContext 三巨头介绍"></a>1.  ChannelPipeline | ChannelHandler | ChannelHandlerContext 三巨头介绍</h2><p>如果把 Netty 比作一个人类的话，那么 EventLoop 就是这个人的大脑，负责这个人的所有操作。而 pipeline 就是这个的肠道，负责将这个人吃进去的东西进行消化然后处理。这个比喻可能不是很恰当，当然这也是为了加深理解。</p>
<p>当然，我说的 pipelie 是一个广义的概念，pipeline 包括很多东西，就像我们标题说的三巨头，下面我们就来好好说说他们的关系。</p>
<h4 id="1-0三者关系"><a href="#1-0三者关系" class="headerlink" title="1.0三者关系"></a>1.0三者关系</h4><p>我们在之前的文章中知道，每当 ServerSocket 创建一个新的连接，就会创建一个 Socket，对应的就是目标客户端。而每一个新创建的 Socket 都将会分配一个全新的 ChannelPipeline（以下简称 pipeline），他们的关系是永久不变的；而每一个 ChannelPipeline 内部都含有多个 ChannelHandlerContext（以下简称 Context），他们一起组成了双向链表，这些 Context 用于包装我们调用 addLast 方法时添加的 ChannelHandler（以下简称 handler）。</p>
<p>所以说，他们的关系是这样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3c1e4da3ceaf3559.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图中：ChannelSocket 和 ChannelPipeline 是一对一的关联关系，而 pipeline 内部的多个 Context 形成了链表，Context 只是对 Handler 的封装。</p>
<p>为什么需要对 Handler 进行封装呢？想象一下：当你  A handler 要调 B handler 方法的时候，如果没有 Context，那么就直接调用了，如果有一些需要在调用前后通用的逻辑就需要在每个 handler 地方都写，这样会导致代码重复，而且紧耦合，不符合设计原则。</p>
<p>总的来说，当一个请求进来的时候，会进入 Socket 对应的 pipeline，并流经 pipeline 所有的 handler，对，就是设计模式中的过滤器模式，可以说是最佳实践。用过滤器处理网络数据的不止 netty，还有 tomcat，相信大家对 tomcat 的 filter（应该是 servlet 的 filter） 都非常的熟悉吧。</p>
<p>知道了他们的概念，我们继续深入看看他们的设计。</p>
<h4 id="1-1-ChannelPipeline-作用及设计"><a href="#1-1-ChannelPipeline-作用及设计" class="headerlink" title="1.1 ChannelPipeline 作用及设计"></a>1.1 ChannelPipeline 作用及设计</h4><p>首先看 pipeline 的接口设计：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c179e6a51e6d0896.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelPipeline</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ChannelInboundInvoker</span>, <span class="title">ChannelOutboundInvoker</span>, <span class="title">Iterable</span>&lt;<span class="title">Entry</span>&lt;<span class="title">String</span>, <span class="title">ChannelHandler</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(String name, ChannelHandler handler)</span></span>;</span><br><span class="line">  <span class="function">ChannelPipeline <span class="title">addAfter</span><span class="params">(String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line">  <span class="function">ChannelPipeline <span class="title">addBefore</span><span class="params">(String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line">  <span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span></span>;</span><br><span class="line">  <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ChannelHandlerContext <span class="title">context</span><span class="params">(ChannelHandler handler)</span></span>;</span><br><span class="line">  <span class="function">ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span></span>;</span><br><span class="line">  <span class="function">ChannelPipeline <span class="title">replace</span><span class="params">(ChannelHandler oldHandler, String newName, ChannelHandler newHandler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 UML 图，可以看到该接口继承了 inBound，outBound，Iterable 接口，表示他可以调用当数据出站的方法和入站的方法，同时也能遍历内部的链表。</p>
<p>再看看他的几个具有代表性的方法，基本上都是针对 handler 链表的插入，追加，删除，替换操作，甚至，我们可以想象他就是一个 LinkedList。同时，他也能返回 channel（也就是 socket）。</p>
<p>在 pipeline 的接口文档上，作者写了很多注释并且画了一幅图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-180e212b5357414f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>文档大致意思是：</strong></p>
<p> 这是一个 handler 的 list，handler 用于处理或拦截入站事件和出站事件，pipeline 实现了过滤器的高级形式，以便用户完全控制事件如何处理以及 handler 在 pipeline 中如何交互。</p>
<p>上图描述了一个典型的  handler 在 pipeline 中处理 I/O 事件的方式，IO 事件由 inboundHandler 或者 outBoundHandler 处理，并通过调用 ChannelHandlerContext.fireChannelRead 方法转发给其最近的处理程序 。</p>
<p>入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的I / O线程生成入站数据。入站数据通常从如 SocketChannel.read(ByteBuffer) 获取。如果入站事件超出顶层入站处理程序，它将被静默放弃，或者在需要您关注时进行记录。</p>
<p>通常一个 pipeline 有多个 handler，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序，但是您的里程可能会因协议和业务逻辑的复杂性和特征而异：</p>
<ol>
<li> 协议解码器 - 将二进制数据（例如 ByteBuf 在io.netty.buffer中的类)）转换为Java对象。</li>
<li> 协议编码器 - 将Java对象转换为二进制数据。</li>
<li> 业务逻辑处理程序 - 执行实际业务逻辑（例如数据库访问）。</li>
</ol>
<p>注意：你的业务程序不能将线程阻塞，他将会影响 IO 的速度，进而影响整个 Netty 程序的性能。如果你的业务程序很快，就可以放在 IO 线程中，反之，你需要异步执行。或者在添加 handler 的时候添加一个线程池，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面这个任务执行的时候，将不会阻塞 IO 线程，执行的线程来自 group 线程池</span></span><br><span class="line"> pipeline.addLast（group，“handler”，<span class="keyword">new</span> MyBusinessLogicHandler（））;</span><br></pre></td></tr></table></figure>

<p>好，关于 pipeline 的设计就介绍到这里。我们再看看我们常见的 ChannelHandler。</p>
<h4 id="1-2-ChannelHandler-作用及设计"><a href="#1-2-ChannelHandler-作用及设计" class="headerlink" title="1.2 ChannelHandler  作用及设计"></a>1.2 ChannelHandler  作用及设计</h4><p>关于 ChannelHanderl 我们都非常的熟悉吧，在每个最初认识 Netty 的人都知道他的 demo 程序中会添加 handler 并自己实现 handler，通常，我们说 handler 指的就是 ChannelHandler。</p>
<p>ChannelHandler 是一个顶级接口，没有继承任何接口：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-4efe995fcd157b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>定义了 3 个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当把 ChannelHandler 添加到 pipeline 时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">// 当从 pipeline 中移除时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">// 当处理过程中在 pipeline 发生异常时调用</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，ChannelHandler 的作用就是处理 IO 事件或拦截 IO 事件，并将其转发给下一个处理程序 ChannelHandler。</p>
<p>从上面的代码中，可以看到，ChannelHandler 并没有提供很多的方法，因为 Handler 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，Netty 定义了两个子接口继承 ChannelHandler。</p>
<p><strong>1. ChannelInboundHandler 入站事件接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果你经常使用 Netty 程序，你会非常的熟悉这些方法，比如 channelActive 用于当 Channel 处于活动状态时被调用；channelRead —— 当从Channel 读取数据时被调用等等方法。通常我们需要重写一些方法，当发生关注的事件，我们需要在方法中实现我们的业务逻辑，因为当事件发生时，Netty 会回调对应的方法。</p>
<p>注意：当你重写了上面的 channelRead 方法时，你需要显示的释放与池化的 ByteBuf 实例相关的内存。Netty 为此提供了了一个使用方法 ReferenceCountUtil.release().</p>
<p><strong>2. ChannelOutboundHandler 出站事件接口</strong></p>
<p>ChannelOutboundHandler  负责出站操作和处理出站数据。接口方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelOutboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">            SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家可以熟悉熟悉这个接口，比如 bind 方法，当请求将 Channel 绑定到本地地址时调用，close 方法，当请求关闭 Channel 时调用等等，总的来说，出站操作都是一些连接和写出数据类似的方法。和入站操作有很大的不同。</p>
<p>总之，我们要区别入站方法和出站方法，这在 pipeline 中将会起很大的作用。</p>
<p><strong>3. ChannelDuplexHandler 处理出站和入站事件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDuplexHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">                     ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">                        SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.disconnect(promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.deregister(promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.write(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出 ChannelDuplexHandler 间接实现了入站接口并直接实现了出站接口。是一个通用的能够同时处理入站事件和出站事件的类。</p>
<p>介绍了完了  ChannelHandler 的设计，我们再来看看 ChannelHandlerContext 。</p>
<h4 id="1-3-ChannelHandlerContext-作用及设计"><a href="#1-3-ChannelHandlerContext-作用及设计" class="headerlink" title="1.3 ChannelHandlerContext 作用及设计"></a>1.3 ChannelHandlerContext 作用及设计</h4><p>实际上，从上面的代码中，我们已经看到了 Context 的用处，在 ChannelDuplexHandler 中，cxt 无处不在。事实上，以read 方法为例：调用 handler 的 read 方法，如果你不处理，就会调用 context 的 read 方法，context 再调用下一个 context 的 handler 的 read 方法。</p>
<p>我们看看 ChannelHandlerContext 的接口 UML :</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8adb03da878b19de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>ChannelHandlerContext  继承了出站方法调用接口和入站方法调用接口。那么， ChannelInboundInvoker 和 ChannelOutboundInvoker 又有哪些方法呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e3c5145d0a288528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ChannelInboundInvoker 入站方法调用器"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-94cd030d6ee81d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ChannelOutboundInvoker 出站方法调用器"></p>
<p>可以看到，这两个 invoker 就是针对入站或出站方法来的，就是再 入站或出站 handler 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的。</p>
<p>而 ChannelHandlerContext 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandlerContext</span> <span class="keyword">extends</span> <span class="title">AttributeMap</span>, <span class="title">ChannelInboundInvoker</span>, <span class="title">ChannelOutboundInvoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">EventExecutor <span class="title">executor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">handler</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRemoved</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">pipeline</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ByteBufAllocator <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法能够获取 Context 上下文环境中对应的比如 channel，executor，handler ，pipeline，内存分配器，关联的 handler 是否被删除。</p>
<p>我们可以认为，Context 就是包装了 handler 相关的一切，以方便 Context 可以在 pipeline 方便的操作 handler 相关的资源和行为。</p>
<h2 id="2-三巨头编织过程（创建过程）"><a href="#2-三巨头编织过程（创建过程）" class="headerlink" title="2. 三巨头编织过程（创建过程）"></a>2. 三巨头编织过程（创建过程）</h2><p>介绍完了 “三巨头” 的接口设计和一些方法，那么我们就看看，他们是如何编制在一起的。</p>
<p>在文章前面，我们说：</p>
<blockquote>
<p> 每当 ServerSocket 创建一个新的连接，就会创建一个 Socket，对应的就是目标客户端。而每一个新创建的 Socket 都将会分配一个全新的 ChannelPipeline（以下简称 pipeline），他们的关系是永久不变的；而每一个 ChannelPipeline 内部都含有多个 ChannelHandlerContext（以下简称 Context），他们一起组成了双向链表，这些 Context 用于包装我们调用 addLast 方法时添加的 ChannelHandler（以下简称 handler）。</p>
</blockquote>
<p>我们可以分为3个步骤来看编织的过程：</p>
<ol>
<li>任何一个 ChannelSocket 创建的同时都会创建 一个 pipeline。</li>
<li>当用户或系统内部调用 pipeline 的 add*** 方法添加 handler 时，都会创建一个包装这 handler 的 Context。</li>
<li>这些 Context 在 pipeline 中组成了双向链表。</li>
</ol>
<p>让我们从代码层面看看他们的编织过程。</p>
<p><strong>1. Socket 创建的时候创建 pipeline：</strong><br>在 SocketChannel 的抽象父类 AbstractChannel 的构造方法中：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-5ffe2d2322b8bdb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从 newChannelPipeline 方法中获取一个 pipeline，这个方法的标准实现如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-fca694d4f6501b7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>创建一个 DefaultChannelPipeline 对象，并传入 channel 对象。这个 DefaultChannelPipeline 是 ChannelPipeline 接口的标准实现。</p>
<p>我们看看他的创建过程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-58a46fc579e66ad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol>
<li>将 channel 赋值给 channel 字段，用于 pipeline 操作 channel。</li>
<li>创建一个 future 和 promise，用于异步回调使用。</li>
<li>创建一个 inbound  的 tailContext，创建一个既是 inbound 类型又是 outbound 类型的 headContext.</li>
<li>最后，将两个 Context 互相连接，形成双向链表。</li>
</ol>
<p>注意: tailContext 和 HeadContext 非常的重要，所有 pipeline 中的事件都会流经他们，所以我们重点关注 tailContext 和 headContext。</p>
<p>首先看看 TailContext 的设计：一个属于 DefaultChannelPipeline 的内部类。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-16f165c9fe98a42a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>UML 继承图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-840ba6dd1ea987c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UML"></p>
<p>从上图中可以看出， TailContext 是一个处理入站事件的 handler。</p>
<p>构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAIL_NAME = generateName0(TailContext.class);</span><br><span class="line"></span><br><span class="line">  TailContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, TAIL_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        setAddComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,</span><br><span class="line">                              <span class="keyword">boolean</span> inbound, <span class="keyword">boolean</span> outbound) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.inbound = inbound;</span><br><span class="line">    <span class="keyword">this</span>.outbound = outbound;</span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的构造方法中可以看出来，Context 果然就是 Context ，囊括了 Channel 所包含的一切，这里说一下 name 是 简单类名+#0 的形式。pipeline 就是当前的 pipeline，executor 是 null，inbound 属性是 true，outbound 属性是 fasle。说明他是一个入站处理器。当有入站事件时，会调用 tailContext。</p>
<p>说完 TailContext ，再看看 HeadContext。</p>
<p>HeadContext 同样时 DefaultChannelPipeline 的内部类，UML 继承图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-232e3b5ef1b90f87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从上图中，可以看出来 HeadContext 非常的全能，既是入站处理器也是出站处理器，任何事件都逃不过他的眼睛。</p>
<p>他的构造方法和 tail 有些许的不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">    <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    unsafe = pipeline.channel().unsafe();</span><br><span class="line">    setAddComplete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,</span><br><span class="line">                              <span class="keyword">boolean</span> inbound, <span class="keyword">boolean</span> outbound) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.inbound = inbound;</span><br><span class="line">    <span class="keyword">this</span>.outbound = outbound;</span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从构造方法上看，唯一的区别就是比 tailContext 多了一个属性 unsafe，而这个属性来自于 pipeline 所属的 channel 的 unsafe，如果大家有印象的话，会记得 channel 初始化的时候，也会初始化一个 unsafe，这个我们今天先不细说，只需要知道他是一个 Netty 中一个直接处理的类，每个类型的 Socket 都有不同的实现。而为什么 head 需要这样一个属性呢？因为 head 需要处理出站数据，还记得出站接口时怎么定义的吗？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-2d69485554e4ea54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="出站处理器定义的方法"></p>
<p>出站接口中都是针对数据的操作，比如 read，write，flush 等操作，所以需要 unsafe 这个能够处理数据的工具实例。</p>
<p>为什么 tail 不需要呢？我想你应该知道了，tail 虽然是入站 handler，入站 handler 定义的方法没有需要直接处理数据的，比如 read，write，flush等：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4a4d17c32d934c57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="入站处理器定义的方法"></p>
<p>理解这两个处理器的定义很重要，因为每种类型的处理器定义的的任务都是不同的。</p>
<p><strong>2. 在 add</strong>** 添加处理器的时候创建 Context**</p>
<p>我们看看 DefaultChannelPipeline 的 addLast 方法如何创建的 Context，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addLast(executor, <span class="keyword">null</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，addLast 是个重载方法，你可以选择传入一个线程池，作用是什么呢？当你的业务 handler 非常耗时，甚至阻塞线程，那么 Netty 建议你异步执行该任务，否则将会影响 Netty 的性能。而这个线程池就是用来执行这个 handler 的耗时任务的。</p>
<p>什么时候会返回这个线程池呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1781d82635ae101d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>当你调用类似 ChannelActive 方法的时候，会需要 Cotext 的 executor，方法如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ff849ec873cc383f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如果你没有定义 handler 自己的 executor，那么就使用 channel 的 线程，也就是 IO 线程。你需要十分确定你的业务不会阻塞线程。</p>
<p>再看看 addLast 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    callHandlerAdded0(newCtx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>向 pipeline 添加 handler，参数是线程池，name 是null， handler 是我们或者系统传入的handler。Netty 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：</p>
<ol>
<li>检查这个 handler 实例是否是共享（Sharable 注解）的，如果不是，并且已经被别的 pipeline 使用了，则抛出异常。</li>
<li>调用 newContext(group, filterName(name, handler), handler) 方法，创建一个 Context。从这里可以看出来了，每次添加一个 handler 都会创建一个关联 Context。</li>
<li>调用 addLast 方法，将 Context 追加到链表中。</li>
<li>如果这个通道还没有注册到 selecor 上，就将这个 Context 添加到这个 pipeline 的待办任务中。当注册好了以后，就会调用 callHandlerAdded0 方法（默认是什么都不做，用户可以实现这个方法）。</li>
</ol>
<p>我们重点看看第 2 步和第 3 步：<br>newContext 方法代码如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-16920e97964168f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建默认的 DefaultChannelHandlerContext 实例"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1ed0ae84617fd8a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构造方法"></p>
<p>这里的 super 构造方法和 head  tail 一样，没什么不同，有 2 个方法需要注意一下 isInbound 和 isOutbound 方法。这两个方法是辨别这个 handler 是 inbound 还是 outbound 。如果是你，你怎么写？我们还是看看 Netty 是怎么写的吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInbound</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> ChannelInboundHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOutbound</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> ChannelOutboundHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，通过 instanceof 关键字判断。哈哈。</p>
<p>再看看第 3 步，如何将这个新创建的 Context 插入到链表中：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6f9bc53d9ccb4253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入链表"></p>
<p>也很简单，一个标准的双向链表实现。将新的 Context 的 prev 指向 tail 之前的 prev，将新的 Context 的 next 指向 tail，将 tail 之前的 prev 的 next 指向新的 Context， 将 tail 现在的 prev 指向新的 Context。成功插入到 tail 的前面，所以，这里的 addLast 不是真正的 last，而是除了 tail 的 last，因为 tail 是系统的节点，需要做一些系统工作。</p>
<p>好了，到这里，针对三巨头的创建过程，我们就了解的差不多了，就和我们最初说的一样，每当创建 ChannelSocket 的时候都会创建一个绑定的 pipeline，一对一的关系，同时也创建一个 pipeline，创建 pipeline 的时候也会创建 tail 节点和 head 节点，形成最初的链表。tail 是入站 inbound 类型的 handler，  head 既是 inbound 也是 outbound 类型的 handler。在调用 pipeline 的 addLast 方法的时候，会根据给定的 handler 创建一个 Context，然后，将这个 Context 插入到链表的尾端（tail 前面）。这样，整个三巨头就连接起来了，就能为后面的请求进行流式处理了。</p>
<h2 id="3-ChannelPipeline-是如何调度-handler-的"><a href="#3-ChannelPipeline-是如何调度-handler-的" class="headerlink" title="3. ChannelPipeline 是如何调度 handler 的"></a>3. ChannelPipeline 是如何调度 handler 的</h2><p>说了这么多，那么当一个请求进来的时候，ChannelPipeline 是如何调用内部的这些 handler 的呢？我们一起来看看。</p>
<p>首先，当一个请求进来的时候，会第一个调用 pipeline 的 相关方法，如果是入站事件，这些方法由 fire 开头，表示开始管道的流动。让后面的 handler 继续处理。</p>
<p>我们看看 DefaultChannelPipeline 是如何实现这些 fire 方法的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-fb950aae1682ce47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从上图中可以看出来，这些方法都是 inbound 的方法，也就是入站事件，调用静态方法传入的也是 inbound 的类型 head handler。这些静态方法则会调用 head 的  ChannelInboundInvoker 接口的方法，再然后调用 handler 的真正方法。</p>
<p>再看看 piepline 的 outbound 的 fire 方法实现：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ca0c316eeb94acc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>和 inbound 类似，这些都是出站的实现，但是调用的是 outbound 类型的 tail handler 来进行处理，因为这些都是 outbound 事件。</p>
<p>为什么出站是 tail 开始，入站从 head 开始呢？因为出站是从内部外面写，从tail 开始，能够让前面的 handler 进行处理，防止由 handler 被遗漏，比如编码。反之，入站当然是从 head 往内部输入，让后面的 handler 能够处理这些输入的数据。比如解码。</p>
<p>这也解释了虽然 head 也实现了 outbound 接口，但不是从 head 开始执行出站任务。</p>
<p>关于如何调度，请让我用一张图来表示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e441911aa953368a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>pipeline 首先会调用 Context 的静态方法 fireXXX，并传入 Context，然后，静态方法调用 Context 的 invoker  方法，而 invoker 方法内部会调用该 Context 所包含的 Handler 的真正的 XXX 方法，调用结束后，如果还需要继续向后传递，就调用 Context 的 fireXXX2 方法，循环往复。</p>
<p>我们将在下一篇文章中详细的解析一个请求在 pipeline 中的流动过程。这幅图仅作抛砖引玉。</p>
<p>好，到这里，关于这三巨头的介绍就差不多了，下面，外面来做一下总结。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>这是我们 Netty 系列关于 pipeline 的第一篇文章，讲述了关于 pipeline ，Context，Handler 错综复杂的关系，实际上，还是很清晰的。Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表，入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开始。而节点中间的传递通过  AbstractChannelHandlerContext 类内部的 fire 系列方法，找到当前节点的下一个节点不断的循环传播。是一个完美的过滤器高级形式。</p>
<p>下一篇，将和大家一起在 pipeline 的管道中游走一趟。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之线程池的使用及扩展和优化</title>
    <url>/2018/01/04/2018/2018-01-04-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%89%A9%E5%B1%95%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       多线程的软件设计方法确实可以最大限度的发挥现代多核处理器的计算能力，提高生产系统的吞吐量和性能。但是，如果一个系统同时创建大量线程，线程间频繁的切换上下文导致的系统开销将会拖慢整个系统。严重的甚至导致内存耗尽导致OOM异常。因此，在实际的生产环境中，线程的数量必须得到控制，盲目的创建大量新车对系统是有伤害的。

<p>那么，怎么才能最大限度的利用CPU的性能，又能保持系统的稳定性呢？其中有一个方法就是使用线程池。</p>
<p>简而言之，在使用线程池后，创建线程便处理从线程池获得空闲线程，关闭线程变成了向池子归还线程。也就是说，提高了线程的复用。</p>
<p>而 JDK 在 1.5 之后为我提供了现成的线程池工具，我们今天就来学习看看如何使用他们。</p>
<ol>
<li>Executors 线程池工厂能创建哪些线程池</li>
<li>如何手动创建线程池</li>
<li>如何扩展线程池</li>
<li>如何优化线程池的异常信息</li>
<li>如何设计线程池中的线程数量</li>
</ol>
<h2 id="1-Executors-线程池工厂能创建哪些线程池"><a href="#1-Executors-线程池工厂能创建哪些线程池" class="headerlink" title="1. Executors 线程池工厂能创建哪些线程池"></a><strong>1. Executors 线程池工厂能创建哪些线程池</strong></h2><p>先来一个最简单的线程池使用例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out</span><br><span class="line">        .println(System.currentTimeMillis() + <span class="string">&quot;: Thread ID :&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  MyTask myTask = <span class="keyword">new</span> MyTask();</span><br><span class="line">  ExecutorService service1 = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    service1.submit(myTask);</span><br><span class="line">  &#125;</span><br><span class="line">  service1.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-78568c1e3a3862a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>我们创建了一个线程池实例，并设置默认线程数量为5，并向线程池提交了10任务，分别打印当前毫秒时间和线程ID，从结果中，我们可以看到结果中有5个相同 id 的线程打印了毫秒时间。</p>
<p>这是最简单的例子。</p>
<p>接下来我们讲讲其他的线程创建方式。</p>
<p><strong>1. 固定线程池</strong><br> ExecutorService service1 = Executors.newFixedThreadPool(5);<br>该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行，若没有，则新的任务会被暂存在一个任务队列（默认无界队列 int 最大数）中，待有线程空闲时，便处理在任务队列中的任务。</p>
<p><strong>2. 单例线程池</strong><br>ExecutorService service3 = Executors.newSingleThreadExecutor();<br> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列（默认无界队列 int 最大数）中，待线程空闲，按先入先出的顺序执行队列中的任务。</p>
<p><strong>3. 缓存线程池</strong><br>ExecutorService service2 = Executors.newCachedThreadPool();<br> 该方法返回一个可根据实际情况调整线程数量的线程池，线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程，所有线程均在工作，如果有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p>
<p><strong>4. 任务调用线程池</strong><br>ExecutorService service4 = Executors.newScheduledThreadPool(2);<br>该方法也返回一个 ScheduledThreadPoolExecutor 对象，该线程池可以指定线程数量。</p>
<p>前3个线程的用法没什么差异，关键是第四个，虽然线程任务调度框架很多，但是我们仍然可以学习该线程池。如何使用呢？下面来个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ScheduledThreadPoolExecutor service4 = (ScheduledThreadPoolExecutor) Executors</span><br><span class="line">        .newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前面的任务没有完成，则调度也不会启动</span></span><br><span class="line">    service4.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 如果任务执行时间大于间隔时间，那么就以执行时间为准（防止任务出现堆叠）。</span></span><br><span class="line">          Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">          System.out.println(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="comment">// initialDelay（初始延迟） 表示第一次延时时间 ; period 表示间隔时间</span></span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    service4.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">          System.out.println(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="comment">// initialDelay（初始延迟） 表示延时时间；delay + 任务执行时间 = 等于间隔时间 period</span></span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在给定时间，对任务进行一次调度</span></span><br><span class="line">    service4.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5 秒之后执行 schedule&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码创建了一个 ScheduledThreadPoolExecutor 任务调度线程池，分别调用了3个方法，需要着重解释 scheduleAtFixedRate 和 scheduleWithFixedDelay 方法，这两个方法的作用很相似，唯一的区别就是他们执行人物的间隔时间的计算方式，前者时间间隔算法是根据指定的 period 时间和任务执行时间中取时间长的，后者取的是指定的 delay 时间 + 任务执行时间。如果同学们有兴趣，可以将上面的代码跑跑看。一样便能看出端倪。</p>
<p>好了，JDK 给我们封装了创建线程池的 4 个方法，但是，请注意，由于这些方法高度封装，因此，如果使用不当，出了问题将无从排查，因此，我建议，程序员应到自己手动创建线程池，而手动创建的前提就是高度了解线程池的参数设置。那么我们就来看看如何手动创建线程池。</p>
<h2 id="2-如何手动创建线程池"><a href="#2-如何手动创建线程池" class="headerlink" title="2. 如何手动创建线程池"></a><strong>2. 如何手动创建线程池</strong></h2><p>下面是一个手动创建线程池的范本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认5条线程（默认数量，即最少数量），</span></span><br><span class="line"><span class="comment"> * 最大20线程（指定了线程池中的最大线程数量），</span></span><br><span class="line"><span class="comment"> * 空闲时间0秒（当线程池梳理超过核心数量时，多余的空闲时间的存活时间，即超过核心线程数量的空闲线程，在多长时间内，会被销毁），</span></span><br><span class="line"><span class="comment"> * 等待队列长度1024，</span></span><br><span class="line"><span class="comment"> * 线程名称[MXR-Task-%d],方便回溯，</span></span><br><span class="line"><span class="comment"> * 拒绝策略：当任务队列已满，抛出RejectedExecutionException</span></span><br><span class="line"><span class="comment"> * 异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">20</span>, <span class="number">0L</span>,</span><br><span class="line">    TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1024</span>)</span><br><span class="line">    , <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;My-Task-%d&quot;</span>).build()</span><br><span class="line">    , <span class="keyword">new</span> AbortPolicy()</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看到，<strong>ThreadPoolExecutor</strong> 也就是线程池有 7 个参数，我们一起来好好看看：</p>
<ol>
<li><strong>corePoolSize</strong> 线程池中核心线程数量</li>
<li><strong>maximumPoolSize</strong> 最大线程数量</li>
<li><strong>keepAliveTime</strong>  空闲时间（当线程池梳理超过核心数量时，多余的空闲时间的存活时间，即超过核心线程数量的空闲线程，在多长时间内，会被销毁）</li>
<li><strong>unit</strong> 时间单位</li>
<li><strong>workQueue</strong> 当核心线程工作已满，需要存储任务的队列</li>
<li><strong>threadFactory</strong> 创建线程的工厂</li>
<li><strong>handler</strong> 当队列满了之后的拒绝策略</li>
</ol>
<p>前面几个参数我们就不讲了，很简单，主要是后面几个参数，队列，线程工厂，拒绝策略。</p>
<p>我们先看看队列，线程池默认提供了 4 个队列。</p>
<ol>
<li>无界队列： 默认大小 int 最大值，因此可能会耗尽系统内存，引起OOM，非常危险。</li>
<li>直接提交的队列 ：  没有容量，不会保存，直接创建新的线程，因此需要设置很大的线程池数。否则容易执行拒绝策略，也很危险。</li>
<li>有界队列：如果core满了，则存储在队列中，如果core满了且队列满了，则创建线程，直到maximumPoolSize 到了，如果队列满了且最大线程数已经到了，则执行拒绝策略。</li>
<li>优先级队列：按照优先级执行任务。也可以设置大小。</li>
</ol>
<p>楼主在自己的项目中使用了无界队列，但是设置了任务大小，1024。如果你的任务很多，建议分为多个线程池。不要把鸡蛋放在一个篮子里。</p>
<p>再看看拒绝策略，什么是拒绝策略呢？当队列满了，如何处理那些仍然提交的任务。JDK 默认有4种策略。</p>
<ol>
<li>AbortPolicy ：直接抛出异常，阻止系统正常工作.</li>
<li>CallerRunsPolicy : 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li>
<li>DiscardOldestPolicy: 该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务.</li>
<li>DiscardPolicy: 该策略默默地丢弃无法处理的任务，不予任何处理，如果允许任务丢失，我觉得这是最好的方案.</li>
</ol>
<p>当然，如果你不满意JDK提供的拒绝策略，可以自己实现，只需要实现 RejectedExecutionHandler 接口，并重写 rejectedExecution 方法即可。</p>
<p>最后，线程工厂，线程池的所有线程都由线程工厂来创建，而默认的线程工厂太过单一，我们看看默认的线程工厂是如何创建线程的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default thread factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，线程名称为 pool- + 线程池编号 + -thread- + 线程编号 。设置为非守护线程。优先级为默认。</p>
<p>如果我们想修改名称呢？对，实现 ThreadFactory 接口，重写 newThread 方法即可。但是已经有人造好轮子了， 比如我们的例子中使用的 google 的 guaua 提供的 ThreadFactoryBuilder 工厂。可以自定义线程名称，是否守护，优先级，异常处理等等，功能强大。</p>
<h2 id="3-如何扩展线程池"><a href="#3-如何扩展线程池" class="headerlink" title="3. 如何扩展线程池"></a><strong>3. 如何扩展线程池</strong></h2><p>那么我们能扩展线程池的功能吗？比如记录线程任务的执行时间。实际上，JDK 的线程池已经为我们预留的接口，在线程池核心方法中，有2 个方法是空的，就是给我们预留的。还有一个线程池退出时会调用的方法。我们看看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何扩展线程池，重写 beforeExecute, afterExecute, terminated 方法，这三个方法默认是空的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以监控每个线程任务执行的开始和结束时间，或者自定义一些增强。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在 Worker 的 runWork 方法中，会调用这些方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out</span><br><span class="line">          .println(<span class="string">&quot;正在执行：Thread ID:&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;, Task Name = &quot;</span> + name);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;()) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备执行：&quot;</span> + ((MyTask) r).name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完成： &quot;</span> + ((MyTask) r).name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池退出&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      MyTask myTask = <span class="keyword">new</span> MyTask(<span class="string">&quot;TASK-GEYM-&quot;</span> + i);</span><br><span class="line">      es.execute(myTask);</span><br><span class="line">      Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    es.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们重写了 beforeExecute 方法，也就是执行任务之前会调用该方法，而 afterExecute 方法则是在任务执行完毕后会调用该方法。还有一个 terminated 方法，在线程池退出时会调用该方法。执行结果是什么呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-754d506dbff55db4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，每个任务执行前后都会调用 before 和 after 方法。相当于执行了一个切面。而在调用 shutdown 方法后则会调用 terminated 方法。</p>
<h2 id="4-如何优化线程池的异常信息"><a href="#4-如何优化线程池的异常信息" class="headerlink" title="4. 如何优化线程池的异常信息"></a><strong>4. 如何优化线程池的异常信息</strong></h2><p>如何优化线程池的异常信息？ 在说这个问题之前，我们先说一个不容易发现的bug：</p>
<p>看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">0L</span>,</span><br><span class="line">      TimeUnit.MILLISECONDS, <span class="keyword">new</span> SynchronousQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    executor.submit(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DivTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DivTask</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> re = a / b;</span><br><span class="line">    System.out.println(re);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-a3b52ab932d7be31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意：只有4个结果，其中一个结果被吞没了，并且没有任何信息。为什么呢？如果仔细看代码，会发现，在进行 100 / 0 的时候肯定会报错的，但是却没有报错信息，令人头痛，为什么呢？实际上，如果你使用 execute 方法则会打印错误信息，当你使用 submit 方法却没有调用它的get 方法，异常将会被吞没，因为，如果发生了异常，异常是作为返回值返回的。</p>
<p>怎么办呢？我们当然可以使用 execute 方法，但是我们可以有另一种方式：重写 submit 方法，楼主写了一个例子，大家看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">        TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line"><span class="comment">//      super.execute(command);</span></span><br><span class="line">      <span class="keyword">super</span>.execute(wrap(command, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line"><span class="comment">//      return super.submit(task);</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Client stack trace&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task, <span class="keyword">final</span> Exception clientStack,</span></span></span><br><span class="line"><span class="params"><span class="function">        String clientThreaName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            task.run();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            clientStack.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们重写了 submit 方法，封装了异常信息，如果发生了异常，将会打印堆栈信息。我们看看使用重写后的线程池后的结果是什么？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-793e4be77a2ed977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从结果中，我们清楚的看到了错误信息的原因：by zero！并且堆栈信息明确，方便排错。优化了默认线程池的策略。</p>
<h2 id="5-如何设计线程池中的线程数量"><a href="#5-如何设计线程池中的线程数量" class="headerlink" title="5. 如何设计线程池中的线程数量"></a><strong>5. 如何设计线程池中的线程数量</strong></h2><p>线程池的大小对系统的性能有一定的影响，过大或者过小的线程数量都无法发挥最优的系统性能，但是线程池大小的确定也不需要做的非常精确。因为只要避免极大和极小两种情况，线程池的大小对性能的影响都不会影响太大，一般来说，确定线程池的大小需要考虑CPU数量，内存大小等因素，在《Java Concurrency in Practice》 书中给出了一个估算线程池大小的经验公式：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-557329a5eea427f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>公式还是有点复杂的，简单来说，就是如果你是CPU密集型运算，那么线程数量和CPU核心数相同就好，避免了大量无用的切换线程上下文，如果你是IO密集型的话，需要大量等待，那么线程数可以设置的多一些，比如CPU核心乘以2. </p>
<p>至于如何获取 CPU 核心数，Java 提供了一个方法：</p>
<p>Runtime.getRuntime().availableProcessors()；</p>
<p>返回了CPU的核心数量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这里，我们已经对如何使用线程池有了一个认识，这里，楼主建议大家手动创建线程池，这样对线程池中的各个参数可以有精准的了解，在对系统进行排错或者调优的时候有好处。比如设置核心线程数多少合适，最大线程数，拒绝策略，线程工厂，队列的大小和类型等等，也可以是G家的线程工厂自定义线程。</p>
<p>下一篇，我们将深入源码，看看JDK 的线程池是如何实现的。因此，先熟悉线程池的使用吧！！！</p>
<p>good  luck！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-核心组件-Pipeline-源码分析（二）一个请求的-Pipeline-之旅</title>
    <url>/2018/03/15/2018/2018-03-15-Netty-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-Pipeline-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84-pipeline-%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录大纲：
1. 前言
2. 针对 Netty 例子源码做了哪些修改？
3. 看 pipeline 是如何将数据送到自定义 handler 的
4. 看 pipeline 是如何将数据从自定义 handler 送出的
5. 总结


<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://www.jianshu.com/p/18e53b6b224f">Netty 核心组件 Pipeline 源码分析（一）之剖析 pipeline 三巨头</a> 中，我们详细阐述了 pipeline，context，handler 的设计与实现。知道了 Netty 是如何处理网络数据的，但到目前为止，我们都没有实打实的走一遍流程，实际上，debug 一遍流程，会让我们对 Netty 处理整个数据流更加深刻理解。</p>
<p>楼主此次使用的依然还是 Netty 自带的 ServerExample 和 Client Example，我想大家应该早就下好源码了吧。当然，针对源码，我们也做了一些修改，方便让我们更加的容易测试。</p>
<h2 id="1-针对-Netty-例子源码做了哪些修改？"><a href="#1-针对-Netty-例子源码做了哪些修改？" class="headerlink" title="1. 针对 Netty 例子源码做了哪些修改？"></a>1. 针对 Netty 例子源码做了哪些修改？</h2><p>针对 EchoInServerHandler 的channelRead 方法做了如下修改：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-fdc1b8d5389d5733.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>读取客户端发送来的数据，并打印，然后发送一串字符串给客户端。当然，其余方法都加入了日志打印。</p>
<p>针对 EchoClientHandler  的 channelActive 方法做了如下修改：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-29742911b277d575.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>当连接服务器成功时，发送一串字符串。</p>
<p>针对 EchoClientHandler 的 channelRead 方法做了如下修改：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-1e6ca8bca7225eca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解码客户端发送来的数据并打印。</p>
<p>同时新增了一个 EchoOutServerHandler 类，继承了 ChannelOutboundHandlerAdapter 类，用于打印出站事件：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-b75b1bbe7b32a870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>运行后的结果如下：</p>
<p>Server 控制台：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-00bf8f5a7be44ab4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Client 控制台：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-d33d691218b7daa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从上面红色字可以看出，打印出了我们想要的结果，Server 接收到了 Client 的信息并打印，Client 接收到了 Server 的信息并打印。</p>
<p>下面就让我们 debug，看看一个请求是如何在 pipeline 中游走的吧！</p>
<h2 id="2-看-pipeline-是如何将数据送到自定义-handler-的"><a href="#2-看-pipeline-是如何将数据送到自定义-handler-的" class="headerlink" title="2. 看 pipeline 是如何将数据送到自定义 handler 的"></a>2. 看 pipeline 是如何将数据送到自定义 handler 的</h2><p>首先我们 debug 模式启动 EchoServer，让整个 Server 处于待命状态。断点打在 EventLoop 类的 processSelectedKey 方法中，监听 accpet 事件和 read 事件。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-99ed3ae33b56b29a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>同时启动客户端，这个时候 Server 断点开始卡住，我们开始 debug。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-12b446587ef0d477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里的 readOps 是16，Accept 事件，这里的 unsafe 是 ServerSocket 的 unsafe，如果还记的 <a href="https://www.jianshu.com/p/c83de9575825">Netty 接受请求过程源码分析 (基于4.1.23)</a> 文中所说，在这之后，会创建一个 客户端的 ChannelSocket，然后该 Socket 会向 selector 注册读事件，所以，我们这里需要放开断点，得到读事件才是真正请求的开始。</p>
<p>好，我们使用 IDEA 的 Force run to cursor 功能，让线程直接卡到这里，这时，你会发现，EventLoop-3-1 卡住了，而不是之前的 EventLoop-2-1，3-1 是上面线程大家应该知道吧，就是 worker group 线程池中的 eventLoop，也就是刚刚注册的 Socket。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-756d646f6b69e535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从上面的断点可以看出，这里确实是读事件，断点提示也指出这个 unsafe 是 NioSocketChannel 的 内部类 NioSocketChannelUnsafe，我们跟进去看看。</p>
<p>进入的是 NioSocketChannelUnsafe 的抽象父类 AbstractNioByteChannel 的 read 方法。精简过的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据到容器</span></span><br><span class="line">    byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">    allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">    <span class="comment">// 让 handler 处理容器中的数据</span></span><br><span class="line">    pipeline.fireChannelRead(byteBuf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉容器处理完毕了，触发完成事件</span></span><br><span class="line">    pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里楼主简化了很多代码，留下的是对本次分析比较重要的内容。注释已经写的很清除，首先从 unsafe 中读取数据，然后，将读好的数据交给 pipeline，pipeline 调用 inbound 的 channelRead 方法，读取成功后，调用 inbound 的 handler 的 ChannelReadComplete 方法。</p>
<p>在进入方法之前，楼主向祭出上文中的图，让我们看后面的代码更清晰：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6955360ea06b490e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该图诠释了一个请求在 pipeline 的流动过程。请记住他。</p>
<p>整个过程还是比较清晰的。我们首先进入 pipeline 的 fireChannelReadComplete 方法，这个方法是实现了 invoker 的方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f84b26476da61a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>内部调用的是 AbstractChannelHandlerContext.invokeChannelRead(head, msg) 静态方法，并传入了 head，我们知道入站数据都是从 head 开始的，以保证后面所有的 handler 都由机会处理数据流。</p>
<p>我们看看这个静态方法内部是怎么样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用这个 Context （也就是 head） 的 invokeChannelRead 方法，并传入数据。我们再看看 invokeChannelRead 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里和我们的图画的是一致的，调用了 Context 包装的 handler 的 channelRead 方法。注意：直到目前，这个  Context 还是 head，也就是调用 head 的 channelRead 方法。那么这个方法是怎么实现的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么都没做，和我们图中一样，调用 Context 的 fire 系列方法，将请求转发给下一个节点。我们这里是 fireChannelRead 方法，注意，这里方法名字都挺像的。需要细心区分。下面我们看看 Context 的成员方法 fireChannelRead：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是 head 的抽象父类 AbstractChannelHandlerContext 的实现，该方法再次调用了静态 fire 系列方法，但和上次不同的是，不再放入 head 参数了，而是使用 findContextInbound 方法的返回值。从这个方法的名字可以看出，是找到入站类型的 handler。我们看看方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!ctx.inbound);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法很简单，找到当前 Context 的 next 节点（inbound 类型的）并返回。这样就能将请求传递给后面的 inbound handler 了。</p>
<p>重复上面的逻辑，终于数据到了我们自己写的 handler——-EchoInServerHandler。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-eede9c0daf8ed698.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>好，到这里，我们已经知道了一个请求时怎么到达我们自定义的 handler 的，再来看看我们的图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-30b277ac753eab11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>请求进来时，pipeline 会从 head 节点开始输送，通过配合 invoker 接口的 fire 系列方法，实现 Context 链在 pipeline 中的完美传递。最终到达我们自定义的 handler。 </p>
<p>到了自定义 handler，我们会输出客户端发送的内容，我们截图看看：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-5b08aaba119302cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>成功输出。</p>
<p>注意：此时如果我们想继续向后传递该怎么办呢？我们前面说过，可以调用 Context 的 fire 系列方法，就像 head 的 channelRead 方法一样，调用 fire 系列方法，直接向后传递就 ok 了。</p>
<p>当然，我们这里不需要，我们需要发送一条数据客户端。那么，我们就来看看一条数据是如何到达客户端的。</p>
<h2 id="3-看-pipeline-是如何将数据从自定义-handler-送出的"><a href="#3-看-pipeline-是如何将数据从自定义-handler-送出的" class="headerlink" title="3. 看 pipeline 是如何将数据从自定义  handler 送出的"></a>3. 看 pipeline 是如何将数据从自定义  handler 送出的</h2><p>在打印了客户端的内容后，我们调用了 Context 的 writeAndFlush 方法，从 inbound 和 outbound 的定义来看，这个方法是 outbound 定义的，也就是出站方法。</p>
<p>在debug 进去看看之前，我们能否猜测一下呢，这个 Context 肯定会调用他的抽象父类  AbstractChannelHandlerContext 方法， 我们跟进去看看：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-5afd30f50fc5c7d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>果不其然。调用了 AbstractChannelHandlerContext  的 writeAndFlush 方法，然后，调用了他的重载方法，多传入了一个 promise 实例。看看是如何创建的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ChannelPromise <span class="title">newPromise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel(), executor());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们再跟进去看看 writeAndFlush ：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-85e7a0488be896be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里调用了 write 方法，并直接返回了 promise。继续跟进查看：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-716b4681c5144259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意：这里调用了 findContextOutbound，寻找下一个 outbound 节点。我们看看是如何实现的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9249357897f47f61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>根据当前节点，找到之前的节点并且是 outbound 类型。</p>
<p>可以看到，数据开始出站，从后向前开始流动，和入站的方向是反的。</p>
<p>回到 write 方法，得到下一个节点后，调用下一个节点的 invokeWriteAndFlush 方法，这个是 invoker 接口的方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8bd120ca2114c6ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>调用 invokeWrite0 方法，注意，Netty 很多方法都以 0 结尾，表示这是最底层的方法了，而再 JDK 中，结尾是 0 表示这是一个本地方法。我们进入该方法查看：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9296cc974cfb2626.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>调用了这个 Context 的 worite 方法。还记得我们也写了一个 EchoOutServerHandler 类吗，可能会进入我们自己写入的类的方法吗？当然不会，因为我们添加的顺序是下面这样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c592f9ffa68759c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>inbound 在前，outbound 在后，当程序走到 inbound 就调用 outbound 的方法了，并找当前节点的上一个节点，而我们写的 outbound 是这个节点的下一个节点，永远不会走到这里的。</p>
<p>那么会走到哪里呢，当然是走到 head 节点，因为 head 节点就是 outbound 类型的 handler。</p>
<p>进入到 head 的 write 方法查看：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f46eaec28fb8a213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>调用了 底层的 unsafe 操作数据，到这里，我们就不跟了，基于我们今天的目的，我们只想知道一个请求在 pipeline 是如何流转的。底层数据传播的细节就不再赘述。留在以后研究。</p>
<p>当执行完这个 write 方法后，方法开始退栈。逐步退到 unsafe 的 read 方法，回到最初开始的地方，然后继续调用  pipeline.fireChannelReadComplete() 方法，重复之前 pipeline 的设计。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-931b09e2ca0d0a0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>到这里，我们应该已经清楚了一个请求时如何在 pipeline 中周转的了。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>总结一下一个请求在 pipeline 中的流转过程：</p>
<ol>
<li>调用 pipeline 的 fire 系列方法，这些方法是接口 invoker 设计的，pipeline 实现了 invoker 的所有方法，inbound 事件从 head 开始流入，outbound 事件从 tail 开始流出。</li>
<li>pipeline 会将请求交给 Context，然后 Context 通过抽象父类 AbstractChannelHandlerContext 的 invoke 系列方法（静态和非静态的）配合 AbstractChannelHandlerContext 的 fire 系列方法再配合 findContextInbound 和 findContextOutbound 方法完成各个 Context 的数据流转。</li>
<li>当入站过程中，调用 了出站的方法，那么请求就不会向后走了。后面的处理器将不会有任何作用。想继续相会传递就调用 Context 的 fire 系列方法，让 Netty 在内部帮你传递数据到下一个节点。如果你想在整个通道传递，就在 handler 中调用 channel 或者 pipeline 的对应方法，这两个方法会将数据从头到尾或者从尾到头的流转一遍。</li>
</ol>
<p>最后，再次祭上我们的图，配合 debug 堆栈信息：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-59d16c1e00f7847b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图就是 pipeline 一个通用的数据流动过程。</p>
<p>好。good luck ！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-源码阅读的思考------耗时业务到底该如何处理</title>
    <url>/2018/03/16/2018/2018-03-16-Netty-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%9A%84%E6%80%9D%E8%80%83------%E8%80%97%E6%97%B6%E4%B8%9A%E5%8A%A1%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录大纲：
1. 前言
2. 处理耗时业务的第一种方式-------handler 种加入线程池
3. 处理耗时业务的第二种方式-------Context 中添加线程池
4. 总结：两种方式的对比和思考



<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>熟悉 Netty 的同学都知道，不能在 Netty 中做耗时的，不可预料的操作，比如数据库，网络请求，这将会严重影响 Netty 对 Socket 的处理速度。而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有2种方式，而且这2种方式的区别也蛮大的。今天就好好讲一讲。</p>
<h2 id="1-处理耗时业务的第一种方式——-handler-种加入线程池"><a href="#1-处理耗时业务的第一种方式——-handler-种加入线程池" class="headerlink" title="1. 处理耗时业务的第一种方式——-handler 种加入线程池"></a>1. 处理耗时业务的第一种方式——-handler 种加入线程池</h2><p>以我们之前的 Netty 的 demo 源码例子，在 channelRead 方法种进行异步：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6b7c32cd8f819fa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图中的 channelRead 方法，我们模拟了一个耗时 10 秒的操作，于是，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 Netty 的 IO 线程。</p>
<p>这样操作之后，整个程序的逻辑是这样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a32da82f708c52cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解释一下上图，当 IO 线程轮询到一个 socket 事件，然后，IO 线程开始处理，当走到耗时 handler 的时候，将耗时任务交给业务线程池。当耗时任务执行完毕再执行 pipeline write 方法的时候（代码中使用的是 context 的 write 方法，上图画的是执行 pipeline 方法），会将任务这个任务交给 IO 线程。</p>
<p>下面是 write 方法的源码：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f556a95201d6c690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>当判定下个 outbound 的 executor 线程不是当前线程的时候，会将当前的工作封装成 task ，然后放入 mpsc 队列中，等待 IO 任务执行完毕后执行队列中的任务。很明显，下个任务的线程肯定是 IO 线程，因为我们没有设置。</p>
<h2 id="2-处理耗时业务的第二种方式——-Context-中添加线程池"><a href="#2-处理耗时业务的第二种方式——-Context-中添加线程池" class="headerlink" title="2. 处理耗时业务的第二种方式——-Context 中添加线程池"></a>2. 处理耗时业务的第二种方式——-Context 中添加线程池</h2><p>第二种方式是 Netty 建议的方式，在添加 pipeline 中的 handler 时候，添加一个线程池：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-61cc571307a6a794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>而 handler 中的代码不用做任何修改：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ca9ba6040fecaab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>当我们在调用 addLast 方法添加线程池后，handler 将优先使用这个线程池，如果不添加，将使用 IO 线程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-aab8c455b8b2e0fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>所以，当走到 AbstractChannelHandlerContext  的 invokeChannelRead 方法的时候，executor.inEventLoop() 是不会通过的，因为当前线程是 IO 线程，Context（也就是 Handler） 的 executor 是业务线程，所以会异步执行，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-25f42e2f0c78ae6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这个时候，后面的整个流程就变成和第一个方式一样了。</p>
<h2 id="总结：-两种方式的对比和思考"><a href="#总结：-两种方式的对比和思考" class="headerlink" title="总结： 两种方式的对比和思考"></a>总结： 两种方式的对比和思考</h2><p>有什么区别呢？第一种方式在 handler 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 mpscTask 中。如果不凑巧，IO 时间很短，task 很多，可能一个循环下来，都没时间执行整个 task，导致响应时间达不到指标。</p>
<p>第二种方式是 Netty 建议的，但是，这么做会将整个 handler 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</p>
<p>再回顾一下我们刚开始的图吧：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b31d02e96cb46f02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>个人建议还是使用第一种方式，比较灵活。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-内存回收之-noCleaner-策略</title>
    <url>/2018/03/18/2018/2018-03-18-Netty-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E4%B9%8B-noCleaner-%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>对于堆外内存，使用 System.gc() 是不靠谱的，依赖老年代 FGC 也是不靠谱的，而且大部分调优指南都设置了 -DisableExplicitGC 禁用 System.gc()。所以主动回收比较靠谱， JDK 在 DirectByteBuffer 中提供了 Cleaner 用来主动释放内存。同时还有 Unsafe 的 freeMemory 方法也可以。 下面看看他是怎么做的。这里以非池化创建直接内存为例。</p>
<h2 id="UnpooledByteBufAllocator-newDirectBuffer-方法"><a href="#UnpooledByteBufAllocator-newDirectBuffer-方法" class="headerlink" title="UnpooledByteBufAllocator  newDirectBuffer 方法"></a>UnpooledByteBufAllocator  newDirectBuffer 方法</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        buf = noCleaner ? <span class="keyword">new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                <span class="keyword">new</span> InstrumentedUnpooledUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = <span class="keyword">new</span> InstrumentedUnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点在于 noCleaner 的结果。影响其结果的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">boolean</span> disableLeakDetector, <span class="keyword">boolean</span> tryNoCleaner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(preferDirect);</span><br><span class="line">    <span class="keyword">this</span>.disableLeakDetector = disableLeakDetector;</span><br><span class="line">    noCleaner = tryNoCleaner &amp;&amp; PlatformDependent.hasUnsafe()</span><br><span class="line">            &amp;&amp; PlatformDependent.hasDirectBufferNoCleanerConstructor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tryNoCleaner 结果来自 PlatformDependent.useDirectBufferNoCleaner()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">boolean</span> disableLeakDetector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(preferDirect, disableLeakDetector, PlatformDependent.useDirectBufferNoCleaner());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否含有 DirectByteBuffer 构造器，有则 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useDirectBufferNoCleaner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> USE_DIRECT_BUFFER_NO_CLEANER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据是否含有 DirectByteBuffer 的构造器判断，如果没有，USE_DIRECT_BUFFER_NO_CLEANER=false</span></span><br><span class="line"><span class="keyword">if</span> (maxDirectMemory == <span class="number">0</span> || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) &#123;</span><br><span class="line">    USE_DIRECT_BUFFER_NO_CLEANER = <span class="keyword">false</span>;</span><br><span class="line">    DIRECT_MEMORY_COUNTER = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    USE_DIRECT_BUFFER_NO_CLEANER = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxDirectMemory &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxDirectMemory = maxDirectMemory0();</span><br><span class="line">        <span class="keyword">if</span> (maxDirectMemory &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            DIRECT_MEMORY_COUNTER = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DIRECT_MEMORY_COUNTER = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DIRECT_MEMORY_COUNTER = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 DirectByteBuffer 的构造器</span></span><br><span class="line"><span class="keyword">final</span> ByteBuffer direct;</span><br><span class="line">Constructor&lt;?&gt; directBufferConstructor;</span><br><span class="line"><span class="keyword">long</span> address = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object maybeDirectBufferConstructor =</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">final</span> Constructor&lt;?&gt; constructor =</span><br><span class="line">                                direct.getClass().getDeclaredConstructor(<span class="keyword">long</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">                        Throwable cause = ReflectionUtil.trySetAccessible(constructor, <span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> cause;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> constructor;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            ((Constructor&lt;?&gt;) maybeDirectBufferConstructor).newInstance(address, <span class="number">1</span>);</span><br><span class="line">            directBufferConstructor = (Constructor&lt;?&gt;) maybeDirectBufferConstructor;</span><br><span class="line">         </span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address != -<span class="number">1</span>) &#123;</span><br><span class="line">        UNSAFE.freeMemory(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DIRECT_BUFFER_CONSTRUCTOR = directBufferConstructor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>noCleaner  为 true：创建 InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf 对象。简称 noCleaner；<br>noCleaner  为false：创建 InstrumentedUnpooledUnsafeDirectByteBuf 对象。简称 hasCleaner；</p>
<p><strong>两者构造器方式不同：</strong></p>
<blockquote>
<p>noCleaner 反射调用 private DirectByteBuffer(long addr, int cap)<br>hasCleaner new 操作调用 DirectByteBuffer(int cap)</p>
</blockquote>
<p><strong>两个释放内存方式不同:</strong></p>
<blockquote>
<p>noCleaner  使用 unSafe.freeMemory(address);<br>hasCleaner  使用 DirectByteBuffer 的 Cleaner 的 clean 方法。</p>
</blockquote>
<p><strong>hasCleaner   的 clean 方法有 2 种策略：</strong></p>
<blockquote>
<p> 1.Java9 使用 Unsafe 的 invokeCleaner 方法。调用了 ByteBuffer 的 Cleaner 的 clean 方法。<br>    2. Java6 — Java9 使用 DirectByteBuffer 的 属性 Cleaner 的 clean 方法。</p>
</blockquote>
<p><strong>clean 方法原理:</strong></p>
<blockquote>
<p>这个 clean 方法内部调用了一个名为 thunk 的 Deallocator 线程的 run 方法。该线程对象在创建 DirectByteBuffer 的时候同时创建。该线程的 run 方法内部会调用 unsafe 的 freeMemory 方法，同时还会调用 Bits.unreserveMemory 方法，该方法会相应的减小已经使用的内存大小数字（因为，每次申请直接内存都需要 Bits 判断是否足够，如果 FGC 后还不够，OOM，所以，这里的做法还是挺重要的）</p>
</blockquote>
<blockquote>
<p>注意：这个 Cleaner 是个虚引用，DirectByteBuffer  创建他的时候，会将自己放入虚引用的构造函数中，如果这个 DirectByteBuffer  被回收了（无人再引用这个 Cleaner），那么 GC 将会把这个 Cleaner 赋值给 Reference 的 pending 变量中，专门有一条 ReferenceHandler 的线程会死循环执行 Reference 的 tryHandlePending 方法，这个方法会调用 pending 的 clean 方法，完成内存回收操作。</p>
</blockquote>
<p><strong>这是 cleaner 对象的构造时机：</strong></p>
<pre><code class="java">DirectByteBuffer(int cap) &#123;                   // package-private

    super(-1, 0, cap, cap);
    boolean pa = VM.isDirectMemoryPageAligned();
    int ps = Bits.pageSize();
    long size = Math.max(1L, (long)cap + (pa ? ps : 0));
    Bits.reserveMemory(size, cap);

    long base = 0;
    try &#123;
        base = unsafe.allocateMemory(size);
    &#125; catch (OutOfMemoryError x) &#123;
        Bits.unreserveMemory(size, cap);
        throw x;
    &#125;
    unsafe.setMemory(base, size, (byte) 0);
    if (pa &amp;&amp; (base % ps != 0)) &#123;
        // Round up to page boundary
        address = base + ps - (base &amp; (ps - 1));
    &#125; else &#123;
        address = base;
    &#125;
    // 这里构造 cleaner
    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
    att = null;
&#125;
</code></pre>
<p><strong>该构造只有一个 int 参数</strong></p>
<p>所以，你知道了吧，noCleaner 的构造方法是不能调用 cleaner 的 clean 方法的。只能使用 unSafe 的 freeMemory 方法。而这就是 Netty 默认的做法。</p>
<p>同时，noCleaner  的构造方法也没有向 Bits 申请内存的内容，在申请内存的时候，性能会比 hasCleaner  要好一点。关于 Bits 的设计，我觉得不够优雅。当内存不够了，就 System.gc()，却只休眠 100 毫秒。根本不够回收到堆外内存。</p>
<p>实际上，Cleaner 的作用除了更新一下 Bits 的一些属性，方便下次申请内存之外，别无作用。</p>
<p>我猜想 Netty 使用 noCleaner  是性能优化的考虑吧。为了防止用户忘记使用 ReferenceCountUtil.release（）， 导致内存泄漏，Netty 还使用了虚引用跟踪每一个 ByteBuf，基本上避免了内存泄漏的发生。</p>
<p>综上所述：noCleaner  无论是在申请内存还是释放内存都比使用 hasCleaner  性能好要好一点。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-源码剖析之-unSafe-Read-方法</title>
    <url>/2018/03/18/2018/2018-03-18-Netty-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B-unSafe-read-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录：
1. NioSocketChannel$NioSocketChannelUnsafe 的 read 方法
2. 首先看 ByteBufAllocator
3. 再看 RecvByteBufAllocator.Handle
4. 两者如何配合进行内存分配
5. 如何读取到 ByteBuf
6. 总结

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的文章 <a href="https://www.jianshu.com/p/9c1925e24e95">Netty 核心组件 Pipeline 源码分析（二）一个请求的 pipeline 之旅</a>中，我们知道了当客户端请求进来的时候，boss 线程会将 Socket 包装后交给 worker 线程，worker 线程会将这个 Socket 注册 selector  的读事件，当读事件进来的时候，会调用 unsafe 的 read 方法，这个方法的主要作用是读取 Socket 缓冲区的内存，并包装成 Netty 的 ByteBuf 对象，最后传递进 pipeline 中的所有节点完成处理。</p>
<p>今天，我们就要好好的看看这个 read方法的实现。</p>
<h2 id="1-NioSocketChannel-NioSocketChannelUnsafe-的-read-方法"><a href="#1-NioSocketChannel-NioSocketChannelUnsafe-的-read-方法" class="headerlink" title="1. NioSocketChannel$NioSocketChannelUnsafe 的 read 方法"></a>1. NioSocketChannel$NioSocketChannelUnsafe 的 read 方法</h2><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="comment">// 用来处理内存的分配:池化或者非池化 UnpooledByteBufAllocator</span></span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="comment">// 用来计算此次读循环应该分配多少内存 AdaptiveRecvByteBufAllocator 自适应计算缓冲分配</span></span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);<span class="comment">// 重置为0</span></span><br><span class="line"></span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;<span class="comment">// 如果上一次读到的字节数小于等于0，清理引用和跳出循环</span></span><br><span class="line">                <span class="comment">// nothing was read. release the buffer.</span></span><br><span class="line">                byteBuf.release();<span class="comment">// 引用 -1</span></span><br><span class="line">                byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;<span class="comment">// 如果远程已经关闭连接</span></span><br><span class="line">                <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                    <span class="comment">// There is nothing left to read as we received an EOF.</span></span><br><span class="line">                    readPending = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);<span class="comment">//  totalMessages += amt;</span></span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，怎么办呢？当然是拆解，然后逐个击破。步骤如下：</p>
<ol>
<li>获取到 Channel 的 config 对象，并从该对象中获取内存分配器，还有”计算内存分配器”。</li>
<li>将 <code>计算内存分配器</code> 重置。</li>
<li>进入一个循环，循环体的作用是：使用内存分配器获取数据容器—–ByteBuf，调用 doReadBytes 方法将数据读取到容器中，如果这次读取什么都没有或远程连接关闭，则跳出循环。还有，如果满足了跳出推荐，也要结束循环，不能无限循环，默认16 次，默认参数来自 AbstractNioByteChannel 的 属性 ChannelMetadata 类型的 METADATA 实例。每读取一次就调用 pipeline 的 channelRead 方法，为什么呢？因为由于 TCP 传输如果包过大的话，丢失的风险会更大，导致重传，所以，大的数据流会分成多次传输。而 channelRead 方法也会被调用多次，因此，使用 channelRead 方法的时候需要注意，如果数据量大，最好将数据放入到缓存中，读取完毕后，再进行处理。</li>
<li>跳出循环后，调用 <code>allocHandle</code> 的 readComplete 方法，表示读取已完成，并记录读取记录，用于下次分配合理内存。</li>
<li>调用 pipeline 的方法。</li>
</ol>
<p>接下来就一步步看。</p>
<h2 id="2-首先看-ByteBufAllocator"><a href="#2-首先看-ByteBufAllocator" class="headerlink" title="2. 首先看 ByteBufAllocator"></a>2. 首先看 ByteBufAllocator</h2><p>首先看看这个节点的定义：</p>
<blockquote>
<p>  Implementations are responsible to allocate buffers. Implementations of this interface are expected to be hread-safe.<br>实现负责分配缓冲区。这个接口的实现应该是线程安全的。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-34d07961151497cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="定义了如上方法"></p>
<p>通过这个接口，可以看出来，主要作用是创建 ByteBuf，这个 ByteBuf 是 Netty 用来替代 NIO 的 ByteBuffer 的，是存储数据的缓存区。其中，这个接口有一个默认实现  ByteBufUtil.DEFAULT_ALLOCATOR ：该实现根据配置创建一个 池化或非池化的缓存区分配器。该参数是 <code>io.netty.allocator.type</code>。</p>
<p>同时，由于很多方法都是重载的，那就说说上面的主要方法作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer() <span class="comment">// 返回一个 ByteBuf 对象，默认直接内存。如果平台不支持，返回堆内存。</span></span><br><span class="line">heapBuffer（）<span class="comment">// 返回堆内存缓存区</span></span><br><span class="line">directBuffer（）<span class="comment">// 返回直接内存缓冲区</span></span><br><span class="line">compositeBuffer（） <span class="comment">// 返回一个复合缓冲区。可能同时包含堆内存和直接内存。</span></span><br><span class="line">ioBuffer（） <span class="comment">// 当当支持 Unsafe 时，返回直接内存的 Bytebuf，否则返回返回基于堆内存，当使用 PreferHeapByteBufAllocator 时返回堆内存</span></span><br></pre></td></tr></table></figure>








<h2 id="3-再看-RecvByteBufAllocator-Handle"><a href="#3-再看-RecvByteBufAllocator-Handle" class="headerlink" title="3. 再看 RecvByteBufAllocator.Handle"></a>3. 再看 RecvByteBufAllocator.Handle</h2><p>首先看这个接口：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f6f18e4fac080d3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图中， Handle 是 RecvByteBufAllocator 的内部接口。而 RecvByteBufAllocator 是如何定义的呢？</p>
<blockquote>
<p> Creates a new handle.  The handle provides the actual operations and keeps the internal information which is required for predicting an optimal buffer capacity.<br>创建一个新的句柄。句柄提供了实际操作，并保留了用于预测最佳缓冲区容量所需的内部信息。</p>
</blockquote>
<p>该接口只定义了一个方法：newHandle（）。</p>
<p>而 handle 的作用是什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ByteBuf <span class="title">allocate</span><span class="params">(ByteBufAllocator alloc)</span></span>;<span class="comment">//创建一个新的接收缓冲区，其容量可能大到足以读取所有入站数据和小到数据足够不浪费它的空间。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guess</span><span class="params">()</span></span>;<span class="comment">// 猜测所需的缓冲区大小，不进行实际的分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(ChannelConfig config)</span></span>;<span class="comment">// 每次开始读循环之前，重置相关属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incMessagesRead</span><span class="params">(<span class="keyword">int</span> numMessages)</span></span>;<span class="comment">// 增加本地读循环的次数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lastBytesRead</span><span class="params">(<span class="keyword">int</span> bytes)</span></span>; <span class="comment">// 设置最后一次读到的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastBytesRead</span><span class="params">()</span></span>; <span class="comment">// 最后一次读到的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attemptedBytesRead</span><span class="params">(<span class="keyword">int</span> bytes)</span></span>; <span class="comment">// 设置读操作尝试读取的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attemptedBytesRead</span><span class="params">()</span></span>; <span class="comment">// 获取尝试读取的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">continueReading</span><span class="params">()</span></span>; <span class="comment">// 判断是否需要继续读</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readComplete</span><span class="params">()</span></span>; <span class="comment">// 读结束后调用</span></span><br></pre></td></tr></table></figure>
<p>从上面的方法中，可以看出，该接口的主要作用就是计算字节数，如同 RecvByteBufAllocator 的文档说的那样，根据预测和计算最佳大小的缓存区，确保不浪费。</p>
<h2 id="4-两者如何配合进行内存分配"><a href="#4-两者如何配合进行内存分配" class="headerlink" title="4. 两者如何配合进行内存分配"></a>4. 两者如何配合进行内存分配</h2><p>在默认的 config （NioSocketChannelConfig）中，allocator 来自 ByteBufAllocator 接口的默认实例，allocHandle 来自 AdaptiveRecvByteBufAllocator 自适应循环缓存分配器 的内部类 HandleImpl。</p>
<p>好，知道了他们的默认实现，我们一个方法看看。</p>
<p>首先看 reset 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(ChannelConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    maxMessagePerRead = maxMessagesPerRead();</span><br><span class="line">    totalMessages = totalBytesRead = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置了上次获取的最大消息读取次数（默认16），将之前计算的读取消息总数归零。该方法如同他的名字，归零重置。</p>
<p>再看看 allocHandle.allocate(allocator) 方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">allocate</span><span class="params">(ByteBufAllocator alloc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> alloc.ioBuffer(guess());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们刚刚说的 ioBuffer 方法，该方法默认返回直接内存缓冲区。而 guess() 方法返回一个猜测的大小，一个 nextReceiveBufferSize 属性，默认 1024，也就是说，默认创建一个 1024 大小的直接内存缓冲区。这个值的设定来自 HandleImpl 的构造方法，存储在一个 SIZE_TABLE 的数组中。</p>
<p>我们还是看看 RecvByteBufAllocator 的实现类 AdaptiveRecvByteBufAllocator 的具体内容吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MINIMUM = <span class="number">64</span>; <span class="comment">// 缓存区最小值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL = <span class="number">1024</span>; <span class="comment">// 缓冲区初始值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAXIMUM = <span class="number">65536</span>; <span class="comment">// 缓冲区最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_INCREMENT = <span class="number">4</span>;<span class="comment">// 当发现缓存过小，数组下标自增值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_DECREMENT = <span class="number">1</span>;<span class="comment">// 当发现缓冲区过大，数组下标自减值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] SIZE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; sizeTable = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &lt; <span class="number">512</span>; i += <span class="number">16</span>) &#123;</span><br><span class="line">        sizeTable.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">512</span>; i &gt; <span class="number">0</span>; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sizeTable.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SIZE_TABLE = <span class="keyword">new</span> <span class="keyword">int</span>[sizeTable.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE_TABLE.length; i ++) &#123;</span><br><span class="line">        SIZE_TABLE[i] = sizeTable.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>楼主在上面的代码中写了注释，这个 SIZE_TABLE 的作用是存储缓存区大小的一个 int 数组，从 static 块中可以看到，这个数组从16开始，同时递增16，直到值到了 512，也就是下标 31 的地方，递增策略变为了 每次 * 2，直到溢出。最终的数组长度为 53。而对应的值接近 int 最大值。</p>
<p>好，回到 allocate 方法中，进入到 ioBuffer 方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断，如果平台支持 unSafe，就使用直接内存，否则使用堆内存，初始大小就是我们刚刚说的 1024。而这个判断的标准是：如果尝试获取 Unsafe 的时候有异常了，则赋值给一个  UNSAFE_UNAVAILABILITY_CAUSE 对象，否则赋值为 null，Netty 通过这个判 Null 确认平台是否支持 Unsafe。</p>
<p>我们继续看看 directBuffer 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> directBuffer(initialCapacity, DEFAULT_MAX_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(initialCapacity, maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> newDirectBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        buf = noCleaner ? <span class="keyword">new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                <span class="keyword">new</span> InstrumentedUnpooledUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = <span class="keyword">new</span> InstrumentedUnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于方法层层递进，楼主将代码合在一起，最终调用的是 newDirectBuffer，根据 noCleaner 参数决定创建一个 ByteBuf，这个属性怎么来的呢？当 unsafe 不是 null 的时候，会尝试获取 DirectByteBuffer 的构造器，如果成功获取，则 noCleaner 属性为 true。</p>
<p>这个 noCleaner  属性的详细介绍请看这里<a href="https://www.jianshu.com/p/5b0395d513fc">Netty 内存回收之 noCleaner 策略</a>.</p>
<p>默认情况下就是 true，那么，也就是创建了一个 InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf 对象，该对象构造如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@<span class="number">1</span></span><br><span class="line">InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(</span><br><span class="line">        UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">    <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="number">2</span></span><br><span class="line">UnpooledUnsafeNoCleanerDirectByteBuf(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">    <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledUnsafeDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(maxCapacity);</span><br><span class="line">    <span class="keyword">if</span> (alloc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;alloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;initialCapacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxCapacity: &quot;</span> + maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">&quot;initialCapacity(%d) &gt; maxCapacity(%d)&quot;</span>, initialCapacity, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.alloc = alloc;</span><br><span class="line">    setByteBuffer(allocateDirect(initialCapacity), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkPositiveOrZero(capacity, <span class="string">&quot;capacity&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (ByteBuffer) DIRECT_BUFFER_CONSTRUCTOR.newInstance(address, capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终使用了 DirectByteBuffer  的构造器进行反射创建。而这个构造器是没有默认的 new 创建的 Cleaner 对象的。因此称为 noCleaner。</p>
<p>创建完毕后，调用 setByteBuffer ，将这个 DirectByteBuffer  包装一下。</p>
<p>回到 newDirectBuffer 方法。</p>
<p>最后根据 disableLeakDetector 属性判断释放进行自动内存回收（也就是当你忘记回收的时候，帮你回收），原理这里简单的说一下，使用虚引用进行跟踪。 FastThreadLocal 的内存回收类似。我们将在以后的文章中详细说明此策略。</p>
<p>到这里，创建 ByteBuf 的过程就结束了。</p>
<p>可以说，大部分工作都是 allocator 做的，allocHandle 的作用就是提供了如何分配一个合理的内存的策略。</p>
<h2 id="5-如何读取到-ByteBuf"><a href="#5-如何读取到-ByteBuf" class="headerlink" title="5. 如何读取到 ByteBuf"></a>5. 如何读取到 ByteBuf</h2><p>回到 read 方法，doReadBytes(byteBuf) 就是将 Channel 的内容读取到容器中，并返回一个读取到的字节数。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadBytes</span><span class="params">(ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.attemptedBytesRead(byteBuf.writableBytes());</span><br><span class="line">    <span class="keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到 <code>内存预估器</code>，设置一个 attemptedBytesRead 属性为 ByteBuf 的可写字节数。这个参数可用于后面分配内存时的一些考量。</p>
<p>然后调用 byteBuf.writeBytes（）方法。传入了 NIO 的 channel，还有刚刚的可写字节数。进入到该方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeBytes</span><span class="params">(ScatteringByteChannel in, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureWritable(length);</span><br><span class="line">    <span class="keyword">int</span> writtenBytes = setBytes(writerIndex, in, length);</span><br><span class="line">    <span class="keyword">if</span> (writtenBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        writerIndex += writtenBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> writtenBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先对长度进行校验，确保可写长度大于0，如果被并发了导致容量不够，将这个底层的 ByteBuffer 的容量增加传入的长度。</p>
<p>关于 ByteBuf 的 wirteIndex ，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-db077a19e426423e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>回到 writeBytes 方法，调用 setBytes 方法，将流中输入写入到缓冲区。方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, ScatteringByteChannel in, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    ByteBuffer tmpBuf = internalNioBuffer();</span><br><span class="line">    tmpBuf.clear().position(index).limit(index + length);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> in.read(tmpBuf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClosedChannelException ignored) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常熟悉的 NIO 操作。</p>
<p>首先获取到内部 ByteBuffer 的共享缓冲区，赋值给临时的 tmpNioBuf 属性。然后返回这个引用。将这个引用清空，并将指针移动到给定 index 为止，然后 limit 方法设置缓存区大小。</p>
<p>最后调用 Channel 的 read 方法，将Channel 数据读入到 ByteBuffer 中。读的过程时线程安全的，内部使用了 synchronized 关键字控制写入 buffer 的过程。返回了读到的字节数。</p>
<p>回到 writeBytes 方法，得到字节数之后，将这个字节数追加到 writerIndex 属性，表示可写字节变小了。</p>
<p>回到 read 方法。allocHandle 得到读取到的字节数，调用 lastBytesRead 方法，该方法的作用时调整下一次分配内存的大小。进入到该方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lastBytesRead</span><span class="params">(<span class="keyword">int</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we read as much as we asked for we should check if we need to ramp up the size of our next guess.</span></span><br><span class="line">    <span class="comment">// This helps adjust more quickly when large amounts of data is pending and can avoid going back to</span></span><br><span class="line">    <span class="comment">// the selector to check for more data. Going back to the selector can add significant latency for large</span></span><br><span class="line">    <span class="comment">// data transfers.</span></span><br><span class="line">    <span class="keyword">if</span> (bytes == attemptedBytesRead()) &#123;</span><br><span class="line">        record(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.lastBytesRead(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Netty 写了注释：</p>
<blockquote>
<p>如果我们读的内容和我们要求的一样多，我们应该检查一下是否需要增加下一个猜测的大小。<br>这有助于在等待大量数据时更快地进行调整，并且可以避免返回选择器以检查更多数据。回到选择器可以为大型数据传输添加显著的延迟。</p>
</blockquote>
<p>当获取的字节数和预估的一样大，则需要进行扩容。看看 record 方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">(<span class="keyword">int</span> actualReadBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (actualReadBytes &lt;= SIZE_TABLE[max(<span class="number">0</span>, index - INDEX_DECREMENT - <span class="number">1</span>)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (decreaseNow) &#123;</span><br><span class="line">            index = max(index - INDEX_DECREMENT, minIndex);</span><br><span class="line">            nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">            decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decreaseNow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actualReadBytes &gt;= nextReceiveBufferSize) &#123;</span><br><span class="line">        index = min(index + INDEX_INCREMENT, maxIndex);</span><br><span class="line">        nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">        decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实际读取到的字节数小于等于预估的字节 下标 - 2（排除2以下），则将容量缩小一个下标。如果实际读取到的字节数大于等于预估的。则将下标增加 4，下次创建的 Buffer 容量也相应增加。如果不满足这两个条件，什么都不做。</p>
<p>回答 lastBytesRead 方法，该方法记录了读取到的总字节数并且更新了最后一次的读取字节数。总字节数会用来判断是否可以结束读取循环。如果什么都没有读到，将最多持续到读 16（默认） 次。</p>
<p>回到 read 方法。</p>
<p>如果最后一次读取到字节数小于等于0，跳出循环，不做 channelRead 操作。<br>反之，将 totalMessages 加1，这个就是用来记录循环次数，判断不能超过 16次。</p>
<p>调用 fireChannelRead 方法，方法结束后，将这个 Buffer 的引用置为null，</p>
<p>判断是否需要继续读取，带入如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">continueReading</span><span class="params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config.isAutoRead() &amp;&amp;</span><br><span class="line">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class="line">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class="line">           totalBytesRead &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几个条件：</p>
<ol>
<li>首先是否自动读取。</li>
<li>且猜测是否还有更多数据，如果实际读取的和预估的一致，说明可能还有数据没读，需要再次循环。</li>
<li>如果读取次数为达到 16 次，继续读取。</li>
<li>如果读取到的总数大于0，说明有数据，继续读取。</li>
</ol>
<p>这里的循环的主要原因就像我们刚刚说的，TCP 传输过大数据容易丢包（带宽限制），因此会将大包分好几次传输，还有就是可能预估的缓冲区不够大，没有充分读取 Channel 的内容。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>从 <code>NioSocketChannel$NioSocketChannelUnsafe</code> 的实现看 read 方法。每个 ByteBuf 都会由一个 Config 实例中的 ByteBufAllocator 对象创建，池化或非池化，直接内存或堆内存，这些都根据系统是否支持或参数设置，底层使用的是 NIO 的 API。今天我们看的是非池化的直接内存。同时，为了节省内存，为每个 ByteBufAllocator  配置了一个 handle，用于计算和预估缓冲区大小。</p>
<p>还有一个需要注意的地方就是 noCleaner 策略。这是 Netty 的一个优化。针对默认的直接内存创建和销毁做了优化——–不使用 JDK 的 cleaner 策略。</p>
<p>最终读取数据到封装了 NIO ByteBuffer 实例的 Netty 的 ByteBuf 中，其中，如果数据量超过 1024，则会读取超过两次，但最多不超过 16 次， 这个次数可以设置，也就是说，可能会调用超过2次 fireChannelRead 方法，使用的时候需要注意（存起来一起在 ChannelReadComplete 使用之类的方法）。</p>
<p>好，关于 Netty 读取 Socket 数据到容器中的逻辑，就到这里。</p>
<p>good luck！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-出站缓冲区-ChannelOutboundBuffer-源码解析（isWritable-属性的重要性）</title>
    <url>/2018/03/19/2018/2018-03-19-Netty-%E5%87%BA%E7%AB%99%E7%BC%93%E5%86%B2%E5%8C%BA-ChannelOutboundBuffer-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88isWritable-%E5%B1%9E%E6%80%A7%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录：

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li>ChannelOutboundBuffer 介绍</li>
<li>addMessage 方法</li>
<li>addFlush 方法</li>
<li>flush0 方法</li>
<li>缓冲区扩展思考</li>
<li>总结</li>
</ol>
<p>每个 ChannelSocket 的 Unsafe 都有一个绑定的  ChannelOutboundBuffer ，  Netty 向站外输出数据的过程统一通过 ChannelOutboundBuffer 类进行封装，目的是为了提高网络的吞吐量，在外面调用 write 的时候，数据并没有写到 Socket，而是写到了 ChannelOutboundBuffer 这里，当调用 flush 的时候，才真正的向 Socket 写出。同时，本文也关注当缓冲区满了的时候，Netty 如何处理。</p>
<h2 id="1-ChannelOutboundBuffer-介绍"><a href="#1-ChannelOutboundBuffer-介绍" class="headerlink" title="1. ChannelOutboundBuffer 介绍"></a>1. ChannelOutboundBuffer 介绍</h2><p>官方文档这么介绍的：</p>
<blockquote>
<p>(Transport implementors only) an internal data structure used by AbstractChannel to store its pending outbound write requests.<br>All methods must be called by a transport implementation from an I/O thread。<br>意思是，这个一个数据传输的实现者，一个内部的数据结构用于存储等待的出站写请求。所有的方法都必有由 IO 线程来调用。</p>
</blockquote>
<p>既然该类有一个内部的数据结构，我们就看看他的数据结构的样子，有以下几个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry flushedEntry; <span class="comment">// 即将被消费的开始节点</span></span><br><span class="line"><span class="keyword">private</span> Entry unflushedEntry;<span class="comment">// 被添加的开始节点，但没有准备好被消费。</span></span><br><span class="line"><span class="keyword">private</span> Entry tailEntry;<span class="comment">// 最后一个节点</span></span><br></pre></td></tr></table></figure>


<p>从上面的属性可以看出，这他么就是个链表。不过，这个链表有2个头，在调用 addFlush 方法的时候会将 unflushedEntry 赋值给 flushedEntry。表示即将从这里开始刷新。具体如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d55bf0096ae7dbd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>调用 addMessage 方法的时候，创建一个 Entry ，将这个 Entry 追加到 TailEntry 节点后面，调用 addFlush 的时候，将 unflushedEntry 的引用赋给 flushedEntry，然后将 unflushedEntry 置为 null。</p>
<p>当数据被写进 Socket 后，从 flushedEntry（current） 节点开始，循环将每个节点删除。</p>
<p>关于这 3 个方法，我们后面详细解释。</p>
<h2 id="2-addMessage-方法"><a href="#2-addMessage-方法" class="headerlink" title="2. addMessage 方法"></a>2. addMessage 方法</h2><p>该方法 doc 文档：</p>
<blockquote>
<p>Add given message to this ChannelOutboundBuffer. The given ChannelPromise will be notified once the message was written.<br>将给定的消息添加到 ChannelOutboundBuffer，一旦消息被写入，就会通知 promise。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Object msg, <span class="keyword">int</span> size, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    Entry entry = Entry.newInstance(msg, size, total(msg), promise);</span><br><span class="line">    <span class="keyword">if</span> (tailEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        flushedEntry = <span class="keyword">null</span>;</span><br><span class="line">        tailEntry = entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry tail = tailEntry;</span><br><span class="line">        tail.next = entry;</span><br><span class="line">        tailEntry = entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unflushedEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        unflushedEntry = entry;</span><br><span class="line">    &#125;</span><br><span class="line">    incrementPendingOutboundBytes(entry.pendingSize, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说说方法步骤：</p>
<ol>
<li>根据 ByteBuf 相互属性和 promise 创建一个 Entry 节点。</li>
<li>将新的节点追加到 tailEntry 节点上。如果考虑之前的全部被清空了话，则新节点就是唯一节点，unflushedEntry 属性就是新的节点。可对照上面的图来看。</li>
<li>使用 CAS 将 totalPendingSize（总的数据大小） 属性增加 Entry 实例的大小（96 字节） + 真实数据的大小。</li>
</ol>
<p>主要这个 Entry 节点的创建有点意思：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-59f7cbb7909ab494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-458cc28c298eddbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4f525db9ed4835de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Netty 将在 ThreadLocalMap 中存储了一个  Stack （栈）对象，存储重复使用的 DefaultHandle 实例，该实例的 value 属性就是 Entry ，所以这个 Entry 也是重复使用的，每次用完所有参数置为 null，再返回到栈中，下次再用，从这个栈中弹出。重复利用。对象池的最佳实践。而且是保存再线程中，速度更快，不会有线程竞争。这个设计倒是可以学习以下。</p>
<p>看完了 addMessage ，再看看 addFlush 方法。</p>
<h2 id="3-addFlush-方法"><a href="#3-addFlush-方法" class="headerlink" title="3. addFlush 方法"></a>3. addFlush 方法</h2><p>当 addMessage 成功添加进 ChannelOutboundBuffer 后，就需要 flush 刷新到 Socket 中去。但是这个方法并不是做刷新到 Socket 的操作。而是将 unflushedEntry 的引用转移到 flushedEntry 引用中，表示即将刷新这个 flushedEntry，至于为什么这么做？<br>答：因为 Netty 提供了 promise，这个对象可以做取消操作，例如，不发送这个 ByteBuf 了，所以，在 write 之后，flush 之前需要告诉 promise 不能做取消操作了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFlush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry entry = unflushedEntry;</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flushedEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            flushedEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            flushed ++;</span><br><span class="line">            <span class="keyword">if</span> (!entry.promise.setUncancellable()) &#123;</span><br><span class="line">                <span class="keyword">int</span> pending = entry.cancel();</span><br><span class="line">                decrementPendingOutboundBytes(pending, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entry.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line">        unflushedEntry = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结合上面的图：</p>
<ol>
<li>首先拿到未刷新的头节点。</li>
<li>判 null 之后，将这个 unflushedEntry 赋值给 flushedEntry，而这里的判 null 是做什么呢？防止多次调用 flush 。</li>
<li>循环尝试设置这些节点，告诉他们不能做取消操作了，如果尝试失败了，就将这个节点取消，在调用 nioBuffers 方法的时候，这个节点会被忽略。同时将 totalPendingSize 相应的减小。</li>
</ol>
<p>设置之后，promise 调用 cancel 方法就会返回 false。</p>
<p>在调用完 outboundBuffer.addFlush() 方法后，Channel 会调用 flush0 方法做真正的刷新。</p>
<h2 id="4-flush0-方法"><a href="#4-flush0-方法" class="headerlink" title="4. flush0 方法"></a>4. flush0 方法</h2><p>flush0 的核心是调用 dowrite 方法并传入 outboundBuffer。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-61d33ded018276b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>每种类型的 Channel 都实现都不一样。我们看的是 NioSocketChannel 的实现，方法很长，楼主截取重要逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到NIO Socket</span></span><br><span class="line">SocketChannel ch = javaChannel();</span><br><span class="line"><span class="comment">// 获取自旋的次数，默认16</span></span><br><span class="line"><span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</span><br><span class="line"><span class="comment">// 获取设置的每个 ByteBuf 的最大字节数，这个数字来自操作系统的 so_sndbuf 定义</span></span><br><span class="line"><span class="keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line"><span class="comment">// 调用 ChannelOutboundBuffer 的 nioBuffers 方法获取 ByteBuffer 数组，从flushedEntry开始，循环获取</span></span><br><span class="line">ByteBuffer[] nioBuffers = in.nioBuffers(<span class="number">1024</span>, maxBytesPerGatheringWrite);</span><br><span class="line"><span class="comment">// ByteBuffer 的数量</span></span><br><span class="line"><span class="keyword">int</span> nioBufferCnt = in.nioBufferCount();</span><br><span class="line"><span class="comment">// 使用 NIO 写入 Socket </span></span><br><span class="line">ch.write(buffer);</span><br><span class="line"><span class="comment">// 调整最大字节数</span></span><br><span class="line">adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);</span><br><span class="line"><span class="comment">// 删除 ChannelOutboundBuffer 中的 Entry</span></span><br><span class="line">in.removeBytes(localWrittenBytes);</span><br><span class="line"><span class="comment">// 自旋减一，直到自旋小于0停止循环，当然如果 ChannelOutboundBuffer 空了，也会停止。</span></span><br><span class="line">--writeSpinCount;</span><br><span class="line"><span class="comment">// 如果自旋16次还没有完成 flush，则创建一个任务放进mpsc 队列中执行。</span></span><br><span class="line">incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面的注释基本就是 flush 的逻辑。</p>
<ul>
<li><strong>当然 flush0 方法在 NIO 的具体实现中，还加入了对注册事件的判断：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFlushPending()) &#123;</span><br><span class="line">        <span class="keyword">super</span>.flush0();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isFlushPending</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SelectionKey selectionKey = selectionKey();</span><br><span class="line">    <span class="keyword">return</span> selectionKey.isValid() &amp;&amp; (selectionKey.interestOps() &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的判断是：如果注册了写事件，就暂时不写了，因为缓冲区到了水位线了，所以这次直接返回，等会再写。等到 EventLoop 触发写事件了，就会调用  <code>ch.unsafe().forceFlush()</code> 方法将数据刷新到 TCP 缓冲区。</p>
<ul>
<li><strong>这里有一个小知识点：</strong><blockquote>
<p>NIO 的写事件大部分时候是不需要注册的，只有当 TCP 缓冲区达到水位线了，不能写入了，才需要注册写事件。当缓冲区有空间了，NIO 就会触发写事件。</p>
</blockquote>
</li>
</ul>
<h2 id="5-缓冲区扩展思考"><a href="#5-缓冲区扩展思考" class="headerlink" title="5. 缓冲区扩展思考"></a>5. 缓冲区扩展思考</h2><p>从上面的逻辑上来看，不直到大家有没有发现一个问题：如果对方 Socket 接收很慢，ChannelOutboundBuffer 就会积累很多的数据。并且这个 ChannelOutboundBuffer  是没有大小限制的链表。可能会导致 OOM，Netty 已经考虑了这个问题，在　addMessage　方法的最后一行，incrementPendingOutboundBytes方法，会判断　totalPendingSize　的大小是否超过了高水位阈值（默认64 kb），如果超过，关闭写开关，调用 piepeline  的 fireChannelWritabilityChanged 方法可改变 flush 策略。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-0578a3188c6f5848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a97a3af8330cd752.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-2e9f3a4695acde09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b8c3bf159102b5b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1fb36d876b4f0925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>关于 channelWritabilityChanged API，Netty 这样解释：</p>
<blockquote>
<p>当 Channel 的可写状态发生改变时被调用。用户可以确保写操作不会完成的太快（以避免发生 OOM）或者可以在 Channel 变为再次可写时恢复写入。可以通过调用 Channel 的 isWritable 方法来检测 Channel 的可写性。与可写性相关的阈值可以通过 Channel.config().setWriteBufferHighWaterMark 和 Channel.config().setWriteBufferLowWaterMark 方法来设置，默认最小 32 kb，最大 64 kb。</p>
</blockquote>
<p>那么，上面时候恢复可写状态呢？remove 的时候，或者 addFlush 是丢弃了某个节点，会对 totalPendingSize 进行削减，削减之后进行判断。如果 totalPendingSize 小于最低水位了。就恢复写入。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9a486d98e28f5bfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>也就是说，默认的情况下，ChannelOutboundBuffer  缓存区的大小最大是 64 kb，最小是 32 kb，哪里看出来的呢？</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-19cbea156a36c817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>当然了，可以在 option 选项中进行修改，API 文档也说过了。</p>
<p>当不能写的时候，就会调用 ChannelWritabilityChanged 方法，用户可以在代码中，让写操作进行的慢一点。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>到了总结的时刻。</p>
<p>Netty 的 write 的操作不会立即写入，而是存储在了 ChannelOutboundBuffer 缓冲区里，这个缓冲区内部是 Entry 节点组成的链表结构，通过 addMessage 方法添加进链表，通过 addFlush 方法表示可以开始写入了，最后通过 SocketChannel 的 flush0 方法真正的写入到 JDK 的 Socket 中。同时需要注意如果 TCP 缓冲区到达一个水位线了，不能写入 TCP 缓冲区了，就需要晚点写入，这里的方法判断是 isFlushPending（）。</p>
<p>其中，有一个需要注意的点就是，如果对方接收数据较慢，可能导致缓冲区存在大量的数据无法释放，导致OOM，Netty 通过一个 isWritable 开关尝试解决此问题，但用户需要重写 ChannelWritabilityChanged 方法，因为一旦超过默认的高水位阈值，Netty 就会调用 ChannelWritabilityChanged 方法，执行完毕后，继续进行 flush。用户可以在该方法中尝试慢一点的操作。等到缓冲区的数据小于低水位的值时，开关就关闭了，就不会调用 ChannelWritabilityChanged 方法。因此，合理设置这两个数值也挺重要的。</p>
<p>好，限于篇幅，关于 ChannelOutboundBuffer  的分析就到这里，今天说的这几个方法算是这个类的主要方法，因为 Netty 的写操作都是围绕这三个方法来的。</p>
<p>good luck！！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty--粘包-&amp;-拆包-&amp;-编码-&amp;-解码-&amp;-序列化-介绍</title>
    <url>/2018/03/21/2018/2018-03-21-Netty--%E7%B2%98%E5%8C%85-&amp;-%E6%8B%86%E5%8C%85-&amp;-%E7%BC%96%E7%A0%81-&amp;-%E8%A7%A3%E7%A0%81-&amp;-%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录：
1. 粘包 & 拆包及解决方案 ByteToMessageDecoder
2. 基于长度编解码器
3. 基于分割符的编解码器
4. google 的 Protobuf 序列化介绍
5. 其他的

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Netty 作为一个网络框架，对 TCP 连接中的问题都做了全面的考虑，比如粘包拆包导致的半包问题，如何编解码，如何实现私有协议，序列化等等。本文主要针对这些问题做一个简单介绍，目的是想对整个 Netty 的编解码框架做一个全盘的审视，以确保在后面的源码学习中不会一叶障目不见泰山。</p>
<h2 id="1-粘包-amp-拆包及解决方案-ByteToMessageDecoder"><a href="#1-粘包-amp-拆包及解决方案-ByteToMessageDecoder" class="headerlink" title="1. 粘包 &amp; 拆包及解决方案 ByteToMessageDecoder"></a>1. 粘包 &amp; 拆包及解决方案 ByteToMessageDecoder</h2><p>由于TCP是面向字节流的，什么意思呢：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成式一连串的<strong>无结构的字节流</strong>。TCP 并不知道所传送的字节流的含义。</p>
<p>因此 TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的 TCP 共 10 个数据块，但接收方的 TCP 可能只用了 4 个就把收到的字节流交付上层的应用程序）。</p>
<p>同时，TCP 不关心应用进程一次把多长的报文发送到 TCP 的 <strong>缓存</strong> 中，而是根据对方给出的窗口值和当前网络阻塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。如果应用进程传送到 TCP 缓存的数据块太长，TCP 就可以把他划分短一点再传送。如果应用程序一次只发来一个字节，TCP  也可以等待积累有足够多的字节后再构成报文段发送出去。</p>
<ul>
<li><strong>TCP 发送报文一般是 3 个时机：</strong></li>
</ul>
<ol>
<li>缓冲区数据达到 <code>最大报文长度 MSS</code>；</li>
<li>由发送端的应用进程指明要求发送报文段，即 TCP 支持的推送（push）操作；</li>
<li>当发送方的一个计时器期限到了，即使长度不超过 MSS ，也发送。</li>
</ol>
<p><strong>以上引自《计算机网络—–谢希仁》。</strong></p>
<p>说了这么多，TCP 的这种机制，会导致什么问题呢？粘包问题。有了粘包，就需要拆包。</p>
<ul>
<li><strong>一般解决粘包拆包问题有 4 种办法：</strong></li>
</ul>
<ol>
<li>固定数据的长度，比如 100 字节，如果不够就补空格。</li>
<li>学习 HTTP ，FTP 等，使用回车换行符号。</li>
<li>将消息分为 head 和 body，head 中包含 body 长度的字段，一般 head 的第一个字段使用 int 值来表示 body 长度。</li>
<li>使用更复杂的应用层协议（等于没说 =_= !）。</li>
</ol>
<p>Netty 作为一个网络框架，直接和 TCP 打交道，自然考虑了这个问题。而解决这个问题的主要实现就是抽象类 ByteToMessageDecoder，详见 <a href="https://www.jianshu.com/p/4c35541eec10">Netty 解码器抽象父类 ByteToMessageDecoder 源码解析</a>。Netty 使用了模板设计模式，这个类只定义了共有行为，具体解码实现还是子类，比如上面提到的 4 种方式。</p>
<h2 id="2-基于长度编解码器的具体实现"><a href="#2-基于长度编解码器的具体实现" class="headerlink" title="2. 基于长度编解码器的具体实现"></a>2. 基于长度编解码器的具体实现</h2><p>基于长度的实现有2个现成的类：</p>
<ol>
<li><p>FixedLengthFrameDecoder 基于构造函数中的固定长度<br>该类很简单，构造方法中，传入一个整数，该解码器就会按照这个数字对累积区的字节进行切分。</p>
</li>
<li><p>LengthFieldBasedFrameDecoder 基于流中动态的长度<br>该类比较复杂。构造函数参数多达 6 个，在构建私有协议栈时大有用处。</p>
</li>
</ol>
<h2 id="3-基于分割符的编解码器"><a href="#3-基于分割符的编解码器" class="headerlink" title="3. 基于分割符的编解码器"></a>3. 基于分割符的编解码器</h2><p>同样有 2 个：</p>
<ol>
<li><p>DelimiterBasedFrameDecoder 用户提供分割符。<br>该类比较简单，根据用户提供的分割符对累积区的内容进行分割。性能相对不是那么完美。</p>
</li>
<li><p>LineBasedFrameDecoder  基于换行符,支持多种换行符 \n  \r\n 速度相比自定义较快。<br>该类使用更简单，根据换行符进行拆包粘包。</p>
</li>
</ol>
<h2 id="4-google-的-ProtobufDecoder-ProtobufEncoder-序列化介绍"><a href="#4-google-的-ProtobufDecoder-ProtobufEncoder-序列化介绍" class="headerlink" title="4. google 的 ProtobufDecoder ProtobufEncoder 序列化介绍"></a>4. google 的 ProtobufDecoder ProtobufEncoder 序列化介绍</h2><p>Netty 中有很多序列化工具，比如 Jboss 的 Marshalling，同时也支持 Java 标准的序列化。 但我们重点关注 google 的 protobuf 库。因为它的性能最高。</p>
<p>上面的 4 个解码器都是基于 ByteToMessageDecoder，将粘包的字节转为用户需要的字节。而ProtobufDecoder 不是继承自 ByteToMessageDecoder，而是继承自 MessageToMessageDecoder，名字都不同。MessageToMessageDecoder 的作用是什么呢？</p>
<p>从名字上看，该类用于将两个消息进行转换（比如一种 POJO 转成另一种）。后面我们将花大篇幅讲述这个类库。</p>
<h2 id="5-其他的"><a href="#5-其他的" class="headerlink" title="5. 其他的"></a>5. 其他的</h2><p><strong>1. TooLongFrameException</strong></p>
<p>由于 Netty 是一个异步框架，所以需要在字节可以解码之前在内存中缓冲他们。因此不能让解码器缓冲大量的数据以至于耗尽可用的内存。为了解决这个问题，Netty 提供了 <strong>TooLongFrameException</strong> 类，其将由解码器在帧超出指定的大小限制时抛出异常。</p>
<p>你可以设置一个最大的阈值，当超过该阈值，这抛出异常。</p>
<p><strong>2. 写大型数据的 FileRegion</strong></p>
<p>有时候你可能需要写一个大型的数据，如果不停的写入，可能导致 OOM，所以在写大型数据时，需要准备好处理到远程节点的连接时慢速连接的情况，这种情况会导致内存释放的延迟。</p>
<p>我们可以使用 NIO 的零拷贝特性，这种特性消除了将文件内容从文件系统移动到网络栈的复制过程。而我们所需要做的就是使用一个 FileRegion 接口的实现。<br>官方定义：</p>
<blockquote>
<p><strong>通过支持零拷贝的文件传输的 Channel 来发送的文件区域。</strong></p>
</blockquote>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文并没有刨析源码，主要是针对 Netty 中现有的或者设计的编解码，序列化等工具做一个介绍，方便后面有条不紊的按照这个路线研究他们的具体实现。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-源码剖析之-unSafe-Write-方法</title>
    <url>/2018/03/19/2018/2018-03-19-Netty-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B-unSafe-write-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>在  <a href="https://www.jianshu.com/p/bb579eb4fadd">Netty 源码剖析之 unSafe.read 方法</a> 一文中，我们研究了 read 方法的实现，这是读取内容到容器，再看看 Netty 是如何将内容从容器输出 Channel 的吧。</p>
<h2 id="1-ctx-writeAndFlush-方法"><a href="#1-ctx-writeAndFlush-方法" class="headerlink" title="1. ctx.writeAndFlush 方法"></a>1. ctx.writeAndFlush 方法</h2><p>当我们调用此方法时，会从当前节点找上一个 outbound 节点，进行，并调用下个节点的 write 方法。具体看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writeAndFlush(msg, newPromise()); <span class="comment">// 创建了一个默认的 DefaultChannelPromise 实例，返回的就是这个实例。</span></span><br><span class="line"></span><br><span class="line">@<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">true</span>)) &#123;<span class="comment">//判断 promise 有效性</span></span><br><span class="line">        ReferenceCountUtil.release(msg);<span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(msg, <span class="keyword">true</span>, promise);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AbstractWriteTask task;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        safeExecute(executor, task, promise, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最终调用的就是 @3 方法。找到上一个 outbound 节点，判断他的节点是否时当前线程。如果是，则会直接调用，泛着，将后面的工作封装成一个任务放进 mpsc 队列，供当前线程稍后执行。这个 任务的 run 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ESTIMATE_TASK_SIZE_ON_SUBMIT) &#123;</span><br><span class="line">            ctx.pipeline.decrementPendingOutboundBytes(size);</span><br><span class="line">        &#125;</span><br><span class="line">        write(ctx, msg, promise);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ctx = <span class="keyword">null</span>;</span><br><span class="line">        msg = <span class="keyword">null</span>;</span><br><span class="line">        promise = <span class="keyword">null</span>;</span><br><span class="line">        handle.recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ctx.invokeWrite(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终执行的是 invokeWrite 方法。</p>
<p>我们看看如果直接执行会如何处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        invokeWrite0(msg, promise);</span><br><span class="line">        invokeFlush0();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeAndFlush(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先执行 invokeWrite0 方法进行 write，然后 flush。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e09ae6d795112fa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@1"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f0c987de5b04d088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@2"></p>
<p>最终执行的是 unSafe 的 write 方法。<strong>注意：当前节点已经到了 Head 节点。</strong></p>
<p>详细说说该方法。</p>
<h2 id="2-unSafe-的-write-方法"><a href="#2-unSafe-的-write-方法" class="headerlink" title="2. unSafe  的 write 方法"></a>2. unSafe  的 write 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法步骤如下：</p>
<ol>
<li>判断 outboundBuffer 有效性。</li>
<li>将 ByteBuf 过滤成池化或者线程局部直接内存（如果不是直接内存的话）。</li>
<li>预估当前 ByteBuf 大小（就是可读字节数）。</li>
<li>将 ByteBuf 包装成一个 Entry 节点放入到 outboundBuffer 的单向链表中。</li>
</ol>
<p>这里有一个地方需要注意一下， filterOutboundMessage 方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ee8f5fbb83da5912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如果是直接内存的话，就直接返回了 ，反之调用 newDirectBuffer 方法。我们猜想肯定是重新包装成直接内存，利用直接内存令拷贝的特性，提升性能。</p>
<p>看看该方法内部逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(ByteBuf buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> readableBytes = buf.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (readableBytes == <span class="number">0</span>) &#123;</span><br><span class="line">        ReferenceCountUtil.safeRelease(buf);</span><br><span class="line">        <span class="keyword">return</span> Unpooled.EMPTY_BUFFER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator alloc = alloc();</span><br><span class="line">    <span class="keyword">if</span> (alloc.isDirectBufferPooled()) &#123;</span><br><span class="line">        ByteBuf directBuf = alloc.directBuffer(readableBytes);</span><br><span class="line">        directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);</span><br><span class="line">        ReferenceCountUtil.safeRelease(buf);</span><br><span class="line">        <span class="keyword">return</span> directBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBuf directBuf = ByteBufUtil.threadLocalDirectBuffer();</span><br><span class="line">    <span class="keyword">if</span> (directBuf != <span class="keyword">null</span>) &#123;</span><br><span class="line">        directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);</span><br><span class="line">        ReferenceCountUtil.safeRelease(buf);</span><br><span class="line">        <span class="keyword">return</span> directBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocating and deallocating an unpooled direct buffer is very expensive; give up.</span></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先判断可读字节数，如果是0，之际返回一个空的 Buffer。</li>
<li>获取该 Channel 的 ByteBufAllocator ，如果是直接内存且池化，则分配一个直接内存，将旧的 Buffer 写入到新的中，释放旧的 Buffer。返回新的直接内存 Buffer。</li>
<li>反之，从 FastThreadLocal 中返回一个可重用的直接内存 Buffer，后面和上面的操作一样，写入，删除旧的，返回新的。注意，这里返回的可重用的 Buffer，当调用他的 release 方法的时候，实际上是归还到了 FastThreadLocal 中。对象池的最佳实践。</li>
</ol>
<p>关于 addMessage 方法，我们将在另一篇文章<a href="http://thinkinjava.cn/articles/2018/03/18/1521380047606.html">Netty 出站缓冲区 ChannelOutboundBuffer 源码解析（isWritable 属性的重要性）</a>详细阐述，这里只需要知道，他放入了一个 出站缓存中就行了。</p>
<h2 id="3-unSafe-的-flush-方法"><a href="#3-unSafe-的-flush-方法" class="headerlink" title="3. unSafe 的 flush 方法"></a>3. unSafe 的 flush 方法</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-15438cc4bf67d74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>重点是 outboundBuffer.addFlush() 方法和 flush0 方法。</p>
<p>这两个方法在 <a href="http://thinkinjava.cn/articles/2018/03/18/1521380047606.html">Netty 出站缓冲区 ChannelOutboundBuffer 源码解析（isWritable 属性的重要性）</a></p>
<p>这里只需要知道，addFlush 方法将刚刚添加进出站 buffer 的数据进行检查，并准备写入 Socket。<br>flush0 做真正的写入操作，其中，调用了 JDK 的 Socket 的 write 方法，将 ByteBuf 封装的 ByteBuffer 写到 Socket 中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到，数据真正的写出还是调用了 head 的节点中 unsafe 的 write 方法和 flush 方法，其中，write 只是将数据写入到了出站缓冲区，并且，write 方法可以调用多次，flush 才是真正的写入到 Socket。而更详细的细节，可以查看我的另一篇文章<a href="http://thinkinjava.cn/articles/2018/03/18/1521380047606.html">Netty 出站缓冲区 ChannelOutboundBuffer 源码解析（isWritable 属性的重要性）</a>。</p>
<p>good luck ！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-解码器抽象父类-ByteToMessageDecoder--源码解析</title>
    <url>/2018/03/21/2018/2018-03-21-Netty-%E8%A7%A3%E7%A0%81%E5%99%A8%E6%8A%BD%E8%B1%A1%E7%88%B6%E7%B1%BB-ByteToMessageDecoder--%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>Netty 的解码器有很多种，比如基于长度的，基于分割符的，私有协议的。但是，总体的思路都是一致的。</p>
<p>拆包思路：当数据满足了 解码条件时，将其拆开。放到数组。然后发送到业务 handler 处理。</p>
<p>半包思路： 当读取的数据不够时，先存起来，直到满足解码条件后，放进数组。送到业务 handler 处理。</p>
<p>而实现这个逻辑的就是我们今天的主角：ByteToMessageDecoder。</p>
<p>看名字的意思是：将字节转换成消息的解码器。人如其名。而他本身也是一个入站 handler，所以，我们还是从他的 channelRead 方法入手。</p>
<h2 id="1-channelRead-方法"><a href="#1-channelRead-方法" class="headerlink" title="1. channelRead 方法"></a>1. channelRead 方法</h2><p>精简过的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   	<span class="comment">// 从对象池中取出一个List</span></span><br><span class="line">	CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line">	ByteBuf data = (ByteBuf) msg;</span><br><span class="line">	first = cumulation == <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (first) &#123;</span><br><span class="line">	    <span class="comment">// 第一次解码</span></span><br><span class="line">	    cumulation = data;<span class="comment">// 累计</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// 第二次解码，就将 data 向 cumulation 追加，并释放 data</span></span><br><span class="line">	    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 得到追加后的 cumulation 后，调用 decode 方法进行解码</span></span><br><span class="line">	<span class="comment">// 解码过程中，调用 fireChannelRead 方法，主要目的是将累积区的内容 decode 到 数组中</span></span><br><span class="line">	callDecode(ctx, cumulation, out);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果累计区没有可读字节了</span></span><br><span class="line">	<span class="keyword">if</span> (cumulation != <span class="keyword">null</span> &amp;&amp; !cumulation.isReadable()) &#123;</span><br><span class="line">	    <span class="comment">// 将次数归零</span></span><br><span class="line">	    numReads = <span class="number">0</span>;</span><br><span class="line">	    <span class="comment">// 释放累计区</span></span><br><span class="line">	    cumulation.release();</span><br><span class="line">	    <span class="comment">// 等待 gc</span></span><br><span class="line">	    cumulation = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="comment">// 如果超过了 16 次，就压缩累计区，主要是将已经读过的数据丢弃，将 readIndex 归零。</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (++ numReads &gt;= discardAfterReads) &#123;</span><br><span class="line">	    numReads = <span class="number">0</span>;</span><br><span class="line">	    discardSomeReadBytes();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> size = out.size();</span><br><span class="line">    <span class="comment">// 如果没有向数组插入过任何数据</span></span><br><span class="line">    decodeWasNull = !out.insertSinceRecycled();</span><br><span class="line">    <span class="comment">// 循环数组，向后面的 handler 发送数据，如果数组是空，那不会调用</span></span><br><span class="line">    fireChannelRead(ctx, out, size);</span><br><span class="line">    <span class="comment">// 将数组中的内容清空，将数组的数组的下标恢复至原来</span></span><br><span class="line">    out.recycle();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>楼主已经在方法中写了注释，但还是说说主要的步骤：</p>
<ol>
<li>从对象池中取出一个空的数组。</li>
<li>判断成员变量是否是第一次使用，（注意，既然使用了成员变量，所以这个 handler 不能是 handler 的。）将 unsafe 中传递来的数据写入到这个 cumulation 累积区中。</li>
<li>写到累积区后，调用子类的 decode 方法，尝试将累积区的内容解码，每成功解码一个，就调用后面节点的 channelRead 方法。若没有解码成功，什么都不做。</li>
<li>如果累积区没有未读数据了，就释放累积区。</li>
<li>如果还有未读数据，且解码超过了 16 次（默认），就对累积区进行压缩。将读取过的数据清空，也就是将 readIndex 设置为0.</li>
<li>设置 decodeWasNull 的值，如果上一次没有插入任何数据，这个值就是 ture。该值在 调用 channelReadComplete 方法的时候，会触发 read 方法（不是自动读取的话），尝试从 JDK 的通道中读取数据，并将之前的逻辑重来。主要应该是怕如果什么数据都没有插入，就执行 channelReadComplete 会遗漏数据。</li>
<li>调用 fireChannelRead 方法，将数组中的元素发送到后面的 handler 中。</li>
<li>将数组清空。并还给对象池。</li>
</ol>
<p>下面来说说详细的步骤。</p>
<h2 id="2-从对象池中取出一个空的数组"><a href="#2-从对象池中取出一个空的数组" class="headerlink" title="2. 从对象池中取出一个空的数组"></a>2. 从对象池中取出一个空的数组</h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@<span class="number">1</span></span><br><span class="line">CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line">@<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> CodecOutputList <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CODEC_OUTPUT_LISTS_POOL.get().getOrCreate();</span><br><span class="line">&#125;</span><br><span class="line">@<span class="number">3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;CodecOutputLists&gt; CODEC_OUTPUT_LISTS_POOL =</span><br><span class="line">        <span class="keyword">new</span> FastThreadLocal&lt;CodecOutputLists&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> CodecOutputLists <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 16 CodecOutputList per Thread are cached.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CodecOutputLists(<span class="number">16</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">@<span class="number">4</span></span><br><span class="line">CodecOutputLists(<span class="keyword">int</span> numElements) &#123;</span><br><span class="line">    elements = <span class="keyword">new</span> CodecOutputList[MathUtil.safeFindNextPositivePowerOfTwo(numElements)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// Size of 16 should be good enough for the majority of all users as an initial capacity.</span></span><br><span class="line">        elements[i] = <span class="keyword">new</span> CodecOutputList(<span class="keyword">this</span>, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    count = elements.length;</span><br><span class="line">    currentIdx = elements.length;</span><br><span class="line">    mask = elements.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CodecOutputList</span><span class="params">(CodecOutputListRecycler recycler, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.recycler = recycler;</span><br><span class="line">    array = <span class="keyword">new</span> Object[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="number">6</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CodecOutputList <span class="title">getOrCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Return a new CodecOutputList which will not be cached. We use a size of 4 to keep the overhead</span></span><br><span class="line">        <span class="comment">// low.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CodecOutputList(NOOP_RECYCLER, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    --count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = (currentIdx - <span class="number">1</span>) &amp; mask;</span><br><span class="line">    CodecOutputList list = elements[idx];</span><br><span class="line">    currentIdx = idx;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码分为 1，2，3，4，5， 6 步骤。</p>
<ol>
<li>静态方法调用。</li>
<li>从 FastThreadLocal 中取出一个 CodecOutputLists 对象，并从这个集合中再取出一个 List。也就是 List 中有 List。可以理解为双重数组。</li>
<li>调用 FastThreadLocal 的 initialValue 方法返回一个 CodecOutputLists 对象。</li>
<li> 创建数组。数组大小默认16，循环填充 CodecOutputList 元素。设置 count，currentIdx ，mask 属性。</li>
<li>创建 CodecOutputList 对象，这个 recycler 就是他的父 CodecOutputLists，并创建一个默认 16 的空数组。</li>
<li>首次进入 count 不是0，应该是 16，随后将 count -1，并与运算出 Lists 中的下标，获取到下标的内容。也就是一个 List。在调用 recycle 方法还给对象池的时候，会将所有参数恢复。</li>
</ol>
<p>由于这个 getOrCreate 方法会被一个线程的多个地方使用，因此 16 是个统计值。当 16 不够的时候，就会创建一个新的 List。也就是 count == 0 的逻辑。而 &amp; mask 的操作就是一个取模的操作。</p>
<h2 id="3-写入累积区"><a href="#3-写入累积区" class="headerlink" title="3. 写入累积区"></a>3. 写入累积区</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br></pre></td></tr></table></figure>

<p>这个 cumulator 默认是个 Cumulator 类型的 MERGE_CUMULATOR，该实例最主要的是从重写了 cumulate 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator MERGE_CUMULATOR = <span class="keyword">new</span> Cumulator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ByteBuf buffer;</span><br><span class="line">        <span class="keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</span><br><span class="line">                || cumulation.refCnt() &gt; <span class="number">1</span> || cumulation.isReadOnly()) &#123;</span><br><span class="line">            buffer = expandCumulation(alloc, cumulation, in.readableBytes());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buffer = cumulation;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.writeBytes(in);</span><br><span class="line">        in.release();</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法，主要是将 unsafe.read 传递过来的 ByteBuf 的内容写入到 cumulation 累积区中，然后释放掉旧的内容，由于这个变量是成员变量，因此可以多次调用 channelRead 方法写入。</p>
<p>同时这个方法也考虑到了扩容的问题，总的来说就是 copy。</p>
<p>当然，ByteToMessageDecoder 中还有一个 Cumulator 实例，称之为 COMPOSITE_CUMULATOR，混合累积。由于上个实例的 cumulate 方法是使用内存拷贝的，因此，这里提供了使用混合内存。相较于拷贝，性能会更好点，但同时也会更复杂。</p>
<h2 id="4-decode-方法的作用"><a href="#4-decode-方法的作用" class="headerlink" title="4. decode 方法的作用"></a>4. decode 方法的作用</h2><p>当数据追击到累积区之后，需要调用 decode 方法进行解码，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@ <span class="number">1</span></span><br><span class="line">callDecode(ctx, cumulation, out);</span><br><span class="line"></span><br><span class="line">@<span class="number">2</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">callDecode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果累计区还有可读字节</span></span><br><span class="line">    <span class="keyword">while</span> (in.isReadable()) &#123;</span><br><span class="line">        <span class="keyword">int</span> outSize = out.size();</span><br><span class="line">        <span class="comment">// 上次循环成功解码</span></span><br><span class="line">        <span class="keyword">if</span> (outSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用后面的业务 handler 的  ChannelRead 方法</span></span><br><span class="line">            fireChannelRead(ctx, out, outSize);</span><br><span class="line">            <span class="comment">// 将 size 置为0</span></span><br><span class="line">            out.clear();<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (ctx.isRemoved()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            outSize = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到可读字节数</span></span><br><span class="line">        <span class="keyword">int</span> oldInputLength = in.readableBytes();</span><br><span class="line">        <span class="comment">// 调用 decode 方法，将成功解码后的数据放入道 out 数组中，可能会删除当前节点，删除之前会将数据发送到最后的 handler</span></span><br><span class="line">        decodeRemovalReentryProtection(ctx, in, out);<span class="comment">// decode()</span></span><br><span class="line">        <span class="keyword">if</span> (ctx.isRemoved()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outSize == out.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldInputLength == in.readableBytes()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSingleDecode()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要逻辑：只要累积区还有未读数据，就循环进行读取。</p>
<ol>
<li><p>调用 decodeRemovalReentryProtection 方法，内部调用了子类重写的 decode 方法，很明显，这里是个模板模式。decode 方法的逻辑就是将累积区的内容按照约定进行解码，如果成功解码，就添加到数组中。同时该方法也会检查该 handler 的状态，如果被移除出 pipeline 了，就将累积区的内容直接刷新到后面的 handler 中。</p>
</li>
<li><p>如果 Context 节点被移除了，直接结束循环。如果解码前的数组大小和解码后的数组大小相等，且累积区的可读字节数没有变化，说明此次读取什么都没做，就直接结束。如果字节数变化了，说明虽然数组没有增加，但确实在读取字节，就再继续读取。</p>
</li>
<li><p>如果上面的判断过了，说明数组读到数据了，但如果累积区的 readIndex 没有变化，则抛出异常，说明没有读取数据，但数组却增加了，子类的操作是不对的。</p>
</li>
<li><p>如果是个单次解码器，解码一次就直接结束了。</p>
</li>
</ol>
<p>所以，这段代码的关键就是子类需要重写 decode 方法，将累积区的数据正确的解码并添加到数组中。每添加一次成功，就会调用 fireChannelRead 方法，将数组中的数据传递给后面的 handler。完成之后将数组的 size 设置为 0.</p>
<p>所以，如果你的业务 handler 在这个地方可能会被多次调用。也可能一次也不调用。取决于数组中的值。当然，如果解码 handler 被移除了，就会将累积区的所有数据刷到后面的 handler。</p>
<h2 id="5-剩下的逻辑"><a href="#5-剩下的逻辑" class="headerlink" title="5. 剩下的逻辑"></a>5. 剩下的逻辑</h2><p>上面的逻辑就是解码器最主要的逻辑：</p>
<blockquote>
<p>将 read 方法的数据读取到累积区，使用解码器解码累积区的数据，解码成功一个就放入到一个数组中，并将数组中的数据一次次的传递到后面的handler。</p>
</blockquote>
<p>从上面的逻辑看，除非 handler 被移除，否则不会调用后面的 handler 方法，也就是说，只要不满足解码器的解码规则，就不会传递给后面的 handler。</p>
<p>再看看后面的逻辑，主要在 finally 块中：</p>
<ol>
<li>如果累积区没有可读数据了，将计数器归零，并释放累积区。</li>
<li>如果不满足上面的条件，且计数器超过了 16 次，就压缩累积区的内容，压缩手段是删除已读的数据。将 readIndex 置为 0。还记得 ByteBuf 的指针结构吗？</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e1677855b8511908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这样就能节省一些内存了，但这会引起一些内存复制的过程，以性能损耗为前提的。</p>
<ol start="3">
<li>记录 decodeWasNull 属性，这个值的决定来自于你有没有成功的向数组中插入数据，如果插入了，它就是 fasle，没有插入，他就是 true。这个值的作用在于，当 channelRead 方法结束的时候，执行该 decoder 的 channelReadComplete 方法（如果你没有重写的话），会判断这个值：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ac2d0671ad4b5360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如果是 true，则会判断 autoRead 属性，如果是 false 的话，那么 Netty 认为还有数据没有读到，不然数组为什么一直是空的？就主动调用 read 方法从 Socket 读取。</p>
<ol start="4">
<li>调用 fireChannelRead 方法，尝试将数组中的数据发送到后面的 handler。为什么要这么做。按道理，到这一步的时候，数组不可能是空，为什么这里还要这么谨慎的再发送一次？</li>
</ol>
<p>答：如果是单次解码器，就需要发送了，因此单词解码器是不会再 callDecode 方法中发送的。</p>
<ol start="5">
<li>最后，将数组还给对象池。并清空数组内容。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9971c4ceaebc9935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>最后一行的 recycler.recycle(this)，有两种结果，如果是 CodecOutputLists 的 recycle 方法，内容如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a798685e7dc40c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>恢复数组下标，对 count ++，表示有对象可用了。</p>
<p>还有第二种，当 16 个数组不够用了，就需要创建一个新的，在 getOrCreate 方法体现。而构造函数中的 recycler 是一个空对象。我们看看这个对象：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-58790955f6762627.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>当调用 recycle 方法的时候，什么都不做。等待 GC 回收。因为这不是个对象池的引用。</p>
<p>好，到这里，关于 ByteToMessageDecoder 解码器的主要功能就解读完了。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>可以说，ByteToMessageDecoder 是解码器的核心所做，Netty 在这里使用了模板模式，留给子类扩展的方法就是 decode 方法。</p>
<p>主要逻辑就是将所有的数据全部放入累积区，子类从累积区取出数据进行解码后放入到一个 数组中，ByteToMessageDecoder 会循环数组调用后面的 handler 方法，将数据一帧帧的发送到业务 handler 。完成这个的解码逻辑。</p>
<p>使用这种方式，无论是粘包还是拆包，都可以完美的实现。</p>
<p>还有一些小细节：</p>
<ol>
<li>比如解码器可以单次的。</li>
<li>如果解码一直不成功，那么数据就一直无法到达后面的 handler。除非该解码器从 pipeline 移除。</li>
<li>像其他的 Netty 模块一样，这里也使用了对象池的概念，数组存放在线程安全的 ThreadLocal 中，默认 16 个，当不够时，就创建新的，用完即被 GC 回收。</li>
<li>当数组从未成功添加数据，且程序没有开启 autoRead ，就主动调用 read 方法。尝试读取数据。</li>
</ol>
<p>Netty 所有的解码器，都可以在此类上扩展，一切取决于 decode 的实现。只要遵守 ByteToMessageDecoder 的约定即可。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-高性能之道---Recycler-对象池的复用</title>
    <url>/2018/03/22/2018/2018-03-22-Netty-%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93---Recycler-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ![Recycler 设计图](https://upload-images.jianshu.io/upload_images/4236553-552d2878c402b15c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道，Java 创建一个实例的消耗是不小的，如果没有使用栈上分配和 TLAB，那么就需要使用 CAS 在堆中创建对象。所以现在很多框架都使用对象池。Netty 也不例外，通过重用对象，能够避免频繁创建对象和销毁对象带来的损耗。</p>
<p>来看看具体实现。</p>
<h2 id="1-Recycler-抽象类简介"><a href="#1-Recycler-抽象类简介" class="headerlink" title="1. Recycler 抽象类简介"></a>1. Recycler 抽象类简介</h2><p>该类 doc：</p>
<blockquote>
<p> Light-weight object pool based on a thread-local stack.<br>基于线程局部堆栈的轻量级对象池。</p>
</blockquote>
<p>该类是个容器，内部主要是一个 Stack 结构。当需要使用一个实例时，就弹出，当使用完毕时，就清空后入栈。</p>
<ul>
<li>该类有 2 个主要方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> <span class="comment">// 从 threadLocal 中取出 Stack 中首个 T 实例。</span></span></span><br><span class="line"><span class="function">2. <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">newObject</span><span class="params">(Handle&lt;T&gt; handle)</span> <span class="comment">// 当 Stack 中没有实例的时候，创建一个实例返回。</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>该类有 4 个内部接口 / 内部类：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 handler 回收实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handle</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">(T object)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle 的默认实现，可以将实例回收，放入 stack。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultHandle</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Handle</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 存储对象的数据结构。对象池的真正的 “池”</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 多线程共享的队列</span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">WeakOrderQueue</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 队列中的链表结构，用于存储多线程回收的实例</span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">AtomicInteger</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>实现线程局部缓存的 FastThreadLocal：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = <span class="keyword">new</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Stack&lt;T&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Stack&lt;T&gt;(Recycler.<span class="keyword">this</span>, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,</span><br><span class="line">                ratioMask, maxDelayedQueuesPerThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(Stack&lt;T&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.threadRef.get() == Thread.currentThread()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (DELAYED_RECYCLED.isSet()) &#123;</span><br><span class="line">               DELAYED_RECYCLED.get().remove(value);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>核心方法 get 操作</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        handle.value = newObject(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>核心方法 DefaultHandle 的 recycle 操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object != value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;object does not belong to handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="2-Netty-中的使用范例"><a href="#2-Netty-中的使用范例" class="headerlink" title="2. Netty 中的使用范例"></a>2. Netty 中的使用范例</h2><blockquote>
<p><strong>io.netty.channel.ChannelOutboundBuffer.Entry 类</strong></p>
</blockquote>
<ul>
<li>示例代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现了 Recycler 抽象类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;Entry&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;Entry&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Entry <span class="title">newObject</span><span class="params">(Handle&lt;Entry&gt; handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Entry(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line">Entry entry = RECYCLER.get();</span><br><span class="line"><span class="comment">// doSomeing......</span></span><br><span class="line"><span class="comment">// 归还实例</span></span><br><span class="line">entry.recycle();</span><br></pre></td></tr></table></figure>

<p>从上面的 get 方法，我们知道，最终会从 threadLocal 取出 Stack，从 Stack 中弹出 DefaultHandle 对象（如果没有就创建一个），然后调用我们重写的 newObject 方法，将创建的对象和 handle 绑定。最后返回这个对象。</p>
<p>当调用 entry.recycle() 方法的时候，实际会调用 DefaultHandle 的 recycle 方法。我们看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object != value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;object does not belong to handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 value 就是 get 方法中赋值的。如果不相等，就抛出异常。反之，将 handle 入栈 stack。注意：这里并没有对 value 做任何处理，只是在 Entry 内部做了清空处理。所以，这个 handle 和 handle 绑定的对象就保存在了 stack 中。</p>
<p>下次再次调用 get 时，就可以直接从该 threadLocal 中取出 handle 和 handle 绑定的 value了。完成了一次完美的对象池的实践。也就是说，一个 handle 绑定一个实例。而这个 handle 还是比较轻量的。</p>
<p>从这里可以看出，Stack 就是真正的 “池子”。我们就看看这个池子的内部实现。</p>
<p>而这个 stack 对外常用的方法的 pop 和 push。我们就来看看这两个方法。</p>
<h2 id="3-pop-方法"><a href="#3-pop-方法" class="headerlink" title="3. pop 方法"></a>3. pop 方法</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!scavenge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line">    size --;</span><br><span class="line">    DefaultHandle ret = elements[size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recycled multiple times&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret.recycleId = <span class="number">0</span>;</span><br><span class="line">    ret.lastRecycledId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑如下：</p>
<ol>
<li>拿到这个 Stack 的长度，实际上，这个 Stack 就是一个 DefaultHandle 数组。</li>
<li>如果这个长度是 0，没有元素了，就调用 scavenge 方法尝试从 queue 中转移一些数据到 stack 中。scavenge 方法待会详细再讲。</li>
<li>重置 size 属性和其余两个属性。返回实例。</li>
</ol>
<p>这个方法除了 scavenge 之外，还是比较简单的。</p>
<h2 id="4-push-方法"><a href="#4-push-方法" class="headerlink" title="4. push 方法"></a>4. push 方法</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (threadRef.get() == currentThread) &#123; </span><br><span class="line">        pushNow(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        pushLater(item, currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个对象使用 pop 方法取出来之后，可能会被别的线程使用，这时候，如果是你，你怎么处理呢？</p>
<p>先看看当前线程的处理：</p>
<p>看看 pushNow 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushNow</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((item.recycleId | item.lastRecycledId) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recycled already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= maxCapacity || dropHandle(item)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == elements.length) &#123;</span><br><span class="line">        elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class="number">1</span>, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elements[size] = item;</span><br><span class="line">    <span class="keyword">this</span>.size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要逻辑如下：</p>
<ol>
<li>如果 Stack 大小已经大于等于最大容量或者这个 handle 在容器里了，就不做回收了。</li>
<li>如果数组满了，扩容一倍，最大 4096（默认）。</li>
<li>size + 1。</li>
</ol>
<p>看看 dropHandle 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dropHandle</span><span class="params">(DefaultHandle&lt;?&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有被回收过</span></span><br><span class="line">    <span class="keyword">if</span> (!handle.hasBeenRecycled) &#123;</span><br><span class="line">        <span class="comment">// 第一次是 -1，++ 之后变为0，取余7。其实如果正常情况下，结果应该都是0。</span></span><br><span class="line">        <span class="comment">// 如果下面的判断不是0 的话，那么已经归还。这个对象就没有必要重复归还。</span></span><br><span class="line">        <span class="comment">// 直接丢弃。</span></span><br><span class="line">        <span class="keyword">if</span> ((++handleRecycleCount &amp; ratioMask) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Drop the object.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 改为被回收过，下次就不会进入了</span></span><br><span class="line">        handle.hasBeenRecycled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已经写了注释，就不再过多解释。</p>
<p>可以看到，pushNow 方法还是很简单的。由于在当前线程里，只需要还原到 Stack 的数组中就好了。</p>
<p><strong>关键是：如果是其他的线程做回收操作，该怎么办？</strong></p>
<h2 id="5-pushLater-方法（多线程回收如何操作）"><a href="#5-pushLater-方法（多线程回收如何操作）" class="headerlink" title="5. pushLater 方法（多线程回收如何操作）"></a>5. pushLater 方法（多线程回收如何操作）</h2><p>先说说 Netty 的解决办法和思路：</p>
<ul>
<li><p>每个线程都有一个 Stack 对象，每个线程也都有一个软引用 Map，键为 Stack，值是 queue。</p>
</li>
<li><p>线程每次从 local 中获取 Stack 对象，再从 Stack 中取出实例。如果取不到，尝试从 queue 取，也就是从queue 中的 Link 中取出，并销毁 Link。</p>
</li>
<li><p>但回收的时候，可能就不是原来的那个线程了，由于回收时使用的还是原来的 Stack，所以，需要考虑这个实例如何才能正确的回收。</p>
</li>
<li><p>这个时候，就需要 Map 出场了。创建一个 queue 关联这个 Stack，将数据放到这个 queue 中。等到持有这个 Stack 的线程想拿数据了，就从 Stack 对应的 queue 中取出。</p>
</li>
<li><p>看出来了吗？只有一个线程持有唯一的 Stack，其余的线程只持有这个 Stack 关联的 queue。因此，可以说，这个 queue 是两个线程共享的。除了 Stack 自己的线程外，其余的线程的归还都是放到 自己的queue 中。</p>
</li>
<li><p>这个 queue 是无界的。内部的 Link 是有界的。每个线程对应一个 queue。</p>
</li>
<li><p>这些线程的 queue 组成了链表。</p>
</li>
</ul>
<p>具体如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-552d2878c402b15c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Recycler 设计图"></p>
<p>看完了设计，再看看代码实现：</p>
<p><strong>pushLater 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLater</span><span class="params">(DefaultHandle&lt;?&gt; item, Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个 Stack 对应一串 queue，找到当前线程的 map</span></span><br><span class="line">    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class="line">    <span class="comment">// 查看当前线程中是否含有这个 Stack 对应的队列</span></span><br><span class="line">    WeakOrderQueue queue = delayedRecycled.get(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;<span class="comment">// 如果没有</span></span><br><span class="line">        <span class="comment">// 如果 map 长度已经大于最大延迟数了，则向 map 中添加一个假的队列</span></span><br><span class="line">        <span class="keyword">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;<span class="comment">// 8</span></span><br><span class="line">            delayedRecycled.put(<span class="keyword">this</span>, WeakOrderQueue.DUMMY);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果长度不大于最大延迟数，则尝试创建一个queue，链接到这个 Stack 的 head 节点前（内部创建Link）</span></span><br><span class="line">        <span class="keyword">if</span> ((queue = WeakOrderQueue.allocate(<span class="keyword">this</span>, thread)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// drop object</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delayedRecycled.put(<span class="keyword">this</span>, queue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class="line">        <span class="comment">// drop object</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.add(item);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>该方法步骤如下：</p>
<ol>
<li>从 threadLcoal 中取出当前线程的 Map，尝试从 Map 中取出 Stack 映射的 queue。</li>
<li>如果没有，就调用 WeakOrderQueue.allocate(this, thread) 方法创建一个。然后将这个 Stack 和 queue 绑定。</li>
<li>将实例添加到这个 queue 中。</li>
</ol>
<p><strong>我们主要关注如何 allocate 方法，关键方法 newQueue：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@<span class="number">1</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> WeakOrderQueue <span class="title">newQueue</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">    WeakOrderQueue queue = <span class="keyword">new</span> WeakOrderQueue(stack, thread);</span><br><span class="line">    stack.setHead(queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="number">2</span> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WeakOrderQueue</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Link();</span><br><span class="line">    owner = <span class="keyword">new</span> WeakReference&lt;Thread&gt;(thread);</span><br><span class="line">    availableSharedCapacity = stack.availableSharedCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="number">3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">AtomicInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultHandle&lt;?&gt;[] elements = <span class="keyword">new</span> DefaultHandle[LINK_CAPACITY];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> readIndex;</span><br><span class="line">    <span class="keyword">private</span> Link next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(WeakOrderQueue queue)</span> </span>&#123;</span><br><span class="line">    queue.setNext(head);</span><br><span class="line">    head = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码1，2，3，4。</p>
<ol>
<li>调用  WeakOrderQueue 构造方法，传入 stack 和 thread。</li>
<li>创建一个 Link 对象，赋值给链表中的 head 和 tail。</li>
<li>Lind 的构造函数，也是一个链表。其中包含了保存实例的 Handle 数组，默认 16.</li>
<li>将这个新的 queue 设置为该 stack 的 head 节点。</li>
</ol>
<p>其中，有一个需要注意的地方就是   owner = new WeakReference<Thread>(thread)，使用了弱引用，当这个线程对象被 GC 后，这个 owner 也会变为 null，就可以像 threadLoca 一样对该引用进行判 null，来检查这个线程对象是否回收了。</p>
<p>再看看如何添加进 queue 中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(DefaultHandle&lt;?&gt; handle)</span> </span>&#123;</span><br><span class="line">    handle.lastRecycledId = id;</span><br><span class="line">    Link tail = <span class="keyword">this</span>.tail;</span><br><span class="line">    <span class="keyword">int</span> writeIndex;</span><br><span class="line">    <span class="keyword">if</span> ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!reserveSpace(availableSharedCapacity, LINK_CAPACITY)) &#123;</span><br><span class="line">            <span class="comment">// Drop it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.tail = tail = tail.next = <span class="keyword">new</span> Link();</span><br><span class="line">        writeIndex = tail.get();</span><br><span class="line">    &#125;</span><br><span class="line">    tail.elements[writeIndex] = handle;</span><br><span class="line">    handle.stack = <span class="keyword">null</span>;</span><br><span class="line">    tail.lazySet(writeIndex + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，拿到这个 queue 的 tail 节点，如果这个 tiail 节点满了，查看是否还有共享空间，如果没了，就丢弃这个实例。<br>反之，则新建一个 Link，追加到 tail 节点的尾部。然后，将数据插入新 tail 的数组。然后，将这个 handle 的 stack 属性设置成 null，表示这个 handle 不属于任何 statck 了，其他 stack 都可以使用。</p>
<p><strong>数据放进去了，怎么取出来呢？</strong></p>
<h2 id="6-scavenge-方法"><a href="#6-scavenge-方法" class="headerlink" title="6. scavenge 方法"></a>6. scavenge 方法</h2><p>我们刚刚留了这个方法，现在可以开始讲了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavenge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// continue an existing scavenge, if any</span></span><br><span class="line">    <span class="comment">// 清理成功后，stack 的 size 会变化</span></span><br><span class="line">    <span class="keyword">if</span> (scavengeSome()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset our scavenge cursor</span></span><br><span class="line">    prev = <span class="keyword">null</span>;</span><br><span class="line">    cursor = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要调用的是 scavengeSome 方法，返回 true 表示将 queue 中的数据转移成功。看看该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavengeSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeakOrderQueue prev;</span><br><span class="line">    WeakOrderQueue cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">    <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        cursor = head;</span><br><span class="line">        <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev = <span class="keyword">this</span>.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 将 head queue 的实例转移到 this stack 中</span></span><br><span class="line">        <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果上面失败，找下一个节点</span></span><br><span class="line">        WeakOrderQueue next = cursor.next;</span><br><span class="line">        <span class="comment">// 如果当前线程被回收了，</span></span><br><span class="line">        <span class="keyword">if</span> (cursor.owner.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 只要最后一个节点还有数据，就一直转移</span></span><br><span class="line">            <span class="keyword">if</span> (cursor.hasFinalData()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                        success = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.setNext(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = cursor;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cursor != <span class="keyword">null</span> &amp;&amp; !success);</span><br><span class="line">    <span class="comment">// 转移成功之后，将 cursor 重置</span></span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    <span class="keyword">this</span>.cursor = cursor;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法还是挺长的。我们拆解一下：</p>
<ol>
<li>拿到这个 stack 的 queue，调用这个 queue 的 transfer 方法，如果成功，结束循环。</li>
<li>如果 queue 所在的线程被回收了，就将这个线程对应的 queue 中的所有数据全部转移到 stack 中。</li>
</ol>
<p>可以看到，最重要的还是 transfer 方法。然而该方法更长，就不贴代码了，说说主要逻辑，有兴趣可以自己看看，逻辑如下：</p>
<ol>
<li>拿到这个 queue 的 head 节点，也就是 Link。如果 head 是 null，取出 next。</li>
<li>循环 Link 中的实例，将其赋值到 stack 数组中。并将刚刚 handle 置为 null  的 stack 属性赋值。</li>
<li>最后，将 statck 的 size 属性更新。</li>
</ol>
<p><strong>其中有一个疑问：为什么在其他线程插入 Link 时将 handle 的 stack 的属性置为 null？在取出时，又将 handle 的 stack 属性恢复。</strong></p>
<p>答：因为如果 stack 被用户手动置为 null，而容器中的 handle 还持有他的引用的话，就无法回收了。同时 Map 也使用了软引用map，当 stack 没有了引用被 GC 回收时，对应的 queue 也就被回收了。避免了内存泄漏。实际上，在之前的 Recycler 版本中，确实存在内存泄漏的情况。</p>
<p>该方法的主要目的就是将 queue 所属的 Link 中的数据转移到 stack 中。从而完成多线程的最终回收。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Netty 并没有使用第三方库实现对象池，而是自己实现了一个相对轻量的对象池。通过使用 threadLocal，避免了多线程下取数据时可能出现的线程安全问题，同时，为了实现多线程回收同一个实例，让每个线程对应一个队列，队列链接在 Stack 对象上形成链表，这样，就解决了多线程回收时的安全问题。同时，使用了软引用的map 和 软引用的 thradl 也避免了内存泄漏。</p>
<p>在本次的源码阅读中，确实收获很大。再回顾以下 Recycler 的设计图吧。设计的真的非常好。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-0594c2f96c319a8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Recycler 设计图"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>看-Netty-在-Dubbo-中如何应用</title>
    <url>/2018/03/24/2018/2018-03-24-%E7%9C%8B-Netty-%E5%9C%A8-Dubbo-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录：
1. dubbo 的 Consumer 消费者如何使用 Netty
2. dubbo 的 Provider 提供者如何使用 Netty
3. 总结

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，国内知名框架 Dubbo 底层使用的是 Netty 作为网络通信，那么内部到底是如何使用的呢？今天我们就来一探究竟。</p>
<h2 id="1-dubbo-的-Consumer-消费者如何使用-Netty"><a href="#1-dubbo-的-Consumer-消费者如何使用-Netty" class="headerlink" title="1. dubbo 的 Consumer 消费者如何使用 Netty"></a>1. dubbo 的 Consumer 消费者如何使用 Netty</h2><p>注意：此次代码使用了从 github 上 clone 的 dubbo 源码中的 dubbo-demo 例子。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.net.preferIPv4Stack&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;META-INF/spring/dubbo-demo-consumer.xml&quot;</span>&#125;);</span><br><span class="line">context.start();</span><br><span class="line"> <span class="comment">// @1</span></span><br><span class="line">DemoService demoService = (DemoService) context.getBean(<span class="string">&quot;demoService&quot;</span>); <span class="comment">// get remote service proxy</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.err.println( ++ a + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        String hello = demoService.sayHello(<span class="string">&quot;world&quot;</span>); <span class="comment">// call remote method</span></span><br><span class="line">        System.out.println(hello); <span class="comment">// get result</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当代码执行到 @1 的时候，会调用 Spring 容器的 getBean 方法，而 dubbo 扩展了 FactoryBean，所以，会调用 getObject 方法，该方法会创建代理对象。</p>
<p>这个过程中会调用 DubboProtocol 实例的 getClients（URL url） 方法，当这个给定的 URL 的 client 没有初始化则创建，然后放入缓存，代码如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-984c498c87f19523.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这个 initClient 方法就是创建 Netty 的 client 的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f7c8ff6b04270c7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>最终调用的就是抽象父类 AbstractClient 的构造方法，构造方法中包含了创建 Socket 客户端，连接客户端等行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractClient</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    doOpen();</span><br><span class="line">	connect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doOpent 方法用来创建 Netty 的 bootstrap ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    bootstrap = <span class="keyword">new</span> ClientBootstrap(channelFactory);</span><br><span class="line">    bootstrap.setOption(<span class="string">&quot;keepAlive&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.setOption(<span class="string">&quot;tcpNoDelay&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.setOption(<span class="string">&quot;connectTimeoutMillis&quot;</span>, getTimeout());</span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;handler&quot;</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connect 方法用来连接提供者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    ChannelFuture future = bootstrap.connect(getConnectAddress());</span><br><span class="line">    <span class="keyword">boolean</span> ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; future.isSuccess()) &#123;</span><br><span class="line">        Channel newChannel = future.getChannel();</span><br><span class="line">        newChannel.setInterestOps(Channel.OP_READ_WRITE);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，调用了 bootstrap 的 connect 方法，熟悉的 Netty 连接操作。当然这里使用的是  jboss 的 netty3，稍微有点区别。当连接成功后，注册写事件，准备开始向提供者传递数据。</p>
<p>当 main 方法中调用 demoService.sayHello(“world”) 的时候，最终会调用 HeaderExchangeChannel 的 request 方法，通过 channel 进行请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Request req = <span class="keyword">new</span> Request();</span><br><span class="line">    req.setVersion(<span class="string">&quot;2.0.0&quot;</span>);</span><br><span class="line">    req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">    req.setData(request);</span><br><span class="line">    DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line">    channel.send(req);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>send 方法中最后调用 jboss  Netty 中继承了  NioSocketChannel 的 NioClientSocketChannel 的 write 方法。完成了一次数据的传输。</p>
<h2 id="2-dubbo-的-Provider-提供者如何使用-Netty"><a href="#2-dubbo-的-Provider-提供者如何使用-Netty" class="headerlink" title="2. dubbo 的 Provider 提供者如何使用 Netty"></a>2. dubbo 的 Provider 提供者如何使用 Netty</h2><p>Provider demo 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.net.preferIPv4Stack&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;META-INF/spring/dubbo-demo-provider.xml&quot;</span>&#125;);</span><br><span class="line">context.start();</span><br><span class="line">System.in.read(); <span class="comment">// press any key to exit</span></span><br></pre></td></tr></table></figure>

<p>Provider 作为被访问方，肯定是一个 Server 模式的 Socket。如何启动的呢？</p>
<p>当 Spring 容器启动的时候，会调用一些扩展类的初始化方法，比如继承了 InitializingBean，ApplicationContextAware，ApplicationListener 。而 dubbo 创建了 ServiceBean 继承了一个监听器。Spring 会调用他的 onApplicationEvent 方法，该类有一个 export 方法，用于打开 ServerSocket 。</p>
<p>然后执行了 DubboProtocol 的 createServer 方法，然后创建了一个 NettyServer 对象。NettyServer 对象的<br>构造方法同样是  doOpen 方法和。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;NettyServerBoss&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line">    ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;NettyServerWorker&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line">    ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">    bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;handler&quot;</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中，看到了熟悉的 boss 线程，worker 线程，和 ServerBootstrap，在添加了编解码 handler  之后，添加一个 NettyHandler，最后调用 bind 方法，完成绑定端口的工作。和我们使用 Netty 是一摸一样。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>可以看到，dubbo 使用 Netty 还是挺简单的，消费者使用 NettyClient，提供者使用 NettyServer，Provider  启动的时候，会开启端口监听，使用我们平时启动 Netty 一样的方式。而 Client 在 Spring getBean 的时候，会创建 Client，当调用远程方法的时候，将数据通过 dubbo 协议编码发送到 NettyServer，然后 NettServer 收到数据后解码，并调用本地方法，并返回数据，完成一次完美的 RPC 调用。</p>
<p>好，关于 dubbo 如何使用 Netty 就简短的介绍到这里。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty-心跳服务之-IdleStateHandler-源码分析</title>
    <url>/2018/03/23/2018/2018-03-23-Netty-%E5%BF%83%E8%B7%B3%E6%9C%8D%E5%8A%A1%E4%B9%8B-IdleStateHandler-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言：Netty 提供的心跳介绍

<p>Netty 作为一个网络框架，提供了诸多功能，比如我们之前说的编解码，Netty 准备很多现成的编解码器，同时，Netty 还为我们准备了网络中，非常重要的一个服务—–心跳机制。通过心跳检查对方是否有效，这在 RPC 框架中是必不可少的功能。</p>
<p>Netty 提供了 IdleStateHandler ，ReadTimeoutHandler，WriteTimeoutHandler 检测连接的有效性。当然，你也可以自己写个任务。但我们今天不准备使用自定义任务，而是使用 Netty 内部的。</p>
<p>说以下这三个 handler 的作用。</p>
<table>
<thead>
<tr>
<th>序 号</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>IdleStateHandler</td>
<td>当连接的空闲时间（读或者写）太长时，将会触发一个 IdleStateEvent 事件。然后，你可以通过你的 ChannelInboundHandler 中重写 userEventTrigged 方法来处理该事件。</td>
</tr>
<tr>
<td>2</td>
<td>ReadTimeoutHandler</td>
<td>如果在指定的事件没有发生读事件，就会抛出这个异常，并自动关闭这个连接。你可以在 exceptionCaught 方法中处理这个异常。</td>
</tr>
<tr>
<td>3</td>
<td>WriteTimeoutHandler</td>
<td>当一个写操作不能在一定的时间内完成时，抛出此异常，并关闭连接。你同样可以在 exceptionCaught 方法中处理这个异常。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong><br>其中，关于 WriteTimeoutHandler  的描述，著名的 《Netty 实战》和 他的英文原版的描述都过时了，原文描述：</p>
<blockquote>
<p>如果在指定的时间间隔内没有任何出站数据写入，则抛出一个 WriteTimeoutException.</p>
</blockquote>
<p>此书出版的时候，Netty 的文档确实是这样的，但在 2015 年 12 月 28 号的时候，被一个同学修改了逻辑，见下方 git 日志：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-655f41785daa83ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>貌似还是个国人妹子。。。。而现在的文档描述是：</p>
<blockquote>
<p>Raises a {@link WriteTimeoutException} when a write operation cannot finish in a certain period of time.<br>当一个写操作不能在一定的时间内完成时，就会产生一个 WriteTimeoutException。</p>
</blockquote>
<p>ReadTimeout 事件和  WriteTimeout 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以下，我们重点看 IdleStateHandler。</p>
<h2 id="1-什么是-IdleStateHandler"><a href="#1-什么是-IdleStateHandler" class="headerlink" title="1. 什么是 IdleStateHandler"></a>1. 什么是 IdleStateHandler</h2><ul>
<li>回顾一下 IdleStateHandler ：</li>
</ul>
<blockquote>
<p>当连接的空闲时间（读或者写）太长时，将会触发一个 IdleStateEvent 事件。然后，你可以通过你的 ChannelInboundHandler 中重写 userEventTrigged 方法来处理该事件。</p>
</blockquote>
<ul>
<li>如何使用呢？</li>
</ul>
<blockquote>
<p>IdleStateHandler 既是出站处理器也是入站处理器，继承了 ChannelDuplexHandler 。通常在 initChannel 方法中将 IdleStateHandler 添加到 pipeline 中。然后在自己的 handler 中重写 userEventTriggered 方法，当发生空闲事件（读或者写），就会触发这个方法，并传入具体事件。<br>这时，你可以通过 Context 对象尝试向目标 Socekt 写入数据，并设置一个 监听器，如果发送失败就关闭 Socket （Netty  准备了一个 <code>ChannelFutureListener.CLOSE_ON_FAILURE</code> 监听器用来实现关闭 Socket 逻辑）。<br>这样，就实现了一个简单的心跳服务。</p>
</blockquote>
<hr>
<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><ul>
<li><h5 id="1-构造方法，该类有-3-个构造方法，主要对一下-4-个属性赋值："><a href="#1-构造方法，该类有-3-个构造方法，主要对一下-4-个属性赋值：" class="headerlink" title="1.构造方法，该类有 3 个构造方法，主要对一下 4 个属性赋值："></a>1.构造方法，该类有 3 个构造方法，主要对一下 4 个属性赋值：</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> observeOutput;<span class="comment">// 是否考虑出站时较慢的情况。默认值是false（不考虑）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> readerIdleTimeNanos; <span class="comment">// 读事件空闲时间，0 则禁用事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> writerIdleTimeNanos;<span class="comment">// 写事件空闲时间，0 则禁用事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> allIdleTimeNanos; <span class="comment">//读或写空闲时间，0 则禁用事件</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="2-handlerAdded-方法"><a href="#2-handlerAdded-方法" class="headerlink" title="2. handlerAdded 方法"></a>2. handlerAdded 方法</h5></li>
</ul>
<p>当该 handler 被添加到 pipeline 中时，则调用 initialize 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">    initOutputChanged(ctx);</span><br><span class="line"></span><br><span class="line">    lastReadTime = lastWriteTime = ticksInNanos();</span><br><span class="line">    <span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">new</span> ReaderIdleTimeoutTask(ctx),</span><br><span class="line">                readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        writerIdleTimeout = schedule(ctx, <span class="keyword">new</span> WriterIdleTimeoutTask(ctx),</span><br><span class="line">                writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        allIdleTimeout = schedule(ctx, <span class="keyword">new</span> AllIdleTimeoutTask(ctx),</span><br><span class="line">                allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要给定的参数大于0，就创建一个定时任务，每个事件都创建。同时，将 state 状态设置为 1，防止重复初始化。调用 initOutputChanged 方法，初始化 “监控出站数据属性”，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initOutputChanged</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (observeOutput) &#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        Unsafe unsafe = channel.unsafe();</span><br><span class="line">        ChannelOutboundBuffer buf = unsafe.outboundBuffer();</span><br><span class="line">        <span class="comment">// 记录了出站缓冲区相关的数据，buf 对象的 hash 码，和 buf 的剩余缓冲字节数</span></span><br><span class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastMessageHashCode = System.identityHashCode(buf.current());</span><br><span class="line">            lastPendingWriteBytes = buf.totalPendingWriteBytes();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先说说这个 observeOutput  “监控出站数据属性” 的作用。因为 github 上有人提了 issue ，<a href="https://github.com/netty/netty/issues/6150">issue 地址</a>，本来是没有这个参数的。为什么需要呢？</p>
<p>假设：当你的客户端应用每次接收数据是30秒，而你的写空闲时间是 25 秒，那么，当你数据还没有写出的时候，写空闲时间触发了。实际上是不合乎逻辑的。因为你的应用根本不空闲。</p>
<p>怎么解决呢？</p>
<p>Netty 的解决方案是：记录最后一次输出消息的相关信息，并使用一个值 firstXXXXIdleEvent 表示是否再次活动过，每次读写活动都会将对应的 first 值更新为 true，如果是 false，说明这段时间没有发生过读写事件。同时如果第一次记录出站的相关数据和第二次得到的出站相关数据不同，则说明数据在缓慢的出站，就不用触发空闲事件。</p>
<p>总的来说，这个字段就是用来对付 “客户端接收数据奇慢无比，慢到比空闲时间还多” 的极端情况。所以，Netty 默认是关闭这个字段的。</p>
<ul>
<li><h5 id="3-该类内部的-3-个定时任务类"><a href="#3-该类内部的-3-个定时任务类" class="headerlink" title="3. 该类内部的 3 个定时任务类"></a>3. 该类内部的 3 个定时任务类</h5></li>
</ul>
<p>如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c64efc5485213104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这 3 个定时任务分别对应 读，写，读或者写 事件。共有一个父类。这个父类提供了一个模板方法：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-5b534402509a5ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>当通道关闭了，就不执行任务了。反之，执行子类的 run 方法。</p>
<p><strong>1. 读事件的 run 方法</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nextDelay = readerIdleTimeNanos;</span><br><span class="line">    <span class="keyword">if</span> (!reading) &#123;</span><br><span class="line">        nextDelay -= ticksInNanos() - lastReadTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Reader is idle - set a new timeout and notify the callback.</span></span><br><span class="line">        <span class="comment">// 用于取消任务 promise</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> first = firstReaderIdleEvent;</span><br><span class="line">        firstReaderIdleEvent = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 再次提交任务</span></span><br><span class="line">            IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">            <span class="comment">// 触发用户 handler use</span></span><br><span class="line">            channelIdle(ctx, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ctx.fireExceptionCaught(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法很简单：</p>
<ol>
<li>得到用户设置的超时时间。</li>
<li>如果读取操作结束了（执行了 channelReadComplete 方法设置） ，就用当前时间减去给定时间和最后一次读操作的时间（执行了 channelReadComplete 方法设置），如果小于0，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</li>
<li>触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 promise 对象，用于做取消操作。然后，设置 first 属性为 false ，表示，下一次读取不再是第一次了，这个属性在 channelRead 方法会被改成 true。</li>
<li>创建一个 IdleStateEvent  类型的写事件对象，将此对象传递给用户的 UserEventTriggered 方法。完成触发事件的操作。</li>
</ol>
<p>总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 UserEventTriggered 方法。就是这么简单。</p>
<p>再看看写事件任务。</p>
<p><strong>2. 写事件的 run 方法</strong></p>
<p>写任务的逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对 出站较慢数据的判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (hasOutputChanged(ctx, first)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个方法返回 true，就不执行触发事件操作了，即使时间到了。看看该方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasOutputChanged</span><span class="params">(ChannelHandlerContext ctx, <span class="keyword">boolean</span> first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (observeOutput) &#123;</span><br><span class="line">        <span class="comment">// 如果最后一次写的时间和上一次记录的时间不一样，说明写操作进行过了，则更新此值</span></span><br><span class="line">        <span class="keyword">if</span> (lastChangeCheckTimeStamp != lastWriteTime) &#123;</span><br><span class="line">            lastChangeCheckTimeStamp = lastWriteTime;</span><br><span class="line">            <span class="comment">// 但如果，在这个方法的调用间隙修改的，就仍然不触发事件</span></span><br><span class="line">            <span class="keyword">if</span> (!first) &#123; <span class="comment">// #firstWriterIdleEvent or #firstAllIdleEvent</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        Unsafe unsafe = channel.unsafe();</span><br><span class="line">        ChannelOutboundBuffer buf = unsafe.outboundBuffer();</span><br><span class="line">        <span class="comment">// 如果出站区有数据</span></span><br><span class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 拿到出站缓冲区的 对象 hashcode</span></span><br><span class="line">            <span class="keyword">int</span> messageHashCode = System.identityHashCode(buf.current());</span><br><span class="line">            <span class="comment">// 拿到这个 缓冲区的 所有字节</span></span><br><span class="line">            <span class="keyword">long</span> pendingWriteBytes = buf.totalPendingWriteBytes();</span><br><span class="line">            <span class="comment">// 如果和之前的不相等，或者字节数不同，说明，输出有变化，将 &quot;最后一个缓冲区引用&quot; 和 “剩余字节数” 刷新</span></span><br><span class="line">            <span class="keyword">if</span> (messageHashCode != lastMessageHashCode || pendingWriteBytes != lastPendingWriteBytes) &#123;</span><br><span class="line">                lastMessageHashCode = messageHashCode;</span><br><span class="line">                lastPendingWriteBytes = pendingWriteBytes;</span><br><span class="line">                <span class="comment">// 如果写操作没有进行过，则任务写的慢，不触发空闲事件</span></span><br><span class="line">                <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写了一些注释，还是再梳理一下吧：</p>
<ol>
<li>如果用户没有设置了需要观察出站情况。就返回 false，继续执行事件。</li>
<li>反之，继续向下， 如果最后一次写的时间和上一次记录的时间不一样，说明写操作刚刚做过了，则更新此值，但仍然需要判断这个 first 的值，如果这个值还是 false，说明在这个写事件是在两个方法调用间隙完成的 / 或者是第一次访问这个方法，就仍然不触发事件。</li>
<li>如果不满足上面的条件，就取出缓冲区对象，如果缓冲区没对象了，说明没有发生写的很慢的事件，就触发空闲事件。反之，记录当前缓冲区对象的 hashcode 和 剩余字节数，再和之前的比较，如果任意一个不相等，说明数据在变化，或者说数据在慢慢的写出去。那么就更新这两个值，留在下一次判断。</li>
<li>继续判断 first ，如果是 fasle，说明这是第二次调用，就不用触发空闲事件了。</li>
</ol>
<p>整个逻辑如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-131573522cdb3942.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图"></p>
<p>这里有个问题，为什么第一次的时候一定要触发事件呢？假设，客户端开始变得很慢，这个时候，定时任务监听发现时间到了，就进入这里判断，当上次记录的缓冲区相关数据已经不同，这个时候难道触发事件吗？</p>
<p>实际上，这里是 Netty 的一个考虑：假设真的发生了很写出速度很慢的问题，很可能引发 OOM，相比叫连接空闲，这要严重多了。为什么第一次一定要触发事件呢？如果不触发，用户根本不知道发送了什么，当一次写空闲事件触发，随后出现了 OOM，用户可以感知到：可能是写的太慢，后面的数据根本写不进去，所以发生了OOM。所以，这里的一次警告还是必要的。</p>
<p>当然，这是我的一个猜测。有必要的话，可以去 Netty 那里提个 issue。</p>
<p>好，关于客户端写的慢的特殊处理告一段落。再看看另一个任务的逻辑。</p>
<p><strong>3. 所有事件的 run 方法</strong></p>
<p>这个类叫做 AllIdleTimeoutTask ，表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致，除了这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> nextDelay = allIdleTimeNanos;</span><br><span class="line"><span class="keyword">if</span> (!reading) &#123;</span><br><span class="line">   <span class="comment">// 当前时间减去 最后一次写或读 的时间 ，若大于0，说明超时了</span></span><br><span class="line">   nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。最后调用 ctx.fireUserEventTriggered(evt) 方法。</p>
<p>通常这个使用的是最多的。构造方法一般是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span>, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure>
<p>读写都是 0 表示禁用，30 表示 30 秒内没有任务读写事件发生，就触发事件。注意，当不是 0 的时候，这三个任务会重叠。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IdleStateHandler 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 handler 的 userEventTriggered 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</p>
<p>IdleStateHandler  的实现基于 EventLoop 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</p>
<p>内部有 3 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</p>
<p>同时，IdleStateHandler  内部也考虑了一些极端情况：<code>客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间</code>。Netty 通过构造方法中的 observeOutput 属性来决定是否对出站缓冲区的情况进行判断。</p>
<p>如果出站缓慢，Netty 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，OOM 比空闲的问题更大。</p>
<p>所以，当你的应用出现了内存溢出，OOM之类，并且写空闲极少发生（使用了 observeOutput 为 true），那么就需要注意是不是数据出站速度过慢。</p>
<p>默认 observeOutput  是 false，意思是，即使你的应用出站缓慢，Netty 认为是写空闲。</p>
<p>可见这个 observeOutput 的作用好像不是那么重要，如果真的发生了出站缓慢，判断是否空闲根本就不重要了，重要的是 OOM。所以 Netty 选择了默认 false。</p>
<p>还有一个注意的地方：刚开始我们说的 ReadTimeoutHandler ，就是继承自 IdleStateHandler，当触发读空闲事件的时候，就触发 ctx.fireExceptionCaught 方法，并传入一个 ReadTimeoutException，然后关闭 Socket。</p>
<p>而 WriteTimeoutHandler 的实现不是基于 IdleStateHandler 的，他的原理是，当调用 write 方法的时候，会创建一个定时任务，任务内容是根据传入的 promise 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 promise 的 isDone 方法返回 false，表明还没有写完，说明超时了，则抛出异常。当 write 方法完成后，会打断定时任务。</p>
<p>好了，关于 Netty 自带的心跳相关的类就介绍到这里。这些功能对于开发稳定的高性能 RPC 至关重要。</p>
<p>good luck！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>自己用-Netty-实现一个简单的-RPC</title>
    <url>/2018/03/25/2018/2018-03-25-%E8%87%AA%E5%B7%B1%E7%94%A8-Netty-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-RPC/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录：
1. 需求
2. 设计
3. 实现
   1. 创建 maven 项目，导入 Netty 4.1.16。
   2. 项目目录结构
   3. 设计接口
   4. 提供者相关实现
   5. 消费者相关实现
   6. 测试结果
4. 总结

<p>源码地址：<a href="https://github.com/stateIs0/rpc-netty-demo">github 地址</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，dubbo 底层使用了 Netty 作为网络通讯框架，而 Netty 的高性能我们之前也分析过源码，对他也算还是比较了解了。今天我们就自己用 Netty 实现一个简单的 RPC 框架。</p>
<h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h2><p>模仿 dubbo，消费者和提供者约定接口和协议，消费者远程调用提供者，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 Netty 4.1.16。</p>
<h2 id="2-设计"><a href="#2-设计" class="headerlink" title="2. 设计"></a>2. 设计</h2><ol>
<li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li>
<li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li>
<li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 Netty 请求提供者返回数据。</li>
</ol>
<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><h4 id="1-创建-maven-项目，导入-Netty-4-1-16。"><a href="#1-创建-maven-项目，导入-Netty-4-1-16。" class="headerlink" title="1. 创建 maven 项目，导入 Netty 4.1.16。"></a>1. 创建 maven 项目，导入 Netty 4.1.16。</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.thinkinjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.16.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-项目目录结构如下："><a href="#2-项目目录结构如下：" class="headerlink" title="2. 项目目录结构如下："></a>2. 项目目录结构如下：</h4><p><img src="https://upload-images.jianshu.io/upload_images/4236553-e1850d945000f7cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="3-设计接口"><a href="#3-设计接口" class="headerlink" title="3. 设计接口"></a>3. 设计接口</h4><p>一个简单的 hello world：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">hello</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-提供者相关实现"><a href="#4-提供者相关实现" class="headerlink" title="4. 提供者相关实现"></a>4. 提供者相关实现</h4><p>4.1. 首先实现约定接口，用于返回客户端数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg != <span class="keyword">null</span> ? msg + <span class="string">&quot; -----&gt; I am fine.&quot;</span> : <span class="string">&quot;I am fine.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>4.2. 实现 Netty 服务端和自定义 handler</p>
<p>启动 Netty Server 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer0</span><span class="params">(String hostName, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    NioEventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    bootstrap.group(eventLoopGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline p = ch.pipeline();</span><br><span class="line">            p.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">            p.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">            p.addLast(<span class="keyword">new</span> HelloServerHandler());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    bootstrap.bind(hostName, port).sync();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中添加了 String类型的编解码 handler，添加了一个自定义 handler。</p>
<p>自定义 handler 逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于处理请求数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何符合约定，则调用本地方法，返回数据</span></span><br><span class="line">    <span class="keyword">if</span> (msg.toString().startsWith(ClientBootstrap.providerName)) &#123;</span><br><span class="line">      String result = <span class="keyword">new</span> HelloServiceImpl()</span><br><span class="line">          .hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="string">&quot;#&quot;</span>) + <span class="number">1</span>));</span><br><span class="line">      ctx.writeAndFlush(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里显示判断了是否符合约定（并没有使用复杂的协议，只是一个字符串判断），然后创建一个具体实现类，并调用方法写回客户端。</p>
<p>还需要一个启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    NettyServer.startServer(<span class="string">&quot;localhost&quot;</span>, <span class="number">8088</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好，关于提供者的代码就写完了，主要就是创建一个 netty 服务端，实现一个自定义的 handler，自定义 handler 判断是否符合之间的约定（算是协议吧），如果符合，就创建一个接口的实现类，并调用他的方法返回字符串。</p>
<h4 id="5-消费者相关实现"><a href="#5-消费者相关实现" class="headerlink" title="5. 消费者相关实现"></a>5. 消费者相关实现</h4><p>消费者有一个需要注意的地方，就是调用需要透明，也就是说，框架使用者不用关心底层的网络实现。这里我们可以使用 JDK 的动态代理来实现这个目的。</p>
<p>思路：客户端调用代理方法，返回一个实现了 HelloService 接口的代理对象，调用代理对象的方法，返回结果。</p>
<p>我们需要在代理中做手脚，当调用代理方法的时候，我们需要初始化 Netty 客户端，还需要向服务端请求数据，并返回数据。</p>
<p>5.1. 首先创建代理相关的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors</span><br><span class="line">      .newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HelloClientHandler client;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建一个代理对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; serviceClass,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">final</span> String providerName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[]&#123;serviceClass&#125;, (proxy, method, args) -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">            initClient();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 设置参数</span></span><br><span class="line">          client.setPara(providerName + args[<span class="number">0</span>]);</span><br><span class="line">          <span class="keyword">return</span> executor.submit(client).get();</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化客户端</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    client = <span class="keyword">new</span> HelloClientHandler();</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    b.group(group)</span><br><span class="line">        .channel(NioSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline p = ch.pipeline();</span><br><span class="line">            p.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">            p.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">            p.addLast(client);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      b.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8088</span>).sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该类有 2 个方法，创建代理和初始化客户端。</p>
<p>初始化客户端逻辑： 创建一个 Netty 的客户端，并连接提供者，并设置一个自定义 handler，和一些 String 类型的编解码器。</p>
<p>创建代理逻辑：使用 JDK 的动态代理技术，代理对象中的 invoke 方法实现如下：<br>如果 client 没有初始化，则初始化 client，这个 client 既是 handler ，也是一个 Callback。将参数设置进 client ，使用线程池调用 client 的 call 方法并阻塞等待数据返回。</p>
<p>看看 HelloClientHandler 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ChannelHandlerContext context;</span><br><span class="line">  <span class="keyword">private</span> String result;</span><br><span class="line">  <span class="keyword">private</span> String para;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    context = ctx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 收到服务端数据，唤醒等待线程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    result = msg.toString();</span><br><span class="line">    notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 写出数据，开始等待唤醒</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    context.writeAndFlush(para);</span><br><span class="line">    wait();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setPara</span><span class="params">(String para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.para = para;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该类缓存了 ChannelHandlerContext，用于下次使用，有两个属性：返回结果和请求参数。</p>
<p>当成功连接后，缓存 ChannelHandlerContext，当调用 call 方法的时候，将请求参数发送到服务端，等待。当服务端收到并返回数据后，调用 channelRead 方法，将返回值赋值个 result，并唤醒等待在 call 方法上的线程。此时，代理对象返回数据。</p>
<p>再看看设计的测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String providerName = <span class="string">&quot;HelloService#hello#&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RpcConsumer consumer = <span class="keyword">new</span> RpcConsumer();</span><br><span class="line">    <span class="comment">// 创建一个代理对象</span></span><br><span class="line">    HelloService service = (HelloService) consumer</span><br><span class="line">        .createProxy(HelloService.class, providerName);</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(service.hello(<span class="string">&quot;are you ok ?&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类首先创建了一个代理对象，然后每隔一秒钟调用代理的 hello 方法，并打印服务端返回的结果。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-1e8afde163935d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>成功打印。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了这么久的 Netty 源码，我们终于实现了一个自己的 Netty 应用，虽然这个应用很简单，甚至代码写的有些粗糙，但功能还是实现了，RPC 的目的就是允许像调用本地服务一样调用远程服务，需要对使用者透明，于是我们使用了动态代理。并使用 Netty 的 handler 发送数据和响应数据，完成了一次简单的 RPC 调用。</p>
<p>当然，还是那句话，代码比较简单，主要是思路，以及了解 RPC 底层的实现。</p>
<p>好吧。good luck！！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>阅读源码的利器——Intellij-IDEA-Replace-in-Path-使用技巧</title>
    <url>/2018/03/25/2018/2018-03-25-%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E7%9A%84%E5%88%A9%E5%99%A8%E2%80%94%E2%80%94Intellij-IDEA-Replace-in-Path-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       讲讲宇宙排名第二的开发工具-----IDEA的使用技巧。

<h2 id="搜索-替换-技巧"><a href="#搜索-替换-技巧" class="headerlink" title="搜索/替换 技巧"></a>搜索/替换 技巧</h2><p>阅读源码的利器</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3c938312209627f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><strong>1. Match case：</strong> 如果勾选该按钮，搜索时将区分大小写字母。<br><strong>2. Preserve case：</strong> 如果勾选该按钮，搜索时不区分大小写，但替换的时候，将会把你给定的字符串的首字母替换成小写。比如，你输入 HelloWorld，将会被替换成 helloWorld。<br><strong>3. regex：</strong> 可以使用正则表达式搜索，可参照 java.util.regex。<br><strong>4. 右上角蓝色漏斗有几个选项：</strong> </p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>anywhere</td>
<td>选择此选项可随处搜索</td>
</tr>
<tr>
<td>in comments</td>
<td>选择此选项将搜索限制在注释中，忽略其他事件</td>
</tr>
<tr>
<td>In string literals</td>
<td>选择此选项可将搜索限制为字符串文字，忽略其他事件</td>
</tr>
<tr>
<td>Except *</td>
<td>以上三个的反向查找</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>5. File mask：</strong> 可以过滤要查找的文件格式。可以使用通配符：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
</table>
<ul>
<li> | 替换一组任何字符<br>？  | 替换单个字符<br>!  | !排除文件。请注意，!应该先以特定文件名称模式进行，例如，!*.gant</li>
</ul>
<p>可以同时指定多个文件，使用逗号隔开。注意：！，即否定模式，隐式的使用了 * 号匹配。</p>
<p><strong>6. Search field：</strong> 这是我们使用的最多的，即——搜索框，可手动输入，也可以点击下拉框寻找历史记录。也可以使用正则表达式。</p>
<p><strong>7. Replace field：</strong>替换字段，可指定替换的文本，也可以使用正在表达式替换文本，如果要在表达式中使用 \，则需要在前面插入三个额外的反斜杠用于转义。</p>
<p><strong>8. In Project：</strong> 在自己的项目范围中搜索。</p>
<p><strong>9. Module：</strong>在模块中搜索， 可以指定模块，并可以在下拉框切换模块哦。</p>
<p><strong>10. Directory：</strong>在指定目录内搜索。右侧那个小文件树 icon，好像并没什么用啊……</p>
<p><strong>11. Scope：</strong>  在指定范围内搜索。下拉框中有各种范围。</p>
<p> <strong>12. Preview area：</strong> 当然,最强大的还是预览窗口了，可以使用方向键上下预览，并且可以在预览框中编辑，爽的不行。</p>
<p><strong>13. 最危险的是下面这个操作：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-08b01a20d43edede.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>当你重构的时候，弄的不好，就全部替换了。。。。。那就尴尬了。<br>说说上面几个选项的具体作用：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Replace</td>
<td>替换选中的目标。</td>
</tr>
<tr>
<td>Skip</td>
<td>跳过选中的目标</td>
</tr>
<tr>
<td>Replace All in This File</td>
<td>替换选中的目标所在文件的所有匹配字符串</td>
</tr>
<tr>
<td>Skip To Next File</td>
<td>放弃当前文件，跳到下一个文件</td>
</tr>
<tr>
<td>All Files</td>
<td>这个很危险了。。。替换所有文件</td>
</tr>
<tr>
<td>Review</td>
<td>保险起见，用这个检查每个文件吧。</td>
</tr>
</tbody></table>
<p><strong>关于  Review ：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e96e45ff7012ceef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这个算是手动模式吧，你可以一个一个检查。Replace All 就是替换所有内容，比较危险，Replace Selected 就是替换选中的内容（使用 ctrl 或 shift 多选）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，关于 IDEA 的搜索功能就介绍到这里啦，其实，在阅读源码的过程中，真的要学会善用搜索，当然，不仅是搜索，还有各种功能，比如打断点，断点的跳转，类的继承，实现 UML，方法调用栈，线程调用栈，变量条件判断等等，很多，这些都是阅读源码时不可获取的重要功能，在 debug 的时候，能大大提高我们的效率。</p>
<p>最后，如有条件，请支持正版。谢谢。</p>
<p>goog luck！！！</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>分布式理论(一)-——-CAP-定理</title>
    <url>/2018/03/26/2018/2018-03-26-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%B8%80)-%E2%80%94%E2%80%94-CAP-%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录：
1. 什么是 CAP 定理
2. 为什么只能 3 选 2
3. 能不能解决 3 选 2 的问题
 4. 引用

<h2 id="1-什么是-CAP-定理"><a href="#1-什么是-CAP-定理" class="headerlink" title="1. 什么是 CAP 定理"></a>1. 什么是 CAP 定理</h2><p>2000 年的时候，Eric Brewer 教授提出了 CAP 猜想，2年后，被 Seth Gilbert 和 Nancy Lynch 从理论上证明了猜想的可能性，从此，CAP 理论正式在学术上成为了分布式计算领域的公认定理。并深深的影响了分布式计算的发展。</p>
<p>CAP 理论告诉我们，一个分布式系统不可能同时满足一致性（C:Consistency)，可用性（A: Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的2个。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>C（Consistence）</td>
<td><strong>一致性</strong>，指数据在多个副本之间能够保持一致的特性（严格的一致性）。</td>
</tr>
<tr>
<td>A（Availability）</td>
<td><strong>可用性</strong>，指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据。</td>
</tr>
<tr>
<td>P（Network partitioning</td>
<td><strong>分区容错性</strong>，分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。</td>
</tr>
</tbody></table>
<p>什么是分区？</p>
<blockquote>
<p>在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域。这就是分区。</p>
</blockquote>
<h2 id="2-为什么只能-3-选-2"><a href="#2-为什么只能-3-选-2" class="headerlink" title="2. 为什么只能 3 选 2"></a>2. 为什么只能 3 选 2</h2><p>为什么只能 3 选 2？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1a91100e8c2a887a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自网络"></p>
<p>首先问，能不能同时满足这三个条件？</p>
<p>假设有一个系统如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-573b18642806420a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>整个系统由两个节点配合组成，之间通过网络通信，当节点 A 进行更新数据库操作的时候，需要同时更新节点 B 的数据库（这是一个原子的操作）。</p>
<p>上面这个系统怎么满足 CAP 呢？C：当节点A更新的时候，节点B也要更新，A：必须保证两个节点都是可用的，P：当节点 A,B 出现了网络分区，必须保证对外可用。</p>
<p>可见，根本完成不了，只要出现了网络分区，A 就无法满足，因为节点 A 根本连接不上节点 B。如果强行满足 C 原子性，就必须停止服务运行，从而放弃可用性 C。</p>
<p>所以，最多满足两个条件：</p>
<table>
<thead>
<tr>
<th>组 合</th>
<th>分析结果</th>
</tr>
</thead>
<tbody><tr>
<td>CA</td>
<td>满足原子和可用，放弃分区容错。说白了，就是一个整体的应用。</td>
</tr>
<tr>
<td>CP</td>
<td>满足原子和分区容错，也就是说，要放弃可用。当系统被分区，为了保证原子性，必须放弃可用性，让服务停用。</td>
</tr>
<tr>
<td>AP</td>
<td>满足可用性和分区容错，当出现分区，同时为了保证可用性，必须让节点继续对外服务，这样必然导致失去原子性。</td>
</tr>
</tbody></table>
<h2 id="3-能不能解决-3-选-2-的问题"><a href="#3-能不能解决-3-选-2-的问题" class="headerlink" title="3. 能不能解决 3 选 2 的问题"></a>3. 能不能解决 3 选 2 的问题</h2><p>难道真的没有办法解决这个问题吗？</p>
<p>CAP 理论已经提出了 13 年，也许可以做些改变。</p>
<p>仔细想想，分区是百分之百出现的吗？如果不出现分区，那么就能够同时满足 CAP。如果出现了分区，可以根据策略进行调整。比如 C 不必使用那么强的一致性，可以先将数据存起来，稍后再更新，实现所谓的 “最终一致性”。</p>
<p>这个思路又是一个庞大的问题，同时也引出了第二个理论 Base 理论，我们将在后面的文章中详细介绍。</p>
<h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a>4. 引用</h2><ol>
<li><a href="https://item.jd.com/11622772.html">《从 Paxos 到 Zookeeper —— 分布式一致性原理实践》倪超</a></li>
<li><a href="http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed"> CAP理论十二年回顾：”规则”变了</a></li>
<li><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86"> 维基百科CAP定理</a></li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式理论(二)——Base-理论</title>
    <url>/2018/03/26/2018/2018-03-26-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%BA%8C)%E2%80%94%E2%80%94Base-%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       在前文 [分布式理论(一) —— CAP 定理](https://www.jianshu.com/p/4118718658ac) 中，我们说，CAP 不可能同时满足，而分区容错是对于分布式系统而言，是必须的。最后，我们说，如果系统能够同时实现 CAP 是再好不过的了，所以出现了 BASE 理论，今天就来讲讲 Base 理论。

<h2 id="1-什么是-Base-理论"><a href="#1-什么是-Base-理论" class="headerlink" title="1. 什么是 Base 理论"></a>1. 什么是 Base 理论</h2><blockquote>
<p>BASE：全称：Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写，来自 ebay 的架构师提出。</p>
</blockquote>
<p>Base 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的。其核心思想是：</p>
<blockquote>
<p>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
</blockquote>
<h2 id="2-Basically-Available-基本可用"><a href="#2-Basically-Available-基本可用" class="headerlink" title="2. Basically Available(基本可用)"></a>2. Basically Available(基本可用)</h2><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p>
<ol>
<li><p>响应时间上的损失：正常情况下的搜索引擎 0.5 秒即返回给用户结果，而<strong>基本可用</strong>的搜索引擎可以在 1 秒作用返回结果。</p>
</li>
<li><p>功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单，但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p>
</li>
</ol>
<h2 id="3-Soft-state（软状态）"><a href="#3-Soft-state（软状态）" class="headerlink" title="3. Soft state（软状态）"></a>3. Soft state（软状态）</h2><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。</p>
<p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<h2 id="4-Eventually-consistent（最终一致性）"><a href="#4-Eventually-consistent（最终一致性）" class="headerlink" title="4. Eventually consistent（最终一致性）"></a>4. Eventually consistent（最终一致性）</h2><p>这个比较好理解了哈。</p>
<p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性。从而达到数据的最终一致性。这个时间期限取决于网络延时，系统负载，数据复制方案设计等等因素。</p>
<p>稍微官方一点的说法就是：</p>
<blockquote>
<p>系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值。</p>
</blockquote>
<p>而在实际工程实践中，<strong>最终一致性分为 5 种：</strong></p>
<p><strong>1. 因果一致性（Causal consistency）</strong></p>
<p>指的是：如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。</p>
<p><strong>2. 读己之所写（Read your writes）</strong></p>
<p>这种就很简单了，节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p>
<p><strong>3. 会话一致性（Session consistency）</strong></p>
<p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p>
<p><strong>4. 单调读一致性（Monotonic read consistency）</strong></p>
<p>单调读一致性是指如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p>
<p><strong>5. 单调写一致性（Monotonic write consistency）</strong></p>
<p>指一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p>
<p>然而，在实际的实践中，这 5 种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的，比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>总的来说，BASE 理论面向的是大型高可用可扩展的分布式系统，和传统事务的 ACID 是<strong>相反的</strong>，它完全不同于 ACID 的强一致性模型，而是<strong>通过牺牲强一致性</strong>来获得可用性，并允许数据在一段时间是不一致的。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式理论（三）——-一致性协议之-2PC</title>
    <url>/2018/03/27/2018/2018-03-27-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E4%B9%8B-2PC/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       为了使系统尽量能够达到 CAP，于是有了 BASE 协议，而 BASE 协议是在可用性和一致性之间做的取舍和妥协。

<p>人们往往需要在系统的可用性和数据一致性之间反复的权衡。于是呢，就产生我们标题中的一致性协议，而且还不止一个呢。</p>
<p>为了解决分布式问题，涌现了很多经典的算法和协议，最著名的就是二阶段提交协议，三阶段提交协议，Paxos 算法。</p>
<p>本文重点介绍二阶段提交协议，简称 2PC。</p>
<h2 id="1-什么是-2PC"><a href="#1-什么是-2PC" class="headerlink" title="1. 什么是 2PC"></a>1. 什么是 2PC</h2><p>在分布式系统中，会有多个机器节点，因此需要一个 “协调者” ，而各个节点就是 “参与者”，协调者统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点就是 “参与者”。</p>
<p>协调者最终决定这些参与者是否要把事务真正进行提交。正式基于这个思想，有了二阶段提交和 三阶段提交。</p>
<p>2PC ，不是 2 个 pc 机的意思，而是 Two-Phase Commit 。可以认为是一种算法，也可以认为是一种协议，主要目的就是为了保证分布式系统数据的一致性。</p>
<p>协议说明：顾名思义，二阶段提交就是讲事务的提交过程分成了两个阶段来进行处理。流程如下：</p>
<h2 id="2-2PC-阶段一"><a href="#2-2PC-阶段一" class="headerlink" title="2. 2PC 阶段一"></a>2. 2PC 阶段一</h2><h5 id="1-事务询问"><a href="#1-事务询问" class="headerlink" title="1. 事务询问"></a>1. 事务询问</h5><p>协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。</p>
<h5 id="2-执行事务"><a href="#2-执行事务" class="headerlink" title="2. 执行事务"></a>2. 执行事务</h5><p>各参与者节点执行事务操作，并将 Undo 和 Redo 信息记入事务日志中</p>
<h5 id="3-各参与者向协调者反馈事务询问的响应"><a href="#3-各参与者向协调者反馈事务询问的响应" class="headerlink" title="3. 各参与者向协调者反馈事务询问的响应"></a>3. 各参与者向协调者反馈事务询问的响应</h5><p>如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行；如果参与者没有成功执行事务，就返回 No 给协调者，表示事务不可以执行。</p>
<p>从上面可以感觉到，这个一个 所谓的 “投票阶段”，什么意思呢？所有的节点都投票决定是否执行事务操作。</p>
<h2 id="3-2PC-阶段二"><a href="#3-2PC-阶段二" class="headerlink" title="3. 2PC 阶段二"></a>3. 2PC 阶段二</h2><p>在阶段二中，会根据阶段一的投票结果执行 2 种操作：执行事务提交，中断事务。</p>
<p><strong>执行事务提交步骤如下：</strong></p>
<ol>
<li>发送提交请求：协调者向所有参与者发出 commit 请求。</li>
<li>事务提交：参与者收到 commit 请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。</li>
<li>反馈事务提交结果：参与者在完成事务提交之后，向协调者发送 Ack 信息。</li>
<li>协调者接收到所有参与者反馈的 Ack 信息后，完成事务。</li>
</ol>
<p><strong>中断事务步骤如下：</strong></p>
<ol>
<li>发送回滚请求：协调者向所有参与者发出 Rollback 请求。</li>
<li>事务回滚：参与者接收到 Rollback 请求后，会利用其在阶段一种记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li>
<li>反馈事务回滚结果：参与者在完成事务回滚之后，想协调者发送 Ack 信息。</li>
<li>中断事务：协调者接收到所有参与者反馈的 Ack 信息后，完成事务中断。</li>
</ol>
<p>从上面的逻辑可以看出，二阶段提交就做了2个事情：投票，执行。</p>
<blockquote>
<p>核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看成一个强一致性的算法。</p>
</blockquote>
<p>整个事务的执行过程如图（可能不是太直观。。。。）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4ca515b5cd0c4fef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="4-优点缺点"><a href="#4-优点缺点" class="headerlink" title="4. 优点缺点"></a>4. 优点缺点</h2><p>优点：原理简单，实现方便<br>缺点：同步阻塞，单点问题，数据不一致，过于保守</p>
<ol>
<li>同步阻塞：</li>
</ol>
<p>在二阶段提交的过程中，所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。</p>
<ol start="2">
<li>单点问题：</li>
</ol>
<p>协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转，更重要的是：其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。</p>
<ol start="3">
<li>数据不一致：</li>
</ol>
<p>假设当协调者向所有的参与者发送 commti 请求之后，发生了局部网络异常或者是协调者在尚未发送完所有 commit 请求之前自身发生了崩溃，导致最终只有部分参与者收到了 commit 请求。这将导致严重的数据不一致问题。</p>
<ol start="4">
<li>过于保守：</li>
</ol>
<p>如果在二阶段提交的提交询问阶段中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的化，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，显然，这种策略过于保守。换句话说，<strong>二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败</strong>。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>由于 Base 理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法或者说协议，这些协议设计的目的，就是能让分布式系统能够在可用性和一致性之间取得一个很好的平衡，能够基本可用。 比如 2PC，two-phase commit，分为两个阶段提交一个事务：投票，执行。通过协调者和各个参与者的配合，实现一致性协议。</p>
<p>当然，他也是有去缺点的，比如同步阻塞的时候性能较低，协调者的单点问题，网络故障可能引起的数据不一致的问题，执行策略过于保守的问题等等。</p>
<p>这些问题，将在另一个算法 3PC 中解决。我们将在下一篇文章中详细说明。</p>
<p>good luck！！！</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式理论（四）——-一致性协议之-3PC</title>
    <url>/2018/03/28/2018/2018-03-28-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E4%B9%8B-3PC/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>我们说为了实现 BASE 理论，需要在可用性和一致性之间找到一个合适的一致性理论，于是，我们在上篇文章中了解了 2PC 理论，也就是两阶段提交，二阶段提交原理简单，实现方便，但是缺点则是同步阻塞，单点问题，数据不一致，过于保守。</p>
<p>而为了弥补二阶段提交的缺点，研究者们在他的基础上，提出了三阶段提交。</p>
<h2 id="1-什么是三阶段提交"><a href="#1-什么是三阶段提交" class="headerlink" title="1. 什么是三阶段提交"></a>1. 什么是三阶段提交</h2><p>3PC，全称 “three phase commit”，是 2PC 的改进版，其将 2PC 的 “提交事务请求” 过程一分为二。</p>
<p>回忆一下 2PC 的过程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9eade5b9337b3866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>也就是说，3PC 将阶段一 “提交事务请求” 分成了2部分，总共形成了 3 个部分：</p>
<ol>
<li>CanCommit</li>
<li>PreCommit </li>
<li>do Commit</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3dc30375a30462c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3PC"></p>
<h2 id="2-阶段一：CanCommit"><a href="#2-阶段一：CanCommit" class="headerlink" title="2. 阶段一：CanCommit"></a>2. 阶段一：CanCommit</h2><p>第一个阶段： CanCommit</p>
<ol>
<li><p>事务询问：协调者向所有的参与者发送一个包含事务内容的 canCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p>各参与者向协调者反馈事务询问的响应：参与者接收来自协调者的 canCommit 请求，如果参与者认为自己可以顺利执行事务，就返回 Yes，否则反馈 No 响应。</p>
</li>
</ol>
<h2 id="3-阶段-二：PreCommit"><a href="#3-阶段-二：PreCommit" class="headerlink" title="3. 阶段 二：PreCommit"></a>3. 阶段 二：PreCommit</h2><p>协调者在得到所有参与者的响应之后，会根据结果执行2种操作：执行事务预提交，或者中断事务。</p>
<h6 id="1-执行事务预提交分为-3-个步骤："><a href="#1-执行事务预提交分为-3-个步骤：" class="headerlink" title="1. 执行事务预提交分为 3 个步骤："></a>1. 执行事务预提交分为 3 个步骤：</h6><ul>
<li>发送预提交请求：协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态。</li>
<li>事务预提交：参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 中的 “执行事务”，也会 Undo 和 Redo 信息记录到事务日志中。 </li>
<li>各参与者向协调者反馈事务执行的结果：如果参与者成功执行了事务，就反馈 Ack 响应，同时等待指令：提交（commit） 或终止（abor）。</li>
</ul>
<h6 id="2-中断事务也分为2个步骤："><a href="#2-中断事务也分为2个步骤：" class="headerlink" title="2. 中断事务也分为2个步骤："></a>2. 中断事务也分为2个步骤：</h6><ul>
<li>发送中断请求：协调者向所有参与者节点发出 abort 请求 。</li>
<li>中断事务：参与者如果收到 abort 请求或者超时了，都会中断事务。</li>
</ul>
<h2 id="4-阶段三：do-Commit"><a href="#4-阶段三：do-Commit" class="headerlink" title="4. 阶段三：do Commit"></a>4. 阶段三：do Commit</h2><p>该阶段做真正的提交，同样也会出现两种情况：</p>
<h6 id="1-执行提交"><a href="#1-执行提交" class="headerlink" title="1. 执行提交"></a>1. 执行提交</h6><ul>
<li>发送提交请求：进入这一阶段，如果协调者正常工作，并且接收到了所有协调者的 Ack 响应，那么协调者将从 “预提交” 状态变为 “提交” 状态，并向所有的参与者发送 doCommit 请求 。</li>
<li>事务提交：参与者收到 doCommit 请求后，会正式执行事务提交操作，并在完成之后释放在整个事务执行期间占用的事务资源。</li>
<li>反馈事务提交结果：参与者完成事务提交后，向协调者发送 Ack 消息。</li>
<li>完成事务：协调者接收到所有参与者反馈的 Ack 消息后，完成事务。</li>
</ul>
<h6 id="2-中断事务"><a href="#2-中断事务" class="headerlink" title="2. 中断事务"></a>2. 中断事务</h6><p>假设有任何参与者反馈了 no  响应，或者超时了，就中断事务。</p>
<ul>
<li>发送中断请求：协调者向所有的参与者节点发送 abort 请求。</li>
<li>事务回滚：参与者接收到 abort 请求后，会利用其在二阶段记录的 undo 信息来执行事务回滚操作，并在完成回滚之后释放整个事务执行期间占用的资源。</li>
<li>反馈事务回滚结果：参与者在完成事务回滚之后，想协调者发送 Ack 消息。</li>
<li>中断事务：协调者接收到所有的 Ack 消息后，中断事务。</li>
</ul>
<p>注意：一旦进入阶段三，可能会出现 2 种故障：</p>
<ol>
<li>协调者出现问题</li>
<li>协调者和参与者之间的网络故障</li>
</ol>
<p>一段出现了任一一种情况，最终都会导致参与者无法收到 doCommit 请求或者 abort 请求，针对这种情况，参与者都会在等待超时之后，继续进行事务提交。</p>
<h2 id="5-总结："><a href="#5-总结：" class="headerlink" title="5. 总结："></a>5. 总结：</h2><p>优点：相比较 2PC，最大的优点是减少了参与者的阻塞范围（第一个阶段是不阻塞的），并且能够在单点故障后继续达成一致（2PC 在提交阶段会出现此问题，而 3PC 会根据协调者的状态进行回滚或者提交）。</p>
<p>缺点：如果参与者收到了 preCommit 消息后，出现了网络分区，那么参与者等待超时后，都会进行事务的提交，这必然会出现事务不一致的问题。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式理论(五)——-一致性算法-Paxos</title>
    <url>/2018/03/29/2018/2018-03-29-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%BA%94)%E2%80%94%E2%80%94-%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Paxos/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>Paxos 算法如同我们标题大图：世界上只有一种一致性算法，就是 Paxos。出自一位 google 大神之口。</p>
<p>同时，Paxos 也是出名的晦涩难懂，推理过程极其复杂。楼主在尝试理解 Paxos 算法的过程中历经挫折。</p>
<p>今天，楼主不会讲推理过程，因为就算是尝试使用大白话来讲，也非常的难懂。当然更不会讲数学公式。</p>
<p>而是从一个普通 Java 程序员的角度来理解 Paxos 算法。</p>
<h2 id="1-什么是-Paxos-算法"><a href="#1-什么是-Paxos-算法" class="headerlink" title="1. 什么是 Paxos 算法"></a>1. 什么是 Paxos 算法</h2><p>Paxos 算法由图灵奖获得者 Leslie Lamport 于 1990 年提出的一种基于消息传递且具有高度容错的特性的一致性算法。</p>
<p>来看看大师的样貌：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d3dc929240b8f0e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Leslie Lamport（莱斯利·兰波特）"></p>
<p>标准的程序员。。。。</p>
<p>Paxos 有点类似我们之前说的 2PC，3PC，但是解决了他们俩的各种硬伤。该算法在很多大厂都得到了工程实践，比如阿里的 OceanBase 的分布式数据库，底层就是使用的 paxos 算法。再比如 Google 的 chubby 分布式锁也是用的这个算法。可见该算法在分布式系统中的地位，甚至于，paxos 就是分布式一致性的代名词。</p>
<h2 id="2-Paxos-解决了什么问题"><a href="#2-Paxos-解决了什么问题" class="headerlink" title="2. Paxos 解决了什么问题"></a>2. Paxos 解决了什么问题</h2><p>那么它解决了什么问题呢？<br>答：解决了一致性问题。</p>
<p>什么是 consensus （一致性）问题？</p>
<p>在一个分布式系统中，有一组的 process，每个 process 都可以提出一个 value，consensus 算法就是用来从这些 values 里选定一个最终 value。如果没有 value 被提出来，那么就没有 value 被选中；如果有1个 value 被选中，那么所有的 process 都应该被通知到。</p>
<p>我们假设一种情况，在一个集群环境中，要求所有机器上的状态是一致的，其中有2台机器想修改某个状态，机器 A 想把状态改为 A，机器 B 想把状态改为 B，那么到底听谁的呢？</p>
<p>有人说，可以像 2PC，3PC 一样引入一个协调者，谁先到，听谁的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-138fec3412382850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>但是如果，协调者宕机了呢？</p>
<p>所以需要对协调者也做备份，也要做集群。这时候，问题来了，这么多协调者，听谁的呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8cdcb216bb7a10b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Paxos 算法就是为了解决这个问题而生的！！！ 牛不？</p>
<p>下面，楼主会尝试用自己的语言配合图，来解释使用 Paxos 算法来解决这样一个类似问题的过程。如果解释的不好，还请见谅。但楼主不会去写任何的算法推导过程，如果各位想看，文末有 Paxos 论文链接，和很多大牛写的推导过程。</p>
<p>开始吧！</p>
<h2 id="3-Paxos-例子说明"><a href="#3-Paxos-例子说明" class="headerlink" title="3. Paxos 例子说明"></a>3. Paxos 例子说明</h2><p>楼主这个例子来自中文维基百科，但楼主为了形象化，辅以图片解释，但愿不会让人更迷糊。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>在 Paxos 岛上，有A1, A2, A3, A4, A5 5位议员，就税率问题进行决议。我们假设几个场景来解释：</p>
<h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景 1."></a>场景 1.</h4><p>假设 A1 说：税率应该是 10%。而此时只有他一个人提这个建议。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a8942ad847e30fe4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>很完美，没有任何人和他竞争提案，他的这个提案毫无阻挠的通过了。A2 - A5 都会回应他：<code>我们收到了你的提案，等待最终的批准。</code>而 A1 在收到 2 份回复后，就可以发布最终的决议：<code>税率定位 10%，不用再讨论了。</code></p>
<p>这里有个注意的地方就是：为什么收到了 2 份回复就可以确定提案了呢？<br>答：因为包括他自己，就达到 3 个人了，<code>少数服从多数。</code><br>如果各位听说过鸽笼原理/抽屉原理，就明白个大概了。有人说，<code>鸽笼原理/抽屉原理就是 Paxos 的核心思想。</code></p>
<h4 id="场景-2："><a href="#场景-2：" class="headerlink" title="场景 2："></a>场景 2：</h4><p>现在我们假设在 A1 提出 10% 税率提案的同时, A5 决定将税率定为 20%，如果这个提案要通过侍从送到其他议员的案头，A1 的草案将由 4 位侍从送到 A2-A5 那里。但是侍从不靠谱（代表分布式环境不靠谱），负责 A2 和 A3 的侍从顺利送达，而负责 A4 和 A5 的侍从则开溜了！</p>
<p>而 A5 的草案则送到了 A4 和 A3 的手中。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-16ed1e944c9a3164.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>现在，A1 ，A2，A3 收到了 A1 的提案，A3，A4， A5 收到 A5 的提案，按照 Paxos 的协议，A1，A2，A4，A5 4个侍从将接受他们的提案，侍从拿着回复：<code>我已收到你的提案，等待最终批准</code> 回到提案者那里。</p>
<p>而 A3 的行为将决定批准哪一个。</p>
<p>当 A3 同时收到了 A1 和 A5 的请求，该如何抉择呢？不同的抉择将会导致不同的结果。</p>
<p>有 3 种情况，我们分析一下：</p>
<h4 id="场景2：情况一"><a href="#场景2：情况一" class="headerlink" title="场景2：情况一"></a>场景2：情况一</h4><p>假设 A1 的提案先送到 A3 那里，并且 A3 接受了该提案并回复了侍从。这样，A1 加上 A2 加上 A3，构成了多数派，成功确定了税率为 10%。 而 A5 的侍从由于路上喝酒喝多了，晚到了一天，等他到了，税率已经确定了，A3 回复 A5：<code>兄弟，你来的太晚了，税率已经定好了，不用折腾了，听 A1 的吧</code>。</p>
<p>如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8225ccdd35b12857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="场景2：情况二"><a href="#场景2：情况二" class="headerlink" title="场景2：情况二"></a>场景2：情况二</h4><p>依然假设 A1 的提案先送到 A3 处，但是这次 A5 的侍从不是放假了，只是中途耽搁了一会。这次, A3 依然会将”接受”回复给 A1 .但是在决议成型之前它又收到了 A5 的提案。这时协议根据 A5 的身份地位有两种处理方式，但结果相同。</p>
<ol>
<li>当 A5 地位很高，例如 CEO，就回复 A5：<code>我已收到您的提案，等待最终批准，但是您之前有人提出将税率定为10%,请明察。</code></li>
<li>当 A5 没地位，普通码农一个，直接不回复。等待 A1 广播：<code>税率定为 10% 啦！！！</code></li>
</ol>
<p>如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e78d51fcb7950709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="场景2：情况三"><a href="#场景2：情况三" class="headerlink" title="场景2：情况三"></a>场景2：情况三</h4><p>在这个情况中，我们将看见，根据提案的时间及提案者的权势决定<code>是否应答</code>是有意义的。在这里，时间和提案者的权势就构成了给提案编号的依据。这样的编号符合”任何两个提案之间构成偏序”的要求。</p>
<p>A1 和 A5 同样提出上述提案，这时 A1 可以正常联系 A2 和 A3，A5 也可以正常联系这两个人。这次 A2 先收到 A1 的提案; A3 则先收到 A5 的提案。而 A5 <code>更有地位</code>。</p>
<p>在这种情况下，已经回答 A1 的 A2 发现有比 A1 更有权势的 A5 提出了税率 20% 的新提案，于是回复A5说：<code>我已收到您的提案，等待最终批准。</code></p>
<p>而回复 A5 的 A3 发现新的提案者A1是个小人物，<code>没地位不予应答</code>。</p>
<p>此时，A5 得到了 A2，A3 的回复，于是 A5 说：<code>税率定为 20%，别再讨论了</code>。</p>
<p>那 A4 呢？ A4 由于睡过头了，迷迷糊糊的说：<code>现有的税率是什么? 如果没有决定，则建议将其定为 15%.</code></p>
<p>这个时候，其他的议员就告诉他：<code>哥们，已经定为 20% 了，别折腾了。洗洗继续睡吧</code>。</p>
<p>整个过程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6d4bb868d27fc6ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>从上面的例子可以看出：这个 Paxos 协议/算法 就是少数服从多数，标准的 <a href="https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776?fr=aladdin&fromid=8942185&fromtitle=%E9%B8%BD%E7%AC%BC%E5%8E%9F%E7%90%86">鸽笼原理/抽屉原理</a>，同时，还会根据议员的身份来判断是否需要应答，这个身份其实就是一个编号，是为了防止出现活性导致死循环。</p>
<p>注意：这一切都是在没有 <code>拜占庭将军</code> 问题的基础上建立的，即消息不会被篡改（因为分布式大多在局域网中）。</p>
<p>Paxos 的目标：保证最终有一个提案会被选定，当提案被选定后，其他议员最终也能获取到被选定的提案。</p>
<p>Paxos 协议用来解决的问题可以用一句话来简化： 将所有节点都写入同一个值，且被写入后不再更改。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.zhihu.com/question/19787937">如何浅显易懂地解说 Paxos 的算法？</a><br> <a href="http://blog.xiaohansong.com/2016/09/30/Paxos/" title="图解 Paxos 一致性协议">图解 Paxos 一致性协议</a><br> <a href="http://www.cnblogs.com/linbingdong/p/6253479.html">分布式系列文章——Paxos算法原理与推导</a><br><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95">Paxos算法 维基百科，自由的百科全书</a><br><a href="https://wenku.baidu.com/view/bf8e118fa0116c175f0e4853.html?from=search">Paxos Made Simple【翻译】</a><br><a href="https://wenku.baidu.com/view/87276e1dfad6195f312ba6d7.html">The Part-Time Parliament(Paxos算法中文翻译)</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式理论(六)——-Raft-算法</title>
    <url>/2018/03/30/2018/2018-03-30-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E5%85%AD)%E2%80%94%E2%80%94-Raft-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       我们之前讲述了 Paxos 一致性算法，虽然楼主尝试用最简单的算法来阐述，但仍然还是有点绕。楼主最初怀疑自己太笨，后来才直到，该算法的晦涩难懂不是只有我一个人这么认为，而是国际公认！

<p>所以 Paxos 算法在 1990 就发表出来，但却得不到运用。真正的名声大噪还是在兰伯特使用 “更简单” 的方式重写了一篇论文才开始。</p>
<p>这些和今天说的 Raft 有什么关系呢？</p>
<p>答：Raft 也是一个一致性算法，和 Paxos 目标相同。但他还有另一个名字：易于理解的一致性算法。</p>
<p>也就是说，他的目标就是成为一个易于理解的一致性算法。以替代 Paxos 的晦涩难懂。</p>
<p>那我们就开始讲讲 Raft 算法吧！</p>
<h2 id="1-什么是-Raft-算法"><a href="#1-什么是-Raft-算法" class="headerlink" title="1. 什么是 Raft 算法"></a>1. 什么是 Raft 算法</h2><p>首先说什么是 Raft 算法：<strong>Raft 是一种为了管理复制日志的一致性算法。</strong></p>
<p>什么是一致性呢？<br>Raft 的论文这么说的：一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。</p>
<p>这里的<code>一致性</code>针对分布式系统。</p>
<p>什么是管理日志呢？<br>一致性算法是从复制状态机的背景下提出的，复制状态机通常都是<code>基于复制日志</code>实现的，这个日志可以理解为一个比喻，相当于一个指令。</p>
<p>关于状态机的描述：</p>
<blockquote>
<p>多个节点上，从相同的初始状态开始，执行相同的一串命令，产生相同的最终状态。实际上，与其说是一致，其实可以泛化为分布式的两个节点状态存在某种约束。<br>复制状态机通常都是基于复制日志实现的，<strong>保证复制日志相同就是一致性算法的工作了。</strong><br>典型应用就是一个独立的的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。</p>
</blockquote>
<p>对于 Raft 更重要的应该是 <code>易于理解</code>。从 Raft 的论文题目就可以看出：<code>In Search of an Understandable Consensus Algorithm (Extended Version)</code>。这里的易于理解是相对于 Paxos 的，在他的论文中，和 Paxos 做了大量针对 <code>易于理解</code> 的对比和统计测试。</p>
<p>从楼主阅读论文的过程中来看，Raft 相较于 Paxos 确实更易于理解。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。</p>
<p>而和一致性最相关的就是前面 2 个模块：领导人选举和日志复制。</p>
<h2 id="2-领导人选举"><a href="#2-领导人选举" class="headerlink" title="2. 领导人选举"></a>2. 领导人选举</h2><p>Raft 通过选举一个高贵的领导人，然后给予他全部的管理复制日志的责任来实现一致性。</p>
<p>而每个 server 都可能会在 3 个身份之间切换：</p>
<ul>
<li>领导者</li>
<li>候选者</li>
<li>跟随者</li>
</ul>
<p>而影响他们身份变化的则是 <code>选举</code>。<br>当所有服务器初始化的时候，都是 <code>跟随者</code>，这个时候需要一个 <code>领导者</code>，所有人都变成 <code>候选者</code>，直到有人成功当选 <code>领导者</code>。</p>
<p>角色轮换如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-56571f0026939037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="角色变化图"></p>
<p>而领导者也有宕机的时候，宕机后引发新的 <code>选举</code>，所以，整个集群在选举和正常运行之间切换，具体如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-484b50efc95c219a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从上图可以看出，选举和正常运行之间切换，但请注意， 上图中的 term 3 有一个地方，后面没有跟着 <code>正常运行</code> 阶段，为什么呢?</p>
<p>答：当一次选举失败（比如正巧每个人都投了自己），就执行一次 <code>加时赛</code>，每个 Server 会在一个随机的时间里重新投票，这样就能保证不冲突了。所以，当 term 3 选举失败，等了几十毫秒，执行 term 4 选举，并成功选举出领导人。</p>
<p>接着，领导者周期性的向所有跟随者发送心跳包来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，那么他就会认为系统中没有可用的领导者,并且发起选举以选出新的领导者。</p>
<p>要开始一次选举过程，跟随者先要增加自己的当前任期号并且<strong>转换到候选人状态</strong>。然后请求其他服务器<code>为自己投票</code>。那么会产生 3 种结果：</p>
<p>a. 自己成功当选<br>b. 其他的服务器成为领导者<br>c. 僵住，没有任何一个人成为领导者</p>
<p>注意：</p>
<ol>
<li>每一个 server 最多在一个任期内投出一张选票（有任期号约束），先到先得。</li>
<li>要求最多只能有一个人赢得选票。</li>
<li>一旦成功，立即成为领导人，然后广播所有服务器停止投票阻止新得领导产生。</li>
</ol>
<p>僵住怎么办？ Raft 通过使用随机选举超时时间（例如 150 - 300 毫秒）的方法将服务器打散投票。每个候选人在僵住的时候会随机从一个时间开始重新选举。</p>
<p>以上，就是 Raft 所有关于领导选举的策略。</p>
<h2 id="3-日志复制"><a href="#3-日志复制" class="headerlink" title="3. 日志复制"></a>3. 日志复制</h2><p>一旦一个领导人被选举出来，他就开始为客户端提供服务。</p>
<p>客户端发送日志给领导者，随后领导者将日志复制到其他的服务器。如果跟随者故障，领导者将会尝试重试。直到所有的跟随者都成功存储了所有日志。</p>
<p>下图表示了当一个客户端发送一个日志给领导者，随后领导者复制给跟随者的整个过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-dced1da5a414c2a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>4 个步骤：</p>
<ol>
<li>客户端提交</li>
<li>复制数据到所有跟随者</li>
<li>跟随者回复 <code>确认收到</code></li>
<li>领导者回复客户端和所有跟随者 <code>确认提交</code>。</li>
</ol>
<p>可以看到，直到第四步骤，整个事务才会达成。中间任何一个步骤发生故障，都不会影响日志一致性。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>总结一下本文吧：</p>
<p>Raft 算法如同他的论文名字一样：<code>寻找一种易于理解的一致性算法</code>，这里的 <code>易于理解</code> 是相对于 Paxos 的，的确，Paxos 实在过于复杂了。</p>
<p>而如何实现易于理解？</p>
<p>答：Raft 将一致性算法分成了2部分：领导选举，日志复制。</p>
<p>领导选举基于一个随机的时间来保证不会冲突（如果冲突的话）。<br>而日志复制则类似于 2PC。</p>
<p>通常 5 个节点，只要不超过 2 个节点死亡都不会影响系统的运行。保证了系统的可用性，通过领导者的日志复制，实现了系统的一致性。</p>
<p>似乎 CAP 定理已经不起作用了，当然这又是一个重大的话题。</p>
<p>最后，以 Raft 论文的结尾结束本位：</p>
<blockquote>
<p>算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。</p>
</blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">寻找一种易于理解的一致性算法（扩展版）Raft 中文翻译</a><br><a href="https://github.com/maemual/raft-zh_cn">Raft 英文原文</a><br><a href="http://www.cnblogs.com/mindwind/p/5231986.html">Raft 为什么是更易理解的分布式一致性算法</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式理论(七)——--一致性协议之-ZAB</title>
    <url>/2018/03/31/2018/2018-03-31-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E4%B8%83)%E2%80%94%E2%80%94--%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E4%B9%8B-ZAB/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       在前面的文章中，我们说了很多一致性协议，比如 Paxos，Raft，2PC，3PC等等，今天我们再讲一种协议，ZAB 协议，该协议应该是所有一致性协议中生产环境中应用最多的了。为什么呢？因为他是为 Zookeeper 设计的分布式一致性协议！



<h2 id="1-什么是-ZAB-协议？-ZAB-协议介绍"><a href="#1-什么是-ZAB-协议？-ZAB-协议介绍" class="headerlink" title="1. 什么是 ZAB 协议？ ZAB 协议介绍"></a>1. 什么是 ZAB 协议？ ZAB 协议介绍</h2><ol>
<li><p>ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。</p>
</li>
<li><p>Zookeeper 是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper 并没有使用 Paxos ，而是采用了 ZAB 协议。</p>
</li>
<li><p>ZAB 协议定义：<strong>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持 <code>崩溃恢复</code> 和 <code>原子广播</code> 协议</strong>。下面我们会重点讲这两个东西。</p>
</li>
<li><p>基于该协议，Zookeeper 实现了一种 <code>主备模式</code> 的系统架构来保持集群中各个副本之间<code>数据一致性</code>。具体如下图所示：</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a351e61d6ab6a3cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上图显示了 Zookeeper 如何处理集群中的数据。所有客户端写入数据都是写入到 主进程（称为 Leader）中，然后，由 Leader 复制到备份进程（称为 Follower）中。从而保证数据一致性。从设计上看，和 Raft 类似。</p>
<ol start="5">
<li>那么复制过程又是如何的呢？复制过程类似 2PC，ZAB 只需要 Follower 有一半以上返回 Ack 信息就可以执行提交，大大减小了同步阻塞。也提高了可用性。</li>
</ol>
<p>简单介绍完，开始重点介绍 <code>消息广播</code> 和 <code>崩溃恢复</code>。<strong>整个 Zookeeper 就是在这两个模式之间切换。</strong> 简而言之，当 Leader 服务可以正常使用，就进入消息广播模式，当 Leader 不可用时，则进入崩溃恢复模式。</p>
<h2 id="2-消息广播"><a href="#2-消息广播" class="headerlink" title="2. 消息广播"></a>2. 消息广播</h2><p>ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 <strong>二阶段提交过程</strong>。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行 commit 操作（先提交自己，再发送 commit 给所有 Follwer）。</p>
<p><strong>基本上，整个广播流程分为 3 步骤：</strong></p>
<p>1.将数据都复制到 Follwer 中</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c2cb3f3b2b8b5841.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol start="2">
<li>等待 Follwer 回应 Ack，最低超过半数即成功</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-2fe8ee18eef3701c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol start="3">
<li>当超过半数成功回应，则执行 commit ，同时提交自己</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8fe90fc287f2faca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>通过以上 3 个步骤，就能够保持集群之间数据的一致性。实际上，在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，避免同步，实现异步解耦。</p>
<p><strong>还有一些细节：</strong></p>
<ol>
<li><p>Leader 在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一 ID，称为事务ID（ZXID），ZAB 兮协议需要保证事务的顺序，因此必须将每一个事务按照 ZXID 进行先后排序然后处理。</p>
</li>
<li><p>在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞。</p>
</li>
<li><p>zookeeper集群中为保证任何所有进程能够有序的顺序执行，只能是 Leader 服务器接受写请求，即使是 Follower 服务器接受到客户端的请求，也会转发到 Leader 服务器进行处理。</p>
</li>
<li><p>实际上，这是一种简化版本的 2PC，不能解决单点问题。等会我们会讲述 ZAB 如何解决单点问题（即 Leader 崩溃问题）。</p>
</li>
</ol>
<h2 id="3-崩溃恢复"><a href="#3-崩溃恢复" class="headerlink" title="3. 崩溃恢复"></a>3. 崩溃恢复</h2><p>刚刚我们说消息广播过程中，Leader 崩溃怎么办？还能保证数据一致吗？如果 Leader 先本地提交了，然后 commit 请求没有发送出去，怎么办？</p>
<p>实际上，当 Leader 崩溃，即进入我们开头所说的崩溃恢复模式（崩溃即：Leader 失去与过半 Follwer 的联系）。下面来详细讲述。</p>
<p>假设1：Leader 在复制数据给所有 Follwer 之后崩溃，怎么办？<br>假设2：Leader 在收到 Ack 并提交了自己，同时发送了部分 commit 出去之后崩溃怎么办？</p>
<p><strong>针对这些问题，ZAB 定义了 2 个原则：</strong></p>
<ol>
<li>ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。</li>
<li>ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。</li>
</ol>
<p>所以，ZAB 设计了下面这样一个选举算法：<br><strong>能够确保提交已经被 Leader 提交的事务，同时丢弃已经被跳过的事务。</strong></p>
<p>针对这个要求，如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群总所有机器编号（即 ZXID 最大）的事务，那么就能够保证这个新选举出来的 Leader 一定具有所有已经提交的提案。<br>而且这么做有一个好处是：<strong>可以省去 Leader 服务器检查事务的提交和丢弃工作的这一步操作。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-992f9f7b32c4df32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样，我们刚刚假设的两个问题便能够解决。假设 1 最终会丢弃调用没有提交的数据，假设 2 最终会同步所有服务器的数据。这个时候，就引出了一个问题，如何同步？</p>
<h2 id="4-数据同步"><a href="#4-数据同步" class="headerlink" title="4. 数据同步"></a>4. 数据同步</h2><p>当崩溃恢复之后，需要在正式工作之前（接收客户端请求），Leader 服务器首先确认事务是否都已经被过半的 Follwer 提交了，即是否完成了数据同步。目的是为了保持数据一致。</p>
<p>当所有的 Follwer 服务器都成功同步之后，Leader 会将这些服务器加入到可用服务器列表中。</p>
<p>实际上，Leader 服务器处理或丢弃事务都是依赖着 ZXID 的，那么这个 ZXID 如何生成呢？</p>
<p>答：在 ZAB 协议的事务编号 ZXID 设计中，ZXID 是一个 64 位的数字，其中低 32 位可以看作是一个简单的递增的计数器，针对客户端的每一个事务请求，Leader 都会产生一个新的事务 Proposal 并对该计数器进行 + 1 操作。</p>
<p>而高 32 位则代表了 Leader 服务器上取出本地日志中最大事务 Proposal 的 ZXID，并从该 ZXID 中解析出对应的 epoch 值，然后再对这个值加一。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-47e58920c2d33f33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>高 32 位代表了每代 Leader 的唯一性，低 32 代表了每代 Leader 中事务的唯一性。同时，也能让 Follwer 通过高 32 位识别不同的 Leader。简化了数据恢复流程。</p>
<p>基于这样的策略：当 Follower 链接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行比对，比对结果要么回滚，要么和 Leader 同步。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>到了总结的时刻了。</p>
<p>ZAB 协议和我们之前看的 Raft 协议实际上是有相似之处的，比如都有一个 Leader，用来保证一致性（Paxos 并没有使用 Leader 机制保证一致性）。再有采取过半即成功的机制保证服务可用（实际上 Paxos 和 Raft 都是这么做的）。</p>
<p>ZAB 让整个 Zookeeper 集群在两个模式之间转换，消息广播和崩溃恢复，消息广播可以说是一个简化版本的 2PC，通过崩溃恢复解决了 2PC 的单点问题，通过队列解决了 2PC 的同步阻塞问题。</p>
<p>而支持崩溃恢复后数据准确性的就是数据同步了，数据同步基于事务的 ZXID 的唯一性来保证。通过 + 1 操作可以辨别事务的先后顺序。</p>
<p>好了，关于 ZAB 协议就介绍到这里，篇幅有限，难免疏漏。</p>
<p>good luck！！！！</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://search.jd.com/Search?keyword=%E4%BB%8E%20Paxos%20%E5%88%B0%20Zookeeper%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5&enc=utf-8&wq=%E4%BB%8E%20Paxos%20%E5%88%B0%20Zookeeper%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5&pvid=776b62609b5a42fe875f5e520404cb0d">《从 Paxos 到 Zookeeper——分布式一致性原理和实践》</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式理论(八)——-Consistent-Hash（一致性哈希算法）</title>
    <url>/2018/03/31/2018/2018-03-31-%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA(%E5%85%AB)%E2%80%94%E2%80%94-Consistent-Hash%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->在分布式系统中，常常需要使用缓存，而且通常是集群，访问缓存和添加缓存都需要一个 hash 算法来寻找到合适的 Cache 节点。但，通常不是用取余hash，而是使用我们今天的主角—— 一致性 hash 算法。

<p>今天楼主就来说说这个一致性 hash 算法。</p>
<h2 id="1-为什么普通的-hash-算法不行？"><a href="#1-为什么普通的-hash-算法不行？" class="headerlink" title="1. 为什么普通的 hash 算法不行？"></a>1. 为什么普通的 hash 算法不行？</h2><p>普通的 hash 算法通常都是对机器数量进行取余，比如集群环境中有 3 台 redis，当我们放入对象的时候，通常是对 3 进行取余。这种做法在大部分情况下是没有问题的。但是，注意：如果缓存机器需要增减，问题就来了。</p>
<p>什么问题呢？</p>
<p>假设原本是 3 个 redis，这时候，加了一台 redis，那么取余算法就变成了取余 4。</p>
<p>这样有什么问题呢？<br>答：当使用负载均衡的时候，负载均衡器根据对象的 key 对机器进行取余，这个时候，原有的 key 取余现有的机器数 4 就找不到那台机器了！笨一点的办法，就是在增加机器的时候，清除所有缓存，但这会导致缓存击穿甚至缓存雪崩，严重情况下引发 DB 宕机。</p>
<h2 id="2-一致性-hash-怎么解决这个问题？"><a href="#2-一致性-hash-怎么解决这个问题？" class="headerlink" title="2. 一致性 hash 怎么解决这个问题？"></a>2. 一致性 hash 怎么解决这个问题？</h2><p>很简单，既然问题出在对机器取余上，那么就不对机器取余。</p>
<p>具体怎么做呢？</p>
<p>答：我们可以假设有一个 2 的 32 次方的环形，缓存节点通过 hash 落在环上。而对象的添加也是使用 hash，但很大的几率是 hash 不到缓存节点的。怎么办呢？<strong>找离他最近的那个节点。</strong> 比如顺时针找前面那个节点。</p>
<p>能解决问题吗？想象一下：当增减机器时，环形节点变化的只会影响一个节点，就是新节点的顺时针方向的前面的节点。这个时候，我们只需要清除那一个节点的数据就足够了，不用想取余 hash 那样，清除所有节点的数据。</p>
<p>具体类似于下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-cb43963c48dac733.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上图中，节点中的五角星代表对象，红绿黄代表节点，每个对象都会找他的上一个节点。如有增减，只影响一个节点。</p>
<p>如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3c6371dba3a417bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>红色和绿色节点不受影响。</p>
<h2 id="3-一致性-hash-有什么问题呢？"><a href="#3-一致性-hash-有什么问题呢？" class="headerlink" title="3. 一致性 hash 有什么问题呢？"></a>3. 一致性 hash 有什么问题呢？</h2><p>是否这么做就完美了呢？</p>
<p>不是的。</p>
<p>如果认真看是上面的图的话，会发现，黄色节点的负载压力最大，这个集群环境负载不够均衡。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-0dfd0d3194269df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>什么原因导致的呢？原因是：如果缓存节点分布不均匀，就会出现这样的情况。但是，你不能奢望是均匀的。</p>
<p>怎么办呢？</p>
<p>我们可以在不均的地方给他弄均匀。在空闲的地方加入 <strong>虚拟节点</strong>，这些节点的数据映射到真实节点上，就可以了，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a567df4d45038e90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上图中，我们给每个节点都做了虚拟节点（虚线），从而让整个集群在 hash 环比较均匀，从图中也可以看出，这样现对比之前均匀多了，黄色节点的负载和绿色节点额的负载相同。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>总的来说，一致性 hash 还是比较简单的。核心思想是，不使用对机器取余的算法。这样就能避免机器增减带来的影响。</p>
<p>同时，使用 <code>就近寻址</code> 的方式找到最近的节点。当然，这会引起负载不均衡，所以需要引入虚拟节点的方式，变相的增加节点，让整个集群的负载能够均衡。</p>
<p>后面，我们将自己写一个一致性 hash 算法以加深印象。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>自己实现一个一致性-Hash-算法</title>
    <url>/2018/03/31/2018/2018-03-31-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%80%E8%87%B4%E6%80%A7-Hash-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>在前文<a href="https://www.jianshu.com/p/58fde9b2d0a3">分布式理论(八)—— Consistent Hash（一致性哈希算法）</a>中，我们讨论了一致性 hash 算法的原理，并说了，我们会自己写一个简单的算法。今天就来写一个。</p>
<h2 id="普通-hash-的结果"><a href="#普通-hash-的结果" class="headerlink" title="普通 hash 的结果"></a>普通 hash 的结果</h2><p>先看看普通 hash 怎么做。</p>
<p>首先，需要缓存节点对象，缓存中的存储对象，还有一个缓存节点集合，用于保存有效的缓存节点。</p>
<ol>
<li>实际存储对象，很简单的一个类，只需要获取他的 hash 值就好：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">  String key;</span><br><span class="line">  Obj(String key) &#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Obj&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;key=&#x27;&quot;</span> + key + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>缓存节点对象，用于存储实际对象：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Map&lt;Integer, Obj&gt; node = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  Node(String name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObj</span><span class="params">(Obj obj)</span> </span>&#123;</span><br><span class="line">    node.put(obj.hashCode(), obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Obj <span class="title">getObj</span><span class="params">(Obj obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.get(obj.hashCode());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也很简单，内部使用了一个 map 保存节点。</p>
<ol start="3">
<li>缓存节点集合，用于保存有效的缓存节点：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Node[] nodes = <span class="keyword">new</span> Node[<span class="number">1024</span>];</span><br><span class="line">   <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     nodes[size++] = node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">Obj <span class="title">get</span><span class="params">(Obj obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> index = obj.hashCode() % size;</span><br><span class="line">     <span class="keyword">return</span> nodes[index].getObj(obj);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Obj obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> index = obj.hashCode() % size;</span><br><span class="line">     nodes[index].putObj(obj);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内部一个数组，取数据时，通过取余机器数量获取缓存节点，再从节点中取出数据。</p>
<ol start="4">
<li>测试：当增减节点时，还能不能找到原有数据：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 验证普通 hash 对于增减节点，原有会不会出现移动。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   NodeArray nodeArray = <span class="keyword">new</span> NodeArray();</span><br><span class="line"></span><br><span class="line">   Node[] nodes = &#123;</span><br><span class="line">       <span class="keyword">new</span> Node(<span class="string">&quot;Node--&gt; 1&quot;</span>),</span><br><span class="line">       <span class="keyword">new</span> Node(<span class="string">&quot;Node--&gt; 2&quot;</span>),</span><br><span class="line">       <span class="keyword">new</span> Node(<span class="string">&quot;Node--&gt; 3&quot;</span>)</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">     nodeArray.addNode(node);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Obj[] objs = &#123;</span><br><span class="line">       <span class="keyword">new</span> Obj(<span class="string">&quot;1&quot;</span>),</span><br><span class="line">       <span class="keyword">new</span> Obj(<span class="string">&quot;2&quot;</span>),</span><br><span class="line">       <span class="keyword">new</span> Obj(<span class="string">&quot;3&quot;</span>),</span><br><span class="line">       <span class="keyword">new</span> Obj(<span class="string">&quot;4&quot;</span>),</span><br><span class="line">       <span class="keyword">new</span> Obj(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (Obj obj : objs) &#123;</span><br><span class="line">     nodeArray.put(obj);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   validate(nodeArray, objs);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(NodeArray nodeArray, Obj[] objs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Obj obj : objs) &#123;</span><br><span class="line">    System.out.println(nodeArray.get(obj));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nodeArray.addNode(<span class="keyword">new</span> Node(<span class="string">&quot;anything1&quot;</span>));</span><br><span class="line">  nodeArray.addNode(<span class="keyword">new</span> Node(<span class="string">&quot;anything2&quot;</span>));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;========== after  =============&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Obj obj : objs) &#123;</span><br><span class="line">    System.out.println(nodeArray.get(obj));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试步骤如下：</p>
<ol>
<li>向集合中添加 3 个节点。</li>
<li>向 <code>集群</code> 中添加 5 个对象，这 5 个对象会根据 hash 值散列到不同的节点中。</li>
<li>打印 <code>未增减前</code> 的数据。</li>
<li>打印 <code>增加 2 个节点</code> 后数据，看看还能不能访问到数据。</li>
</ol>
<p>结果：</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/4236553-77dfadca6f7a69d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>一个都访问不到了。这就是普通的取余的缺点，在增减机器的情况下，这种结果无法接收。</p>
<p>再看看一致性 hash 如何解决。</p>
<h2 id="一致性-Hash-的结果"><a href="#一致性-Hash-的结果" class="headerlink" title="一致性 Hash 的结果"></a>一致性 Hash 的结果</h2><p>关键的地方来了。</p>
<p>缓存节点对象和实际保存对象不用更改，改的是什么？</p>
<p>改的是保存对象的方式和取出对象的方式，也就是不使用对机器进行取余的算法。</p>
<p>新的 NodeArray 对象如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 按照 键 排序*/</span></span><br><span class="line">TreeMap&lt;Integer, Node&gt; nodes = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  nodes.put(node.hashCode(), node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Obj obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> objHashcode = obj.hashCode();</span><br><span class="line">  Node node = nodes.get(objHashcode);</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.putObj(obj);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到比给定 key 大的集合</span></span><br><span class="line">  SortedMap&lt;Integer, Node&gt; tailMap = nodes.tailMap(objHashcode);</span><br><span class="line">  <span class="comment">// 找到最小的节点</span></span><br><span class="line">  <span class="keyword">int</span> nodeHashcode = tailMap.isEmpty() ? nodes.firstKey() : tailMap.firstKey();</span><br><span class="line">  nodes.get(nodeHashcode).putObj(obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Obj <span class="title">get</span><span class="params">(Obj obj)</span> </span>&#123;</span><br><span class="line">  Node node = nodes.get(obj.hashCode());</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.getObj(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到比给定 key 大的集合</span></span><br><span class="line">  SortedMap&lt;Integer, Node&gt; tailMap = nodes.tailMap(obj.hashCode());</span><br><span class="line">  <span class="comment">// 找到最小的节点</span></span><br><span class="line">  <span class="keyword">int</span> nodeHashcode = tailMap.isEmpty() ? nodes.firstKey() : tailMap.firstKey();</span><br><span class="line">  <span class="keyword">return</span> nodes.get(nodeHashcode).getObj(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类和之前的类的不同之处在于：</p>
<ol>
<li>内部没有使用数组，而是使用了有序 Map。</li>
<li>put 方法中，对象如果没有落到缓存节点上，就找比他小的节点且离他最近的。这里我们使用了 TreeMap 的 tailMap 方法，具体 API 可以看文档。</li>
<li>get 方法中，和 put 步骤相同，否则是取不到对象的。</li>
</ol>
<p>具体寻找节点的方式如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-51768b803b614b25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>相同的测试用例，执行结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f42ecb157ad955a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>找到了之前所有的节点。解决了普通 hash 的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码比较简单，主要是通过 JDK 自带的 TreeMap 实现的寻找临近节点。当然，我们这里也只是测试了添加，关于修改还没有测试，但思路是一样的。这里只是做一个抛砖引玉。</p>
<p>同时，我们也没有实现虚拟节点，感兴趣的朋友可以尝试一下。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>分布式服务框架设计</title>
    <url>/2018/04/02/2018/2018-04-02-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 1. 服务框架的设计

<p>尽管不同的分布式服务框架实现细节存在差异，但是核心功能差异不大，下面的架构图描绘了一个分布式服务框架的整体逻辑架构。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a76ca1e391d924f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>总共分为 3 层：</p>
<ol>
<li><p>服务层，Service，其中主要部分就是动态代理，主要用于将服务提供者的接口封装成远程服务调用。上层的服务接口用于 Spring 之类的业务框架使用，也是 Spring 的 bean.</p>
</li>
<li><p>过滤器层，服务调用职责链，提供多种调用切面供框架自身和使用者扩展，例如负载均衡，性能统计，服务调用完成通知，失败重试等。</p>
</li>
<li><p>RPC 层，这里就是 RPC 框架的核心部分，包括通信框架，序列化框架，还有用于屏蔽底层通信框架和序列化框架的抽象接口。</p>
</li>
</ol>
<p>分布式服务框架通常会包含另外两个重要功能：<strong>服务治理中心</strong> 和 <strong>服务注册中心</strong>。</p>
<p><strong>1. 服务注册中心</strong>：负责服务的发布和通知，通常支持对等集群部署，某个节点宕机不会影响整个集群不可用。即使全部宕机，只影响新的节点注册和发布，不影响现有的，因为客户端需要缓存服务路由信息。</p>
<p><strong>2. 服务治理中心：</strong> 服务治理中心通常包括<strong>服务治理接口</strong>和<strong>服务治理 Portal</strong>，架构师，测试人员和系统运维人员通过服务治理 Portal 对服务的运行状态，历史数据，健康度和调用关系等进行可视化的分析和维护，<strong>目标是要持续优化服务，防止服务架构腐化，保证服务高质量运行。</strong></p>
<h2 id="2-服务框架的功能"><a href="#2-服务框架的功能" class="headerlink" title="2. 服务框架的功能"></a>2. 服务框架的功能</h2><p>虽然每个服务框架不尽相同，但是还有有一些核心功能是相同的，比如以下功能：</p>
<ol>
<li>服务订阅发布：比如，配置化发布和引用服务，服务自动发现，服务在线注册和取消注册。</li>
<li>服务路由：比如，默认提供随机路由，轮询，基于权重的路由，粘滞连接，路由定制功能。</li>
<li>集群容错：比如，Failover（失败自动切换），Failback（失败自动恢复），Failfast（快速失败）。</li>
<li>服务调用：需要支持：同步调用，异步调用，并行调用。</li>
<li>多协议：包括私有协议，公有协议。</li>
<li>序列化方式：需要支持二进制和文本类序列化方式。</li>
<li>统一配置：支持本地静态配置，支持基于配置中心的动态配置。</li>
</ol>
<p>以上功能可以按照业务定制，不需要 100% 支持。</p>
<h2 id="3-服务框架的性能指标"><a href="#3-服务框架的性能指标" class="headerlink" title="3. 服务框架的性能指标"></a>3. 服务框架的性能指标</h2><p>分布式服务框架的性能肯定比不上本地调用，原因是：网络通信，序列化，反射调用，动态代理这些都会消耗性能。所以需要有性能指标。</p>
<ol>
<li>高性能：在同等资源占用情况下，单服务提供者的 TPS 要尽量高。</li>
<li>低延时：在同等资源占用情况下，服务调用延时要尽量低。</li>
<li>性能线性增长：如果增加了服务提供者，整体性能要能够线性增长。</li>
<li>可靠性：服务注册中心的可靠性，网络链路的可靠性。</li>
</ol>
<h2 id="4-服务治理需要哪些功能？"><a href="#4-服务治理需要哪些功能？" class="headerlink" title="4. 服务治理需要哪些功能？"></a>4. 服务治理需要哪些功能？</h2><ol>
<li>服务运行态监控，例如通过路由导流，限流，服务降级，动态控制超时时间。</li>
<li>服务监控，性能统计，报表，报警。</li>
<li>服务生命周期管理</li>
<li>故障快速定位</li>
<li>服务安全</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是在设计分布式服务框架需要注意的地方，例如整体架构的设计，框架需要哪些功能，框架的需要保证哪些性能。同时，一个框架只是可以使用时不够的，还需要服务治理，保证服务不被腐化，同时保证服务的健康。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://item.jd.com/11870213.html">《分布式服务框架——原理和实践》——李林峰</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-SynchronousQueue-核心源码分析</title>
    <url>/2018/04/12/2018/2018-04-12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-SynchronousQueue-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       `SynchronousQueue` 是一个普通用户不怎么常用的队列，通常在创建无界线程池（`Executors.newCachedThreadPool()`）的时候使用，也就是那个非常危险的线程池  `^_^`。

<p>它是一个非常特殊的阻塞队列，他的模式是：在 <code>offer </code>的时候，如果没有另一个线程在 take 或者 <code>poll</code> 的话，就会失败，反之，如果在 <code>take </code>或者 <code>poll </code>的时候，没有线程在<code> offer</code> ，则也会失败，而这种特性，则非常适合用来做高响应并且线程不固定的线程池的<code> Queue</code>。所以，在很多高性能服务器中，如果并发很高，这时候，普通的 <code>LinkedQueue </code>就会成为瓶颈，性能就会出现毛刺，当换上 <code>SynchronousQueue </code>后，性能就会好很多。</p>
<p>今天就看看这个特殊的 Queue 是怎么实现的。友情提示：代码有些小复杂。。。请做好心理准备。</p>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>SynchronousQueue 内部分为公平（队列）和非公平（栈），队列的性能相对而言会好点。构造方法中，就看出来了。默认是非公平的，通常非公平（栈 FIFO）的性能会高那么一点点。</p>
<p><strong>构造方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>offer 方法</strong></p>
<p>该方法我们通常建议使用带有超时机制的 <code>offer </code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">true</span>, unit.toNanos(timeout)) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的代码中，可以看到核心方法就是 <code>transfer </code>方法。如果该方法返回 <code>true</code>，表示，插入成功，如果失败，就返回 <code>false</code>。</p>
<p><strong>poll 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的该方法也是调用了 <code>transfer</code> 方法。结果返回得到的值或者<code> null</code>。区别在于，<code>offer </code>方法的 <code>e</code> 参数是实体的。而 <code>poll</code> 方法 <code>e</code> 参数是 <code>null</code>，我们猜测，方法内部肯定根据这个做了判断。所以，重点在于<code>transfer</code>方法的实现。</p>
<p>而 transferer 有 2 种，队列和栈，我们就研究一种，知晓其原理，另一种有时间在看。</p>
<h2 id="TransferQueue-源码实现"><a href="#TransferQueue-源码实现" class="headerlink" title="TransferQueue 源码实现"></a>TransferQueue 源码实现</h2><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransferQueue() &#123;</span><br><span class="line">    QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// initialize to dummy node.</span></span><br><span class="line">    head = h;</span><br><span class="line">    tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造一个 Node 节点，注释说这是一个加的 node。并赋值给 head 和 tail 节点。形成一个初始化的链表。</p>
<p>看看这个 node：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Node class for TransferQueue. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> QNode next;          <span class="comment">// next node in queue</span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;         <span class="comment">// CAS&#x27;ed to or from null</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// to control park/unpark</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node 持有队列中下一个 node，node 对应的值 value，持有该 node 的线程，拥有 park 或者 unpark，这里用的是 JUC 的工具类 LockSupport，还有一个布尔类型，isData，这个非常重要，需要好好理解，到后面我们会好好讲解。</p>
<p>我们更关注的是这个类的 transfer 方法，该方法是 SynchronousQueue 的核心。</p>
<p>该方法接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs a put or take. put 或者 take</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e if non-null, the item to be handed to a consumer;</span></span><br><span class="line"><span class="comment"> *          if null, requests that transfer return an item</span></span><br><span class="line"><span class="comment"> *          offered by producer. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed if this operation should timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos the timeout, in nanoseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> if non-null, the item provided or received; if null,</span></span><br><span class="line"><span class="comment"> *         the operation failed due to timeout or interrupt --</span></span><br><span class="line"><span class="comment"> *         the caller can distinguish which of these occurred</span></span><br><span class="line"><span class="comment"> *         by checking Thread.interrupted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注释说道 e 参数的作用：</p>
<blockquote>
<p>如果 e 不是 null(说明是生产者调用) ，将 item 交给消费者，并返回 e；反之，如果是 null（说明是消费者调用），将生产者提供的 item 返回给消费者。</p>
</blockquote>
<p>看看 TransferQueue 类的 transfer 方法实现，楼主写了很多的注释尝试解读：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line"><span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);<span class="comment">// 当输入的是数据时，isData 就是 ture，表明这个操作是一个输入数据的操作；同理，当调用者输入的是 null，则是在消费数据。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    QNode t = tail;</span><br><span class="line">    QNode h = head;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// 如果并发导致未&quot;来得及&quot;初始化</span></span><br><span class="line">        <span class="keyword">continue</span>;                       <span class="comment">// 自旋重来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下分成两个部分进行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果当前操作和 tail 节点的操作是一样的；或者头尾相同（表明队列中啥都没有）。</span></span><br><span class="line">    <span class="keyword">if</span> (h == t || t.isData == isData) &#123; </span><br><span class="line">        QNode tn = t.next;</span><br><span class="line">        <span class="keyword">if</span> (t != tail)                  <span class="comment">// 如果 t 和 tail 不一样，说明，tail 被其他的线程改了，重来</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// 如果 tail 的 next 不是空。就需要将 next 追加到 tail 后面了。</span></span><br><span class="line">            advanceTail(t, tn); <span class="comment">// 使用 CAS 将 tail.next 变成 tail,        </span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// 时间到了，不等待，返回 null，插入失败，获取也是失败的。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="comment">// 如果能走到这里，说明 tail 的 next 是 null，这里的判断是避免重复创建 Qnode 对象。</span></span><br><span class="line">            s = <span class="keyword">new</span> QNode(e, isData);<span class="comment">// 创建一个新的节点。</span></span><br><span class="line">        <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// 尝试 CAS 将这个刚刚创建的节点追加到 tail 的 next 节点上.</span></span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">// 如果失败，则重来</span></span><br><span class="line"></span><br><span class="line">        advanceTail(t, s); <span class="comment">// 当新的节点成功追加到 tail 节点的 next 上了， 就尝试将 tail.next 节点覆盖 tail 节点,称之为推进。</span></span><br><span class="line">        <span class="comment">// s == 新节点，“可能”是新的 tail；e 是实际数据。</span></span><br><span class="line">        Object x = awaitFulfill(s, e, timed, nanos);<span class="comment">// 该方法作用就是，让当前线程等待。排除意外情况和超时的话，就是等待其他线程拿走数据并替换成 isData 不同的数据。</span></span><br><span class="line">        <span class="keyword">if</span> (x == s) &#123; <span class="comment">// x == s 是什么意思呢？ 表明在 awaitFulfill 方法中，这个数据被取消了，tryCancel 方法就是将 item 覆盖了 QNode。说明这次操作失败了。</span></span><br><span class="line">            clean(t, s);<span class="comment">// 操作失败则需要清理数据，并返回 null。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果一切顺利，确实被其他线程唤醒了，其他线程也交换了数据。</span></span><br><span class="line">        <span class="comment">// 这个判断：next != this，说明了什么？当这个 tail 节点的 next 不再指向自己，说明了</span></span><br><span class="line">        <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">            <span class="comment">// 这一步是将 S 节点设置为 Head，并且将新 Head 的 next 指向自己，让 Head 和之前的 next 断开。</span></span><br><span class="line">            advanceHead(t, s);          <span class="comment">// unlink if head     </span></span><br><span class="line">            <span class="comment">// 当 x 不是 null，表明对方线程是存放数据的。     </span></span><br><span class="line">            <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                <span class="comment">// 这一步操作将自己的 item 设置成自己。</span></span><br><span class="line">                s.item = s;</span><br><span class="line">            <span class="comment">// 将 S 节点的持有线程变成 null。</span></span><br><span class="line">            s.waiter = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// x 不是 null 表明，对方线程是生产者，返回他生产的数据；如果是 null，说明对方线程是消费者，那他自己就是生产者，返回自己的数据，表示成功。</span></span><br><span class="line">        <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 2. 如果当前的操作类型和 tail 的操作不一样。称之为互补。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">        QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">        <span class="comment">// 如果下方这些判断没过，说明并发修改了，自旋重来。 </span></span><br><span class="line">        <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">            <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">        Object x = m.item;</span><br><span class="line">        <span class="comment">// 如果 head 节点的 isData 和当前操作相同，</span></span><br><span class="line">        <span class="comment">// 如果 操作不同，但 head 的 item 就是自身，也就是发生了取消操作，tryCancel 方法会做这件事情。</span></span><br><span class="line">        <span class="comment">// 如果上面2个都不满足，尝试使用 CAS 将 e 覆盖 item。 </span></span><br><span class="line">        <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">            x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">            !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">            <span class="comment">// CAS 失败了，Head 的操作类型和当前类型相同，item 被取消了，都会走这里。</span></span><br><span class="line">            <span class="comment">// 将 h.next 覆盖 head。重来。</span></span><br><span class="line">            advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里也是将 h.next 覆盖 head。能够走到这里，说明，上面的 CAS 操作成功了，当前线程已经将 e 覆盖了 next 的 item 。</span></span><br><span class="line">        advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">        <span class="comment">// 唤醒 next 的 线程。提醒他可以取出数据，或者“我”已经拿到数据了。</span></span><br><span class="line">        LockSupport.unpark(m.waiter);</span><br><span class="line">        <span class="comment">// 如果 x 不是 null，表明这是一次消费数据的操作，反之，这是一次生产数据的操作。</span></span><br><span class="line">        <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，代码还是比较复杂的。JDK 中注释是这么说的：</p>
<blockquote>
<p>基本算法是死循环采取 2 种方式中的其中一种。<br>   1 如果队列是空的，或者持有相同的模式节点（<code>isData</code> 相同），就尝试添加节点到队列中，并让当前线程等待。<br>  2 如果队列中有线程在等待，那么就使用一种<code>互补</code>的方式，使用 CAS 和等待者交换数据。并返回。</p>
</blockquote>
<p>什么意思呢？</p>
<p>首先明确一点，队列中，数据有 2 种情况（但同时只存在一种），要么<code> QNode</code> 中有实际数据（<code>offer</code> 的时候，是有数据的，但没有“人”来取），要么没有实际数据（<code>poll</code> 的时候，队列中没有数据，线程只好等待）。队列在哪一种状态取决于<code>他为空后，第一个插入的是什么类型的数据</code>。</p>
<p>楼主画了点图来表示：</p>
<ol>
<li>队列初始化的时候，只有一个空的<code> Node</code>。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9b6364f7cff9dc2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol start="2">
<li>此时，一个线程尝试 <code>offer</code> 或者 <code>poll </code>数据，都会插入一个 <code>Node</code> 插入到节点中。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6551db864a188878.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol start="3">
<li>假设刚刚发生的是 offer 操作，这个时候，另一个线程也来 offer，这时就会有 2 个节点。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7fe5dc6026fb6b46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol start="4">
<li>这个时候，队列中有 2 个有真实数据（offer 操作）的节点了，注意，这个时候，那 2 个线程都是 <code>wait </code>的，因为没有人接受他们的数据。此时，又来一个线程，做 poll 操作。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-70a7bfd773823bfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从上图可以看出，<code> poll</code> 线程从<code> head</code> 开始取数据，因为它的 <code>isData</code> 和 <code>tail</code> 节点的 isData 不同，那么就会从 head 开始找节点，并尝试将自己的 null 值和节点中的真实数据进行交换。并唤醒等待中的线程。</p>
<p>这 4 幅图就是 <code>SynchronousQueue </code>的精华。</p>
<p>既然叫做同步队列，一定是 A 线程生产数据的时候，有 B 线程在消费，否则 A  线程就需要等待，反之，如果 A 线程准备消费数据，但队列中没有数据，线程也会等待，直到有 B 线程存放数据。</p>
<p>而 JDK 的实现原理则是：使用一个队列，队列中的用一个 <code>isData</code> 来区分生产还是消费，所有新操作都根据 tail 节点的模式来决定到底是追加到 <code>tail </code>节点还是和 <code>tail </code>节点（从 <code>head</code> 开始）交换数据。</p>
<p>而所谓的交换是从<code>head</code>开始，取出节点的实际数据，然后使用 <code>CAS</code> 和匹配到的节点进行交换。从而完成两个线程直接交换数据的操作。</p>
<p>为什么他在某些情况下，比<code>LinkedBlockingQueue</code>性能高呢？其中有个原因就是没有使用锁，减少了线程上下文切换。第二则是线程之间交换数据的方式更加的高效。</p>
<p>好，重点部分讲完了，再看看其中线程是如何等待的。逻辑在 <code>awaitFulfill</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自旋或者等待，直到填充完毕</span></span><br><span class="line"><span class="comment">// 这里的策略是什么呢？如果自旋次数不够了，通常是 16 次，但还有超过 1 秒的时间，就阻塞等待被唤醒。</span></span><br><span class="line"><span class="comment">// 如果时间到了，就取消这次的入队行为。</span></span><br><span class="line"><span class="comment">// 返回的是 Node 本身</span></span><br><span class="line"><span class="comment">// s.item 就是 e </span></span><br><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> spins = ((head.next == s) ?<span class="comment">// 如果成功将 tail.next 覆盖了 tail，如果有超时机制，则自旋 32 次，如果没有超时机制，则自旋 32 *16 = 512次</span></span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())<span class="comment">// 当前线程被中断</span></span><br><span class="line">            s.tryCancel(e);<span class="comment">// 尝试取消这个 item</span></span><br><span class="line">        Object x = s.item;<span class="comment">// 获取到这个 tail 的 item</span></span><br><span class="line">        <span class="keyword">if</span> (x != e) <span class="comment">// 如果不相等，说明 node 中的 item 取消了，返回这个 item。</span></span><br><span class="line">            <span class="comment">// 这里是唯一停止循环的地方。当 s.item 已经不是当初的哪个 e 了，说明要么是时间到了被取消了，要么是线程中断被取消了。</span></span><br><span class="line">            <span class="comment">// 当然，不仅仅只有这2种 “意外” 情况，还有一种情况是：当另一个线程拿走了这个数据，并修改了 item，也会通过这个判断，返回被“修改”过的 item。</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;<span class="comment">// 如果有时间限制</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;<span class="comment">// 如果时间到了</span></span><br><span class="line">                s.tryCancel(e);<span class="comment">// 尝试取消 item，供上面的 x != e 判断</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 重来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)<span class="comment">// 如果还有自旋次数</span></span><br><span class="line">            --spins;<span class="comment">// 减一</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)<span class="comment">// 如果自旋不够，且 tail 的等待线程还没有赋值</span></span><br><span class="line">            s.waiter = w;<span class="comment">// 当前线程赋值给 tail 的等待线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)<span class="comment">// 如果自旋不够，且如果线程赋值过了，且没有限制时间，则 wait，（危险操作）</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)<span class="comment">// 如果自旋不够，且如果限制了时间，且时间还剩余超过 1 秒，则 wait 剩余时间。</span></span><br><span class="line">            <span class="comment">// 主要目的就是等待，等待其他线程唤醒这个节点所在的线程。</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法逻辑如下：</p>
<ol>
<li>默认自旋 32 次，如果没有超时机制，则 512 次。</li>
<li>如果时间到了，或者线程被中断，则取消这次的操作，将<code>item</code>设置成自己。供后面判断。</li>
<li>如果自旋结束，且剩余时间还超过 1 秒，则阻塞等待至剩余时间。</li>
<li>当线程被其他的线程唤醒，说明数据被交换了。则 <code>return</code>，返回的是交换后的数据。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，关于 <code>SynchronousQueue </code>的核心源码分析就到这里了，楼主没有分析这个类的所有源码，只研究了核心部分代码，这足够我们理解这个 <code>Queue</code> 的内部实现了。</p>
<p>总结下来就是：</p>
<p>JDK 使用了队列或者栈来实现公平或非公平模型。其中，<code>isData</code> 属性极为重要，标识这这个线程的这次操作，决定了他到底应该是追加到队列中，还是从队列中交换数据。</p>
<p>每个线程在没有遇到自己的另一半时，要么快速失败，要么进行阻塞，阻塞等待自己的另一半来，至于对方是给数据还是取数据，取决于她自己，如果她是消费者，那么他就是生产者。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-CountDown-源码分析</title>
    <url>/2018/04/13/2018/2018-04-13-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-CountDown-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>Doug Lea 大神在 JUC 包中为我们准备了大量的多线程工具，其中包括 CountDownLatch ，名为<code>倒计时门栓</code>，好像不太好理解。不过，今天的文章之后，我们就彻底理解了。</p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>在 JDK 的文档中，带有 2 个例子，我们使用其中一个，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    Executor e = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">    System.err.println(<span class="string">&quot;work&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    <span class="keyword">this</span>.i = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doWork(i);</span><br><span class="line">    doneSignal.countDown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;work&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们创建了 1 个 CountDowmLatch 对象，在主线程和另外 10 个线程中使用，主线程调用了他的 await 方法，子线程调用了 countDown 方法。</p>
<p>最后输出结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3ca8f6c011c48350.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>大部分时候，你会得到上面的结果，这是正常的情况，但也可能你会得到下面的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-531fa3e2e14a127b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这看起来不正常。因为我们需要的结果是：主线程最后打印。什么原因导致的呢？其实是由于时间太快，控制台打印的顺序和实际顺序不同，我们可以在后面加个纳秒参数，就能够看出来了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7aa382387277e4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>从纳秒数就能够看出来，主线程是最后执行的。</strong></p>
<p>通过一幅图看看这个 demo 的整体执行顺序。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-529b3110d4c15550.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>图中，主线程会先执行 await 方法，这个方法会挂起当前线程，相当于 wait 方法。而子线程会陆续执行任务，并执行 countDown 方法，countDown 方法每次执行都会将计数器减 1， 当计数器变成 0 的时候，就会唤醒主线程，主线程开始执行自己的任务。不知道这个图画的是否明显，但楼主尽力了。。。。</p>
<p>好了，知道了如何使用，就来看看源码实现吧。</p>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>首先看看这个类的结构：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c4d01befdc5b1d34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>该类是一个独立的类，没有继承别的类，有一个内部类 Sync，这个类继承了 AQS 抽象类，其实，在之前的文章中，我们说过，AQS 是 JUC 所有锁的实现，定义了锁的基本操作。这个内部类重写了 tryAcquireShared 方法和 tryReleaseShared 方法。</p>
<p>然后呢？我们看看构造方法。</p>
<h5 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部实现还是继承了 AQS 的 Sync 类。</p>
<p>Sync 构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<p>设置了这个 State 变量，我们之前分析过 AQS 的源码，这个变量可以说是 AQS 实现的核心，通过控制这个变量，能够实现共享共享锁或者独占锁。</p>
<p>那么，如果让我们来设计这个CountDownLatch ，我们该如何设计呢？</p>
<p>事实上，很简单，我们只需要对 state 变量进行减 1 操作，直到这个变量变成 0，我们就唤醒主线程。</p>
<p>不知道 Doug Lea 是不是这么设计的？我们去看看。</p>
<h5 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h5><p>主线程会调用这个方法，让自己阻塞，直到被唤醒。</p>
<p>看看这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await 方法调用的是 Sync 的 tryAcquireSharedNanos 方法，方法也贴在上面了。该方法会先调用 tryAcquireShared 方法，如果返回值不是大于等于 0 ，说明当前线程不能获取锁，那么就调用 doAcquireSharedNanos 方法。这个方法内部会将当前线程挂起，直到 state 变成 0，才会被唤醒。</p>
<p>而 tryAcquireShared 方法是需要子类自己实现的。我们看看 CountDown 是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是获取 state 变量，也就是构造方法中设置的参数。</p>
<p>doAcquireSharedNanos 方法的是如何将当前线程挂起的呢？</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 node 对象，对象中有个属性就是当前线程对象。并将这个 node 添加进队列尾部。</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 中断失败标记</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 找到这个 node 的上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果上一个节点是 head，说明他前面已经没有线程阻挡他获取锁了。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 获取锁的状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 如果大于等于0，说明可以获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将包装当前线程的 node 设置为 head.</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">// 设置他的 next 是 null，让 GC 回收</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">// 没有发生错误，不必执行下面的取消操作</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果他的前面的节点的状态时 -1，那么当前线程就需要等待。</span></span><br><span class="line">            <span class="comment">// 调用 parkAndCheckInterrupt 等待，如果等待过程中被中断了，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)  </span><br><span class="line">            <span class="comment">// 如果发生了中断异常，则取消获取锁。</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码写了很多注释，总的来说，逻辑如下：</p>
<ol>
<li>将当前线程包装成一个 Node 对象，加入到 AQS 的队列尾部。</li>
<li>如果他前面的 node 是 head ，便可以尝试获取锁了。</li>
<li>如果不是，则阻塞等待，调用的是 LockSupport.park(this); </li>
</ol>
<p><strong>CountDown 的 await 方法就是通过 AQS 的锁机制让主线程阻塞等待。而锁的实现就是通过构造器中设置的 state 变量来控制的。当 state 是 0 的时候，就可以获取锁。然后执行后面的逻辑。</strong></p>
<p>知道了 await 方法，CountDown 方法应该能猜个大概了。</p>
<h5 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown 方法"></a>countDown 方法</h5><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了 Sync 的 releaseShared 方法，也就是父类 AQS 的方法，AQS 需要子类实现 tryReleaseShared 方法。看看 CountDownLatch 是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法很简单，就是将 state 变量减 1，只要减过之后， state 不是 0，就返回 fasle。</p>
<p>回到 releaseShared 方法中，当 tryReleaseShared 返回值是 true 时，也就是 state 是 0，就需要执行 doReleaseShared 方法 ，唤醒阻塞在 CountDown 上的线程了。</p>
<p>唤醒代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要队列中 head 节点不是 null，且和 tail 不相等，并且状态是 -1，使用 CAS 将状态修改成 0，如果成功，唤醒当前线程。当前线程就会在 doAcquireSharedInterruptibly 方法中苏醒，再次尝试获取锁，只要他的上一个节点是 head，也就是没有人和他争抢锁，并且 state 是 0，就能够成功获取到锁，继续执行下面的逻辑，不再继续阻塞。</p>
<p>而我们 CountDownLatch 的主线程也就可以被唤醒从而继续执行了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，CountDownLatch 还是比较简单的。说白了就是通过共享锁实现的。在我们的代码中，只有一个线程会阻塞，那就是我们的主线程， 其余的线程就是在不停的释放 state 变量，直到为 0。从 AQS 的角度来讲，整个工作流程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d155b56e1cfb5436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>简单的一个流程图，CountDownLatch 就是通过使用 AQS 的机制来实现<code>倒计时门栓</code>的。</p>
<p>good luck！！！！</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>使用-ReentrantLock-和-Condition-实现一个阻塞队列</title>
    <url>/2018/04/14/2018/2018-04-14-%E4%BD%BF%E7%94%A8-ReentrantLock-%E5%92%8C-Condition-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>从之前的阻塞队列的源码分析中，我们知道，JDK 中的阻塞队列是使用 ReentrantLock 和  Condition 实现了，我们今天来个简易版的。代码如下：</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> ConditionObject notFull = (ConditionObject) lock.newCondition();</span><br><span class="line">  <span class="keyword">final</span> ConditionObject notEmpty = (ConditionObject) lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 当数组满了</span></span><br><span class="line">      <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">        <span class="comment">// 释放锁，等待</span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 放入数据</span></span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="comment">// 如果到最后一个位置了,下标从头开始,防止下标越界</span></span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) &#123;</span><br><span class="line">        <span class="comment">// 从头开始</span></span><br><span class="line">        putptr = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对 count ++ 加加</span></span><br><span class="line">      ++count;</span><br><span class="line">      <span class="comment">// 通知 take 线程,可以取数据了,不必继续阻塞</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果数组没有数据,则等待</span></span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取数据</span></span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="comment">// 如果到数组尽头了,就从头开始</span></span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) &#123;</span><br><span class="line">        <span class="comment">// 从头开始</span></span><br><span class="line">        takeptr = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将数量减1</span></span><br><span class="line">      --count;</span><br><span class="line">      <span class="comment">// 通知阻塞的 put 线程可以装填数据了</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>其实，这并不是我写的，而是 Condition 接口的 JavaDoc 文档中写的。并且文档中说，请不要再次实现这个队列，因为 JDK 内部已经是实现了。原话如下：</strong></p>
<blockquote>
<p> (The {@link java.util.concurrent.ArrayBlockingQueue} class provides  this functionality, so there is no reason to implement this sample usage class.)</p>
</blockquote>
<p>楼主只是觉得这个代码写的挺好的，所以分享一下，其中关键的还是 Condition 和重入锁，重入锁的核心源码我们已经看过了，今天来看看 Condition 的源码。所以我们今天使用了这个代码作为一个入口。</p>
<p>可以看到，Condition 的重要方法就是 await 和 signal，类似 Object 类的 wait 和 notify 方法。</p>
<p>我们后面会详细讲讲这两个方法的实现。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-Condition-源码分析</title>
    <url>/2018/04/14/2018/2018-04-14-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Condition-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>Condition 是  Lock 的伴侣，至于如何使用，我们之前也写了一些文章来说，例如  <a href="http://thinkinjava.cn/article/97">使用 ReentrantLock 和 Condition 实现一个阻塞队列</a>，<a href="http://thinkinjava.cn/article/36">并发编程之 Java 三把锁</a>， 在这两篇文章中，我们都详细介绍了他们的使用。今天我们就来深入看看源码实现。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>Condition</code> 接口有 2 个实现类，一个是 <code>AbstractQueuedSynchronizer.ConditionObject</code>，还有一个是 <code>AbstractQueuedLongSynchronizer.ConditionObject</code>，都是 AQS 的内部类，该类结构如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-0ae2dda402d75fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>几个公开的方法：</p>
<ol>
<li>await()</li>
<li>await(long time, TimeUnit unit)</li>
<li>awaitNanos(long nanosTimeout)</li>
<li>awaitUninterruptibly()</li>
<li>awaitUntil(Date deadline)</li>
<li>signal() </li>
<li>signalAll() </li>
</ol>
<p>今天我们重点关注 2 个方法，也是最常用的 2 个方法： await 和 signal。</p>
<h2 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h2><p>先贴一波代码加注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 创建一个新的节点,追加到 Condition 队列中最后一个节点.</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放这个锁,并唤醒 AQS 队列中一个线程.</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断这个节点是否在 AQS 队列上,第一次判断总是返回 false</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 第一次总是 park 自己,开始阻塞等待</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 线程判断自己在等待过程中是否被中断了,如果没有中断,则再次循环,会在 isOnSyncQueue 中判断自己是否在队列上.</span></span><br><span class="line">        <span class="comment">//  isOnSyncQueue 判断当前 node 状态,如果是 CONDITION 状态,或者不在队列上了(JDK 注释说,由于 CAS 操作队列上的节点可能会失败),就继续阻塞.</span></span><br><span class="line">        <span class="comment">//  isOnSyncQueue 判断当前 node 还在队列上且不是 CONDITION 状态了,就结束循环和阻塞.</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果被中断了,就跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当这个线程醒来,会尝试拿锁, 当 acquireQueued 返回 false 就是拿到锁了.</span></span><br><span class="line">    <span class="comment">// interruptMode != THROW_IE &gt;&gt;&gt; 表示这个线程没有成功将 node 入队,但 signal 执行了 enq 方法让其入队了.</span></span><br><span class="line">    <span class="comment">// 将这个变量设置成 REINTERRUPT.</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 如果 node 的下一个等待者不是 null, 则进行清理,清理 Condition 队列上的节点. </span></span><br><span class="line">    <span class="comment">// 如果是 null ,就没有什么好清理的了.</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 如果线程被中断了,需要抛出异常.或者什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下这个方法的逻辑:</strong></p>
<ul>
<li>在 Condition 中, 维护着一个队列,每当执行 await 方法,都会根据当前线程创建一个节点,并添加到尾部.</li>
<li>然后释放锁,并唤醒阻塞在锁的 AQS 队列中的一个线程.</li>
<li>然后,将自己阻塞.</li>
<li>在被别的线程唤醒后, 将刚刚这个节点放到 AQS 队列中.接下来就是那个节点的事情了,比如抢锁.</li>
<li>紧接着就会尝试抢锁.接下来的逻辑就和普通的锁一样了,抢不到就阻塞,抢到了就继续执行.</li>
</ul>
<p>看看详细的源码实现，Condition 是如何添加节点的？addConditionWaiter 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法就是创建一个当前线程的节点,追加到最后一个节点中.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到最后一个节点,放在局部变量中,速度更快</span></span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="comment">// 如果最后一个节点失效了,就清除链表中所有失效节点,并重新赋值 t</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个当前线程的 node 节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">// 如果最后一个节点是 null</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 将当前节点设置成第一个节点</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是 null, 将当前节点追加到最后一个节点</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">// 将当前节点设置成最后一个节点</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个当前线程的节点,追加到最后一个节点中. 当然，其中还有一个 unlinkCancelledWaiters 方法的调用，当最后一个节点失效了，就需要清理 Condition 队列中无效的节点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除链表中所有失效的节点.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    <span class="comment">// 当 next 正常的时候,需要保存这个 next, 方便下次循环是链接到下一个节点上.</span></span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果这个节点被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">// 先将他的 next 节点设置为 null</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果这是第一次判断 trail 变量</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 将 next 变量设置为 first, 也就是去除之前的 first(由于是第一次,肯定去除的是 first)</span></span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果不是 null,说明上个节点正常,将上个节点的 next 设置为无效节点的 next, 让 t 失效</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="comment">// 如果 next 是 null, 说明没有节点了,那么就可以将 trail 设置成最后一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果该节点正常,那么就保存这个节点,在下次链接下个节点时使用</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        <span class="comment">// 换下一个节点继续循环</span></span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么又是如何释放锁，并唤醒 AQS 队列中的一个节点上的线程的呢？fullyRelease 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 state 变量</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 如果释放成功,则返回 state 的大小,也就是之前持有锁的线程的数量</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果释放失败,抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放失败</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 将这个节点是指成取消状态.随后将从队列中移除.</span></span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 release 方法中，又是如何操作的呢？代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  主要功能,就是释放锁,并唤醒阻塞在锁上的线程.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果释放锁成功,返回 true, 可能会抛出监视器异常,即当前线程不是持有锁的线程.</span></span><br><span class="line">	<span class="comment">// 也可能是释放失败,但 fullyRelease 基本能够释放成功.</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    	<span class="comment">// 释放成功后, 唤醒 head 的下一个节点上的线程.</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>release 方法主要调用了 tryRelease 方法，该方法就是释放锁的。tryRelease 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要功能就是对 state 变量做减法, 如果 state 变成0,则将持有锁的线程设置成 null.</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 计算 state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程不是持有该锁的线程,则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果结果是 0,说明成功释放了锁.</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 将持有当前锁的线程设置成 null.</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置变量</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们大概知道了 Condition 是如何释放锁的了，那么又是如何将自己阻塞的呢？在将自己阻塞之前，需要调用 isOnSyncQueue 方法判断，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果他的状态不是等地啊,且他的上一个节点是 null, 便不在队列中了</span></span><br><span class="line">    <span class="comment">// 这里判断 == CONDITION,实际上是第一次判断,而后面的判断则是线程醒来后的判断.</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果他的 next 不是 null, 说明他还在队列上.</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果从 tail 开始找上一个节点,找到了给定的节点,说明也在队列上.返回 true.</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，第一次总是会返回 fasle，从而进入 while 块调用 park 方法，阻塞自己，至此，Condition 成功的释放了所在的 Lock 锁，并将自己阻塞。</p>
<p>虽然阻塞了，但总有人会调用 signal 方法唤醒他，唤醒之后走下面的 if 逻辑，也就是 checkInterruptWhileWaiting 方法，看名字是当等待的时候检查中断状态，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        <span class="comment">// transferAfterCancelledWait &gt;&gt;&gt;&gt; 如果将 node 放入 AQS 队列失败,就返回 REINTERRUPT, 成功则返回 THROW_IE</span></span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程中断了，就需要根据调用 transferAfterCancelledWait 方法的返回值来返回不同的常量，该方法内部逻辑是怎么样的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 node 的状态设置成 0 成功后,将这个 node 放进 AQS 队列中.</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 CAS 失败, 返回 false ,</span></span><br><span class="line">    <span class="comment">// 当 node 不在 AQS 节点上, 就自旋. 直到 enq 方法完成.</span></span><br><span class="line">    <span class="comment">// JDK 认为, 在这个过程中, node 不在 AQS 队列上是少见的,也是暂时的.所以自旋.</span></span><br><span class="line">    <span class="comment">// 如果不自旋的话,后面的逻辑是无法继续执行的. 实际上,自旋是在等待在 signal 中执行 enq 方法让 node 入队.</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实是尝试将自己放入到队列中。如果无法放入，就自旋等待 signal 方法放入。</p>
<p>回到 await 方法，继续向下走，执行 3 个 if 块，第一个 if 块，尝试拿锁，为什么？因为这个时候，这个线程已经被唤醒了，而且他在 AQS 的队列中，那么，他就需要在醒的时候，去拿锁。acquireQueued 方法是拿锁的逻辑，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 返回结果:是否被中断了, 当返回 false 就是拿到锁了,反之没有拿到.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 返回他的上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果这个节点的上个节点是 head, 且成功获取了锁.</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置成 head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 他的上一个节点(head)设置成 null.</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回 false,没有中断</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire &gt;&gt;&gt; 如果没有获取到锁,就尝试阻塞自己等待(上个节点的状态是  -1 SIGNAL).</span></span><br><span class="line">            <span class="comment">// parkAndCheckInterrupt &gt;&gt;&gt;&gt; 返回自己是否被中断了.</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果这里拿不到锁，就会在 parkAndCheckInterrupt 方法中阻塞。这里和正常的 AQS 中的队列节点是一摸一样的，没有特殊。</p>
<p>这里有个 tryAcquire 方法需要注意一下： 这个就是尝试拿锁的逻辑所在。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果锁的状态是空闲的.</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// !hasQueuedPredecessors() &gt;&gt;&gt;  是否含有比自己的等待的时间长的线程, false &gt;&gt; 没有</span></span><br><span class="line">        <span class="comment">// compareAndSetState &gt;&gt;&gt; CAS 设置 state 变量成功</span></span><br><span class="line">        <span class="comment">// 设置当前线程为锁的持有线程成功</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">// 上面 3 个条件都满足, 抢锁成功.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 state 状态不是0, 且当前线程和锁的持有线程相同,则认为是重入.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要逻辑是设置 state 变量，将锁的持有线程变成自己。这些是在没有比自己等待时间长的线程的情况下发生的。意思是，优先哪些等待时间久的线程拿锁。当然，这里还有一些重入的逻辑。</p>
<p>后面的两个 if 块就简单了，如果 Condition 中还有节点，那么就尝试清理无效的节点，调用的是 unlinkCancelledWaiters 方法，这个方法，我们在上面分析过了，就不再重复分析了。</p>
<p>最后，判断是否中断，执行 reportInterruptAfterWait 方法，这个方法可能会抛出异常，也可能会对当前线程打一个中断标记。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好，关于 await 方法就分析完了，可以看到，楼主贴了很多的注释，事实上，都是为了以后能更好的复习，也方便感兴趣的同学在看源码的时候结合我的注释一起分析。</p>
<p>这个方法的总结都在开始说了，就不再重复总结了。后面，我们会结合 signal 方法一起总结。</p>
<p>再来看看 signal 方法实现。</p>
<h2 id="signal-方法"><a href="#signal-方法" class="headerlink" title="signal 方法"></a>signal 方法</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果当前线程不是持有该锁的线程.抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 拿到 Condition 队列上第一个节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，唤醒策略是从头部开始的。</p>
<p>看看 doSignal(first) 方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果第一个节点的下一个节点是 null, 那么, 最后一个节点也是 null.</span></span><br><span class="line">        <span class="keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将 next 节点设置成 null.</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果修改这个 node 状态为0失败了(也就是唤醒失败), 并且 firstWaiter 不是 null, 就重新循环.</span></span><br><span class="line">        <span class="comment">// 通过从 First 向后找节点,直到唤醒或者没有节点为止.</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在于 transferForSignal 方法，该方法肯定做了唤醒操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不能改变状态,就取消这个 node. </span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将这个 node 放进 AQS 的队列,然后返回他的上一个节点.</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 如果上一个节点的状态被取消了, 或者尝试设置上一个节点的状态为 SIGNAL 失败了(SIGNAL 表示: 他的 next 节点需要停止阻塞), </span></span><br><span class="line">    <span class="comment">// 唤醒输入节点上的线程.</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="comment">// 如果成功修改了 node 的状态成0,就返回 true.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果然，看到了 unpark 操作，该方法先是 CAS 修改了节点状态，如果成功，就将这个节点放到 AQS 队列中，然后唤醒这个节点上的线程。此时，那个节点就会在 await 方法中苏醒，并在执行 checkInterruptWhileWaiting 方法后开始尝试获取锁。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下 Condition 执行 await 和 signal 的过程吧。</p>
<ol>
<li><p>首先，线程如果想执行 await 方法，必须拿到锁，在 AQS 里面，抢到锁的一般都是 head，然后 head 失效，从队列中删除。</p>
</li>
<li><p>在当前线程（也就是 AQS 的 head）拿到锁后，调用了 await 方法，第一步创建一个 Node 节点，放到 Condition 自己的队列尾部，并唤醒 AQS 队列中的某个（head）节点，然后阻塞自己，等待被 signal 唤醒。</p>
</li>
<li><p>当有其他线程调用了 signal 方法，就会唤醒 Condition 队列中的 first 节点，然后将这个节点放进 AQS 队列的尾部。</p>
</li>
<li><p>阻塞在 await 方法的线程苏醒后，他已经从 Condition 队列总转移到 AQS 队列中了，这个时候，他就是一个正常的 AQS 节点，就会尝试抢锁。并清除 Condition 队列中无效的节点。</p>
</li>
</ol>
<p>下面这张图说明了这几个步骤。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6f61ca06236ce9fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>好啦，关于 Condition 就说到这里啦，总的来说，就是在 Condition 中新增一个休眠队列来实现的。只要调用 await 方法，就会休眠，进入 Condition 队列，调用 signal 方法，就会从 Condition 队列中取出一个线程并插入到 AQS 队列中，然后唤醒，让这个线程自己去抢锁。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-CyclicBarrier-源码分析</title>
    <url>/2018/04/14/2018/2018-04-14-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-CyclicBarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->## 前言

<p>在之前的介绍 CountDownLatch 的文章中，CountDown 可以实现多个线程协调，在所有指定线程完成后，主线程才执行任务。</p>
<p>但是，CountDownLatch 有个缺陷，这点 JDK 的文档中也说了：他只能使用一次。在有些场合，似乎有些浪费，需要不停的创建 CountDownLatch 实例，JDK  在 CountDownLatch 的文档中向我们介绍了 CyclicBarrier——循环栅栏。具体使用参见文章 <a href="http://thinkinjava.cn/article/37">并发编程之 线程协作工具类</a>。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>该类结构如下:<br><img src="https://upload-images.jianshu.io/upload_images/4236553-9d1936c1348d5538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>有一个我们常用的方法 await，还有一个内部类，Generation ，仅有一个参数，有什么作用呢？</p>
<p>在 CyclicBarrier 中，有一个 “代” 的概念，因为 CyclicBarrier 是可以复用的，那么每次所有的线程通过了栅栏，就表示一代过去了，就像我们的新年一样。当所有人跨过了元旦，日历就更新了。</p>
<p>为什么需要这个呢？后面我们看源码的时候在细说，现在说有点不太容易懂。</p>
<p>再看看构造方法，有 2 个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用 CyclicBarrier 就知道了，CyclicBarrier 支持在所有线程通过栅栏的时候，执行一个线程的任务。</p>
<p>parties 属性就是线程的数量，这个数量用来控制什么时候释放打开栅栏，让所有线<br>程通过。</p>
<p>好了，CyclicBarrier 的最重要的方法就是 await 方法，当执行了这样一个方法，就像是树立了一个栅栏，将线程挡住了，只有所有的线程都到了这个栅栏上，栅栏才会打开。</p>
<p>看看这个方法的实现。</p>
<h2 id="await-方法实现"><a href="#await-方法实现" class="headerlink" title="await 方法实现"></a>await 方法实现</h2><p>代码加注释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 锁住</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// 如果这代损坏了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程中断了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 将损坏状态设置为 true</span></span><br><span class="line">            <span class="comment">// 并通知其他阻塞在此栅栏上的线程</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取下标    </span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">// 如果是 0 ,说明到头了</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">// 执行栅栏任务</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 更新一代,将 count 重置,将 generation 重置.</span></span><br><span class="line">                <span class="comment">// 唤醒之前等待的线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="comment">// 结束</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 如果执行栅栏任务的时候失败了,就将栅栏失效</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有时间限制,则直接等待,直到被唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">// 如果有时间限制,则等待指定时间</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// g == generation &gt;&gt; 当前代</span></span><br><span class="line">                <span class="comment">// ! g.broken &gt;&gt;&gt; 没有损坏</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 让栅栏失效</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 上面条件不满足,说明这个线程不是这代的.</span></span><br><span class="line">                    <span class="comment">// 就不会影响当前这代栅栏执行逻辑.所以,就打个标记就好了</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当有任何一个线程中断了,会调用 breakBarrier 方法.</span></span><br><span class="line">            <span class="comment">// 就会唤醒其他的线程,其他线程醒来后,也要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">            <span class="comment">// g != generation &gt;&gt;&gt; 正常换代了</span></span><br><span class="line">            <span class="comment">// 一切正常,返回当前线程所在栅栏的下标</span></span><br><span class="line">            <span class="comment">// 如果 g == generation，说明还没有换代，那为什么会醒了？</span></span><br><span class="line">            <span class="comment">// 因为一个线程可以使用多个栅栏，当别的栅栏唤醒了这个线程，就会走到这里，所以需要判断是否是当前代。</span></span><br><span class="line">            <span class="comment">// 正是因为这个原因，才需要 generation 来保证正确。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            <span class="comment">// 如果有时间限制,且时间小于等于0,销毁栅栏,并抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码虽然长，但整体逻辑还是很简单的。总结一下该方法吧。</p>
<ol>
<li><p>首先，每个 CyclicBarrier 都有一个 Lock，想执行 await 方法，就必须获得这把锁。所以，CyclicBarrier 在并发情况下的性能是不高的。</p>
</li>
<li><p>一些线程中断的判断，注意，CyclicBarrier 中，只有有一个线程中断了，其余的线程也会抛出中断异常。并且，<strong>这个 CyclicBarrier 就不能再次使用了。</strong></p>
</li>
<li><p>每次线程调用一次 await 方法，表示这个线程到了栅栏这里了，那么就将计数器减一。如果计数器到 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。最后，将代更新，计数器重置，并唤醒所有之前等待在栅栏上的线程。</p>
</li>
<li><p>如果不是最后一个线程到达栅栏了，就使用 Condition 的 await 方法阻塞线程。如果等待过程中，线程中断了，就抛出异常。这里，注意一下，如果中断的线程的使用 CyclicBarrier 不是这代的，比如，在最后一次线程执行 signalAll 后，并且更新了这个“代”对象。在这个区间，这个线程被中断了，那么，JDK 认为任务已经完成了，就不必在乎中断了，只需要打个标记。所以，catch 里的 else 判断用于极少情况下出现的判断——任务完成，“代” 更新了，突然出现了中断。这个时候，CyclicBarrier 是不在乎的。因为任务已经完成了。</p>
</li>
<li><p>当有一个线程中断了，也会唤醒其他线程，那么就需要判断 broken 状态。 </p>
</li>
<li><p>如果这个线程被其他的 CyclicBarrier 唤醒了，那么 g 肯定等于 generation，这个事件就不能 return 了，而是继续循环阻塞。反之，如果是当前 CyclicBarrier 唤醒的，就返回线程在 CyclicBarrier 的下标。完成了一次冲过栅栏的过程。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从 await 方法看，CyclicBarrier 还是比较简单的，JDK 的思路就是：设置一个计数器，线程每调用一次计数器，就减一，并使用  Condition 阻塞线程。当计数器是0的时候，就唤醒所有线程，并尝试执行构造函数中的任务。由于 CyclicBarrier 是可重复执行的，所以，就需要重置计数器。</p>
<p>CyclicBarrier 还有一个重要的点，就是 generation 的概念，由于每一个线程可以使用多个 CyclicBarrier，每个 CyclicBarrier 又都可以唤醒线程，那么就需要用代来控制，如果代不匹配，就需要重新休眠。同时，这个代还记录了线程的中断状态，如果任何线程中断了，那么所有的线程都会抛出中断异常，并且 CyclicBarrier 不再可用了。</p>
<p>总而言之，CyclicBarrier 是依靠一个计数器实现的，内部有一个 count 变量，每次调用都会减一。当一次完整的栅栏活动结束后，计数器重置，这样，就可以重复利用了。</p>
<p>而他和 CountDownLatch 的区别在于，CountDownLatch 只能使用一次就 over 了，CyclicBarrier 能使用多次，可以说功能类似，CyclicBarrier 更强大一点。并且 CyclicBarrier 携带了一个在栅栏处可以执行的任务。更加灵活。</p>
<p>下面来一张图，说说 CyclicBarrier 的流程。和 CountDownLatch 类似：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-98429ec758d7f705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-Semaphore-源码分析</title>
    <url>/2018/04/14/2018/2018-04-14-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>并发 JUC 包提供了很多工具类，比如之前说的 CountDownLatch，CyclicBarrier ，今天说说这个 Semaphore——信号量，关于他的使用请查看往期文章<a href="http://thinkinjava.cn/article/37">并发编程之 线程协作工具类</a>，今天的任务就是从源码层面分析一下他的原理。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>如果先不看源码，根据以往我们看过的 CountDownLatch CyclicBarrier 的源码经验来看，Semaphore 会怎么设计呢？</p>
<p>首先，他要实现多个线程线程同时访问一个资源，类似于共享锁，并且，要控制进入资源的线程的数量。</p>
<p>如果根据 JDK 现有的资源，我们是否可以使用 AQS 的 state 变量来控制呢？类似 CountDownLatch 一样，有几个线程我们就为这个 state 变量设置为几，当 state 达到了阈值，其他线程就不能获取锁了，就需要等待。当 Semaphore 调用 release 方法的时候，就释放锁，将 state 减一，并唤醒 AQS 上的线程。</p>
<p>以上，就是我们的猜想，那我们看看 JDK 是不是和我们想的一样。</p>
<p>首先看看 Semaphore 的 UML 结构：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-0a842485b2e18ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>内部有 3 个类，继承了 AQS。一个公平锁，一个非公平锁，这点和 ReentrantLock 一摸一样。</p>
<p>看看他的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个构造器，两个参数，一个是许可线程数量，一个是是否公平锁，默认非公平。</p>
<p>而 Semaphore 有 2 个重要的方法，也是我们经常使用的 2 个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore.acquire();</span><br><span class="line">// doSomeing.....</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>

<p>acquire 和 release 方法，我们今天重点看这两个方法的源码，一窥 Semaphore 的全貌。</p>
<h2 id="acquire-方法源码分析"><a href="#acquire-方法源码分析" class="headerlink" title="acquire 方法源码分析"></a>acquire 方法源码分析</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">// 尝试获取一个锁</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是抽象类 AQS 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 如果小于0，就获取锁失败了。加入到AQS 等待队列中。</span></span><br><span class="line">    <span class="comment">// 如果大于0，就直接执行下面的逻辑了。不用进行阻塞等待。</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是抽象父类 Sync 的方法，默认是非公平的</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非公平锁的释放锁的方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">// 获取锁的状态</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">// state 变量是否还足够当前获取的</span></span><br><span class="line">        <span class="comment">// 如果小于 0，获取锁就失败了。</span></span><br><span class="line">        <span class="comment">// 如果大于 0，就循环尝试使用 CAS 将 state 变量更新成减去输入参数之后的。</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的释放就是对 state 变量减一（或者更多）的。</p>
<p>返回了剩余的 state 大小。</p>
<p>当返回值小于 0 的时候，说明获取锁失败了，那么就需要进入 AQS 的等待队列了。代码入下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个节点 AQS 队列尾部</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 找到新节点的上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果这个节点是 head，就尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            	<span class="comment">// 继续尝试获取锁，这个方法是子类实现的</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 如果大于0，说明拿到锁了。</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                	<span class="comment">// 将 node 设置为 head 节点</span></span><br><span class="line">                	<span class="comment">// 如果大于0，就说明还有机会获取锁，那就唤醒后面的线程，称之为传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果他的上一个节点不是 head，就不能获取锁</span></span><br><span class="line">            <span class="comment">// 对节点进行检查和更新状态，如果线程应该阻塞，返回 true。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            	<span class="comment">// 阻塞 park，并返回是否中断，中断则抛出异常</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        	<span class="comment">// 取消节点</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的逻辑就是：</p>
<ol>
<li><p>创建一个分享类型的 node 节点包装当前线程追加到 AQS 队列的尾部。</p>
</li>
<li><p>如果这个节点的上一个节点是 head ，就是尝试获取锁，获取锁的方法就是子类重写的方法。如果获取成功了，就将刚刚的那个节点设置成 head。</p>
</li>
<li><p>如果没抢到锁，就阻塞等待。</p>
</li>
</ol>
<h2 id="release-方法源码分析"><a href="#release-方法源码分析" class="headerlink" title="release 方法源码分析"></a>release 方法源码分析</h2><p>该方法用于释放锁，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 死循环释放成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    	<span class="comment">// 唤醒 AQS 等待对列中的节点，从 head 开始	</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Sync extends AbstractQueuedSynchronizer </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">// 对 state 变量 + 1</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里释放锁的逻辑写在了抽象类 Sync 中。逻辑简单，就是对 state 变量做加法。</p>
<p>在加法成功后，执行 <code>doReleaseShared </code>方法，这个方法是 AQS 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            	<span class="comment">// 设置 head 的等待状态为 0 ，并唤醒 head 上的线程</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成功设置成 0 之后，将 head 状态设置成传播状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的主要作用就是从 AQS 的 head 节点开始唤醒线程，注意，这里唤醒是 head 节点的下一个节点，需要和 <code>doAcquireSharedInterruptibly </code>方法对应，因为 <code>doAcquireSharedInterruptibly</code> 方法唤醒的当前节点的上一个节点，也就是 head 节点。</p>
<p>至此，释放 state 变量，唤醒 AQS 头节点结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下 Semaphore 的原理吧。</p>
<p>总的来说，Semaphore 就是一个共享锁，通过设置 state 变量来实现对这个变量的共享。当调用 acquire 方法的时候，state 变量就减去一，当调用 release 方法的时候，state 变量就加一。当 state 变量为 0 的时候，别的线程就不能进入代码块了，就会在 AQS 中阻塞等待。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之-Exchanger-源码分析</title>
    <url>/2018/04/15/2018/2018-04-15-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Exchanger-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>JUC 包中除了 CountDownLatch, CyclicBarrier, Semaphore, 还有一个重要的工具,只不过相对而言使用的不多,什么呢? Exchange —— 交换器。用于在两个线程之间交换数据，A 线程将 a 数据交给 B 线程，B 线程将 b 数据交给 a 线程。</p>
<p>具体使用例子参见 <a href="http://thinkinjava.cn/article/37">并发编程之 线程协作工具类</a>。我们这篇文章就不再讲述如何使用了。</p>
<p>而今天，我们将从源码处分析，Exchange 的实现原理。如果大家看过之前关于 SynchronousQueue 的文章  <a href="http://thinkinjava.cn/article/95">并发编程之 SynchronousQueue 核心源码分析</a>，就能够看的出来，Exchange 的原理和他很类似。</p>
<h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h2><p>类 UML：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-945d4f8ddf29ce92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>内部有 2 个内部类： Node ， Participant 重写了 ThreadLocal 的 initialValue 方法。</p>
<p>构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    participant = <span class="keyword">new</span> Participant();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是创建了一个 ThreadLocal 对象，并设置了初始值，一个 Node 对象。</p>
<p>看看这个 node 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">//  node 在 arena 数组下标</span></span><br><span class="line">    <span class="keyword">int</span> bound;              <span class="comment">//  交换器的最后记录值 </span></span><br><span class="line">    <span class="keyword">int</span> collides;           <span class="comment">//  记录的 CAS 失败数</span></span><br><span class="line">    <span class="keyword">int</span> hash;               <span class="comment">//  伪随机的自旋数</span></span><br><span class="line">    Object item;            <span class="comment">//  这个线程的数据项</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;  <span class="comment">//  别的线程提供的元素,也就是释放他的线程提供的数据 item</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked; <span class="comment">//  当阻塞时，设置此线程，不阻塞的话就不必了(因为会自旋)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 node 对象就是 A ，B 线程实际存储数据的容器。A 线程存在 item 属性上，B 线程存储在 match 线程上，称为匹配。同时，有个线程对象，你应该猜到做什么用处的吧，对，挂起线程的。</p>
<p>和 SynchronousQueue 的区别在于， SynchronousQueue 使用了一个变量来保存数据项，通过 isData 来区别 “存” 操作和 “取” 操作。而 Exchange 使用了 2 个变量，就不用使用 isData 来区分了。</p>
<p>我们再来看看 Exchange 的唯一重要方法 ： exchange 方法。</p>
<h2 id="2-exchange-方法源码分析"><a href="#2-exchange-方法源码分析" class="headerlink" title="2. exchange 方法源码分析"></a>2. exchange 方法源码分析</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="comment">// arena 不是 Null ,返回的却是 null, 说明线程中断了.</span></span><br><span class="line">    <span class="comment">// 如果 arena 是 null, 就执行后面的方法.反之,如果不是 null, 执行没有意义.</span></span><br><span class="line">    <span class="comment">// 注意,当 slotExchange 有机会被执行,且返回的不是 null, 这个表达式整个就是 false, 下面的表达式就不会执行了.</span></span><br><span class="line">    <span class="comment">// 也就是说,当 slot 有效的时候, arena 是没有必要执行的.</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> || (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        <span class="comment">// 线程中断了,或者返回的是 null. 说明线程中断了</span></span><br><span class="line">        <span class="comment">// 如果线程没有中断 ,就执行后面的方法.</span></span><br><span class="line">        ((Thread.interrupted() || (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>)))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说一下方法的逻辑：</p>
<ol>
<li>如果执行 slotExchange 有结果,就不再执行 arenaExchange.</li>
<li>如果 slot 被占用了,就执行 arenaExchange.</li>
</ol>
<p>返回值是什么呢？返回值就是对方线程的数据项，如果 A 线程先调用，那么 A 线程将数据项存在 item 中，B 线程后调用，则 B 线程将数据存在 match 属性中。</p>
<p>A 返回的是 match 属性，b 返回的是 item 属性。</p>
<p>从该方法中，可以看到，有 2 个重要的方法： slotExchange， arenaExchange。先简单说说这两个方法。</p>
<p>当没有多线程并发操作 Exchange 的时候，使用 slotExchange 就足够了。 slot 是一个 node 对象。</p>
<p>当出现并发了，一个 slot 就不够了，就需要使用一个 node 数组 arena 操作了。</p>
<p>so，我们先看看 slotExchange 方法吧，两个方法的逻辑类似。</p>
<h2 id="3-slotExchange-方法源码分析"><a href="#3-slotExchange-方法源码分析" class="headerlink" title="3. slotExchange 方法源码分析"></a>3. slotExchange 方法源码分析</h2><p>代码加注释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">slotExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">       Node p = participant.get(); <span class="comment">// 从 ThreadLocal 中取出 node 对象</span></span><br><span class="line">       Thread t = Thread.currentThread();<span class="comment">// 当前线程</span></span><br><span class="line">       <span class="keyword">if</span> (t.isInterrupted()) <span class="comment">// preserve interrupt status so caller can recheck</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Node q;;) &#123;<span class="comment">// 死循环</span></span><br><span class="line">           <span class="comment">// 另一个下线程进入这里, 假设 slot 有值</span></span><br><span class="line">           <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 将  slot 修改为 null</span></span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   <span class="comment">// 拿到 q 的 item</span></span><br><span class="line">                   Object v = q.item;</span><br><span class="line">                   <span class="comment">// 自己的 item 赋值给 match,以让对方线程获取</span></span><br><span class="line">                   q.match = item;</span><br><span class="line">                   <span class="comment">// q 线程</span></span><br><span class="line">                   Thread w = q.parked;</span><br><span class="line">                   <span class="comment">// slot 的  parked 就是阻塞等待的线程对象.</span></span><br><span class="line">                   <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                       U.unpark(w);</span><br><span class="line">                   <span class="comment">// 返回了上一个线程放入的 item</span></span><br><span class="line">                   <span class="keyword">return</span> v;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果使用 CAS 修改slot 失败了,说明 slot 被使用了,那就需要创建 arena 数组了</span></span><br><span class="line">               <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                   U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ)) <span class="comment">// SEQ == 256; 默认 BOUND == 0</span></span><br><span class="line">                   arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];<span class="comment">// length = (2 + 2) &lt;&lt; 7 == 512</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果 slot 是 null, 但 arena 有值了,说明有线程竞争 slot 了,返回 null, 执行 arenaExchange 逻辑</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (arena != <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// caller must reroute to arenaExchange</span></span><br><span class="line">           <span class="keyword">else</span> &#123;<span class="comment">// 第一次循环,给 p node 的 item 赋值</span></span><br><span class="line">               p.item = item;</span><br><span class="line">               <span class="comment">// 将 slot 赋值赋值为 p</span></span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, <span class="keyword">null</span>, p))</span><br><span class="line">                   <span class="comment">// 赋值成功跳出循环</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="comment">// 如果 CAS 失败,将 p 的值清空,重来</span></span><br><span class="line">               p.item = <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 当走到这里的时候,说明 slot 是 null, 且 arena 不是 null(没有多线程竞争使用 slot),并且成功将 item 放入了 slot 中.</span></span><br><span class="line">       <span class="comment">// 这个时候要做的就是阻塞自己,等待对方取出 slot 的数据项,然后重置 slot 的数据和池化对象的数据</span></span><br><span class="line">       <span class="comment">// 伪随机数</span></span><br><span class="line">       <span class="keyword">int</span> h = p.hash;</span><br><span class="line">       <span class="comment">// 超时时间 </span></span><br><span class="line">       <span class="keyword">long</span> end = timed ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">       <span class="comment">// 自旋,默认 1024</span></span><br><span class="line">       <span class="keyword">int</span> spins = (NCPU &gt; <span class="number">1</span>) ? SPINS : <span class="number">1</span>;</span><br><span class="line">       Object v;</span><br><span class="line">       <span class="comment">// 如果这个值不是 null, 说明数据被其他线程拿走了, 并且其他线程将数据赋值给 match 属性,完成了一次交换</span></span><br><span class="line">       <span class="keyword">while</span> ((v = p.match) == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 自旋</span></span><br><span class="line">           <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 计算伪随机数</span></span><br><span class="line">               h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>;</span><br><span class="line">               <span class="comment">// 如果算出来的是0,就使用线程 ID</span></span><br><span class="line">               <span class="keyword">if</span> (h == <span class="number">0</span>)</span><br><span class="line">                   h = SPINS | (<span class="keyword">int</span>)t.getId();</span><br><span class="line">               <span class="comment">// 如果不是0,就将自旋数减一,并且让出 CPU 时间片</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                   Thread.yield();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果自旋数不够了,且 slot 还没有得到,就重置自旋数</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (slot != p)</span><br><span class="line">               spins = SPINS;</span><br><span class="line">           <span class="comment">// 如果 slot == p 了,说明对 slot 赋值成功</span></span><br><span class="line">           <span class="comment">// 如果线程没有中断 &amp;&amp; 数组不是 null &amp;&amp; 没有超时限制</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (!timed || (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">               <span class="comment">// 为线程中的 parkBlocker 属性赋值为 Exchange 自己</span></span><br><span class="line">               U.putObject(t, BLOCKER, <span class="keyword">this</span>);</span><br><span class="line">               <span class="comment">// node 节点的阻塞线程为当前线程</span></span><br><span class="line">               p.parked = t;</span><br><span class="line">               <span class="comment">// 如果这个数据还没有被拿走,阻塞自己</span></span><br><span class="line">               <span class="keyword">if</span> (slot == p)</span><br><span class="line">                   U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">               <span class="comment">// 线程苏醒后,将 p 的阻塞线程属性清空</span></span><br><span class="line">               p.parked = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">// 将当前线程的 parkBlocker 属性设置成 null</span></span><br><span class="line">               U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果有超时限制,使用 CAS 将 slot 从 p 变成 null,取消这次交换</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">               <span class="comment">// 如果CAS成功,如果时间到了 &amp;&amp; 线程没有中断 : 返回 time_out 对象: 返回 null</span></span><br><span class="line">               v = timed &amp;&amp; ns &lt;= <span class="number">0L</span> &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">// 跳出内层循环</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将 p 的 match 属性设置成 null, 表示初始化状态,没有任何匹配  &gt;&gt;&gt;  putOrderedObject是putObjectVolatile的内存非立即可见版本.</span></span><br><span class="line">       U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">// 重置 item</span></span><br><span class="line">       p.item = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 保留伪随机数,供下次种子数字</span></span><br><span class="line">       p.hash = h;</span><br><span class="line">       <span class="comment">// 返回</span></span><br><span class="line">       <span class="keyword">return</span> v;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>源码还是有点小长的。简单说说逻辑。</p>
<p>Exchange 使用了对象池的技术,将对象保存在 ThreadLocal 中,这个对象(Node)封装了数据项,线程对象等关键数据。</p>
<p>当第一个线程进入的时候,会将数据放到 池化对象中,并赋值给 slot 的 item.并阻塞自己(通常不会立即阻塞,而是使用 yield 自旋一会儿),等待对方取值.</p>
<p>当第二个线程进入的时候,会拿出存储在 slot item 中的值, 然后对 slot 的 match 赋值,并唤醒上次阻塞的线程.</p>
<p>当第一个线程阻塞被唤醒后,说明对方取到值了,就获取 slot 的 match 值, 并重置 slot 的数据和池化对象的数据,并返回自己的数据.</p>
<p>如果超时了,就返回 Time_out 对象.</p>
<p>如果线程中断了,就返回 null.</p>
<p>在该方法中,会返回 2 种结果,一是有效的 item, 二是 null— 要么是线程竞争使用 slot 了,创建了 arena 数组,要么是线程中断了.</p>
<p>用一幅图来看看具体逻辑，其实还是挺简单的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-fcb6dc8a5cf7412b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当 slot 被别是线程使用了，那么就需要创建一个 arena 的数组了。通过操纵数组里面的元素来实现数据交换。</p>
<p>关于 arenaExchange 方法的源码我就不贴了，有 2 个原因，一个是总体逻辑和 slotExchange 相同，第二个原因则是，其中有一些细节我没有弄懂，就不发出自己写代码注释了，防止误导。但我们已经掌握了 Exchange 的原理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Exchange 和 SynchronousQueue 类似，都是通过两个线程操作同一个对象实现数据交换，只不过就像我们开始说的，SynchronousQueue 使用的是同一个属性，通过不同的 isData 来区分，多线程并发时，使用了队列进行排队。</p>
<p>Exchange 使用了一个对象里的两个属性，item 和 match，就不需要 isData 属性了，因为在 Exchange 里面，没有 isData 这个语义。而多线程并发时，使用数组来控制，每个线程访问数组中不同的槽。</p>
<p>最后，用我们的图收尾吧：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-405970f00b740114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程-——-ConcurrentHashMap-Size-方法原理分析</title>
    <url>/2018/04/16/2018/2018-04-16-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E2%80%94%E2%80%94-ConcurrentHashMap-size-%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>ConcurrentHashMap 博大精深，从他的 50 多个内部类就能看出来，似乎 JDK 的并发精髓都在里面了。但他依然拥有体验良好的 API 给我们使用，程序员根本感觉不到他内部的复杂。但，他内部的每一个方法都复杂无比，就连 size 方法，都挺复杂的。</p>
<p>今天就一起来看看这个 size 方法。</p>
<h2 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> : (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大返回 int 最大值，但是这个 Map 的长度是有可能超过 int 最大值的，所以 JDK 8 增了 mappingCount 方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比较 size 方法，mappingCount 方法的返回值是 long 类型。所以不必限制最大值必须是 Integer.MAX_VALUE。而 JDK 推荐使用这个方法。但这个返回值依然不一定绝对准确。</p>
<p>从这两个方法中可以看出，sumCount 方法是核心。</p>
<h2 id="sumCount-方法实现"><a href="#sumCount-方法实现" class="headerlink" title="sumCount 方法实现"></a>sumCount 方法实现</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法逻辑：当 counterCells 不是 null，就遍历元素，并和 baseCount 累加。</p>
<p>两个属性 ： baseCount 和 counterCells。</p>
<p>先看 baseCount。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment"> * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment"> * races. Updated via CAS.</span></span><br><span class="line"><span class="comment"> * 当没有争用时，使用这个变量计数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br></pre></td></tr></table></figure>

<p>一个 volatile 的变量，在 addCount 方法中会使用它，而 addCount 方法在 put 结束后会调用。在 addCount 方法中，会对这个变量做 CAS 加法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a40dedc4bbf3307f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>但是如果并发导致 CAS 失败了，怎么办呢？使用 counterCells。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ac8855d5dcf40996.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果上面 CAS 失败了，在 fullAddCount 方法中，会继续死循环操作，直到成功。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a9a7cd9076a24321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>而这个 CounterCell 类又是上面鬼呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一种用于分配计数的填充单元。改编自LongAdder和Striped64。请查看他们的内部文档进行解释。</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了 sun.misc.Contended  标记的类，内部一个 volatile 变量。注释说，改编自LongAdder和Striped64,关于这两个类，请看 <a href="http://ifeve.com/java8-striped64-and-longadder/">Java8 Striped64 和 LongAdder</a>。</p>
<p>而关于这个注解，有必要解释一下。这个注解标识着这个类防止需要防止 “伪共享”.</p>
<p>说说伪共享。引用 一下别人的说法：</p>
<blockquote>
<p>避免伪共享(false sharing)。<br>先引用个伪共享的解释：<br>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，<br>一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，<br>如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>
</blockquote>
<p>所以伪共享对性能危害极大。</p>
<p>JDK 8 版本之前没有这个注解，Doug Lea 使用拼接来解决这个问题，把缓存行加满，让缓存之间的修改互不影响。</p>
<p>在我的机器上测试，加和不加这个注解的性能差距达到了 5 倍。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，关于 Size 方法就简单介绍到这里。总结一下：</p>
<p>JDK 8 推荐使用mappingCount 方法，因为这个方法的返回值是 long 类型，不会因为 size 方法是 int 类型限制最大值（size 方法是接口定义的，不能修改）。</p>
<p>在没有并发的情况下，使用一个 baseCount volatile 变量就足够了，当并发的时候，CAS 修改 baseCount 失败后，就会使用 CounterCell 类了，会创建一个这个对象，通常对象的 volatile value 属性是 1。在计算 size 的时候，会将 baseCount 和 CounterCell 数组中的元素的 value 累加，得到总的大小，但这个数字仍旧可能是不准确的。</p>
<p>还有一个需要注意的地方就是，这个 CounterCell 类使用了 sun.misc.Contended  注解标识，这个注解是防止伪共享的。是 1.8 新增的。使用时，需要加上 <code> -XX:-RestrictContended</code> 参数。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程——详解-AQS-CLH-锁</title>
    <url>/2018/04/16/2018/2018-04-16-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E8%AF%A6%E8%A7%A3-AQS-CLH-%E9%94%81/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       1. 从 acquire 方法开始 —— 获取
2. 为什么 AQS 需要一个虚拟 head 节点
3. reelase 方法如何释放锁
4. 总结

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AQS 是 JUC 中的核心，其中封装了资源的获取和释放，在我们之前的  <a href="http://thinkinjava.cn/article/50">并发编程之 AQS 源码剖析</a> 文章中，我们已经从 ReentranLock 那里分析了锁的获取和释放。但我有必要再次解释 AQS 的核心 CLH 锁。</p>
<p>这里引用一下别人对于 CLH 的解释：</p>
<blockquote>
<p>CLH CLH(Craig, Landin, and Hagersten  locks): 是一个自旋锁，能确保无饥饿性，提供先来先服务的公平性。</p>
</blockquote>
<blockquote>
<p>CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p>
</blockquote>
<p>Java AQS 的设计对 CLH 锁进行了优化或者说变体。</p>
<p>我们还是从代码开始说起吧。</p>
<h2 id="1-从-acquire-方法开始-——-获取"><a href="#1-从-acquire-方法开始-——-获取" class="headerlink" title="1. 从 acquire 方法开始 —— 获取"></a>1. 从 acquire 方法开始 —— 获取</h2><p>acquire 方法是获取锁的常用方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 当 tryAcquire 返回 true 就说明获取到锁了，直接结束。</span></span><br><span class="line">	<span class="comment">// 反之，返回 false 的话，就需要执行后面的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要子类的 tryAcquire 方法返回 false，那么就说明获取锁事变，就需要将自己加入队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个独占类型的节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果 tail 节点不是 null，就将新节点的 pred 节点设置为 tail 节点。</span></span><br><span class="line">    <span class="comment">// 并且将新节点设置成 tail 节点。</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 tail 节点是  null，或者 CAS 设置 tail 失败。</span></span><br><span class="line">    <span class="comment">// 在 enq 方法中处理</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将自己加入了尾部，并更新了 tail 节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果 tail 是 null，就创建一个虚拟节点，同时指向 head 和 tail，称为 初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是 null</span></span><br><span class="line">        	<span class="comment">// 和 上个方法逻辑一样，将新节点追加到 tail 节点后面，并更新队列的 tail 为新节点。</span></span><br><span class="line">        	<span class="comment">// 只不过这里是死循环的，失败了还可以再来 。</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enq 方法的逻辑是什么呢？当 tail 是 null（没有初始化队列），就需要初始化队列了。CAS 设置  tail 失败，也会走这里，需要在 enq 方法中循环设置 tail。直到成功。</p>
<p>注意：这里会创建一个<strong>虚拟节点。</strong></p>
<h2 id="2-为什么-AQS-需要一个虚拟-head-节点"><a href="#2-为什么-AQS-需要一个虚拟-head-节点" class="headerlink" title="2. 为什么 AQS 需要一个虚拟 head 节点"></a>2. 为什么 AQS 需要一个虚拟 head 节点</h2><p>为什么要创建一个虚拟节点呢？</p>
<p>事情要从 Node 类的 waitStatus 变量说起，简称 ws。每个节点都有一个 ws 变量，用于这个节点状态的一些标志。初始状态是 0。如果被取消了，节点就是 1，那么他就会被 AQS 清理。</p>
<p>还有一个重要的状态：SIGNAL —— -1，表示：当当前节点释放锁的时候，需要唤醒下一个节点。</p>
<p>所有，每个节点在休眠前，都需要将前置节点的 ws 设置成 SIGNAL。<strong>否则自己永远无法被唤醒</strong>。</p>
<p>而为什么需要这么一个 ws 呢？—— 防止重复操作。假设，当一个节点已经被释放了，而此时另一个线程不知道，再次释放。这时候就错误了。</p>
<p>所以，需要一个变量来保证这个节点的状态。而且修改这个节点，必须通过 CAS 操作保证线程安全。</p>
<p>So，回到我们之前的问题：为什么要创建一个虚拟节点呢？</p>
<p>每个节点都必须设置前置节点的 ws 状态为 SIGNAL，所以必须要一个前置节点，而这个前置节点，实际上就是当前持有锁的节点。</p>
<p>问题在于有个边界问题：<strong>第一个节点怎么办？</strong>他是没有前置节点的。</p>
<blockquote>
<p>那就创建一个假的。</p>
</blockquote>
<p>这就是为什么要创建一个虚拟节点的原因。</p>
<p>总结下来就是：<strong>每个节点都需要设置前置节点的 ws 状态（这个状态为是为了保证数据一致性），而第一个节点是没有前置节点的，所以需要创建一个虚拟节点</strong>。</p>
<p>回到我们的 acquireQueued 方法证实一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里返回的节点是新创建的节点，arg 是请求的数量</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 找上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果上一个节点是 head ，就尝试获取锁</span></span><br><span class="line">            <span class="comment">// 如果 获取成功，就将当前节点设置为 head，注意 head 节点是永远不会唤醒的。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在获取锁失败后，就需要阻塞了。</span></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire ---&gt; 检查上一个节点的状态，如果是 SIGNAL 就阻塞，否则就改成 SIGNAL。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有 2 个逻辑：</p>
<ol>
<li>如何将自己挂起？</li>
<li>被唤醒之后做什么？</li>
</ol>
<p>先回答第二个问题： 被唤醒之后做什么？</p>
<p>尝试拿锁，成功之后，将自己设置为 head，断开和 next 的连接。</p>
<p>再看第二个问题：如何将自己挂起？</p>
<p>注意：挂起自己之前，需要将前置节点的 ws 状态设置成 SIGNAL，告诉他：你释放锁的时候记得唤醒我。</p>
<p>具体逻辑在 shouldParkAfterFailedAcquire 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//  如果他的上一个节点的 ws 是 SIGNAL，他就需要阻塞。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    	<span class="comment">// 阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 前任被取消。 跳过前任并重试。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        	<span class="comment">// 将前任的前任 赋值给 当前的前任</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将前任的前任的 next 赋值为 当前节点</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    	<span class="comment">// 如果没有取消 || 0 || CONDITION || PROPAGATE，那么就将前任的 ws 设置成 SIGNAL.</span></span><br><span class="line">    	<span class="comment">// 为什么必须是 SIGNAL 呢？</span></span><br><span class="line">    	<span class="comment">// 答：希望自己的上一个节点在释放锁的时候，通知自己（让自己获取锁）</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的主要逻辑就是将前置节点的状态修改成 SIGNAL。其中如果前置节点被取消了，就跳过他。</p>
<p>那么肯定，在前置节点释放锁的时候，肯定会唤醒这个节点。看看释放的逻辑吧。</p>
<h2 id="3-reelase-方法如何释放锁"><a href="#3-reelase-方法如何释放锁" class="headerlink" title="3. reelase 方法如何释放锁"></a>3. reelase 方法如何释放锁</h2><p>先来一波代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 所有的节点在将自己挂起之前，都会将前置节点设置成 SIGNAL，希望前置节点释放的时候，唤醒自己。</span></span><br><span class="line">        <span class="comment">// 如果前置节点是 0 ，说明前置节点已经释放过了。不能重复释放了，后面将会看到释放后会将 ws 修改成0.</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>从这个方法的判断就可以看出，head 必须不等于 0。为什么呢？当一个节点尝试挂起自己之前，都会将前置节点设置成 SIGNAL -1，就算是第一个加入队列的节点，在获取锁失败后，也会将虚拟节点设置的 ws 设置成 SIGNAL。</p>
<p>而这个判断也是防止多线程重复释放。</p>
<p>那么肯定，在释放锁之后，肯定会将 ws 状态设置成 0。防止重复操作。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="comment">// 将 head 节点的 ws 改成 0，清除信号。表示，他已经释放过了。不能重复释放。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果 next 是 null，或者 next 被取消了。就从 tail 开始向上找节点。</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾部开始，向前寻找未被取消的节点，直到这个节点是 null，或者是 head。</span></span><br><span class="line">        <span class="comment">// 也就是说，如果 head 的 next 是 null，那么就从尾部开始寻找，直到不是 null 为止，找到这个 head 就不管了。</span></span><br><span class="line">        <span class="comment">// 如果是 head 的 next 不是 null，但是被取消了，那这个节点也会被略过。</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 head.next 这个节点。</span></span><br><span class="line">    <span class="comment">// 通常这个节点是 head 的 next。</span></span><br><span class="line">    <span class="comment">// 但如果 head.next 被取消了，就会从尾部开始找。</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 ws 小于 0，我们假设是 SIGNAL，就修改成 0.  证实了我们的想法。</p>
<p>如果他的 next 是 null，说明 next 取消了，那么就从尾部开始向上寻找（不从尾部也没办法）。当然找的过程中，也跳过了失效的节点。</p>
<p>最后，唤醒他。</p>
<p>唤醒之后的逻辑是什么样子的还记得吗？</p>
<p>复习一下：拿锁，设置自己为 head，断开前任 head 和自己的连接。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>AQS 使用的 CLH 锁，需要一个虚拟 head 节点，这个节点的作用是防止重复释放锁。当第一个进入队列的节点没有前置节点的时候，就会创建一个虚拟的。</p>
<p>来一幅图尝试解释 AQS 吧：</p>
<ol>
<li><p>新增节点时<br><img src="https://upload-images.jianshu.io/upload_images/4236553-d84d01082e8d1765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>更新 tail </p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-73807009865edd6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol start="3">
<li>唤醒节点时，之前的 head 取消了</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b7ca9dc21e29bc6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程-——-源码分析公平锁和非公平锁</title>
    <url>/2018/04/16/2018/2018-04-16-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E2%80%94%E2%80%94-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>ReentrantLock 提供了公平锁和非公平锁，只需要在构造方法中使用一个 <code>boolean</code> 参数即可。默认非公平锁。</p>
<p>今天从源码层面看看区别和具体实现。</p>
<h2 id="1-类-UML-图"><a href="#1-类-UML-图" class="headerlink" title="1. 类 UML 图"></a>1. 类 UML 图</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-72bf4f94efeac073.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>ReentrantLock</code> 内部有一个抽象类 <code>Sync</code>，继承了 AQS。</p>
<p>而公平锁的实现就是 <code>FairSync</code>，非公平锁的实现就是 <code>NodFairSync</code>。</p>
<p>两把锁的区别在于<code> lock</code> 方法的实现。</p>
<h2 id="2-公平锁-lock-方法实现"><a href="#2-公平锁-lock-方法实现" class="headerlink" title="2. 公平锁 lock 方法实现"></a>2. 公平锁 lock 方法实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的是 AQS 的<code>acquire</code>方法，熟悉 AQS 的同学都知道，AQS 会回调子类的 <code>tryAcquire</code> 方法，看看公平锁的<code>tryAcquire</code>实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说下逻辑：</p>
<ol>
<li>获取 state 变量，如果是 0，说明锁可以获取。</li>
<li><strong>判断 AQS 队列中是否有等待的线程</strong>，如果没有，就使用 CAS 尝试获取。获取成功后，将 CLH 的持有线程修改为当前线程。</li>
<li>重入锁逻辑。</li>
<li>如果失败，返回 false， AQS 会将这个线程放进队列，并挂起。</li>
</ol>
<p>注意上面的第二步：<strong>判断 AQS 队列中是否有等待的线程</strong>。</p>
<blockquote>
<p>这就是公平的体现。</p>
</blockquote>
<p>再看看非公平锁的区别。</p>
<h2 id="3-非公平锁-lock-方法实现"><a href="#3-非公平锁-lock-方法实现" class="headerlink" title="3. 非公平锁 lock 方法实现"></a>3. 非公平锁 lock 方法实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock  方法就不同了，很冲动的一个方法，直接使用 CAS 获取锁，如果成功了，就设置锁的持有线程为自己。很快速。所以默认使用了非公平锁。</p>
<p>如果失败了，就调用 AQS 的 <code>acquire</code> 方法。当然，我们看的还是<code>tryAcquire</code>方法，在上面的代码中，<code>tryAcquire</code>方法调用了父类<code> Sync</code> 的 <code>nonfairTryAcquire</code>，为什么在父类中呢？</p>
<p>在<code> ReentrantLock</code> 的 <code>tryLock </code>方法中，也调用了该方法。因为这个方法是快速返回的。该方法不会让等待时间久的线程获取锁。符合 <code>tryLock</code> 的设计。</p>
<p>方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法相比较公平锁的 <code>tryAcquire </code>方法，少了一步<strong>判断 AQS 队列中是否有等待的线程</strong>的操作。</p>
<p>他要做的就是直接抢锁，不让给队列里那些等待时间长的。</p>
<p>抢不到再进入队列。等待他的前置节点唤醒他。这个过程是公平的。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><code>ReentrantLock</code>中的公平锁和非公平锁的区别就在于：调用 <code>lock</code> 方法获取锁的时候 <code>要不要判断 AQS 队列中是否有等待的线程</code>，公平锁为了让每一个线程都均衡的使用锁，就需要判断，如果有，让给他，非公平锁很霸道，不让不让就不让。</p>
<p>但如果失败了，进入队列了，进会按照 AQS 的逻辑来，整体顺序就是公平的。</p>
<p>还有个注意的地方就是：<code>ReentrantLock</code> 的 <code>tryLock（无超时机制）</code> 方法使用的非公平策略。符合他的设计。</p>
<p>而 <code>tryLock(long timeout, TimeUnit unit)</code> 方法则会根据 Sync 的具体实现来调用。不会冲动的调用 <code>nonfairTryAcquire</code> 方法。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程-——-自己写一个异步回调-API</title>
    <url>/2018/04/17/2018/2018-04-17-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E2%80%94%E2%80%94-%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83-API/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 1. 前言

<p>在并发编程中，异步回调的效率不言而喻，在业务开发中，如果由阻塞的任务需要执行，必然要使用异步线程。并且，如果我们想在异步执行之后，根据他的结果执行一些动作。</p>
<p>JDK 8 之前的 Future 只能解决上面需求的一半问题，即异步执行，返回一个 Future，需要程序员调用 get 方法等待，或者使用 isDone 轮询。</p>
<p>效率不高。</p>
<p>JDK 8 新出的 CompletableFuture API 可以解决这个问题。但他的 API， 说实话，不太好用。</p>
<p>我们只想要一个简单的 API，能实现我们的回调功能。</p>
<p>我需要 3 个功能： </p>
<ol>
<li>能通过 get 之类的方法返回结果。</li>
<li>能设置监听器进行回调。</li>
<li>可以在业务线程中设置成功或者失败。</li>
</ol>
<p>楼主写一个简单的例子，借鉴了 Netty 的异步 API，希望能起到抛砖引玉的作用。</p>
<h2 id="2-设计"><a href="#2-设计" class="headerlink" title="2. 设计"></a>2. 设计</h2><p>根据我们的需求：<br>第一，我们需要一个类，拥有 get 方法和 addListener 方法。<br>第二，我们需要一个类，能够回调我们设置的监听器。<br>第三，我们需要一个类，能够在业务线程中设置成功或者失败。</p>
<h2 id="3-初步实现"><a href="#3-初步实现" class="headerlink" title="3. 初步实现"></a>3. 初步实现</h2><p>设计一个监听器接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyListener</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 子类需要重写此方法，在异步任务完成之后会回调此方法。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> promise 异步结果占位符。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(MyPromise promise)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>设计一个异步占位符，类似 Future：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行结果占位符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 监听器集合*/</span></span><br><span class="line">  List&lt;MyListener&gt; listeners = <span class="keyword">new</span> ArrayList&lt;MyListener&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 是否成功*/</span></span><br><span class="line">  <span class="keyword">boolean</span> success;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 执行结果**/</span></span><br><span class="line">  Object result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置事变计数器**/</span></span><br><span class="line">  <span class="keyword">int</span> failCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置成功，并通知所有监听器。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> result 结果</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setSuccess</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.result = result;</span><br><span class="line"></span><br><span class="line">    signalListeners();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通知所有监听器，回调监听器方法。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (MyListener l : listeners) &#123;</span><br><span class="line">      l.operationComplete(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置失败</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 异常对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 设置是否成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setFail</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (failCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++failCount;</span><br><span class="line">    result = e;</span><br><span class="line">    signalListeners();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否成功执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加监听器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> myListener 监听器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(MyListener myListener)</span> </span>&#123;</span><br><span class="line">    listeners.add(myListener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除监听器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> myListener 监听器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(MyListener myListener)</span> </span>&#123;</span><br><span class="line">    listeners.remove(myListener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取执行结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望使用线程池执行此类任务，所以需要一个自定义的 Runnable，而在这个 Runnable 中，我们需要做一些简单的手脚：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个任务类，通过重写 doWork 方法执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; 返回值类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> MyPromise myPromise;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">MyRunnable</span><span class="params">(MyPromise myPromise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.myPromise = myPromise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      V v = doWork();</span><br><span class="line">      myPromise.setSuccess(v);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      myPromise.setFail(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 子类需要重写此方法。并返回值，这个值由 Promise 的 get 方法返回。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-写个-Demo-测试一下"><a href="#4-写个-Demo-测试一下" class="headerlink" title="4. 写个 Demo 测试一下"></a>4. 写个 Demo 测试一下</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stateis0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 占位对象</span></span><br><span class="line">    <span class="keyword">final</span> MyPromise myPromise = <span class="keyword">new</span> MyPromise();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Dto dto = <span class="keyword">new</span> Dto();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池</span></span><br><span class="line">    Executor executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步执行任务，</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> MyRunnable&lt;String&gt;(myPromise) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dto.doSomething();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个监听器</span></span><br><span class="line">    myPromise.addListener(<span class="keyword">new</span> MyListener() &#123;</span><br><span class="line">      <span class="comment">// 当任务完成后，就执行此方法。</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(MyPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        String result;</span><br><span class="line">        <span class="comment">// 如果任务成功执行了</span></span><br><span class="line">        <span class="keyword">if</span> (promise.isSuccess()) &#123;</span><br><span class="line">          <span class="comment">// 获取结果并打印</span></span><br><span class="line">          result = (String) promise.get();</span><br><span class="line">          System.out.println(<span class="string">&quot;operationComplete ----&gt; &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果失败了, 打印异常堆栈</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ((Exception) promise.get()).printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line"><span class="comment">//    throw new RuntimeException(&quot;cxs&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;result is success&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doSomething</span><br><span class="line">operationComplete ----&gt; result is success</span><br></pre></td></tr></table></figure>


<p>符合我们的预期。我们希望在业务对象 Dto 的 doSomething 成功返回之后，回调监听器的  operationComplete 方法。如果失败，打印异常堆栈。</p>
<p>当然，整体代码比较简单，仅仅只是抛砖引玉。</p>
<p>实际上，如果直接向 Callable 或者 Runnable 传入一个业务对象，当 call 方法或者 run 方法执行完毕，就可以根据执行结果执行我们的业务对象的方法了。这样就是一个最简单直接的异步回调。</p>
<p>只是这样过于耦合。</p>
<p>异步任务和业务的任务耦合在了一起，并且不能添加多个监听器，也无法使用  promise 的 setSuccess 功能和 setFail 功能，这两个功能可以在业务线程中设置成功或者失败，灵活性更高。</p>
<p>关于异步，我们可以多看看 Netty 的 API 设计，易懂好用。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之——写锁源码分析</title>
    <url>/2018/04/18/2018/2018-04-18-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E2%80%94%E2%80%94%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 1.前言

<p>Java 中的读写锁实现是  ReentrantReadWriteLock ，是一种锁分离策略。能有效提高读比写多的场景下的程序性能。</p>
<p>关于如何使用参见 <a href="http://thinkinjava.cn/article/36">并发编程之 Java 三把锁</a>。</p>
<p>由于读写锁较为复杂，故分为篇文章进行源码分析，今天先说较为简单的写锁。</p>
<h2 id="2-写锁介绍"><a href="#2-写锁介绍" class="headerlink" title="2. 写锁介绍"></a>2. 写锁介绍</h2><p>不论是读锁还是写锁，都是基于 AQS 的，而 AQS 留给子类实现的就是 tryAcquire 或者 tryAcquireShared 方法，前者是写锁的实现，后者是读锁的实现，从名字上可以看出，一个是独占锁，一个是共享锁。</p>
<p>今天看的就是 tryAcquire 和 tryRelease 的实现，获取和释放。</p>
<h2 id="3-tryAcquire-实现"><a href="#3-tryAcquire-实现" class="headerlink" title="3. tryAcquire 实现"></a>3. tryAcquire 实现</h2><p>源码加注释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果有读锁，此时是获取不到写锁的。当有写锁时，判断重入次数。</span></span><br><span class="line"><span class="comment">// 当写锁空闲，读锁空闲，公平模式下，如果队列中有等待的，不会抢锁。非公平模式下，必抢锁。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 用 state &amp; 65535 得到低 16 位的值。</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 如果 state 不是0，且低16位是0，说明了什么？说明写锁是空闲的，读锁被霸占了。那么也不能拿锁，返回 fasle。</span></span><br><span class="line">        <span class="comment">// 如果低 16 位不是0，说明写锁被霸占了，并且，如果持有锁的不是当前线程，那么这次拿锁是失败的。返回 fasle。</span></span><br><span class="line">        <span class="comment">// 总之，当有读锁，就不能获取写锁。当有写锁，就必须是重入锁。</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 到这一步了，只会是写重入锁。如果写重入次数超过最大值 65535，就会溢出。</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 将 state  + 1</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 state 是 0 的时候，那么就可以获取锁了。</span></span><br><span class="line">    <span class="comment">// writerShouldBlock 判断是否需要锁。非公平情况下，返回 false。公平情况下，根据 hasQueuedPredecessors 结果判断。</span></span><br><span class="line">    <span class="comment">// 当队列中有锁等待了，就返回 false 了。</span></span><br><span class="line">    <span class="comment">// 当是非公平锁的时候，或者队列中没有等待节点的时候，尝试用 CAS 修改 state。</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 修改成功 state 后，修改锁的持有线程。</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br></pre></td></tr></table></figure>

<p>详解的逻辑都写在注释里了，可以对照源码查看，这里再次总结这个方法的逻辑。</p>
<ol>
<li><p>首先判断锁是否空闲。</p>
</li>
<li><p>如果空闲，则根据公平与否判断是否应该获取锁，当 <code>writerShouldBlock</code> 返回结果是<code> false</code> 的时候，就使用 CAS  修改 state 变量，获取锁。成功之后修改 AQS 持有线程。</p>
</li>
<li><p>如果不是空闲的，则判断写锁是否是空闲的，这里有 2 种情况：</p>
<p>3.1 如果写锁空闲，但 <code>state</code> 不是0，说明有读锁，那么就不能获取锁。</p>
<p>3.2 如果写锁不空闲，判断持有 AQS 锁的线程是不是当前线程，如果不是，不能获取，反之，可以获取重入锁。</p>
</li>
</ol>
<h2 id="4-tryRelease-实现"><a href="#4-tryRelease-实现" class="headerlink" title="4. tryRelease 实现"></a>4. tryRelease 实现</h2><p>代码加注释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否持有当前锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 计算 state 值</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">// 计算写锁的状态，如果是0，说明是否成功。</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 释放成功，设置持有锁的线程为 null。</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置 state</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是很简单的，只是有一个地方需要注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算写锁的状态，如果是0，说明是否成功。</span></span><br><span class="line"><span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这里计算的只是 state 变量的低 16 的值，而不是整个 state 的值。虽然写的时候，必然是串行的，但这里计算的仍然是低 16 位的。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>写锁在获取锁的时候，有几个地方需要注意：当有读锁的时候，是不能获取写锁的。写锁可以重入，但不能超过 65535 次。写锁状态设置在 state 变量的低 16 位。</p>
<p>同时，在获取锁的时候，也会根据公平与否决定此次释放需要获取锁。</p>
<p>如果是非公平的，直接尝试CAS 修改 state ，获取锁。</p>
<p>如果是公平的，则根据 hasQueuedPredecessors 方法的返回值判断，也就是如果队列中有等待的线程，则依据公平策略，放弃此次获取锁的操作。反之，直接获取锁。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程-——-Timer-源码分析</title>
    <url>/2018/04/20/2018/2018-04-20-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E2%80%94%E2%80%94-Timer-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>在平时的开发中，肯定需要使用定时任务，而 Java 1.3 版本提供了一个 java.util.Timer 定时任务类。今天一起来看看这个类。</p>
<h2 id="1-API-介绍"><a href="#1-API-介绍" class="headerlink" title="1.API 介绍"></a>1.API 介绍</h2><p>Timer 相关的有 3 个类：</p>
<p>Timer ：面向程序员的API 都在这个类中。<br>TaskQuue: 存储任务。<br>TimerThread： 执行任务的线程。</p>
<p>这个类的构造方法有 4 个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timer()                               创建一个新计时器。</span><br><span class="line">Timer(<span class="keyword">boolean</span> isDaemon)               创建一个新计时器，可以指定其相关的线程作为守护程序运行。</span><br><span class="line">Timer(String name)                    创建一个新计时器，其相关的线程具有指定的名称。</span><br><span class="line">Timer(String name, <span class="keyword">boolean</span> isDaemon)  创建一个新计时器，其相关的线程具有指定的名称，并且可以指定作为守护程序运行。</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">程序员可以使用的 API 如下：</span><br><span class="line">```<span class="function">java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span>                                                          终止此计时器，丢弃所有当前已安排的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">purge</span><span class="params">()</span>                                                            从此计时器的任务队列中移除所有已取消的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, Date time)</span>                               安排在指定的时间执行指定的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, Date firstTime, <span class="keyword">long</span> period)</span>             安排指定的任务在指定的时间开始进行重复的固定延迟执行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay)</span>                              安排在指定延迟后执行指定的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span>                 安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">(TimerTask task, Date firstTime, <span class="keyword">long</span> period)</span>  安排指定的任务在指定的时间开始进行重复的固定速率执行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span>      安排指定的任务在指定的延迟后开始进行重复的固定速率执行。</span></span><br></pre></td></tr></table></figure>

<p>下面从几个具有代表性的方法开始分析 Timer 的源码。</p>
<h2 id="2-从构造方法开始"><a href="#2-从构造方法开始" class="headerlink" title="2. 从构造方法开始"></a>2. 从构造方法开始</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;Timer-&quot;</span> + serialNumber());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    thread.setName(name);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The timer thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TimerTask[] queue = <span class="keyword">new</span> TimerTask[<span class="number">128</span>];</span><br></pre></td></tr></table></figure>


<p>从上面一连串的构造方法中，可以看出，Timer 内部使用了一个线程 TimerThread，线程的构造参数是一个队列（数组）。</p>
<p>然后直接启动了这个线程，默认是非守护模式的。</p>
<p>而这个线程的 run 方法又是如何的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mainLoop();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></span><br><span class="line">        <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">            newTasksMayBeScheduled = <span class="keyword">false</span>;</span><br><span class="line">            queue.clear();  <span class="comment">// Eliminate obsolete references</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要执行 mainLoop 方法，当任务结束后，清除队列。并不在接受新的任务。</p>
<p>那么这个 mainLoop 方法的逻辑是什么呢？猜想一下，肯定是执行队列中的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimerTask task;</span><br><span class="line">            <span class="keyword">boolean</span> taskFired;</span><br><span class="line">            <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">                <span class="comment">// 如果队列是空 且 newTasksMayBeScheduled 是 true，阻塞等待</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                    queue.wait();</span><br><span class="line">                <span class="comment">// 如果被唤醒了，且队列还是空，跳出循环结束。</span></span><br><span class="line">                <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></span><br><span class="line">                <span class="keyword">long</span> currentTime, executionTime;</span><br><span class="line">                <span class="comment">// 拿到队列中第一个任务。</span></span><br><span class="line">                task = queue.getMin();</span><br><span class="line">                <span class="keyword">synchronized</span>(task.lock) &#123;<span class="comment">// 对这个任务进行同步</span></span><br><span class="line">                    <span class="comment">// 如果取消了，就删除这个任务，并跳过这次循环</span></span><br><span class="line">                    <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">                        queue.removeMin();</span><br><span class="line">                        <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    currentTime = System.currentTimeMillis();</span><br><span class="line">                    executionTime = task.nextExecutionTime;</span><br><span class="line">                    <span class="comment">// 如果任务的下次执行时间小于当前时间，</span></span><br><span class="line">                    <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">                        <span class="comment">// 且任务是不重复的</span></span><br><span class="line">                        <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></span><br><span class="line">                            <span class="comment">// 删除这个任务</span></span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            <span class="comment">// 修改状态</span></span><br><span class="line">                            task.state = TimerTask.EXECUTED;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></span><br><span class="line">                            <span class="comment">// 如果任务是重复的。重新调度任务时间，以便下次执行。</span></span><br><span class="line">                            queue.rescheduleMin(</span><br><span class="line">                              task.period&lt;<span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">                                            : executionTime + task.period);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果时间没到，就等代指定时间</span></span><br><span class="line">                <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn&#x27;t yet fired; wait</span></span><br><span class="line">                    queue.wait(executionTime - currentTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果时间到了，就执行任务。</span></span><br><span class="line">            <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></span><br><span class="line">                task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 如果有中断异常就忽略。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一如既往，写了很多注释，简单说说逻辑：</p>
<ol>
<li>死循环并锁住队列，因为这个 Timer 对象可能会被多个线程使用。</li>
<li>从队列中取出任务。如果任务是重复执行的，就重新设置任务的执行时间。</li>
<li>执行任务的 run 方法。</li>
</ol>
<p>这里有几个注意的地方：</p>
<ol>
<li>该方法忽略了线程中断异常。当 wait 方法中断异常的时候，是不起作用的。</li>
<li>该方法值只捕获线程中断异常，如果发生了其他异常，整个 Timer 就会停止。</li>
</ol>
<p>So，一定不要在自己的任务里抛出异常，否则一定会影响整个定时任务。</p>
<h2 id="3-schedule-方法"><a href="#3-schedule-方法" class="headerlink" title="3. schedule 方法"></a>3. schedule 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">timer.schedule(<span class="keyword">new</span> MyTask(), <span class="number">1000</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>以上定义了一个任务，1 秒后执行，重复执行时间 2 秒。</p>
<p>schedule 代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative delay.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Non-positive period.&quot;</span>);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, -period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 dealy 时间的基础上，加上了当前时间，将 period 变成负数。</p>
<p>看看 sched 方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal execution time.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止数值溢出</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</span><br><span class="line">        period &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">        <span class="comment">// 如果该变量是 false ，说明任务线程停止了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Timer already cancelled.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">            <span class="comment">// 如果任务状态不是纯洁的初始状态，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;Task already scheduled or cancelled&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这只下次执行时间</span></span><br><span class="line">            task.nextExecutionTime = time;</span><br><span class="line">            task.period = period;</span><br><span class="line">            task.state = TimerTask.SCHEDULED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加进队列末尾</span></span><br><span class="line">        queue.add(task);</span><br><span class="line">        <span class="comment">// 如果获取到第一个任务就刚刚添加的任务，说明线程阻塞了，唤醒他。</span></span><br><span class="line">        <span class="keyword">if</span> (queue.getMin() == task)</span><br><span class="line">            queue.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下该方法，将任务添加进队列，如果调度线程结束了，就抛出异常—— 不能再添加。如果添加成功之后，获取到的第一个任务就是这个任务，说明调度线程阻塞了，那就唤醒他。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>从一个定时任务的角度讲，Timer 非常的简单，使用一个线程，使用一个队列。在简单的场合，Timer 确实能够满足需求，但 Timer 还是有很多的缺陷：</p>
<ol>
<li><p>不能 catch 住非线程中断异常，如果用户任务异常，将会导致整个 Timer 停止。</p>
</li>
<li><p>默认情况下不是守护线程，也就是说，他会阻止应用程序停止。你可以使用 cancel 方法停止他。</p>
</li>
<li><p>如果 Timer 因为 stop 方法获取用户任务异常终止了，那么将再也不能向队列中添加任务了。否则抛出异常。</p>
</li>
<li><p>如果某个任务的执行时间太长，那么他将会 “独占” 计时器的任务执行现场。导致延迟后续任务的执行，并且会将任务 “堆” 在一起。</p>
</li>
</ol>
<p>So, 大规模的生产环境中，不建议使用 Timer，而是使用 JUC 的 ScheduledThreadPoolExecutor。楼主将在后面的文章中分析  ScheduledThreadPoolExecutor 的实现，相比较 Timer 有什么好处。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之——读锁源码分析(解释关于锁降级的争议)</title>
    <url>/2018/04/18/2018/2018-04-18-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E2%80%94%E2%80%94%E8%AF%BB%E9%94%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E8%A7%A3%E9%87%8A%E5%85%B3%E4%BA%8E%E9%94%81%E9%99%8D%E7%BA%A7%E7%9A%84%E4%BA%89%E8%AE%AE)/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 1. 前言

<p>在前面的文章 <a href="http://thinkinjava.cn/article/106">并发编程之——写锁源码分析</a>中，我们分析了 1.8 JUC 中读写锁中的<strong>写锁的获取和释放过程</strong>，今天来分析一下读锁的获取和释放过程，读锁相比较写锁要稍微复杂一点，其中还有一点有争议的地方——锁降级。</p>
<p>今天就来解开迷雾。</p>
<h2 id="2-获取读锁-tryAcquireShared-方法"><a href="#2-获取读锁-tryAcquireShared-方法" class="headerlink" title="2. 获取读锁 tryAcquireShared 方法"></a>2. 获取读锁 tryAcquireShared 方法</h2><p>首先说明，获取读锁的过程是获取共享锁的过程。</p>
<p>代码加注释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> int11 <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// exclusiveCount(c) != 0 ---》 用 state &amp; 65535 得到低 16 位的值。如果不是0，说明写锁别持有了。</span></span><br><span class="line">    <span class="comment">// getExclusiveOwnerThread() != current----&gt; 不是当前线程</span></span><br><span class="line">    <span class="comment">// 如果写锁被霸占了，且持有线程不是当前线程，返回 false，加入队列。获取写锁失败。</span></span><br><span class="line">    <span class="comment">// 反之，如果持有写锁的是当前线程，就可以继续获取读锁了。</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="comment">// 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果写锁没有被霸占，则将高16位移到低16位。</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);<span class="comment">// c &gt;&gt;&gt; 16</span></span><br><span class="line">    <span class="comment">// !readerShouldBlock() 和写锁的逻辑一样（根据公平与否策略和队列是否含有等待节点）</span></span><br><span class="line">    <span class="comment">// 不能大于 65535，且 CAS 修改成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; r &lt; <span class="number">65535</span> &amp;&amp; compareAndSetState(c, c + <span class="number">65536</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果读锁是空闲的， 获取锁成功。</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前线程设置为第一个读锁线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">// 计数器为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">// 如果读锁不是空闲的，且第一个读线程是当前线程。获取锁成功。</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;<span class="comment">// </span></span><br><span class="line">            <span class="comment">// 将计数器加一</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是第一个线程，获取锁成功。</span></span><br><span class="line">            <span class="comment">// cachedHoldCounter 代表的是最后一个获取读锁的线程的计数器。</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 如果最后一个线程计数器是 null 或者不是当前线程，那么就新建一个 HoldCounter 对象</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 给当前线程新建一个 HoldCounter</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="comment">// 如果不是 null，且 count 是 0，就将上个线程的 HoldCounter 覆盖本地的。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 对 count 加一</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死循环获取读锁。包含锁降级策略。</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下上面代码的逻辑吧！</p>
<ol>
<li>判断写锁是否空闲。</li>
<li>如果不是空闲，且当前线程不是持有写锁的线程，则返回 -1 ，表示抢锁失败。如果是空闲的，进入第三步。如果是当前线程，进入第三步。</li>
<li>判断持有读锁的数量是否超过 65535，然后使用 CAS 设置 int 高 16 位的值，也就是加一。</li>
<li>如果设置成功，且是第一次获取读锁，就设置 firstReader 相关的属性（为了性能提升）。</li>
<li>如果不是第一次，当当前线程就是第一次获取读锁的线程，对 “第一次获取读锁线程计数器” 加 1.</li>
<li>如果都不是，则获取最后一个读锁的线程计数器，判断这个计数器是不是当前线程的。如果是，加一，如果不是，自己创建一个新计数器，并更新 “最后读取的线程计数器”（也是为了性能考虑）。最后加一。返回成功。</li>
<li>如果上面的判断失败了（CAS 设置失败，或者队列有等待的线程（公平情况下））。就调用 fullTryAcquireShared 方法死循环执行上面的步骤。</li>
</ol>
<p>步骤还是有点多哈，画个图吧，更清晰一点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c747934c55844272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其实，上面的逻辑里，是有锁降级的逻辑在里面的。但我们等会放在后面说。</p>
<p>先看看 <code>fullTryAcquireShared</code> 方法，其实这个方法和 <code>tryAcquireShared</code> 高度类似。代码加注释如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这段代码与tryAcquireShared中的代码有部分重复，但整体更简单。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果存在写锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 并且不是当前线程，获取锁失败，反之，如果持有写锁的是当前线程，那么就会进入下面的逻辑。</span></span><br><span class="line">            <span class="comment">// 反之，如果存在写锁，但持有写锁的是当前线程。那么就继续尝试获取读锁。</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果写锁空闲，且可以获取读锁。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// 第一个读线程是当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果不是当前线程</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        <span class="comment">// 从 ThreadLocal 中取出计数器</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果读锁次数达到 65535 ，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试对 state 加 65536, 也就是设置读锁，实际就是对高16位加一。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 如果读锁是空闲的</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置第一个读锁</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                <span class="comment">// 计数器为 1</span></span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果不是空闲的，查看第一个线程是否是当前线程。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;<span class="comment">// 更新计数器</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))<span class="comment">// 如果最后一个读计数器所属线程不是当前线程。</span></span><br><span class="line">                    <span class="comment">// 自己创建一个。</span></span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                <span class="comment">// 对计数器 ++</span></span><br><span class="line">                rh.count++;</span><br><span class="line">                <span class="comment">// 更新缓存计数器。</span></span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法其实高度相似的。就不再解释了。</p>
<p>到这里，其实留下了几个问题：一个是 <code>firstReader </code>和 <code>firstReaderHoldCount</code> 的作用，还有就是 <code>cachedHoldCounter</code> 的作用。最后是锁降级。</p>
<p>解释一下：</p>
<ul>
<li><code>firstReader</code> 是获取读锁的第一个线程。如果只有一个线程获取读锁，很明显，使用这样一个变量速度更快。<br> * <code>firstReaderHoldCount </code>是 <code>firstReader</code>的计数器。同上。</li>
<li><code>cachedHoldCounter</code>是最后一个获取到读锁的线程计数器，每当有新的线程获取到读锁，这个变量都会更新。这个变量的目的是：当最后一个获取读锁的线程重复获取读锁，或者释放读锁，就会直接使用这个变量，速度更快，相当于缓存。</li>
</ul>
<p>关于锁降级，重点解释一下，毕竟是我们的标题。</p>
<h2 id="3-锁降级的争议"><a href="#3-锁降级的争议" class="headerlink" title="3. 锁降级的争议"></a>3. 锁降级的争议</h2><p>首先，什么是锁降级？在读锁的哪个地方体现？</p>
<p>回答第一个问题，引自 JDK 的解释：</p>
<blockquote>
<p>锁降级:<br>重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</p>
</blockquote>
<p>体现在读锁哪里？</p>
<p>在 tryAcquireShared 方法和 fullTryAcquireShared 中都有体现，例如下面的判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码的意思是：当写锁被持有时，如果持有该锁的线程不是当前线程，就返回 “获取锁失败”，反之就会继续获取读锁。称之为锁降级。</p>
<p>在很多书和文章中，对锁降级都会有类似下面的解释：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-929c163b9a89093d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上面提到，锁降级中，读锁的获取的目的是 “为了保证数据的可见性”。而得到这个结论的依据是 “如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程 T）获取了写锁并修改了数据，那么当前线程无法感知线程 T 的数据更新”。</p>
<p>这里貌似有个漏洞：如果另一个线程获取了写锁（并修改了数据），那么这个锁就被独占了，没有任何其他线程可以读到数据，更不用谈 “感知数据更新”。</p>
<p>楼主认为，锁降级说白了就是写锁的一种特殊重入机制。通过这种重入，可以减少一步流程——释放写锁后 再次 获取读锁。</p>
<p>使用了锁降级，就可以减去<strong>释放写锁</strong>的步骤。直接获取读锁。效率更高。而且没有线程争用。和 “可见性” 并没有关系。</p>
<p>用一幅图来展示锁降级：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f545a504abde8c2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>总的来说，锁降级就是一种特殊的锁重入机制，JDK 使用 <code>先获取写入锁，然后获取读取锁，最后释放写入锁</code> 这个步骤，是为了提高获取锁的效率，而不是所谓的可见性。</p>
<p>最后再总结一下获取锁的逻辑，首先判断写锁释放被持有了，如果被持有了，且是当前线程，使用锁降级，如果没有，读锁正常获取。</p>
<p>获取过程中，会使用 firstReader 和 cachedHoldCounter 提高性能。</p>
<h2 id="4-读锁的释放-tryReleaseShared-方法"><a href="#4-读锁的释放-tryReleaseShared-方法" class="headerlink" title="4. 读锁的释放 tryReleaseShared 方法"></a>4. 读锁的释放 tryReleaseShared 方法</h2><p>代码加注释如下：</p>
<pre><code class="java">
protected final boolean tryReleaseShared(int unused) &#123;
    Thread current = Thread.currentThread();
    // 如果是第一个线程
    if (firstReader == current) &#123;
        // 如果是 1，将第一个线程设置成 null。结束。
        if (firstReaderHoldCount == 1)
            firstReader = null;
        // 如果不是 1，减一操作
        else
            firstReaderHoldCount--;
    &#125; else &#123;//如果不是当前线程
        HoldCounter rh = cachedHoldCounter;
        // 如果缓存是 null 或者缓存所属线程不是当前线程，则当前线程不是最后一个读锁。
        if (rh == null || rh.tid != getThreadId(current))
            // 获取当前线程的计数器
            rh = readHolds.get();
        int count = rh.count;
        // 如果计数器小于等于一，就直接删除计数器
        if (count &lt;= 1) &#123;
            readHolds.remove();
            // 如果计数器的值小于等于0，说明有问题了，抛出异常
            if (count &lt;= 0)
                throw unmatchedUnlockException();
        &#125;
        // 对计数器减一
        --rh.count;
    &#125;
    for (;;) &#123;// 死循环使用 CAS 修改状态
        int c = getState();
        // c - 65536, 其实就是减去一个读锁。对高16位减一。
        int nextc = c - SHARED_UNIT;
        // 修改 state 状态。
        if (compareAndSetState(c, nextc))
            // 修改成功后，如果是 0，表示读锁和写锁都空闲，则可以唤醒后面的等待线程
            return nextc == 0;
    &#125;
&#125;
</code></pre>
<p>释放还是很简单的，步骤如下：</p>
<ol>
<li>如果当前线程是第一个持有读锁的线程，则只需要操作 firstReaderHoldCount 减一。如果不是，进入第二步。</li>
<li>获取到缓存计数器（最后一个线程的计数器），如果匹配到当前线程，就减一。如果不匹配，进入第三步。</li>
<li>获取当前线程自己的计数器（由于每个线程都会多次获取到锁，所以，每个线程必须保存自己的计数器。）。</li>
<li>做减一操作。</li>
<li>死循环修改 state 变量。</li>
</ol>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>“读写锁没有想象中简单” 是此次阅读源码的最大感慨。事实上，花的最多时间是锁降级，因为对这块的不理解，参照了一些书籍和博客，但还是云里雾里，我也不敢确定我说的就是全对的，但我敢说，我写的是经过我思考的。</p>
<p>总结下读锁的获取逻辑。</p>
<p>读锁本质上是个共享锁。</p>
<p>但读锁对锁的获取做了很多优化，比如使用  firstReader  和 cachedHoldCounter 最第一个读锁线程和最后一个读锁线程做优化，优化点主要在释放的时候对计数器的获取。</p>
<p>同时，如果在获取读锁的过程中写锁被持有了，JUC 并没有让所有线程痴痴的等待，而是判断入如果获取读锁的线程是正巧是持有写锁的线程，那么当前线程就可以降级获取写锁，否则就会死锁了（<strong>为什么死锁，当持有写锁的线程想获取读锁，但却无法降级，进入了等待队列，肯定会死锁</strong>）。</p>
<p>还有一点就是性能上的优化，如果先释放写锁，再获取读锁，势必引起锁的争抢和线程上下文切换，影响性能。</p>
<p>还有一个就是，读书的时候，要有怀疑精神，一定要思考，而不是顺着他的思路去看书，诚然，书中大部分时候都是正确的，但我们贪婪的希望，那错误的一小部分尽量不要影响到我们。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程——-FutureTask-源码分析</title>
    <url>/2018/04/20/2018/2018-04-20-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94-FutureTask-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 1. 前言

<p>当我们在 Java 中使用异步编程的时候，大部分时候，我们都会使用 Future，并且使用线程池的 submit 方法提交一个 Callable 对象。然后调用 Future 的 get 方法等待返回值。而 FutureTask 是 Future 的一个实现，也是我们今天的主角。</p>
<p>我们就从源码层面分析 FutureTask.</p>
<h2 id="2-FutureTask-初体验"><a href="#2-FutureTask-初体验" class="headerlink" title="2. FutureTask 初体验"></a>2. FutureTask 初体验</h2><p>我们一般接触的都是 Future ，而不是 FutureTask , Future 是一个接口， FutureTask 是一个标准的实现。在我们向线程池提交任务的时候，线程池会创建一个 FutureTask 返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newTaskFor 方法就是创建一个了一个 FutureTask 返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>而线程池就会执行 FutureTask 的 run 方法。</p>
<p>那么，我们看看 FutureTask 的 UML。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d998d1b07d607c56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>可以看出，FutureTask 实现了 Runnable，Future 。Runnable 就不必说了，一个 run 方法，那 Future 呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;   </span><br></pre></td></tr></table></figure>

<p>主要是这 5 个方法撑起了 Future，功能相对而言比较薄弱，毕竟这只是一个 Future ，而不是 Promise。</p>
<p>FutureTask 还有一个内部类，WaitNode ，结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来是不是和 AQS 的节点似曾相识呢？</p>
<p>FutureTask 内部维护了一个栈结构，和 AQS 的队列有所区别。</p>
<p>实际上，在之前的版本中，FutureTask 确实直接使用的 AQS ，但是 Doug lea 又对该类进行了优化，优化的目的是 ：</p>
<blockquote>
<p>主要是为了避免有些用户在取消竞争期间保留中断状态。</p>
</blockquote>
<p>而内部依然使用了一个 volatile 的 state 变量来控制状态，同时使用了一个栈结构来保存等待的线程。</p>
<p><strong>至于原因，当然是 FutureTask 的 get 方法是支持并发的，多个线程可以获取到同一个 FutureTask 的同一个结果，而这些线程在 get 的阻塞过程中必然是要挂起自己等待的。</strong></p>
<p>知道了 FutureTask 的结构。我们知道，线程池肯定会执行 FutureTask 的 run 方法，所以，我们到他的 run 方法看看。</p>
<p>同时，我们也要看看关键方法 —— get 方法。</p>
<h2 id="3-FutureTask-的-get-方法"><a href="#3-FutureTask-的-get-方法" class="headerlink" title="3. FutureTask 的 get 方法"></a>3. FutureTask 的 get 方法</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断状态，然后挂起自己等待，最后，返回结果，代码很简单。</p>
<p>注意：FutureTask 中有 7 种状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>构造时，状态就是 NEW，当任务完成中，状态变成 COMPLETING。当任务彻底完成，状态变成 NORMAL。</p>
<p>我们重点看看 awaitDone 和 report 方法。</p>
<p>awaitDone 方法代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法相对于 JUC 其他的类，还是比较简单的。需要注意一个点：get 方法是可以并发访问的，当并发访问的时候，需要将这些线程保存在 FutureTask 内部的栈中。</p>
<p> 简单说说方法步骤：</p>
<ol>
<li>如果线程中断了，删除节点，并抛出异常。</li>
<li>如果字体大于  COMPLETING ，说明任务完成了，返回结果。</li>
<li>如果等于 COMPLETING，说明任务快要完成了，自旋一会。</li>
<li>如果 q 是 null，说明这是第一次进入，创建一个新的节点。保存当前线程引用。</li>
<li>如果还没有修改过 waiters 变量，就使用 CAS  修改当前 waiters 为当前节点，这里是一个栈的结构。</li>
<li>根据时间策略挂起当前线程。</li>
<li>当线程醒来后，继续上面的判断，正常情况下，返回数据。</li>
</ol>
<p>再看看 report 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也还是很简单的，拿到结果，判断状态，如果状态正常，就返回值，如果不正常，就抛出异常。</p>
<p>总结一下 get 方法：</p>
<p>FutureTask 通过挂起自己等待异步线程唤醒，然后拿去异步线程设置好的数据。</p>
<h2 id="4-FutureTask-的-run-方法"><a href="#4-FutureTask-的-run-方法" class="headerlink" title="4. FutureTask 的 run 方法"></a>4. FutureTask 的 run 方法</h2><p>上面总结说，FutureTask 通过挂起自己等待异步线程唤醒，然后拿去异步线程设置好的数据。</p>
<p>那么这个过程在哪里呢？答案就是在 run 方法里。我们知道，线程池在执行 FutureTask 的时候，肯定会执行他的 run 方法。所以，我们看看他的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法逻辑如下：</p>
<ol>
<li>判断状态。</li>
<li>执行 callable 的 call 方法。</li>
<li>设置结果并唤醒等待的所有线程。</li>
</ol>
<p>看看 set 方法是如何设置结果的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将状态变成 COMPLETING，然后设置结果，再然后设置状态为 NORMAL，最后执行 finishCompletion 方法唤醒等待线程。</p>
<p>finishCompletion 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法先将 waiters 修改成 null，然后遍历栈中所有节点，也就是所有等待的线程，依次唤醒他们。</p>
<p>最后执行 done 方法。这个方法是留个子类扩展的。FutureTask 中是个空方法。比如 Spring 的 ListenableFutureTask 就扩展了该方法。还有 JUC 里的 QueueingFuture 类也扩展了该方法。</p>
<p>如果异常了就将状态改为 EXCEPTIONAL。</p>
<p>如果用户执行了 cancel（true）方法。该方法 Java doc 如下：</p>
<blockquote>
<p>试图取消对此任务的执行。如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。当调用 cancel 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。如果任务已经启动，则 mayInterruptIfRunning 参数确定是否应该以试图停止任务的方式来中断执行此任务的线程。</p>
</blockquote>
<p>也就是说，这个 mayInterruptIfRunning 决定当任务已经在执行了，还要终止这个任务。如果 mayInterruptIfRunning 是 true ，就会先将状态改成 INTERRUPTING，然后调用线程的 interrupt 方法，最后，设置状态为 INTERRUPTED。</p>
<p>在 run 方法的 finally 块中，对 INTERRUPTING 有判断，也就是说，在 INTERRUPTING 和 INTERRUPTED 的这段时间，会执行 finally 块，那么这个时候，就需要自旋等待状态变成 INTERRUPTED。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>关于 FutureTask 就介绍完了，该类最重要的就是 get 方法和 run 方法，run 方法负责执行 callable 的 call 方法并设置返回值到一个变量中， get 方法负责阻塞直到 run 方法执行完毕任务唤醒他，然后 get 方法回去结果。</p>
<p>同时，FutureTask 为了多线程可以并发调用 get 方法，使用了一个栈结构保存所有等待的线程。也就是说，所有的线程都等得到 get 方法的结果。</p>
<p>虽然 FutureTask 的设计很好，但我仍然觉得使用异步是更好的选择，效率更高。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程——-LinkedTransferQueue</title>
    <url>/2018/04/22/2018/2018-04-22-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94-LinkedTransferQueue/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 1. 前言

<p>Java 中总的算起来有 8 种阻塞队列。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e05e37fd57cd9fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们分析了：</p>
<ul>
<li><a href="http://thinkinjava.cn/article/95">并发编程之 SynchronousQueue 核心源码分析</a></li>
<li><a href="http://thinkinjava.cn/article/47">并发编程之 ConcurrentLinkedQueue 源码剖析</a></li>
<li><a href="http://thinkinjava.cn/article/45">并发编程之 LinkedBolckingQueue 源码剖析</a></li>
<li>在  <a href="http://thinkinjava.cn/article/110">并发编程 —— ScheduledThreadPoolExecutor</a> 中顺带分析了 DelayWorkQueue。</li>
</ul>
<p><code>ArrayBlockingQueue</code> 数组队列，我们在 <a href="http://thinkinjava.cn/article/97">使用 ReentrantLock 和 Condition 实现一个阻塞队列</a> 看过了 JDK 写的一个例子，就是该类的基本原理和实现。楼主不准备分析了。</p>
<p><code>LinkedBlockingDeque </code>是一个双向链表的队列。常用于 “工作窃取算法”，有机会再分析。</p>
<p><code>DelayQueue</code> 是一个支持延时获取元素的无界阻塞队列。内部用 <code>PriorityQueue</code> 实现。有机会再分析。</p>
<p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列，和 <code>DelayWorkQueue</code> 类似。有机会再分析。</p>
<p>今天要分析的是剩下的一个比较有意思的队列：<code>LinkedTransferQueue</code>。</p>
<p>为什么说有意思呢？他可以算是 <code>LinkedBolckingQueue</code> 和 <code>SynchronousQueue</code> 和合体。</p>
<p>我们知道 <code>SynchronousQueue</code> 内部无法存储元素，当要添加元素的时候，需要阻塞，不够完美，<code>LinkedBolckingQueue</code> 则内部使用了大量的锁，性能不高。</p>
<p>两两结合，岂不完美？性能又高，又不阻塞。</p>
<p>我们一起来看看。</p>
<h2 id="2-LinkedTransferQueue-介绍"><a href="#2-LinkedTransferQueue-介绍" class="headerlink" title="2. LinkedTransferQueue 介绍"></a>2. LinkedTransferQueue 介绍</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-c6909b571f094dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>该类实现了一个 TransferQueue。该接口定义了几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 如果可能，立即将元素转移给等待的消费者。 </span></span><br><span class="line">    <span class="comment">// 更确切地说，如果存在消费者已经等待接收它（在 take 或 timed poll（long，TimeUnit）poll）中，则立即传送指定的元素，否则返回 false。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素转移给消费者，如果需要的话等待。 </span></span><br><span class="line">    <span class="comment">// 更准确地说，如果存在一个消费者已经等待接收它（在 take 或timed poll（long，TimeUnit）poll）中，则立即传送指定的元素，否则等待直到元素由消费者接收。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面方法的基础上设置超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果至少有一位消费者在等待，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回等待消费者人数的估计值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比较普通的阻塞队列，增加了这么几个方法。</p>
<h2 id="3-关键源码分析"><a href="#3-关键源码分析" class="headerlink" title="3. 关键源码分析"></a>3. 关键源码分析</h2><p>阻塞队列不外乎<code>put ，take，offer ，poll</code>等方法，再加上<code>TransferQueue</code>的 几个 <code>tryTransfer</code>  方法。我们看看这几个方法的实现。</p>
<p><code>put </code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>take </code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, SYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>offer</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>poll</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xfer(<span class="keyword">null</span>, <span class="keyword">false</span>, NOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryTransfer</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xfer(e, <span class="keyword">true</span>, NOW, <span class="number">0</span>) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>transfer</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xfer(e, <span class="keyword">true</span>, SYNC, <span class="number">0</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted(); <span class="comment">// failure possible only due to interrupt</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可怕，所有方法都指向了<code> xfer</code> 方法，只不过传入的不同的参数。</p>
<p>第一个参数，如果是 <code>put</code> 类型，就是实际的值，反之就是 null。<br>第二个参数，是否包含数据，put 类型就是 true，take 就是 false。<br>第三个参数，执行类型，有立即返回的<code> NOW</code>，有异步的<code> ASYNC</code>，有阻塞的<code> SYNC</code>， 有带超时的 <code>TIMED</code>。<br>第四个参数，只有在 <code>TIMED </code>类型才有作用。</p>
<p>So，这个类的关键方法就是 xfer 方法了。</p>
<h2 id="4-xfer-方法分析"><a href="#4-xfer-方法分析" class="headerlink" title="4. xfer 方法分析"></a>4. xfer 方法分析</h2><p>源码加注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                            <span class="comment">// restart on append race</span></span><br><span class="line">        <span class="comment">// 从  head 开始</span></span><br><span class="line">        <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123; <span class="comment">// find &amp; match first node</span></span><br><span class="line">            <span class="comment">// head 的类型。</span></span><br><span class="line">            <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">            <span class="comment">// head 的数据</span></span><br><span class="line">            Object item = p.item;</span><br><span class="line">            <span class="comment">// item != null 有 2 种情况,一是 put 操作, 二是 take 的 itme 被修改了(匹配成功)</span></span><br><span class="line">            <span class="comment">// (itme != null) == isData 要么表示 p 是一个 put 操作, 要么表示 p 是一个还没匹配成功的 take 操作</span></span><br><span class="line">            <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123; </span><br><span class="line">                <span class="comment">// 如果当前操作和 head 操作相同，就没有匹配上，结束循环，进入下面的 if 块。</span></span><br><span class="line">                <span class="keyword">if</span> (isData == haveData)   <span class="comment">// can&#x27;t match</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果操作不同,匹配成功, 尝试替换 item 成功,</span></span><br><span class="line">                <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">// match</span></span><br><span class="line">                    <span class="comment">// 更新 head</span></span><br><span class="line">                    <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                        Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                        <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;</span><br><span class="line">                            h.forgetNext();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">                        <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                            (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line">                            <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 唤醒原 head 线程.</span></span><br><span class="line">                    LockSupport.unpark(p.waiter);</span><br><span class="line">                    <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找下一个</span></span><br><span class="line">            Node n = p.next;</span><br><span class="line">            p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这个操作不是立刻就返回的类型    </span></span><br><span class="line">        <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">// No matches available</span></span><br><span class="line">            <span class="comment">// 且是第一次进入这里</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 创建一个 node</span></span><br><span class="line">                s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">            <span class="comment">// 尝试将 node 追加对队列尾部，并返回他的上一个节点。</span></span><br><span class="line">            Node pred = tryAppend(s, haveData);</span><br><span class="line">            <span class="comment">// 如果返回的是 null, 表示不能追加到 tail 节点,因为 tail 节点的模式和当前模式相反.</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 重来</span></span><br><span class="line">                <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">            <span class="comment">// 如果不是异步操作(即立刻返回结果)</span></span><br><span class="line">            <span class="keyword">if</span> (how != ASYNC)</span><br><span class="line">                <span class="comment">// 阻塞等待匹配值</span></span><br><span class="line">                <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>代码有点长，其实逻辑很简单。</p>
<p>逻辑如下:<br>找到 <code>head</code> 节点,如果 <code>head</code> 节点是匹配的操作,就直接赋值,如果不是,添加到队列中。</p>
<p>注意：队列中永远只有一种类型的操作,要么是 <code>put</code> 类型, 要么是 <code>take</code> 类型.</p>
<p>整个过程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d60a5b0368dd8d8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>相比较 <code>SynchronousQueue</code> 多了一个可以存储的队列，相比较 <code>LinkedBlockingQueue</code> 多了直接传递元素，少了用锁来同步。</p>
<p>性能更高，用处更大。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p><code>LinkedTransferQueue </code>是 <code>SynchronousQueue</code> 和 <code>LinkedBlockingQueue</code> 的合体，性能比 <code>LinkedBlockingQueue</code> 更高（没有锁操作），比 <code>SynchronousQueue </code>能存储更多的元素。</p>
<p>当 <code>put</code> 时，如果有等待的线程，就直接将元素 “交给” 等待者， 否则直接进入队列。</p>
<p><code>put </code>和 <code>transfer</code> 方法的区别是，put 是立即返回的， transfer 是阻塞等待消费者拿到数据才返回。<code>transfer </code>方法和 <code>SynchronousQueue </code>的 put 方法类似。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程-——-ScheduledThreadPoolExecutor</title>
    <url>/2018/04/21/2018/2018-04-21-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E2%80%94%E2%80%94-ScheduledThreadPoolExecutor/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 1. 前言

<p>在前面的文章中，我们介绍了定时任务类 Timer ，他是 JDK 1.3 中出现的，位于 java.util 包下。而今天说的 <code>ScheduledThreadPoolExecutor </code>的是在 JUC 包下，是 JDK1.5 新增的。</p>
<p>今天就来说说这个类。</p>
<h2 id="2-API-介绍"><a href="#2-API-介绍" class="headerlink" title="2. API 介绍"></a>2. API 介绍</h2><p>该类内部结构和 <code>Timer </code>还是有点类似的，也是  3 个类：</p>
<ul>
<li><code>ScheduledThreadPoolExecutor</code>：程序员使用的接口。</li>
<li><code>DelayedWorkQueue</code> ： 存储任务的队列。</li>
<li><code>ScheduledFutureTask</code> ： 执行任务的线程。</li>
</ul>
<p><strong>构造方法介绍</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize)  </span><br><span class="line"><span class="comment">// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, RejectedExecutionHandler handler)  </span><br><span class="line"><span class="comment">// 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)  </span><br><span class="line"><span class="comment">// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)  </span><br></pre></td></tr></table></figure>

<p><code>ScheduledThreadPoolExecutor </code>最多支持 3 个参数：核心线程数量，线程工厂，拒绝策略。</p>
<p>为什么没有最大线程数量？由于 <code>ScheduledThreadPoolExecutor</code> 内部是个无界队列，<code>maximumPoolSize</code> 也就没有意思了。</p>
<p>再介绍一下他的 API 方法，请原谅我将 JDK 文档照抄过来了，就当是备忘吧，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)</span> <span class="comment">// 修改或替换用于执行 callable 的任务。</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> &lt;V&gt; RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> <span class="comment">// 修改或替换用于执行 runnable 的任务。        </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> <span class="comment">// 使用所要求的零延迟执行命令。  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	<span class="title">getContinueExistingPeriodicTasksAfterShutdownPolicy</span><span class="params">()</span> <span class="comment">// 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。      </span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	<span class="title">getExecuteExistingDelayedTasksAfterShutdownPolicy</span><span class="params">()</span> <span class="comment">// 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BlockingQueue&lt;Runnable&gt;	<span class="title">getQueue</span><span class="params">()</span> <span class="comment">// 返回此执行程序使用的任务队列。     </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	<span class="title">remove</span><span class="params">(Runnable task)</span> <span class="comment">// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。     </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">&lt;V&gt; ScheduledFuture&lt;V&gt;	<span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span> <span class="comment">// 创建并执行在给定延迟后启用的 ScheduledFuture。    </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">ScheduledFuture&lt;?&gt;	<span class="title">schedule</span><span class="params">(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit)</span> <span class="comment">// 创建并执行在给定延迟后启用的一次性操作。  </span></span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">ScheduledFuture&lt;?&gt;	<span class="title">scheduleAtFixedRate</span><span class="params">(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span> <span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。 </span></span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">ScheduledFuture&lt;?&gt;	<span class="title">scheduleWithFixedDelay</span><span class="params">(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit)</span> <span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。  </span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContinueExistingPeriodicTasksAfterShutdownPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> <span class="comment">// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。  </span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExecuteExistingDelayedTasksAfterShutdownPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> <span class="comment">// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。  </span></span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="comment">// 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">List&lt;Runnable&gt;	<span class="title">shutdownNow</span><span class="params">()</span> <span class="comment">// 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。  </span></span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> <span class="comment">//  提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。 </span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">Future&lt;?&gt; <span class="title">submit</span><span class="params">(Runnable task)</span> <span class="comment">//  提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。  </span></span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> <span class="comment">//  提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span></span></span><br></pre></td></tr></table></figure>


<p>最经常使用的几个方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行在给定延迟后启用的一次性操作。  </span></span><br><span class="line">ScheduledFuture&lt;?&gt;	schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。 </span></span><br><span class="line">ScheduledFuture&lt;?&gt;	scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。       </span></span><br><span class="line">ScheduledFuture&lt;?&gt;	scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) </span><br></pre></td></tr></table></figure>


<p>除了默认的构造方法，还有 3 个 <code>schedule</code> 方法。我们将分析他们内部的实现。</p>
<h2 id="3-构造方法内部实现"><a href="#3-构造方法内部实现" class="headerlink" title="3. 构造方法内部实现"></a>3. 构造方法内部实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们感兴趣的就是这个 <code>DelayedWorkQueue</code> 队列了。他也是一个阻塞队列。这个队列的数据结构是堆。同时，这个 <code>queue</code> 也是可比较的，比较什么呢？任务必须实现 <code>compareTo</code> 方法，这个方法的比较逻辑是：比较任务的执行时间，如果任务的执行时间相同，则比较任务的加入时间。</p>
<p>因此，<code>ScheduledFutureTask</code> 有 2 个变量：</p>
<ul>
<li><code>time</code> ： 任务的执行时间。</li>
<li><code>sequenceNumber</code>：任务的加入时间。</li>
</ul>
<p>这两个变量就是用来比较任务的执行顺序的。整个调度的顺序就是这个逻辑。</p>
<h2 id="4-几个-schedule-方法的的区别"><a href="#4-几个-schedule-方法的的区别" class="headerlink" title="4. 几个 schedule  方法的的区别"></a>4. 几个 schedule  方法的的区别</h2><p>刚刚说了，有 3 个 <code>schedule</code> 方法：</p>
<ol>
<li><p><code>ScheduledFuture&lt;?&gt;  schedule(Runnable command, long delay, TimeUnit unit) </code><br>创建并执行在给定延迟后启用的一次性操作。  </p>
</li>
<li><p><code>ScheduledFuture&lt;?&gt;  scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)  </code><br>创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在<code> initialDelay</code> 后开始执行，然后在 <code>initialDelay+period </code>后执行，接着在<code>initialDelay + 2 * period</code>后执行，依此类推。 </p>
</li>
<li><p><code>ScheduledFuture&lt;?&gt;  scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) </code><br>创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。       </p>
</li>
</ol>
<p>第一个方法执行在给定的时间后，执行一次就结束。</p>
<p><strong>有点意思的地方是 第二个方法和 第三个方法，他们直接的区别。</strong></p>
<p>这两个方法都可以重复的调用。但是，重复调用的逻辑有所区别，这里就是比 Timer 好用的地方。</p>
<p>他们的共同点在于：<strong>必须等待上个任务执行完毕才能执行下个任务。</strong></p>
<p>不同点在于：<strong>他们调度的时间粗略是不同的。</strong></p>
<p><code>scheduleAtFixedRate</code> 方法的执行周期都是固定的，也就是，他是以上一个任务的开始执行时间作为起点，加上之后的 period 时间，调度下次任务。</p>
<p><code>scheduleWithFixedDelay</code> 方法则是以上一个任务的结束时间作为起点，加上之后的 period 时间，调度下次任务。</p>
<p>有什么区别呢？</p>
<p>如何任务执行时间很短，那就没上面区别。但是，如果任务执行时间很长，超过了 period 时间，那么区别就出来了。</p>
<p>我们假设一下。</p>
<p>我们设置 <code>period</code> 时间为  2 秒，而任务耗时 5 秒。</p>
<p>这个两个方法的区别就体现出来了。</p>
<p><code>scheduleAtFixedRate</code> 方法将会在上一个任务结束完毕立刻执行，他和上一个任务的开始执行时间的间隔是 <strong>5</strong> 秒（因为必须等待上一个任务执行完毕）。</p>
<p><code>scheduleWithFixedDelay</code> 方法将会在上一个任务结束后，注意：<strong>再等待 2 秒，</strong>才开始执行，那么他和上一个任务的开始执行时间的间隔是 <strong>7</strong> 秒。</p>
<p>所以，我们在使用 <code>ScheduledThreadPoolExecutor</code> 的过程中需要注意任务的执行时间不能超过间隔时间，如果超过了，最好使用<code> scheduleAtFixedRate</code> 方法，防止任务堆积。</p>
<p>当然，也和具体的业务有关。不能一概而论。但一定要注意这两个方法的区别。</p>
<h2 id="5-scheduled-方法的实现"><a href="#5-scheduled-方法的实现" class="headerlink" title="5. scheduled 方法的实现"></a>5. scheduled 方法的实现</h2><p>我们看看 scheduleAtFixedRate 方法的内部实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(period));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个 <code>ScheduledFutureTask</code> 对象，然后装饰一个这个<code> Future</code> ，该类实现是直接返回，子类可以有自己的实现，在这个任务外装饰一层。</p>
<p>然后执行 <code> delayedExecute</code> 方法，最后返回 <code>Future</code>。</p>
<p>这个 <code>ScheduledFutureTask</code> 实现了很多接口，比如 <code>Future</code>，<code>Runnable</code>， <code>Comparable</code>，<code> Delayed</code> 等。</p>
<p><code>ScheduledFutureTask</code> 的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">层层递进，该类首先通过一个原子静态 `<span class="keyword">int</span> `对象这只任务的入队编号，然后创建一个 `Callable`，这个 Callable 是一个适配器，适配了` Runnable `和` Callable`，也就是将` Runnable `包装成 `callabe`， 他的 `call `方法就是调用给定任务的 run 方法。当然，这里的 `result `是没有什么作用的。</span><br><span class="line"></span><br><span class="line">如果你传递的是一个  `callable` ，那么，就调用 `FutureTask` 的 `run `方法，设置真正的返回值。</span><br><span class="line"></span><br><span class="line">这里使用了适配器模式，还是挺有趣的。</span><br><span class="line"></span><br><span class="line">总的来说，这个 `ScheduledFutureTask` 基于 `FutureTask`， 关于 `FutureTask` 我们之前从源码介绍过了。</span><br><span class="line"></span><br><span class="line">而他自己重写了几个方法：`compareTo`， `getDelay`， `run`，`isPeriodic `<span class="number">4</span> 个方法。</span><br><span class="line"></span><br><span class="line">我们还是要看看 `delayedExecute` 的实现。</span><br><span class="line"></span><br><span class="line">```<span class="function">java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加进队列。</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">// 如果线程池关闭了，且不可以在当前状态下运行任务，且从队列删除任务成功，就给任务打上取消标记。</span></span><br><span class="line">        <span class="comment">// 第二个判断是由两个变量控制的（下面是默认值）：</span></span><br><span class="line">        <span class="comment">// continueExistingPeriodicTasksAfterShutdown = false 表示关闭的时候应取消周期性任务。默认关闭</span></span><br><span class="line">        <span class="comment">// executeExistingDelayedTasksAfterShutdown = true。表示关闭的时候应取消非周期性的任务。默认不关闭。</span></span><br><span class="line">        <span class="comment">// running 状态下，canRunInCurrentRunState 必定返回 ture。</span></span><br><span class="line">        <span class="comment">// 非 running 状态下，canRunInCurrentRunState 根据上面的两个值返回。</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 开始执行任务</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说说上面的方法。</p>
<ol>
<li>判断是否关闭，关闭则拒绝任务。</li>
<li>如果不是 关闭状态，则添加进队列，而添加队列的顺序我们之前讲过了，根据 <code>ScheduledFutureTask</code> 的 <code>compareTo</code> 方法来的，先比较执行时间，再比较添加顺序。</li>
<li>如果这个过程中线程池关闭了，则判断此时是否应该取消任务，根据两个变量来的，注释里面写了。默认的策略是，如果是周期性的任务，就取消，反之不取消。</li>
<li>如果没有关闭线程池。就调用线程池里的线程执行任务。</li>
</ol>
<p>整体的过程如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7cbe02aef6b00d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意上面的图，如果是周期性的任务，则会在执行完毕后，归还队列。</p>
<p>从哪里可以看出来呢？</p>
<p><code>ScheduledFutureTask</code> 的 <code>run</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是周期性任务</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="comment">// 如果不可以在当前状态下运行，就取消任务（将这个任务的状态设置为CANCELLED）。</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 如果不是周期性的任务，调用 FutureTask # run 方法</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="comment">// 如果是周期性的。</span></span><br><span class="line">    <span class="comment">// 执行任务，但不设置返回值，成功后返回 true。（callable 不可以重复执行）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        <span class="comment">// 设置下次执行时间</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        <span class="comment">// 再次将任务添加到队列中</span></span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑如下：</p>
<ol>
<li>如果不能再当前状态下运行了，就取消这个任务。</li>
<li>如果不是周期性的任务，就执行 <code>FutureTask</code> 的 <code>run</code> 方法。</li>
<li>如果是周期性的任务，就需要执行 <code>runAndReset </code>方法。</li>
<li>执行完毕后，重写设置当前任务的下次执行时间，然后添加进队列中。</li>
</ol>
<p>而管理整个执行过程的就是<code>ScheduledThreadPoolExecutor</code>的父类 <code>ThreadPoolExecutor </code>的<code>runWorker</code>方法。其中，该方法会从队列中取出数据，也就是调用队列的 <code>take</code> 方法。</p>
<p>关于<code> DelayedWorkQueue</code> 的<code>take</code>方法，其中有个 <code>leader</code> 变量，如果 leader 不是空，说明已经有线程在等待了，那就阻塞当前线程，如果是空，说明，队列的第一个元素已经被更新了，就设置当前线程为 <code>leader</code>.</p>
<p>这是一个 <code>Leader-Follower </code> 模式，Doug Lea 说的。</p>
<p>当然，<code>take </code>方法整体的逻辑还是不变的。从队列的头部拿数据。使用 <code>Condition</code> 做线程之间的协调。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>关于 <code>ScheduledThreadPoolExecutor</code> 调度类，我们分析的差不多了，总结一下。</p>
<p><code>ScheduledThreadPoolExecutor</code> 是个定时任务线程池，类似 <code>Timer</code>，但是比 <code>Timer </code>强大，健壮。</p>
<p>比如不会像 Timer 那样，任务异常了，整个调度系统就彻底无用了。</p>
<p>也比<code> Timer</code> 多了<code> Rate</code> 模式（<code>Rate 和 Delay</code>）。</p>
<p>这两种模式的区别就是任务执行的起点时间不同，<code>Rate </code>是从上一个任务的开始执行时间开始计算；<code>Delay</code> 是从上一个任务的结束时间开始计算。</p>
<p>因此，如果任务本身的时间超过了间隔时间，那么这两种模式的间隔时间将会不一致。</p>
<p>而任务的排序是通过 <code>ScheduledFutureTask </code>的 <code>compareTo </code>方法排序的，规则是先比较执行时间，如果时间相同，再比较加入时间。</p>
<p>还要注意一点就是：如果任务执行过程中异常了，那么将不会再次重复执行。因为 <code>ScheduledFutureTask </code>的 <code>run </code>方法没有做<code>catch</code>处理。所以程序员需要手动处理，相对于 Timer 异常就直接费了调度系统来说，要好很多。</p>
<p><code>ScheduledThreadPoolExecutor</code> 的是实现基于 <code>ThreadPoolExecutor</code>，大部分功能都是重用的父类，<strong>只是自己在执行完毕之后，重新设置时间，并再次将任务还到了队列中</strong>，形成了定时任务。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>蚂蚁-RPC-框架-SOFA-RPC-初体验</title>
    <url>/2018/04/23/2018/2018-04-23-%E8%9A%82%E8%9A%81-RPC-%E6%A1%86%E6%9E%B6-SOFA-RPC-%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>最近蚂蚁金服开源了分布式框架 SOFA，楼主写了一个 demo，体验了一下 SOFA 的功能，SOFA 完全兼容 SpringBoot（当然 Dubbo 也是可以兼容的）。</p>
<p>项目地址：<a href="https://github.com/alipay/">Alipay </a>，该主页有 5 个项目，都是阿里开源的。<br><a href="https://github.com/alipay/sofa-boot">sofa-boot</a>，<br><a href="https://github.com/alipay/sofa-rpc">sofa-rpc</a>，<br><a href="https://github.com/alipay/sofa-bolt">sofa-bolt</a>，<br><a href="https://github.com/alipay/sofa-ark">sofa-ark</a>，<br> <a href="https://github.com/alipay/sofa-rpc-boot-projects">sofa-rpc-boot-projects</a>。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>实际上，SOFA-RPC 的官方文档已经详细介绍了如何使用这个 RPC 框架，基于 Netty 的长连接。类似 Dubbo。楼主看这个框架主要是为了学习分布式 RPC 框架的设计。</p>
<p>由于测试例子需要两个项目，我们建一个目录，目录下创建两个 maven module（SpringBoot 项目即可）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3fcaa5d7615b2db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>一个生产者，一个消费者。</p>
<p>将这两个项目的 pom.xml 中 springBoot 的 parent 标签换成如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sofaboot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再增加一个依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sofa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-sofa-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>到这里，关于 RPC 框架的依赖和搭建就好了，是不是很简单？</p>
<h2 id="接口创建"><a href="#接口创建" class="headerlink" title="接口创建"></a>接口创建</h2><p>既然是 RPC 服务，那就需要一个接口，再有一个实现类。我们在提供方这里创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloSyncService</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">saySync</span><span class="params">(String string)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSyncServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloSyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">saySync</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;provider tell you : this is your say: &quot;</span> +  string;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在消费方的 pom.xml 添加对这个接口的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.think.in.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有了接口，就需要配置一下。</p>
<h2 id="接口配置"><a href="#接口配置" class="headerlink" title="接口配置"></a>接口配置</h2><p>首先在提供方这里发布接口。创建一个 xml 文件，名为：rpc-sofa-boot-starter-samples.xml。</p>
<p>文件内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:sofa</span>=<span class="string">&quot;http://sofastack.io/schema/sofaboot&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://sofastack.io/schema/sofaboot   http://sofastack.io/schema/sofaboot.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloSyncServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.think.in.java.provider.HelloSyncServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sofa:service</span> <span class="attr">ref</span>=<span class="string">&quot;helloSyncServiceImpl&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;cn.think.in.java.provider.HelloSyncService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sofa:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>很简单，发布了一个接口，类似 Spring 的一个 bean。</p>
<p>同时这个接口的协议是 bolt，也就是阿里的 RPC 网络通信框架 solt（基于 Netty 的最佳实践）。</p>
<p>同样的，在消费者的 resource 文件下，也创建一个同名文件。内容稍有不同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:sofa</span>=<span class="string">&quot;http://sofastack.io/schema/sofaboot&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://sofastack.io/schema/sofaboot   http://sofastack.io/schema/sofaboot.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">&quot;helloSyncServiceReference&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;cn.think.in.java.provider.HelloSyncService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过接口得到一个 bean。</p>
<p>好，接口的配置好了，那么就可以启动测试了。</p>
<h2 id="准备测试"><a href="#准备测试" class="headerlink" title="准备测试"></a>准备测试</h2><p>测试之前还要做点点工作。</p>
<p>在提供者配置文件 appcation.perproties 中，配置一下端口和程序名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># server.port=<span class="number">8080</span> # 默认</span><br><span class="line">spring.application.name=provider</span><br></pre></td></tr></table></figure>

<p>默认 8080 端口，就不必配置了。</p>
<p>然后，在消费者那里同样配置这个文件。内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.application.name=consumer</span><br><span class="line">server.port=<span class="number">8081</span></span><br></pre></td></tr></table></figure>
<p>消费者和提供者端口不能冲突。</p>
<p>还剩最后一步。</p>
<p>将文件引入到 Spring 容器中。</p>
<p>在提供者启动类上加入以下内容（引入配置文件）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&#123; &quot;classpath*:rpc-sofa-boot-starter-samples.xml&quot; &#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在消费者启动类中引入以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&#123; &quot;classpath*:rpc-sofa-boot-starter-samples.xml&quot; &#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication springApplication = <span class="keyword">new</span> SpringApplication(ConsumerApplication.class);</span><br><span class="line">    ApplicationContext applicationContext = springApplication.run(args);</span><br><span class="line"></span><br><span class="line">    HelloSyncService helloSyncServiceReference = (HelloSyncService) applicationContext</span><br><span class="line">        .getBean(<span class="string">&quot;helloSyncServiceReference&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(helloSyncServiceReference.saySync(<span class="string">&quot;sync&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微多点东西，但也还是挺简单的。</p>
<p>首先创建一个 Spring 启动类。然后运行，从 Spirng 容器中获取到 bean（被动态代理封装的远程调用）。然后调用代理方法。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>先运行提供者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">24.776</span>  INFO <span class="number">26654</span> --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped <span class="string">&quot;&#123;[/env/&#123;name:.*&#125;],methods=[GET],produces=[application/json]&#125;&quot;</span> onto <span class="keyword">public</span> java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpoint.value(java.lang.String)</span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">24.776</span>  INFO <span class="number">26654</span> --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped <span class="string">&quot;&#123;[/env || /env.json],methods=[GET],produces=[application/json]&#125;&quot;</span> onto <span class="keyword">public</span> java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()</span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">24.886</span>  INFO <span class="number">26654</span> --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans <span class="keyword">for</span> JMX exposure on startup</span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">24.893</span>  INFO <span class="number">26654</span> --- [           main] o.s.c.support.DefaultLifecycleProcessor  : Starting beans in phase <span class="number">0</span></span><br><span class="line">Sofa-Middleware-Log SLF4J : Actual binding is of type [ com.alipay.remoting Logback ]</span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">24.966</span>  INFO <span class="number">26654</span> --- [           main] com.alipay.sofa.common.log               : Sofa-Middleware-Log SLF4J : Actual binding is of type [ com.alipay.remoting Logback ]</span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">25.174</span>  INFO <span class="number">26654</span> --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : <span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: 8080 <span class="params">(http)</span></span></span><br><span class="line"><span class="function">2018-04-23 23:18:25.179  INFO 26654 --- [           main] c.t.i.java.provider.ProviderApplication  : Started ProviderApplication in 3.352 <span class="title">seconds</span> <span class="params">(JVM running <span class="keyword">for</span> <span class="number">3.978</span>)</span></span></span><br><span class="line"><span class="function">```  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">再运行消费者：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">```java</span></span><br><span class="line"><span class="function">2018-04-23 23:19:21.940  INFO 26673 --- [           main] o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;</span>&#123;[/env || /env.json],methods=[GET],produces=[application/json]&#125;<span class="string">&quot; onto public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()</span></span><br><span class="line"><span class="string">2018-04-23 23:19:22.055  INFO 26673 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup</span></span><br><span class="line"><span class="string">2018-04-23 23:19:22.063  INFO 26673 --- [           main] o.s.c.support.DefaultLifecycleProcessor  : Starting beans in phase 0</span></span><br><span class="line"><span class="string">2018-04-23 23:19:22.319  INFO 26673 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8081 (http)</span></span><br><span class="line"><span class="string">2018-04-23 23:19:22.324  INFO 26673 --- [           main] c.t.i.java.consumer.ConsumerApplication  : Started ConsumerApplication in 3.898 seconds (JVM running for 4.524)</span></span><br><span class="line"><span class="string">provider tell you : this is your say: sync</span></span><br></pre></td></tr></table></figure>

<p>成功打印结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先第一感觉是，这个框架还是挺好用，挺简单的，基于当前的 SpringBoot 。快速启动。而且不是 SpringCloud 的 Http 调用，使用 Netty 作为网络通信框架，性能当然是没有问题的。</p>
<p>当然，我们这里的 demo 使用的注册中心没有使用 ZK，毕竟初体验嘛，使用的本地的文件。</p>
<p>然而，楼主对这个框架有很大的兴趣。接下来的空闲时间里，楼主将好好研究 SOFA 相关的代码。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>一张-JVM-相关的思维脑图（4-4M）</title>
    <url>/2018/04/26/2018/2018-04-26-%E4%B8%80%E5%BC%A0-JVM-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%9D%E7%BB%B4%E8%84%91%E5%9B%BE%EF%BC%884-4M%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       楼主学习 JVM 总结的知识点，用思维脑图串起来，温故而知新，其中含有类加载器，内存布局，GC（右侧）。

<p>最多的就是 GC 的内容了。</p>
<p>内容有错误之处，还请指正。</p>
<h3 id="大图地址"><a href="#大图地址" class="headerlink" title="大图地址"></a><a href="https://raw.githubusercontent.com/stateIs0/2018-study-demo/master/Java-jvm.png">大图地址</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/4236553-13152f19b6c2689a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程-——-Java-内存模型总结图</title>
    <url>/2018/04/26/2018/2018-04-26-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E2%80%94%E2%80%94-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93%E5%9B%BE/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       关于 Java 内存模型的类似思维导图。

<p>如有错误，还请指正。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a10ce3b3ef5d8f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-——-过滤器设计</title>
    <url>/2018/04/27/2018/2018-04-27-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p><a href="http://javatar.iteye.com/blog/1056664"></a></p>
<p>通常 Web 服务器在处理请求时，都会使用过滤器模式，无论是 Tomcat ，还是 Netty，过滤器的好处是能够将处理的流程进行分离和解耦，比如一个 Http 请求进入服务器，可能需要解析 http 报头，权限验证，国际化处理等等，过滤器可以很好的将这些过程隔离，并且，过滤器可以随时卸载，安装。</p>
<p>每个 Web 服务器的过滤器思想都是类似的，只是实现方式略有不同。</p>
<p>比如 Tomcat，Tomcat 使用了一个 FilterChain 对象保存了所有的 filter，通过循环所有 filter 来完成过滤处理。关于 Tomcat 的过滤器源码请看楼主之前的文章：<br><a href="http://thinkinjava.cn/article/19">深入理解 Tomcat（九）源码剖析之请求过程</a></p>
<p>Netty 使用了 pipeline 作为过滤器管道，管道中使用 handler 做拦截处理，而 handler 使用一个 handlerInvoker（Context） 做隔离处理，也就是将 handler 和  handler 隔离开来，中间使用 这个 Context 上下文进行流转。关于 Netty 的 pipeline 可以查看楼主之前的文章 ：<br><a href="http://thinkinjava.cn/article/68">Netty 核心组件 Pipeline 源码分析（一）之剖析 pipeline 三巨头</a><br><a href="http://thinkinjava.cn/article/69">Netty 核心组件 Pipeline 源码分析（二）一个请求的 pipeline 之旅</a></p>
<p>而 SOFA 使用了和上面的两个略有不同，我们今天通过源码分析一下。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>SOFA 的过滤器由 3 个主要的类组成：</p>
<ol>
<li>FilterInvoker 过滤器包装的Invoker对象，主要是隔离了filter和service的关系；</li>
<li>Filter 过滤器（可通过 SPI 扩展）</li>
<li>FilterChain 过滤器链起始接口，其实就是一个 Invoker。</li>
</ol>
<p>我们看看这 3 个类的主要方法，就知道如何设计的了。</p>
<h3 id="Filter-主要方法："><a href="#Filter-主要方法：" class="headerlink" title="Filter  主要方法："></a>Filter  主要方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SofaResponse <span class="title">invoke</span><span class="params">(FilterInvoker invoker, SofaRequest request)</span> <span class="keyword">throws</span> SofaRpcException</span>;</span><br></pre></td></tr></table></figure>

<p>invoke 方法，是一个抽象方法，用户可以自己实现，而方法体就是用户的处理逻辑。通常这个方法的结尾是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> invoker.invoke(request);</span><br></pre></td></tr></table></figure>

<p>调用了参数 invoker 对象的 invoke 方法。我们看看这个 FilterInvoker 。</p>
<h3 id="FilterInvoker-主要方法"><a href="#FilterInvoker-主要方法" class="headerlink" title="FilterInvoker  主要方法"></a>FilterInvoker  主要方法</h3><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FilterInvoker</span><span class="params">(Filter nextFilter, FilterInvoker invoker, AbstractInterfaceConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nextFilter = nextFilter;</span><br><span class="line">    <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.configContext = config.getConfigValueCache(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>楼主这里介绍一下他的主要构造方法。传入一个 filter，一个 invoker。</p>
<p>这个 filter 就是当前 invoker 包装的过滤器，而参数 invoker 就是他的下一个 invoker 节点。当执行 FilterInvoker 的 invoke 方法的时候，通常会调用 filter 的 invoke 方法，并传入 invoker 参数。</p>
<p>这就回到我们上面分析的 filter 的 invoke 方法，该方法内部会调用 invoker 的 invoke 方法，完成一次轮回。</p>
<p>再看看 FilterChain 。</p>
<h3 id="FilterChain-主要方法"><a href="#FilterChain-主要方法" class="headerlink" title="FilterChain 主要方法"></a>FilterChain 主要方法</h3><p>FilterChain 是框架直接操作的实例，每个调用者都间接持有一个 FilterChain 实例，而这个实例相当于过滤器链表的头节点。</p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">FilterChain</span><span class="params">(List&lt;Filter&gt; filters, FilterInvoker lastInvoker, AbstractInterfaceConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用过程外面包装多层自定义filter</span></span><br><span class="line">    <span class="comment">// 前面的过滤器在最外层</span></span><br><span class="line">    invokerChain = lastInvoker;</span><br><span class="line">    <span class="keyword">if</span> (CommonUtils.isNotEmpty(filters)) &#123;</span><br><span class="line">        loadedFilters = <span class="keyword">new</span> ArrayList&lt;Filter&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 从最大的开始，从小到大开始执行</span></span><br><span class="line">            Filter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">if</span> (filter.needToLoad(invokerChain)) &#123;</span><br><span class="line">                invokerChain = <span class="keyword">new</span> FilterInvoker(filter, invokerChain, config);</span><br><span class="line">                <span class="comment">// cache this for filter when async respond</span></span><br><span class="line">                loadedFilters.add(filter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造过滤器链的时候，会传入一个过滤器数组，并传入一个 FilterInvoker，这个 Invoker 是真正的业务方法，框架会在该 invoke 方法中反射调用接口的实现类，也就是业务代码。</p>
<p>上面的构造方法主要逻辑是：</p>
<p> 倒序循环 List 中的 Filter 实例，将 Filter 用 FilterInvoker 封装，并传入上一个 FilterInvoker 到 FilterInvoker 的构造方法中，形成链表。而单独传入的 FilterInvoker 则会放到最后一个节点。`</p>
<p>所以，最终，当 FilterChain 调用过滤器链的时候，会从 order 最小的过滤器开始，最后执行业务方法。</p>
<p>注意：SOFA 过滤器中，真正执行业务方法的不是 Filter，而是 FilterInvoker 的具体实现类，在 invoke 方法中，会反射调用接口实现类的方法。原因是过滤器最后调用的 invoker.invoke。就不用再构造一个 filter 了。</p>
<p>以上就是 SOFA 的过滤器设计。从总体上来讲，和 Tomcat 的 过滤器类似，只是 Tomcat 使用的数组，并且将 Service 区分看待，即执行完所有的过滤器后，执行 Service。而 SOFA 使用的是一个链表，并没有区分对待 Service。</p>
<h2 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h2><p>Filter 是个接口，并且标注了 <code>@Extensible(singleton = false)</code> 注解，表示这是一个扩展点，这个是 SOFA 微内核的一个设计。所有的中间件都可以通过扩展点加入到框架中。</p>
<p>而扩展点其实有点类似 Spring 的 Bean，Spring Bean 和核心数据结构是 BeanDefine，SOFA 的 扩展点核心数据结构则是 ExtensionClass，该类定义了扩展点的所有相关信息。</p>
<p>SOFA 会将所有的扩展点放在一个 ExtensionLoader 的 ConcurrentHashMap&lt;String, ExtensionClass<T>&gt; 中。</p>
<p>ExtensionLoader 可以称之为扩展类加载器，一个 ExtensionLoader 对应一个可扩展的接口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从设计上来说，SOFA 的过滤器更类似 Tomcat 的过滤器，相对于 Netty 的过滤器各有特色。Netty 的过滤器可以随时插拔，也许从业务上来说，SOFA 并不需要这样的功能吧。</p>
<p>而同时，Filter 基于 SOFA 的扩展点来的。Dubbo 作者说过：</p>
<blockquote>
<p>大凡发展的比较好的框架，都遵守微核的理念，<br>Eclipse的微核是OSGi， Spring的微核是BeanFactory，Maven的微核是Plexus，<br>通常核心是不应该带有功能性的，而是一个生命周期和集成容器，<br>这样各功能可以通过相同的方式交互及扩展，并且任何功能都可以被替换，<br>如果做不到微核，至少要平等对待第三方，<br>即原作者能实现的功能，扩展者应该可以通过扩展的方式全部做到，<br>原作者要把自己也当作扩展者，这样才能保证框架的可持续性及由内向外的稳定性。</p>
</blockquote>
<p><strong>微核插件式，平等对待第三方</strong> 对于框架来说，非常重要。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>Java-并发编程常识-——-by-梁飞</title>
    <url>/2018/04/28/2018/2018-04-28-Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%AF%86-%E2%80%94%E2%80%94-by-%E6%A2%81%E9%A3%9E/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ![image.png](https://upload-images.jianshu.io/upload_images/4236553-f68260a82344eae9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-bd8396279f8b8773.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-78439796d52d1ad8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-932357c785f59e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-15756c81c62cfc25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-9d870146f0b6093b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-2a6af5c8f82931be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-ac8bc97d1ceb10a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-57916762cce43481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-5e5dc59b6d325834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-fb3183123ab04bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-78b54a353aff62dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-a45191143b8e143c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-9f97c32a38d96989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-49a98b49e8c673e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/4236553-7326bc007cd2691b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<h2 id="参考-：梁飞-并发编程常识"><a href="#参考-：梁飞-并发编程常识" class="headerlink" title="参考 ：梁飞  并发编程常识"></a>参考 ：梁飞  <a href="http://javatar.iteye.com/blog/1963774">并发编程常识</a></h2>]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-——-服务发布过程</title>
    <url>/2018/04/29/2018/2018-04-29-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>SOFA 包含了 RPC 框架，底层通信框架是 bolt ，基于 Netty 4，今天将通过 SOFA—RPC 源码中的例子，看看他是如何发布一个服务的。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面的代码在 <code>com.alipay.sofa.rpc.quickstart.QuickStartServer</code> 类下。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerConfig serverConfig = <span class="keyword">new</span> ServerConfig()</span><br><span class="line">    .setProtocol(<span class="string">&quot;bolt&quot;</span>) <span class="comment">// 设置一个协议，默认bolt</span></span><br><span class="line">    .setPort(<span class="number">9696</span>) <span class="comment">// 设置一个端口，默认12200</span></span><br><span class="line">    .setDaemon(<span class="keyword">false</span>); <span class="comment">// 非守护线程</span></span><br><span class="line"></span><br><span class="line">ProviderConfig&lt;HelloService&gt; providerConfig = <span class="keyword">new</span> ProviderConfig&lt;HelloService&gt;()</span><br><span class="line">    .setInterfaceId(HelloService.class.getName()) <span class="comment">// 指定接口</span></span><br><span class="line">    .setRef(<span class="keyword">new</span> HelloServiceImpl()) <span class="comment">// 指定实现</span></span><br><span class="line">    .setServer(serverConfig); <span class="comment">// 指定服务端</span></span><br><span class="line"></span><br><span class="line">providerConfig.export(); <span class="comment">// 发布服务</span></span><br></pre></td></tr></table></figure>

<p>首先，创建一个 ServerConfig  ，包含了端口，协议等基础信息，当然，这些都是手动设定的，在该类加载的时候，会自动加载很多配置文件中的服务器默认配置。比如 RpcConfigs 类，RpcRuntimeContext 上下文等。</p>
<p>然后呢，创建一个 ProviderConfig，也是个 config，不过多继承了一个 AbstractInterfaceConfig 抽象类，该类是接口级别的配置，而 ServerConfig 是 服务器级别的配置。虽然都继承了 AbstractIdConfig。</p>
<p>ProviderConfig 包含了接口名称，接口指定实现类，还有服务器的配置。</p>
<p>最后，ProviderConfig 调用 export 发布服务。</p>
<p>展示给我的 API 很简单，但内部是如何实现的呢？</p>
<p>在看源码之前，我们思考一下：如果我们自己来实现，怎么弄？</p>
<p>RPC 框架简单一点来说，就是使用动态代理和 Socket。</p>
<p>SOFA 使用 Netty 来做网络通信框架，我们之前也写过一个简单的 Netty RPC，主要是通过  handler 的 channelRead 方法来实现。</p>
<p>SOFA 是这么操作的吗？</p>
<p>一起来看看。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="# 源码分析"></a># 源码分析</h2><p>上面的示例代码其实就是 3 个步骤，创建 ServerConfig，创建 ProviderConfig，调用 export 方法。</p>
<p>先看第一步，还是有点意思的。</p>
<p>虽然是空构造方法，但 ServerConfig 的属性都是自动初始化的，而他的父类 AbstractIdConfig 更有意思了，父类有 1 个地方值得注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    RpcRuntimeContext.now();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉类加载的同学都知道，这是为了主动加载 RpcRuntimeContext ，看名字是 RPC 运行时上下文，所谓上下文，大约就是我们人类聊天中的 “老地方” 的意思。</p>
<p>这个上下文会在静态块中加载 Module（基于扩展点实现），注册 JVM 关闭钩子（类似 Tomcat）。还有很多配置信息。</p>
<p>然后呢？创建  ProviderConfig 对象。这个类比上面的那个类多继承了一个 AbstractInterfaceConfig，接口级别的配置。比如有些方法我不想发布啊，比如权重啊，比如超时啊，比如具体的实现类啊等等，当然还需要一个 ServerConfig 的属性（注册到 Server 中啊喂）。</p>
<p><strong>最后就是发布了。export 方法。</strong></p>
<p>ProviderCofing 拥有一个 export 方法，但并不是直接就在这里发布的，因为他是一个 config，不适合在config 里面做这些事情，违背单一职责。</p>
<p>SOFA 使用了一个 Bootstrap 类来进行操作。和大部分服务器类似，这里就是启动服务器的地方。因为这个类会多线程使用，比如并发的发布服务。而不是一个一个慢慢的发布服务。所以他不是单例的，而是和 Config 一起使用的，并缓存在 map 中。</p>
<p>ProviderBootstrap 目前有 3 个实现：Rest，Bolt，Dubbo。Bolt 是他的默认实现。</p>
<p>export 方法默认有个实现（Dubbo 的话就要重写了）。主要逻辑是执行 doExport 方法，其中包括延迟加载逻辑。</p>
<p>而 doExport 方法中，就是 SOFA 发布服务的逻辑所在了。</p>
<p>楼主将方法的异常处理逻辑去除，整体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String key = providerConfig.buildKey();</span><br><span class="line">       String appName = providerConfig.getAppName();</span><br><span class="line">       <span class="comment">// 检查参数</span></span><br><span class="line">       checkParameters();</span><br><span class="line">       <span class="comment">// 注意同一interface，同一uniqleId，不同server情况</span></span><br><span class="line">       AtomicInteger cnt = EXPORTED_KEYS.get(key); <span class="comment">// 计数器</span></span><br><span class="line">       <span class="keyword">if</span> (cnt == <span class="keyword">null</span>) &#123; <span class="comment">// 没有发布过</span></span><br><span class="line">           cnt = CommonUtils.putToConcurrentMap(EXPORTED_KEYS, key, <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> c = cnt.incrementAndGet();</span><br><span class="line">       <span class="keyword">int</span> maxProxyCount = providerConfig.getRepeatedExportLimit();</span><br><span class="line">       <span class="keyword">if</span> (maxProxyCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 超过最大数量，直接抛出异常</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 构造请求调用器</span></span><br><span class="line">       providerProxyInvoker = <span class="keyword">new</span> ProviderProxyInvoker(providerConfig);</span><br><span class="line">       <span class="comment">// 初始化注册中心</span></span><br><span class="line">       <span class="keyword">if</span> (providerConfig.isRegister()) &#123;</span><br><span class="line">           List&lt;RegistryConfig&gt; registryConfigs = providerConfig.getRegistry();</span><br><span class="line">           <span class="keyword">if</span> (CommonUtils.isNotEmpty(registryConfigs)) &#123;</span><br><span class="line">               <span class="keyword">for</span> (RegistryConfig registryConfig : registryConfigs) &#123;</span><br><span class="line">                   RegistryFactory.getRegistry(registryConfig); <span class="comment">// 提前初始化Registry</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将处理器注册到server</span></span><br><span class="line">       List&lt;ServerConfig&gt; serverConfigs = providerConfig.getServer();</span><br><span class="line">       <span class="keyword">for</span> (ServerConfig serverConfig : serverConfigs) &#123;</span><br><span class="line">           Server server = serverConfig.buildIfAbsent();</span><br><span class="line">           <span class="comment">// 注册序列化接口</span></span><br><span class="line">           server.registerProcessor(providerConfig, providerProxyInvoker);</span><br><span class="line">           <span class="keyword">if</span> (serverConfig.isAutoStart()) &#123;</span><br><span class="line">               server.start();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 注册到注册中心</span></span><br><span class="line">       providerConfig.setConfigListener(<span class="keyword">new</span> ProviderAttributeListener());</span><br><span class="line">       register();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 记录一些缓存数据</span></span><br><span class="line">       RpcRuntimeContext.cacheProviderConfig(<span class="keyword">this</span>);</span><br><span class="line">       exported = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>主要逻辑如下：</p>
<ol>
<li>根据 providerConfig 创建一个 key 和 AppName。</li>
<li>检验同一个服务多次发布的次数。</li>
<li>创建一个 ProviderProxyInvoker， 其中包含了过滤器链，而过滤器链的最后一链就是对接口实现类的调用。</li>
<li>初始化注册中心，创建 Server（会有多个Server，因为可能配置了多个协议）。</li>
<li>将 config 和 invoker 注册到 Server 中。内部是将其放进了一个 Map 中。</li>
<li>启动 Server。启动 Server 其实就是启动 Netty 服务，并创建一个 RpcHandler，也就是 Netty 的 Handler，这个 RpcHandler 内部含有一个数据结构，包含接口级别的 invoker。所以，当请求进入的时候，RpcHandler 的 channelRead 方法会被调用，然后间接的调用 invoker 方法。</li>
<li>成功启动后，注册到注册中心。将数据缓存到 RpcRuntimeContext 的一个 Set 中。</li>
</ol>
<p>一起来详细看看。</p>
<p>Invoker 怎么构造的？很简单，最主要的就是过滤器。关于过滤器，我们之前已经写过一篇文章了。不再赘述。</p>
<p>关键看看 Server 是如何构造的。</p>
<p>关键代码 <code>serverConfig.buildIfAbsent()</code>，类似 HashMap 的 putIfAbsent。如果不存在就创建。</p>
<p>Server 接口目前有 2 个实现，bolt 和 rest。当然，Server 也是基于扩展的，所以，不用怕，可以随便增加实现。</p>
<p>关键代码在 ServerFactory 的 getServer 中，其中会获取扩展点的 Server，然后，执行 Server 的 init 方法，我们看看默认 bolt 的 init 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServerConfig serverConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.serverConfig = serverConfig;</span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    bizThreadPool = initThreadPool(serverConfig);</span><br><span class="line">    boltServerProcessor = <span class="keyword">new</span> BoltServerProcessor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存了 serverConfig 的引用，启动了一个业务线程池，创建了一个 BoltServerProcessor 对象。</p>
<p>第一：这个线程池会在 Bolt 的 RpcHandler 中被使用，也就是说，复杂业务都是在这个线程池执行，不会影响 Netty 的 IO 线程。</p>
<p>第二：BoltServerProcessor 非常重要，他的构造方法包括了当前的 BoltServer，所以他俩是互相依赖的。关键点来了：</p>
<p>BoltServerProcessor 实现了 UserProcessor 接口，而 Bolt 的 RpcHandler 持有一个 <code>Map&lt;String, UserProcessor&lt;?&gt;&gt;</code>，所以，当 RpcHandler 被执行 channelRead 方法的时候，一定会根据接口名称找到对应的 UserProcessor，并执行他的 handlerRequest 方法。</p>
<p>那么，RpcHandler 是什么时候创建并放置到 RpcHandler 中的呢？</p>
<p>具体是这样的：在 <code>server.start()</code> 执行的时候，该方法会初始化 Netty 的 Server，在 SOFA 中，叫 RpcServer，将 BoltServerProcessor 放置到名叫 userProcessors 的 Map 中。<strong>然后</strong>，当 RpcServer 启动的时候，也就是 start 方法，会执行一个 init 方法，该方法内部就是设置 Netty 各种属性的地方，包括 Hander，其中有 2 行代码对我们很重要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> RpcHandler rpcHandler = <span class="keyword">new</span> RpcHandler(<span class="keyword">true</span>, <span class="keyword">this</span>.userProcessors);</span><br><span class="line">pipeline.addLast(<span class="string">&quot;handler&quot;</span>, rpcHandler);</span><br></pre></td></tr></table></figure>

<p>创建了一个 RpcHandler，并添加到 pipeline 中，这个 Handler 的构造参数就是包含所有 BoltServerProcessor 的 Map。</p>
<p>所以，总的流程就是：</p>
<blockquote>
<p>每个接口都会创建一个 providerConfig 对象，这个对象会创建对应的 invoker 对象（包含过滤器链），这两个对象都会放到 BoltServer 的 invokerMap 中，而 BoltServer 还包含其他对象，比如 BoltServerProcessor（继承 UserProcessor）， RpcServer(依赖 RpcHandler)。当初始化 BoltServerProcessor 的时候，会传入 this（BoltServer），当初始化 RpcServer 的时候，会传入 BoltServerProcessor 到 RpcServer 的 Map 中。在 RpcHandler 初始化的时候，又会将 RpcServer 的 Map 传进自己的内部。完成最终的依赖。<br>当请求进入，RpcHandler 调用对应的 UserProcessor 的 handlerRequest 方法，而该方法中，会调用对应的 invoker，invoker 调用过滤器链，知道调用真正的实现类。</p>
</blockquote>
<p>而大概的 UML 图就是下面这样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-bc548c7fb0b7a331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>红色部分是 RPC 的核心，包含 Solt 的 Server，实现 UserProcessor 接口的 BoltServerProcessor，业务线程池，存储所有接口实现的 Map。</p>
<p>绿色部分是 Bolt 的接口和类，只要实现了 UserProcessor 接口，就能将具体实现替换，也既是处理具体数据的逻辑。</p>
<p>最后，看看关键类 BoltServerProcessor ，他是融合 RPC 和 Bolt 的胶水类。</p>
<p>该类会注册一个序列化器替代 Bolt 默认的。handleRequest 方法是这个类的核心方法。有很多逻辑，主要看这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找服务</span></span><br><span class="line">Invoker invoker = boltServer.findInvoker(serviceName);</span><br><span class="line"><span class="comment">// 真正调用</span></span><br><span class="line">response = doInvoke(serviceName, invoker, request);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到服务端Invoker</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceName 服务名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Invoker对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Invoker <span class="title">findInvoker</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> invokerMap.get(serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据服务名称，从 Map 中找到服务，然后调用 invoker 的 invoker 方法。</p>
<p>再看看 Netty 到 BoltServerProcessor 的 handlerRequest 的调用链，使用 IDEA 的 Hierarchy 功能，查看该方法，最后停留在 ProcessTast 中，一个 Runnable.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9ac01fb1c428aa50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>根据经验，这个类肯定是被放到线程池了。什么时候放的呢？看看他的构造方法的 Hierarchy。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3509b833b40923ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从图中可以看到 ，Bolt 的 RpcHandler 的 channelRead 最终会调用 ProcessTask 的 构造方法。</p>
<p>那么 BoltServer 的用户线程池什么时候使用呢？还是使用 IDEA 的 Hierarchy 功能。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-730e8c41dd65e6b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其实也是在这个过程中，当用户没有设置线程池，则使用系统线程池。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，关于 SOFA 的服务发布和服务的接收过程，就介绍完了，可以说，整个框架还是非常轻量级的。基本操作就是：内部通过在 Netty的 Handler 中保存一个存储服务实现的 Map 完成远程调用。</p>
<p>其实和我们之前用 Netty 写的小 demo 类似。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-——-服务引用过程</title>
    <url>/2018/04/30/2018/2018-04-30-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94%E2%80%94-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>在前面的  <a href="http://thinkinjava.cn/article/117">SOFA 源码分析 —— 服务发布过程</a> 文章中，我们分析了 SOFA 的服务发布过程，一个完整的 RPC 除了发布服务，当然还需要引用服务。 So，今天就一起来看看 SOFA 是如何引用服务的。实际上，基础逻辑和我们之前用 Netty 写的 RPC 小 demo 类似。有兴趣可以看看这个 demo—— <a href="http://thinkinjava.cn/article/80">自己用 Netty 实现一个简单的 RPC</a>。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsumerConfig&lt;HelloService&gt; consumerConfig = <span class="keyword">new</span> ConsumerConfig&lt;HelloService&gt;()</span><br><span class="line">    .setInterfaceId(HelloService.class.getName()) <span class="comment">// 指定接口</span></span><br><span class="line">    .setProtocol(<span class="string">&quot;bolt&quot;</span>) <span class="comment">// 指定协议</span></span><br><span class="line">    .setDirectUrl(<span class="string">&quot;bolt://127.0.0.1:9696&quot;</span>); <span class="comment">// 指定直连地址</span></span><br><span class="line"></span><br><span class="line">HelloService helloService = consumerConfig.refer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    System.out.println(helloService.sayHello(<span class="string">&quot;world&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，代码例子来自 SOFA-RPC  源码，位于<code>com.alipay.sofa.rpc.quickstart.QuickStartClient</code>。</p>
<p>很简单，创建一个消费者配置类，然后使用这个配置引用一个代理对象，调用<br>代理对象的方法，实际上就是调用了远程服务。</p>
<p>我们就通过上面这个简单的例子，看看 SOFA 是如何进行服务引用的。注意：我们今天的目的是看看主流程，有些细节可能暂时就一带而过了，比如负载均衡，错误重试啥的，我们以后再详细分析，实际上，Client 相对有 Server，还是要复杂一些的，因为它要考虑更多的情况。</p>
<p>好，开始吧！</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先看这个 ConsumerConfig 类，和前面的 ProviderConfig 类似，甚至于实现的接口和继承的抽象类都是一样的。</p>
<p>上面的例子设置了一些属性，比如接口名称，协议，直连地址。</p>
<p>关键点来了， refer 方法。</p>
<p>这个方法就是返回了一个代理对象，代理对象中包含了之后远程调用中需要的所有信息，比如过滤器，负载均衡等等。</p>
<p>然后，调用动态代理的方法，进行远程调用，如果是 JDK 的动态代理的话，就是一个实现了 InvocationHandler 接口的类。这个类的 invoke 方法会拦截并进行远程调用，自然就是使用 Netty 的客户端对服务端发起调用并得到数据啦。</p>
<p>先看看 refer 方法。</p>
<h2 id="从-refer-方法开始源码分析"><a href="#从-refer-方法开始源码分析" class="headerlink" title="从 refer 方法开始源码分析"></a>从 refer 方法开始源码分析</h2><p>该方法类套路和 provider 的套路类似，都是使用了一个 BootStrap 引导。即单一职责。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">refer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (consumerBootstrap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        consumerBootstrap = Bootstraps.from(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consumerBootstrap.refer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConsumerBootstrap 是个抽象类，SOFA  基于他进行扩展，目前有 2 个扩展点，bolt 和 rest。默认是 bolt。而 bolt 的实现则是 BoltConsumerBootstrap，目前来看 bolt 和 rest 并没有什么区别，都是使用的一个父类 DefaultConsumerBootstrap。</p>
<p>所以，来看看 DefaultConsumerBootstrap 的 refer 方法。代码我就不贴了，因为很长。基本上引用服务的逻辑全部在这里了，类似 Spring 的 refresh 方法。逻辑如下：</p>
<ol>
<li>根据 ConsumerConfig 创建 key 和 appName。检查参数合法性。对调用进行计数。</li>
<li>创建一个 Cluster 对象，这个对象非常重要，该对象管理着核心部分的信息。详细的后面会说，而构造该对象的参数则是 BootStrap。</li>
<li>设置一些监听器。</li>
<li>初始化 Cluster。其中包括设置路由，地址初始化，连接管理，过滤器链构造，重连线程等。</li>
<li>创建一个 proxyInvoker 执行对象，也就是初始调用对象，作用是注入到动态代理的拦截类中，以便动态代理从此处开始调用。构造参数也是 BootStrap。</li>
<li>最后，创建一个动态代理对象，目前动态代理有 2 个扩展点，分别是 JDK，javassist。默认是 JDK，但似乎 javassist 的性能会更好一点。如果是 JDK 的话，拦截器则是 JDKInvocationHandler 类，构造方法需要代理类和刚刚创建的 proxyInvoker 对象。proxyInvoker 的作用就是从这里开始链式调用。</li>
</ol>
<p>其中，关键的对象是 Cluster。该对象需要重点关注。</p>
<p>Cluster 是个抽象类，也是个扩展点，实现了 Invoker, ProviderInfoListener, Initializable, Destroyable 等接口。而他目前的具体扩展点有 2 个： FailFastCluster（快速失败）， FailoverCluster（故障转移和重试）。默认是后者。当然，还有一个抽象父类，AbstractCluster。</p>
<p>该类有个重要的方法， init 方法，初始化 Cluster，Cluster 可以理解成客户端，封装了集群模式、长连接管理、服务路由、负载均衡等抽象类。</p>
<p>init 方法代码如下，不多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialized) &#123; <span class="comment">// 已初始化</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造Router链</span></span><br><span class="line">    routerChain = RouterChain.buildConsumerChain(consumerBootstrap);</span><br><span class="line">    <span class="comment">// 负载均衡策略 考虑是否可动态替换？</span></span><br><span class="line">    loadBalancer = LoadBalancerFactory.getLoadBalancer(consumerBootstrap);</span><br><span class="line">    <span class="comment">// 地址管理器</span></span><br><span class="line">    addressHolder = AddressHolderFactory.getAddressHolder(consumerBootstrap);</span><br><span class="line">    <span class="comment">// 连接管理器</span></span><br><span class="line">    connectionHolder = ConnectionHolderFactory.getConnectionHolder(consumerBootstrap);</span><br><span class="line">    <span class="comment">// 构造Filter链,最底层是调用过滤器</span></span><br><span class="line">    <span class="keyword">this</span>.filterChain = FilterChain.buildConsumerChain(<span class="keyword">this</span>.consumerConfig,</span><br><span class="line">        <span class="keyword">new</span> ConsumerInvoker(consumerBootstrap));</span><br><span class="line">    <span class="comment">// 启动重连线程</span></span><br><span class="line">    connectionHolder.init();</span><br><span class="line">    <span class="comment">// 得到服务端列表</span></span><br><span class="line">    List&lt;ProviderGroup&gt; all = consumerBootstrap.subscribe();</span><br><span class="line">    <span class="keyword">if</span> (CommonUtils.isNotEmpty(all)) &#123;</span><br><span class="line">        <span class="comment">// 初始化服务端连接（建立长连接)</span></span><br><span class="line">        updateAllProviders(all);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动成功</span></span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果check=true表示强依赖</span></span><br><span class="line">    <span class="keyword">if</span> (consumerConfig.isCheck() &amp;&amp; !isAvailable()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，干的活很多。每一步都值得花很多时间去看，但看完所有不是我们今天的任务，我们今天关注一下调用，上面的代码中，有一段构建 FilterChain 的代码是值得我们今天注意的。</p>
<p>创建了一个 ConsumerInvoker 对象，作为最后一个过滤器调用，关于过滤器的设计，我们之前已经研究过了，不再赘述，详情 <a href="http://thinkinjava.cn/article/115">SOFA 源码分析 —— 过滤器设计</a>。</p>
<p>我们主要看看 ConsumerInvoker 类，该类是离 Netty 最近的过滤器。实际上，他也是拥有了一个 BootStrap，但，注意，拥有了 BootStrap ，相当于挟天子以令诸侯，啥都有了，在他的 invoke 方法中，会直接获取 Boostrap 的 Cluster 向 Netty 发送数据。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> consumerBootstrap.getCluster().sendMsg(providerInfo, sofaRequest);</span><br></pre></td></tr></table></figure>

<p>厉害吧。</p>
<p>那么，Cluster 是如何进行 sendMsg 的呢？如果是 bolt 类型的 Cluster 的话，就直接使用 bolt 的 RpcClient 进行调用了，而 RpcClient 则是使用的 Netty 的 Channel 的 writeAndFlush 方法发送数据。如果是同步调用的话，就阻塞等待数据。</p>
<p>总的流程就是这样，具体细节留到以后慢慢分析。</p>
<p>下面看看拿到动态代理对象后，如何进行调用。</p>
<h2 id="动态代理如何调用？"><a href="#动态代理如何调用？" class="headerlink" title="动态代理如何调用？"></a>动态代理如何调用？</h2><p>当我们调用的时候，肯定会被 JDKInvocationHandler 拦截。拦截方法则是 invoke 方法。方法很简单，主要就是使用我们之前注入的 proxyInvoker 的 invoke 方法。我们之前说了，proxyInvoker 的作用其实就是一个链表的头。而他主要了代理了真正的主角 Cluster，所以，你可以想到，他的 invoke 方法肯定是调用了 Cluster 的 invoke 方法。</p>
<p>Cluster 是真正的主角（注意：默认的 Cluster 是 FailoverCluster），那么他的调用肯定是一连串的过滤器。目前默认有两个过滤器：ConsumerExceptionFilter, RpcReferenceContextFilter。最后一个过滤器则是我们之前说的，离 Netty 最近的过滤器 —— ConsumerInvoker。</p>
<p>ConsumerInvoker 会调用 Cluster 的 sendMsg 方法，Cluster 内部包含一个 ClientTransport ，这个 ClientTransport 就是个胶水类，融合 bolt 的 RpcClient。所以，你可以想到，当 ConsumerInvoker 调用 sendMsg 方法的时候，最后会调用 RpcClient 的 invokeXXX 方法，可能是异步，也可能是同步的，bolt 支持多种调用方式。</p>
<p>而 RpcClient 最后则是调用 Netty 的 Channel 的 writeAndFlush 方法向服务提供者发送数据。</p>
<p>取一段 RpcClietn 中同步（默认）执行的代码看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RemotingCommand <span class="title">invokeSync</span><span class="params">(<span class="keyword">final</span> Connection conn, <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">final</span> <span class="keyword">int</span> timeoutMillis)</span> <span class="keyword">throws</span> RemotingException,</span></span><br><span class="line"><span class="function">                                                             InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> InvokeFuture future = createInvokeFuture(request, request.getInvokeContext());</span><br><span class="line">    conn.addInvokeFuture(future);</span><br><span class="line">    conn.getChannel().writeAndFlush(request).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!f.isSuccess()) &#123;</span><br><span class="line">                conn.removeInvokeFuture(request.getId());</span><br><span class="line">                future.putResponse(commandFactory.createSendFailedResponse(</span><br><span class="line">                    conn.getRemoteAddress(), f.cause()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 阻塞等待</span></span><br><span class="line">    RemotingCommand response = future.waitResponse(timeoutMillis);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Netty 的 Channel 的 writeAndFlush 方法发送数据，并添加一个监听器，如果失败了，就向 future 中注入一个失败的对象。</p>
<p>在异步执行后，主线程开始等待，内部使用 countDownLatch 进行阻塞。而 countDownLatch 的初始化参数为 1。什么时候唤醒 countDownLatch 呢？</p>
<p>在 putResponse 方法中，会唤醒 countDownLatch。</p>
<p>而 putResponse 方法则会被很多地方使用。比如在 bolt 的  RpcResponseProcessor 的 doProcess 方法中就会调用。而这个方法则是在 RpcHandler 的 channelRead 方法中间接调用。</p>
<p>所以，如果 writeAndFlush 失败了，会 putResponse ，没有失败的话，正常执行，则会在 channelRead 方法后简介调用 putResponse.</p>
<p>总结一下调用的逻辑吧，楼主画了一张图，大家可以看看，画的不好，还请见谅。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-25d372877ce1b73d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>红色线条是调用链，从 JDKInvocationHandler 开始，直到 Netty。绿色部分是 Cluster，和 Client 的核心。大红色部分是 bolt 和 Netty。</p>
<p>好了，关于 SOFA 的服务引用主流程我们今天就差不多介绍完了，当然，有很多精华还没有研究到。我们以后会慢慢的去研究。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完了 SOFA 的服务发布和服务引用，相比较 SpringCloud 而言，真心觉得很轻量。上面的一幅图基本就能展示大部分调用过程，这在 Spring 和 Tomcat 这种框架中，是不可想象的。而 bolt 的隔离也让 RPC 框架有了更多的选择，通过不同的扩展点实现，你可以使用不同的网络通信框架。这时候，有必要上一张 SOFA 官方的图了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-221f19cb339e9bef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从上图可以看出，我们今天比较熟悉的地方，比如 Cluster，包含了过滤器，负载均衡，路由，然后调用 remoting 的远程模块，也就是 bolt。 通过 sendMsg 方法。</p>
<p>而 Cluster 的外部模块，我们今天就没有仔细看了，这个肯定是要留到今后看的。比如地址管理，连接管理等等。</p>
<p>好啦，今天就到这里。如有不对之处，还请指正。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-—-扩展机制</title>
    <url>/2018/05/02/2018/2018-05-02-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94-%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>我们在之前的文章中已经稍微了解过 SOFA 的扩展机制，我们也说过，一个好的框架，必然是易于扩展的。那么 SOFA 具体是怎么实现的呢？</p>
<p>一起来看看。</p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>看官方的 demo：</p>
<p>1.定义扩展点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Extensible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.定义扩展实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Extension(&quot;A&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonA</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;li wei&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.编写扩展描述文件：META-INF/services/sofa-rpc/com.alipay.sofa.rpc.extension.Person。文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A=com.alipay.sofa.rpc.extension.PersonA</span><br></pre></td></tr></table></figure>

<p>4.加载扩展点，获取到扩展实现类使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = ExtensionLoaderFactory.getExtensionLoader(Person.class).getExtension(<span class="string">&quot;A&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>很简单对不对，只需要 2 个注解，一个配置文件，然后使用工厂方法通过接口名称和扩展点名称就能够获取到实例。So，我们今天要看的就是这些东西，其实挺简单的，如果用过 Java 自带的 SPI 就会很熟悉了。</p>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>从哪里下手呢？当然是这个工厂方法。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getExtensionLoader(clazz, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的是重载的另一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; clazz, ExtensionLoaderListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = LOADER_MAP.get(clazz);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ExtensionLoaderFactory.class) &#123;</span><br><span class="line">            loader = LOADER_MAP.get(clazz);</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                loader = <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(clazz, listener);</span><br><span class="line">                LOADER_MAP.put(clazz, loader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，从 Map 中取出，如果没有，创建一个，放入缓存。这里使用了双重检查锁。</p>
<p>注意，这里有个参数，ExtensionLoaderListener ，作用是当加载完毕的的时候，回调他的 onLoad 方法，通常是在异步的时候使用。</p>
<p>所以，看出来了吧，关键过程在 new ExtensionLoader（）。</p>
<h2 id="ExtensionLoader-的创建过程"><a href="#ExtensionLoader-的创建过程" class="headerlink" title="ExtensionLoader 的创建过程"></a>ExtensionLoader 的创建过程</h2><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;T&gt; interfaceClass, ExtensionLoaderListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(interfaceClass, <span class="keyword">true</span>, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;T&gt; interfaceClass, <span class="keyword">boolean</span> autoLoad, ExtensionLoaderListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RpcRunningState.isShuttingDown()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.interfaceName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.listener = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.factory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.extensible = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.all = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接口为空，既不是接口，也不是抽象类</span></span><br><span class="line">    <span class="keyword">if</span> (interfaceClass == <span class="keyword">null</span> ||</span><br><span class="line">        !(interfaceClass.isInterface() || Modifier.isAbstract(interfaceClass.getModifiers()))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extensible class must be interface or abstract class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.interfaceClass = interfaceClass;</span><br><span class="line">    <span class="keyword">this</span>.interfaceName = ClassTypeUtils.getTypeStr(interfaceClass);</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">    Extensible extensible = interfaceClass.getAnnotation(Extensible.class);</span><br><span class="line">    <span class="keyword">if</span> (extensible == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">&quot;Error when load extensible interface &quot;</span> + interfaceName + <span class="string">&quot;, must add annotation @Extensible.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.extensible = extensible;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非单例则是空</span></span><br><span class="line">    <span class="keyword">this</span>.factory = extensible.singleton() ? <span class="keyword">new</span> ConcurrentHashMap&lt;String, T&gt;() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.all = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ExtensionClass&lt;T&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (autoLoad) &#123;</span><br><span class="line">        List&lt;String&gt; paths = RpcConfigs.getListValue(RpcOptions.EXTENSION_LOAD_PATH);</span><br><span class="line">        <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">            loadFromFile(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个地方需要注意，autoLoad 属性默认是 ture，也就是默认自动加载。当然，基本上都是自动加载的，这里的参数用于测试用的。</p>
<p>来看这个构造方法。首先是一波赋值操作。</p>
<p>然后检查参数。检查是否是抽象类或者接口，检查是否有 Extensible 注解。</p>
<p>如果是单例，创建一个 Map 保存这个对象，如果不是，Map 就是 null，每次都创建新的。</p>
<p>其中，会有一个  <code>RpcConfigs.getListValue(RpcOptions.EXTENSION_LOAD_PATH)</code> 的操作，用于从获取配置好的路径，通过全局搜索，找到 rpc-config-default.json。包含以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展点加载的路径</span></span><br><span class="line"><span class="string">&quot;extension.load.path&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;META-INF/services/sofa-rpc/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;META-INF/services/&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>两个路径。所以返回值是个 List。</p>
<p>for 循环解析 list 中的 path，即调用 loadFromFile 方法。</p>
<p>方法内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadFromFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认如果不指定文件名字，就是接口名</span></span><br><span class="line">    String file = StringUtils.isBlank(extensible.file()) ? interfaceName : extensible.file().trim();</span><br><span class="line">    String fullFileName = path + file;</span><br><span class="line">    ClassLoader classLoader = ClassLoaderUtils.getClassLoader(getClass());</span><br><span class="line">    loadFromClassLoader(classLoader, fullFileName);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断注解的 file 属性是否为空，如果是空，则使用接口名，否则使用 file 指定的名称。</p>
<p>然后，将配置文件中 path 和 file 属性拼接。这里其实可以使用 StringBuilder。</p>
<p>然后呢？获取 ClassLoader，默认使用当下线程的 ClassLoader，如果为空，使用当前 ExtensionLoader 的 ClassLoader ，若给定的 class 是空，则使用 SystemClassLoader。</p>
<p>从这里可以看出 SPI 设计的好处，如果使用策略模式实现的话，那么 ClassLoader 必定相同，而类似  SPI 的设计，可以让上层应用和下层应用的 ClassLoader 隔离开来。</p>
<p>拿到 ClassLoader 和 全路径的接口名后，开始加载文件。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadFromClassLoader</span><span class="params">(ClassLoader classLoader, String fullFileName)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(fullFileName)</span><br><span class="line">        : ClassLoader.getSystemResources(fullFileName);</span><br><span class="line">    <span class="comment">// 可能存在多个文件。</span></span><br><span class="line">    <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            <span class="comment">// 读取一个文件</span></span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openStream(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    readLine(url, line);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 ClassLoader 获取 classpath 下的文件 URL 集合。然后遍历这些 URL，通过流读取文件，并通过  readLine 方法解析每一行读取出的字符串。这里的字符串就是 SPI 配置文件中的，类似下面的：</p>
<p>文件名称：<code>com.alipay.sofa.rpc.extension.Person</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A=com.alipay.sofa.rpc.extension.PersonA</span><br></pre></td></tr></table></figure>
<p>通过加载指定路径 + 接口名（或 Extensible 指定 file），得到文件名，然后读取文件中的文本。由于按行读取，可能读取多次。</p>
<p>然后看 readLine 方法处理解析出来的字符串。</p>
<p>这个方法就比较长了，主要是数据校验，就不贴出来了，说说逻辑。</p>
<ol>
<li><p>首先解析该行的数据，parseAliasAndClassName 方法，如果是 # 号，就是注释之类的处理。根据 = 号分割，得到 ClassName，创建一个数据，下标 0 是别名，例如上面的 A，下标 1 是全类名。</p>
</li>
<li><p>使用 Class.forName 反射加载该类。</p>
</li>
<li><p>获取该类的 Extension 注解，</p>
</li>
</ol>
<ul>
<li>如果是 null，抛出异常，</li>
<li>如果不是，获取 value 值，value 值不能是空。</li>
<li>如果 SPI 文件中没有配置别名，使用注解上的。</li>
<li>如果SPI 文件配置了，则校验和注解上的是否一致，</li>
<li>如果不一致，抛出异常。</li>
<li>如果接口的注解声明需要编码，而实现类没有配置，抛出异常。</li>
<li>如果别名是 default 或者 * ，抛出异常。</li>
</ul>
<ol start="4">
<li>检查当前系统中，是否已经含有相同的别名的类，注意：这里是一个接口对应一个 Map，因此这里的校验是相对于这个接口，也就是检查当前接口的同名（别名）实现。</li>
</ol>
<ul>
<li>如果有同名的，且<strong>当前实现类扩展</strong> override 是 ture（可以覆盖），且新的实现类的优先级没有老的高，忽略这个新的，反之，加载这个新类。</li>
<li>如果<strong>当前实现类扩展</strong> 不能覆盖，判断，如果旧的实现类扩展可覆盖，且旧优先级大于等于新的。忽略新的，反之，如果旧的扩展类不能覆盖或者优先级小于新的，抛出已存在异常，因为系统不知道该怎么办（新的不能覆盖，老的也不能覆盖且优先级低）。</li>
</ul>
<ol start="5">
<li><p>如果没有老的，直接加载新的实现类，创建一个 extensionClass 对象。</p>
</li>
<li><p>如果加载创建成功，检查是否有互斥的扩展点，循环该接口中缓存的所有的实现。</p>
</li>
</ol>
<ul>
<li>如果当前的实现类的优先级大于等于已存在的，检查新的扩展是否排除老的扩展，这个<code>排除扩展</code>是个别名数组，如果有，循环删除缓存中的 extensionClass。</li>
<li>如果当前的实现类的优先级小于已存在的，则检查已存在的<code>排除扩展</code> 是否包含当前扩展点，如果包含，就不会放入到缓存中了。</li>
</ul>
<ol start="7">
<li>调用 loadSuccess 方法，将刚刚创建的 extensionClass 和对应的别名放入到 all map 中，也就是缓存中。如果配置了监听器，调用监听器的 onLoad 方法，告知监听器：加载完毕，请指示！</li>
</ol>
<p>关闭流。</p>
<p>到这里，一个完整的扩展点就加载完毕了！！！</p>
<p>回到  ExtensionLoaderFactory 的 getExtesionLoader 方法，构造方法结束，通过接口名称，成功从SPI 文件中加载了实现类，然后呢？将接口和对应的 ExtensionLoader 对象放入到缓存中，下次使用。</p>
<p>最后，返回 ExtensionLoader 对象。</p>
<p>通常，紧接着就会调用这个对象的 getExtension 方法。类似下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = ExtensionLoaderFactory.getExtensionLoader(Person.class).getExtension(<span class="string">&quot;A&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过别名获取实例。</p>
<p>可以猜到，肯定是从这个实例的缓存中获取别名对应的 ExtensionClass 对象。如果没有，则抛出 Not Found 异常.</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String alias)</span> </span>&#123;</span><br><span class="line">    ExtensionClass&lt;T&gt; extensionClass = getExtensionClass(alias);</span><br><span class="line">    <span class="keyword">if</span> (extensionClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SofaRpcRuntimeException(<span class="string">&quot;Not found extension of &quot;</span> + interfaceName + <span class="string">&quot; named: \&quot;&quot;</span> + alias + <span class="string">&quot;\&quot;!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extensible.singleton() &amp;&amp; factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            T t = factory.get(alias);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    t = factory.get(alias);</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        t = extensionClass.getExtInstance();</span><br><span class="line">                        factory.put(alias, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> extensionClass.getExtInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果接口标识是单例的且缓存不是空，则从缓存中取出，这里使用双重检查锁，拿到 ExtensionClass 对象后，对应他的 getExtInstance 方法，方法内容就是使用反射创建一个对象实例。并将别名和对应的对象放入到缓存中。</p>
</li>
<li><p>注意：ExtensionLoader 有 2 个缓存，一个是 <code>ConcurrentHashMap&lt;String, ExtensionClass&lt;T&gt;&gt; all</code> 缓存是别名和对应的 ExtensionClass，表示一个接口可以有多个实现。另一个是 ConcurrentHashMap&lt;String, T&gt;， 这个 Map 保存的是对应别名的单例对象。</p>
</li>
<li><p>如果不是单例的，使用反射创建一个新的。</p>
</li>
</ul>
<p>好了，到这里，一个完整的对象就创建出来了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>借用一下 SOFA  官方对扩展点的介绍：</p>
<blockquote>
<h1 id="为了对-SOFARPC-各个环节的都有充足的可扩展性，SOFA-RPC定义了一套十分灵活的扩展机制，所有扩展实现都是平等的。"><a href="#为了对-SOFARPC-各个环节的都有充足的可扩展性，SOFA-RPC定义了一套十分灵活的扩展机制，所有扩展实现都是平等的。" class="headerlink" title="为了对 SOFARPC 各个环节的都有充足的可扩展性，SOFA-RPC定义了一套十分灵活的扩展机制，所有扩展实现都是平等的。"></a>为了对 SOFARPC 各个环节的都有充足的可扩展性，SOFA-RPC定义了一套十分灵活的扩展机制，所有扩展实现都是平等的。</h1><p>这套机制不管是对SOFA-RPC本身的开发者其使用者而言都是非常有用的。SOFA-RPC将其自身抽象为了多个模块，各个模块之间无显式依赖，通过SPI的方式进行交互。</p>
</blockquote>
<p>SOFA  的扩展点没有使用 Java 的  SPI ，而是使用了 Java 的设计进行了扩展。比如：</p>
<ul>
<li>可以使用别名，</li>
<li>可以有优先级（排序），</li>
<li>可以覆盖，</li>
<li>可以控制是否单例，</li>
<li>是否编码。</li>
<li>可以自定义文件位置。</li>
<li>是否排斥其他扩展点。</li>
</ul>
<p>相比较 JDK 的 SPI ，功能强大了太多。值得借鉴。</p>
<p>好了。关于 SOFA  扩展点的设计分析就到这里。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-—-自定义线程池原理</title>
    <url>/2018/05/02/2018/2018-05-02-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>在 SOFA-RPC 的官方介绍里，介绍了自定义线程池，可以为指定服务设置一个独立的业务线程池，和 SOFARPC 自身的业务线程池是隔离的。多个服务可以共用一个独立的线程池。</p>
<p> API使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserThreadPool threadPool = <span class="keyword">new</span> UserThreadPool();</span><br><span class="line">threadPool.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">threadPool.setMaximumPoolSize(<span class="number">100</span>);</span><br><span class="line">threadPool.setKeepAliveTime(<span class="number">200</span>);</span><br><span class="line">threadPool.setPrestartAllCoreThreads(<span class="keyword">false</span>);</span><br><span class="line">threadPool.setAllowCoreThreadTimeOut(<span class="keyword">false</span>);</span><br><span class="line">threadPool.setQueueSize(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">UserThreadPoolManager.registerUserThread(<span class="string">&quot;com.alipay.sofa.rpc.quickstart.HelloService&quot;</span>, threadPool);</span><br></pre></td></tr></table></figure>

<p>如上为 HelloService 服务设置了一个自定义线程池。</p>
<p>在 SOFABoot 中如下使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customExcutor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alipay.sofa.rpc.server.UserThreadPool&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maximumPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alipay.sofa.rpc.quickstart.HelloService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sofa:service</span> <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;XXXService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">thread-pool-ref</span>=<span class="string">&quot;customExcutor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么实现原理是什么呢？</p>
<p>一起来看看。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">UserThreadPoolManager.</span><br><span class="line">        registerUserThread(<span class="string">&quot;com.alipay.sofa.rpc.quickstart.HelloService&quot;</span>, threadPool);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>UserThreadPoolManager 是一个用户自定义线程池管理器。里面包含一个 Map， key 是接口名称，value 是线程池（一个 UserThreadPool对象）。</p>
<p>看看这个 UserThreadPool。</p>
<p>很简单的一个类，封装了 JDK 的线程池。并初始化了一些线程池参数，比如：</p>
<ul>
<li>corePoolSize = 10</li>
<li> maximumPoolSize = 100</li>
<li> keepAliveTime   = 300000（线程回收时间（毫秒））</li>
<li>queueSize       = 0</li>
<li>threadPoolName  = “SofaUserProcessor” 线程名字</li>
<li>boolean  allowCoreThreadTimeOut 是否关闭核心线程池</li>
<li>boolean  prestartAllCoreThreads 是否初始化核心线程池</li>
<li>volatile ThreadPoolExecutor executor</li>
</ul>
<p>初始化的时候，默认参数不变，核心线程数 10，最大 100，默认不关闭核心线程池，默认不初始化线程池。默认是 SynchronousQueue 队列，此队列性能最高，也可以设置成阻塞队列，或者优先级队列。当然，这些都是可以改的。</p>
<p>这个线程池什么时候回起作用呢？</p>
<p>先说结论：当 Netty 读取数据（channelRead 方法）后，通过层层调用，会调用 RpcRequestProcessor 类的 process 方法。该方法会拿到上下文的 UserProcessor 对象（bolt 的话，实现类是 BoltServerProcessor），UserProcessor 有一个内部接口 ExecutorSelector，线程池选择器，该选择器定义了一个 select 方法，返回的是线程池，如果用户自定义了线程池，就会返回自定义线程池（方式：UserThreadPoolManager.getUserThread(service)），如果没有，返回系统线程池。</p>
<p>来看看具体代码。</p>
<p>RpcHandler 我们很熟悉了，就是 Netty 的 handler ，ChannelRead 方法中，会调用 RpcCommandHandler 的 handleCommand 方法，该方法会提交到线程池执行。任务内容是执行 process 方法。</p>
<p>通过调用，最后会执行 RpcRequestProcessor 的 process 方法。调用栈如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b562fc9470487de5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>105 行会有如下判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// to check whether get executor using executor selector</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == userProcessor.getExecutorSelector()) &#123;</span><br><span class="line">    executor = userProcessor.getExecutor();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// in case haven&#x27;t deserialized in io thread</span></span><br><span class="line">    <span class="comment">// it need to deserialize clazz and header before using executor dispath strategy</span></span><br><span class="line">    <span class="keyword">if</span> (!deserializeRequestCommand(ctx, cmd, RpcDeserializeLevel.DESERIALIZE_HEADER)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//try get executor with strategy</span></span><br><span class="line">    executor = userProcessor.getExecutorSelector().select(cmd.getRequestClass(),</span><br><span class="line">        cmd.getRequestHeader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试获取线线程池选择器，如果是 null， 使用系统线程池，如果不是 null，调用选择器的 select 方法得到线程池，随后，使用这个线程执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Till now, if executor still null, then try default</span></span><br><span class="line"><span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executor = (<span class="keyword">this</span>.getExecutor() == <span class="keyword">null</span> ? defaultExecutor : <span class="keyword">this</span>.getExecutor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the final executor dispatch process task</span></span><br><span class="line">executor.execute(<span class="keyword">new</span> ProcessTask(ctx, cmd));</span><br></pre></td></tr></table></figure>

<p>那么这个 select 方法是如何实现的呢？目前仅有一个实现，BoltServerProcessor 的内部类 UserThreadPoolSelector。该方法逻辑如下：<br>从 Header 中获取服务名称，根据服务名称调用 <code>UserThreadPoolManager.getUserThread(service)</code> ，如果返回值不是 null ，说明用户设置自定义线程池了，就返回该线程池。如果是 null，返回系统线程池。</p>
<p>而 BoltServerProcessor 的 getExecutorSelector 判断规则如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExecutorSelector <span class="title">getExecutorSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UserThreadPoolManager.hasUserThread() ? executorSelector : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasUserThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userThreadMap != <span class="keyword">null</span> &amp;&amp; userThreadMap.size() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BoltServerProcessor</span><span class="params">(BoltServer boltServer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.boltServer = boltServer;</span><br><span class="line">    <span class="keyword">this</span>.executorSelector = <span class="keyword">new</span> UserThreadPoolSelector(); <span class="comment">// 支持自定义业务线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，BoltServerProcessor 默认就会创建一个内部类对象，只要 UserThreadPoolManager 里面的 Map 不是空，就会尝试调用 select 方法，如果通过服务名称找到缓存中的自定义线程池，就直接返回了。非常完美。</p>
<p>需要注意一点，系统线程池只有一个，默认核心线程池大小 20 ，最大 200。貌似这也是 tomcat 的默认配置，因此，并发很高的时候，可能就需要用户使用自定义线程池了，能够显著提高并发量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，关于自定线程池的原理探究的差不多了，这个功能挺有用的，当系统并发很高的时候，或者某个服务很慢，不能让该服务影响其他服务，就可以使用自定线程池，将这些慢服务和其他服务隔离开。</p>
<p>原理则是通过 UserThreadPoolManager 与 Server 进行交互，当 Server 执行任务的时候，会从当前的上下文中，找到与调用服务对应的线程池，如果有的话，就返回 UserThreadPoolManager 管理的线程池，如果没有，返回框架线程池。</p>
<p>具体判断的代码在 Bolt 模块  <code>com.alipay.remoting.rpc.protocol.RpcRequestProcessor</code> 的 process 方法中。</p>
<p>bye！！！</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-—-链路数据透传</title>
    <url>/2018/05/02/2018/2018-05-02-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94-%E9%93%BE%E8%B7%AF%E6%95%B0%E6%8D%AE%E9%80%8F%E4%BC%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>SOFA—RPC 支持数据链路透传功能，官方解释：</p>
<blockquote>
<p> 链路数据透传功能支持应用向调用上下文中存放数据，达到整个链路上的应用都可以操作该数据。 使用方式如下，可分别向链路的 request 和 response 中放入数据进行透传，并可获取到链路中相应的数据。</p>
</blockquote>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RpcInvokeContext.getContext().putRequestBaggage(<span class="string">&quot;key_request&quot;</span>,<span class="string">&quot;value_request&quot;</span>);</span><br><span class="line">RpcInvokeContext.getContext().putResponseBaggage(<span class="string">&quot;key_response&quot;</span>,<span class="string">&quot;value_response&quot;</span>);</span><br><span class="line"></span><br><span class="line">RpcInvokeContext.getContext().getAllRequestBaggage(<span class="string">&quot;key_request&quot;</span>);</span><br><span class="line">RpcInvokeContext.getContext().getAllRequestBaggage(<span class="string">&quot;key_response&quot;</span>);</span><br></pre></td></tr></table></figure>





<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>从这个 4 句代码开始看。</p>
<p>关键类： RpcInvokeContext，该类是一个 <code>基于ThreadLocal的面向业务开发者使用的上下文传递对象</code>。</p>
<p>内部维护了一个 ThreadLocal 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RpcInvokeContext&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;RpcInvokeContext&gt;();</span><br></pre></td></tr></table></figure>

<p>value 是一个 RpcInvokeContext 对象。</p>
<p>当调用 getContext 的时候，就会从当前线程获取 RpcInvokeContext 对象。</p>
<p>该类定义了以下属性：</p>
<ul>
<li>boolean BAGGAGE_ENABLE 是否开启上下文透传功能，关闭后，会提高性能</li>
<li>Integer timeout  用户自定义超时时间，单次调用生效</li>
<li>String  targetURL 用户自定义对方地址，单次调用生效</li>
<li>String targetGroup 用户自定义对方分组</li>
<li>SofaResponseCallback responseCallback 用户自定义Callback，单次调用生效</li>
<li>ResponseFuture&lt;?&gt;  future</li>
<li><strong>ConcurrentMap&lt;String, Object&gt; map 自定义属性</strong></li>
<li> <strong>Map&lt;String, String&gt; requestBaggag 请求上的透传数据</strong></li>
<li><strong>Map&lt;String, String&gt;  responseBaggage</strong> 响应上的透传数据</li>
</ul>
<p>知道了基本的数据结构，再看看上面的几个方法：</p>
<ul>
<li>putRequestBaggage（）</li>
<li>putResponseBaggage（）</li>
<li>getAllRequestBaggage（）</li>
<li>getAllRequestBaggage（）</li>
</ul>
<p>其实都是从 Map 中获取数据，不过，貌似官方的例子有点问题，后面两个例子不对。没有 key 。待我提个 issue。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7c8a539476b63ace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sofa-fail.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个功能让我想到了我在公司项目中使用的 CurrentUser 功能，也是使用的 ThreadLocal，将用户的信息存在线程中，这样就不必将常用数据在方法参数中传递了，省了很多事。只不过异步的时候，可能会有点问题，需要手动将 ThreadLocal 传递到异步线程中。</p>
<p>不过，我没有使用手动传递，我是这么设计的：自定义线程池和线程工厂，线程工厂创建线程的时候，会将主线程的 ThreadLocal 复制到异步线程中，并自定义了线程类，在 finally 块中删除 ThreadLocal，非常完美的一个设计。这样就不必每次手动传递并手动删除了。</p>
<p>好了，这个功能还是很简单的。但非常实用，不过要是能加上我上面设计的那个功能就好啦！ 哈哈！ </p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-—-负载均衡和一致性-Hash</title>
    <url>/2018/05/03/2018/2018-05-03-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7-Hash/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>SOFA 内置负载均衡，支持 5 种负载均衡算法，随机（默认算法），本地优先，轮询算法，一致性 hash，按权重负载轮询（不推荐，已被标注废弃）。</p>
<p>一起看看他们的实现（重点还是一致性 hash）。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>具体源码在  AbstractLoadBalancer 类中，子类需要实现 doSelect 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ProviderInfo <span class="title">doSelect</span><span class="params">(SofaRequest invocation, List&lt;ProviderInfo&gt; providerInfos)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>随机是默认算法，RandomLoadBalancer 类是具体实现，基本是就是 providerInfos.get(random.nextInt(size)) 的逻辑，但考虑到权重，会按总权重数随机找个数字，然后这个数字会递减直到小于 0 的时候，确定那个节点。好像看起来和权重没什么关系？ 有大佬懂的可以指导一下。</p>
<p>本地优先算法，则是找本机的 localhost 进行匹配，优先选择和本机地址相同的服务，然后在这些服务列表进行随机选一个。</p>
<p>轮询就是一个个来。使用取于算法。</p>
<p>然后就是一致性 Hash 了，重点讲讲。 有必要复习一下我们之前写过的一致性 hash 算法 demo： <a href="http://thinkinjava.cn/article/89">自己实现一个一致性 Hash 算法</a>。</p>
<p>SOFA 具体实现是 ConsistentHashLoadBalancer 类。内部维护一个 Map，每个服务对应一个选择器，这个选择器内部维护着一个 TreeMap，SOFA 会将所有节点均匀的散列在 Map 中，也就是 hash 环上，使用了虚拟节点。当根据服务的 key 获取节点的时候(如果服务列表没变)，会通过 hash 值找到比他大的那个节点，相同的请求每次找到的都是同一个节点（根据第一个参数 hash）。</p>
<p>来看看具体实现。</p>
<p>先看看 doSelect 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProviderInfo <span class="title">doSelect</span><span class="params">(SofaRequest request, List&lt;ProviderInfo&gt; providerInfos)</span> </span>&#123;</span><br><span class="line">    String interfaceId = request.getInterfaceName();</span><br><span class="line">    String method = request.getMethodName();</span><br><span class="line">    String key = interfaceId + <span class="string">&quot;#&quot;</span> + method;</span><br><span class="line">    <span class="keyword">int</span> hashcode = providerInfos.hashCode(); <span class="comment">// 判断是否同样的服务列表</span></span><br><span class="line">    Selector selector = selectorCache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="keyword">null</span> <span class="comment">// 原来没有</span></span><br><span class="line">        ||</span><br><span class="line">        selector.getHashCode() != hashcode) &#123; <span class="comment">// 或者服务列表已经变化</span></span><br><span class="line">        selector = <span class="keyword">new</span> Selector(interfaceId, method, providerInfos, hashcode);</span><br><span class="line">        selectorCache.put(key, selector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selector.select(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据接口名和方法名从 map 中找到对应的服务选择器，如果没有，或者服务列表变了，则重新创建一个，这点和缓存的一致性 Hash 设计还是有点不一样。</p>
<p>缓存的一致性 Hash 的目的是：如果服务列表变了，比如节点的增减，那么，缓存的 key 通过相同的 hash 算法依然能够找到对应的缓存节点（最多失效一个节点的数据——如果增减一个节点）。</p>
<p>但 RPC 服务的一致性 hash 的目的是：希望相同的请求总是落在同一个节点上。</p>
<p>而这里无法确定增加的是哪一个节点，索性直接创建一个新的。</p>
<p>然后，调用选择的 select 方法返回一个服务节点。</p>
<p>先看看选择器的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Selector</span><span class="params">(String interfaceId, String method, List&lt;ProviderInfo&gt; actualNodes, <span class="keyword">int</span> hashcode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.interfaceId = interfaceId;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    <span class="keyword">this</span>.hashcode = hashcode;</span><br><span class="line">    <span class="comment">// 创建虚拟节点环 （默认一个provider共创建128个虚拟节点，较多比较均匀）</span></span><br><span class="line">    <span class="keyword">this</span>.virtualNodes = <span class="keyword">new</span> TreeMap&lt;Long, ProviderInfo&gt;();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo providerInfo : actualNodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num / <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] digest = messageDigest(providerInfo.getHost() + providerInfo.getPort() + i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line">                virtualNodes.put(m, providerInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要逻辑就是构造虚拟节点，使用 TreeMap，和我们之前实现的一样。那么虚拟节点是如何设计的呢？</p>
<p>SOFA 为每个节点分配了 128 个虚拟节点，保存在 Map 中，也就是 128 个引用指向同一个对象。这里的 hash 算法用来 md5 然后再复杂的 hash 一波，为了更加的均衡吧。</p>
<p>当使用 select 方法的时候，怎么找到相同的节点呢？</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProviderInfo <span class="title">sekectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">    ProviderInfo providerInfo = virtualNodes.get(hash);</span><br><span class="line">    <span class="keyword">if</span> (providerInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        SortedMap&lt;Long, ProviderInfo&gt; tailMap = virtualNodes.tailMap(hash);</span><br><span class="line">        <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">            hash = virtualNodes.firstKey();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash = tailMap.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">        providerInfo = virtualNodes.get(hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> providerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hash 该方法第一个参数，找到比他的 hash 值大节点集合中的第一个节点，如果没有比他大的，则最小的那个节点（回到原点）。</p>
<p>标准的一致性 hash 算法。保证了每次相同的请求都会落在同一个节点上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RPC 的一致性 hash 和缓存的一致性 hash 的目的是不同的。<br>缓存的目的是：当集群中缓存节点增减的时候，服务访问相同 key 依然能够访问到相同的节点（增减造成的失效节点很少）。不会像普通的取于算法那样造成无法访问，进而引起缓存雪崩，甚至 DB 宕机。</p>
<p>而 RPC 的目的是：希望相同的请求（第一个参数相同），每次都会打在相同的节点上。</p>
<p>换个角度想想，其实都是一样的，目的都是为了相同的请求每次都访问到相同的节点。</p>
<p>好啦，关于 SOFA  的负载均衡就到这里啦。</p>
<p>bye！！！</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析—-事件总线</title>
    <url>/2018/05/03/2018/2018-05-03-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>大部分框架都是事件订阅功能，即观察者模式，或者叫事件机制。通过订阅某个事件，当触发事件时，回调某个方法。该功能非常的好用，而 SOFA 内部也设计了这个功能，并且内部大量使用了该功能。来看看是如何设计的。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>核心类有 3 个：</p>
<ul>
<li>EventBus 事件总线</li>
<li>Event 事件，即被观察者</li>
<li>Subscriber 订阅者，即观察者</li>
</ul>
<p>Subscriber 是个抽象类， 子类需要自己实现 onEvent 方法，即回调方法。还有一个是否同步执行的参数。</p>
<p>EventBus 类实现了注册功能，反注册功能（删除）。事件发生时通知订阅者功能。</p>
<p>内部使用一个“大型数据结构”保存事件和订阅者的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap&lt;Class&lt;? extends Event&gt;, CopyOnWriteArraySet&lt;Subscriber&gt;&gt; SUBSCRIBER_MAP</span><br></pre></td></tr></table></figure>

<p>所有相关信息都保存在该数据结构中。</p>
<p>看看注册功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;? extends Event&gt; eventClass, Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArraySet&lt;Subscriber&gt; set = SUBSCRIBER_MAP.get(eventClass);</span><br><span class="line">    <span class="keyword">if</span> (set == <span class="keyword">null</span>) &#123;</span><br><span class="line">        set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;Subscriber&gt;();</span><br><span class="line">        CopyOnWriteArraySet&lt;Subscriber&gt; old = SUBSCRIBER_MAP.putIfAbsent(eventClass, set);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set = old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    set.add(subscriber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数为 一个事件对象，一个订阅对象。</p>
<p>首先从 Map 中根据事件的 Class 获取对应的订阅者集合，注意，这里都是用的并发容器。</p>
<p>下面的判断有点意思，考虑到并发的情况，如果第一次获取 Set 是 null，则尝试创建一个并放进 Map，这里使用的并不是 put 方法，而是 putIfAbsent 方法，该方法作用等同于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!map.containsKey(key)) </span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> map.get(key);</span><br></pre></td></tr></table></figure>

<p>所以，这里再一次考虑并发问题，如果这个间隙有其他线程 put 了，就可以获取到那个线程 put 的 Set。很谨慎。而且性能相比较锁要好很多。虽然这个方法并发量不会很高，但也是一种性能优化。</p>
<p>如果发生了并发，就使用已有的 Set，然后将 Set 放置到 Map 中，完成事件和订阅者的映射。</p>
<p>再看看取消注册方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unRegister</span><span class="params">(Class&lt;? extends Event&gt; eventClass, Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArraySet&lt;Subscriber&gt; set = SUBSCRIBER_MAP.get(eventClass);</span><br><span class="line">    <span class="keyword">if</span> (set != <span class="keyword">null</span>) &#123;</span><br><span class="line">        set.remove(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是直接删除。</p>
<p>再看看通知功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">final</span> Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnable()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CopyOnWriteArraySet&lt;Subscriber&gt; subscribers = SUBSCRIBER_MAP.get(event.getClass());</span><br><span class="line">    <span class="keyword">if</span> (CommonUtils.isNotEmpty(subscribers)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Subscriber subscriber : subscribers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subscriber.isSync()) &#123;</span><br><span class="line">                handleEvent(subscriber, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 异步</span></span><br><span class="line">                AsyncRuntime.getAsyncThreadPool().execute(</span><br><span class="line">                    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            handleEvent(subscriber, event);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看是否开启了总线功能，在性能测试的时候，可能是关闭的。</p>
<p>如果开启了，就根据给定的时间找到订阅者，循环调用 handleEvent 方法（其实就是调用订阅者的 onEvent 方法）。</p>
<p>这里有一个是否异步的判断，如果异步的，则在异步线程池执行。</p>
<p>这个异步线程池 AsyncRuntime 可以看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolExecutor <span class="title">getAsyncThreadPool</span><span class="params">(<span class="keyword">boolean</span> build)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (asyncThreadPool == <span class="keyword">null</span> &amp;&amp; build) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (AsyncRuntime.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (asyncThreadPool == <span class="keyword">null</span> &amp;&amp; build) &#123;</span><br><span class="line">                <span class="comment">// 一些系统参数，可以从配置或者注册中心获取。</span></span><br><span class="line">                <span class="keyword">int</span> coresize = RpcConfigs.getIntValue(RpcOptions.ASYNC_POOL_CORE);</span><br><span class="line">                <span class="keyword">int</span> maxsize = RpcConfigs.getIntValue(RpcOptions.ASYNC_POOL_MAX);</span><br><span class="line">                <span class="keyword">int</span> queuesize = RpcConfigs.getIntValue(RpcOptions.ASYNC_POOL_QUEUE);</span><br><span class="line">                <span class="keyword">int</span> keepAliveTime = RpcConfigs.getIntValue(RpcOptions.ASYNC_POOL_TIME);</span><br><span class="line"></span><br><span class="line">                BlockingQueue&lt;Runnable&gt; queue = ThreadPoolUtils.buildQueue(queuesize);</span><br><span class="line">                NamedThreadFactory threadFactory = <span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;SOFA-RPC-CB&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                RejectedExecutionHandler handler = <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">                    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (i++ % <span class="number">7</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            i = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span> (LOGGER.isWarnEnabled()) &#123;</span><br><span class="line">                                LOGGER.warn(<span class="string">&quot;Task:&#123;&#125; has been reject because of threadPool exhausted!&quot;</span> +</span><br><span class="line">                                    <span class="string">&quot; pool:&#123;&#125;, active:&#123;&#125;, queue:&#123;&#125;, taskcnt: &#123;&#125;&quot;</span>, r,</span><br><span class="line">                                    executor.getPoolSize(),</span><br><span class="line">                                    executor.getActiveCount(),</span><br><span class="line">                                    executor.getQueue().size(),</span><br><span class="line">                                    executor.getTaskCount());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Callback handler thread pool has bean exhausted&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                asyncThreadPool = ThreadPoolUtils.newCachedThreadPool(</span><br><span class="line">                    coresize, maxsize, keepAliveTime, queue, threadFactory, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> asyncThreadPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也做了双重检查锁。</p>
<p>默认核心线程大小 10，最大 200， 队列大小 256， 回收时间 60 秒。</p>
<p>因此，获取的队列就是 LinkedBlockingQueue。</p>
<p>这里的拒绝策略很有意思，每失败 6 次，打印详细信息，当前线程数，活动线程数量，队列 size， 任务总数，不知道为什么这么设计（6次？？）。</p>
<p>目前框架中 Event 的实现很多，我们在之前的源码分析中也看到很多了。而订阅者目前只有一个 FaultToleranceSubscriber。用于容错处理。是 FaultToleranceModule 模块的功能。该功能也是个扩展点，当系统初始化的时候，会注册 ClientSyncReceiveEvent 事件和 ClientAsyncReceiveEvent。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个事件总线功能真是观察者模式的最佳实践，通过系统中发生的事件，能够让外部模块感知到并进行处理，比如上面介绍的容错模块。当发生订阅的事件后，外部模块能够响应，很完美。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>Java-如何获取泛型类型</title>
    <url>/2018/05/04/2018/2018-05-04-Java-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       在 Java 开发中，获取泛型这种操作虽不是很常用，但有时确实必须的，比如 将Json 字符串反序列化成对象的时候。今天就来介绍这个操作。

<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设我们定义了一个类，内部有一个数据结构，泛型为 T，当我们输入一个 Json 字符串，想把这个 Json 反序列化成对象，那么此时，我们就需要知道这个泛型的类型。</p>
<p>具体代码场景如下：</p>
<p>抽象父类（包含泛型）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  T data;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(String json)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = JsonUtil.toObject(json, deSerializable());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想在该类中输入 Json，并将字符串反序列化成对象。比如下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类定义了父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">DataClass</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(String json)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(json);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据类型继承Comparable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataClass</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">DataClass</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(DataClass o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的例子中，子类定义了泛型，但获取泛型类型是在父类。</p>
<p>所以，重点在 deSerializable（） 方法的实现，我们需要一个 Class<T> 让 Json 工具能够正常序列化。</p>
<h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>先说结论：通过 Java 反射包的 ParameterizedType 工具获得泛型具体类型。</p>
<p>例如：下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String json = JsonUtil.toJson(<span class="keyword">new</span> DataClass());</span><br><span class="line">  Son s = <span class="keyword">new</span> Son(json);</span><br><span class="line">  Type t = s.getClass().getGenericSuperclass();</span><br><span class="line">  <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    <span class="comment">// output: cn.think.in.java.clazz.loader.generics.Base&lt;cn.think.in.java.clazz.loader.generics.DataClass&gt;</span></span><br><span class="line">    <span class="keyword">for</span> (Type type : ((ParameterizedType) t).getActualTypeArguments()) &#123;</span><br><span class="line">      System.out.println(type);</span><br><span class="line">      <span class="comment">//output: class cn.think.in.java.clazz.loader.generics.DataClass</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们将一个对象序列化成 Json 字符串，模拟外部输入。然后呢？创建一个子类对象，得到这个 Son 的 Class 。<br>关键地方来了，调用 getGenericSuperclass 方法，这个方法的作用是：<code>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的 Type。</code></p>
<p>所以这里会得到一个 ParameterizedTypeImpl 类型的对象。注意：这个类是 Sun 包下的，不是开源的。该类有以下几个属性：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4f60a84bee81d18f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Type[] 数组就是该类（我们这里是父类）的泛型，rawType 是原始类型，即 Base  的 Class 类型。而 OwnerType 返回的则是 Base 类型。</p>
<p>然后呢，判断这个 t 是不是 ParameterizedType 接口的实现类。如果是，调用 getActualTypeArguments 方法，返回一个 Type数组，即上图的 actualTypeArguments 属性。</p>
<p>而返回的 Type 数组就是父类的泛型 Class。因为 Class 实现了  Type 接口。为什么是数组呢？因为每个类可以有多个泛型。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e704390e0702f436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>通过这样几行代码，我们就得到了泛型。当然，这种用法很少。</p>
<p>现在我们知道了如何得到泛型，那么，就将刚刚的场景中的问题解决。</p>
<p>实现反序列化方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Class&lt;T&gt; <span class="title">deSerializable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Type type = getClass().getGenericSuperclass();</span><br><span class="line">  <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">    System.out.println(parameterizedType.getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> (Class&lt;T&gt;) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到当前类（Son）的泛型 Class，获取到泛型数组，返回第一个（因为我们只有一个泛型）泛型类型的 Class<T>。<br>然后，使用 Json 工具传入 Json 字符串和 Class<T> 类型并返回实体对象。</p>
<p>这样就能够保证编译不会错误，且高度灵活。</p>
<p>这里有一个地方需要注意：Java 的泛型是会在运行期擦除的，但并不总是擦除成 Object ，而是擦除到上限类型。<br>如果时获取接口的泛型则是调用 Class 的 getGenericInterfaces 方法得到接口集合的泛型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为历史原因，Java 的泛型一直是个痛点，但无法避免，所以使用起来确实有点麻烦。但通过 Class 类的众多反射功能，我们还是能够处理泛型的问题。</p>
<p>我们今天使用反射得到了一个类的泛型，并在父类进行处理，成功的将一个字符串反序列化成一个对象。</p>
<p>bye！</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA--源码分析-—-预热权重</title>
    <url>/2018/05/04/2018/2018-05-04-SOFA--%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94-%E9%A2%84%E7%83%AD%E6%9D%83%E9%87%8D/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>SOFA-RPC 支持根据权重对服务进行预热功能，具体地址：<a href="https://github.com/alipay/sofa-rpc/wiki/Provider-Warmup-Weight">预热权重</a>.</p>
<p>引用官方文档：</p>
<p>预热权重功能让客户端机器能够根据服务端的相应权重进行流量的分发。该功能也常被用于集群内少数机器的启动场景。利用流量权重功能在短时间内对服务端机器进行预热，然后再接收正常的流量比重。 运行机制如下： </p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7b33cacfc6b7ba3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>1.服务端服务在启动时会将自身的预热时间，预热期内权重，预热完成后的正常权重推送给服务注册中心。如上图 ServiceB 指向 Service Registry 。</p>
<p>2.客户端在引用服务的时候会获得每个服务实例的预热权重信息。如上图 Service Registry 指向 client 。</p>
<p>3.客户端在进行调用的时候会根据服务所在地址的预热时期所对应的权重进行流量分发。如上图 client 指向 ServiceA 和 ServiceB 。 ServiceA 预热完毕，权重默认 100 ， ServiceB 处于预热期，权重为 10，因此所承受流量分别为 100%110 和 10%110 。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>该功能使用方式如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProviderConfig&lt;HelloWordService&gt; providerConfig = <span class="keyword">new</span> ProviderConfig&lt;HelloWordService&gt;() </span><br><span class="line">            .setWeight(<span class="number">100</span>) </span><br><span class="line">            .setParameter(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT,<span class="string">&quot;10&quot;</span>) </span><br><span class="line">            .setParameter(ProviderInfoAttrs.ATTR_WARM_UP_END_TIME,<span class="string">&quot;12000&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如上，该服务的预热期为12s，在预热期内权重为10，预热期结束后的正常权重为100。如果该服务一共发布在两个机器A,B上，A机器正处于预热期内，并使用上述配置，B已经完成预热，正常权重为200。那么客户端在调用的时候，此时流量分发的比重为10：200，A机器预热结束后，流量分发比重为100：200。 在SOFABoot中，如下配置预热时间，预热期间权重和预热完后的权重即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">&quot;sampleRestFacadeReferenceBolt&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alipay.sofa.endpoint.facade.SampleFacade&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">weight</span>=<span class="string">&quot;100&quot;</span> <span class="attr">warm-up-time</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">warm-up-weight</span>=<span class="string">&quot;1000&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再来看看源码实现。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>从 demo 中看，SOFA 需要在 ProviderConfig 中配置属性，而这些属性都是保存在一个 Map 中。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">setParameter</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (parameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">           parameters = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">           parameters.remove(key);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           parameters.put(key, value);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> castThis();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当发布服务的时候，这个 Map 会被发布到注册中心。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(String appName, String serviceName, ProviderInfo providerInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOGGER.isInfoEnabled(appName)) &#123;</span><br><span class="line">        LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_ROUTE_REGISTRY_PUB, serviceName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#123;service : [provider...]&#125;</span></span><br><span class="line">    ProviderGroup oldGroup = memoryCache.get(serviceName);</span><br><span class="line">    <span class="keyword">if</span> (oldGroup != <span class="keyword">null</span>) &#123; <span class="comment">// 存在老的key</span></span><br><span class="line">        oldGroup.add(providerInfo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有老的key，第一次加入</span></span><br><span class="line">        List&lt;ProviderInfo&gt; news = <span class="keyword">new</span> ArrayList&lt;ProviderInfo&gt;();</span><br><span class="line">        news.add(providerInfo);</span><br><span class="line">        memoryCache.put(serviceName, <span class="keyword">new</span> ProviderGroup(news));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 备份到文件 改为定时写</span></span><br><span class="line">    needBackup = <span class="keyword">true</span>;</span><br><span class="line">    doWriteFile();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subscribe) &#123;</span><br><span class="line">        notifyConsumerListeners(serviceName, memoryCache.get(serviceName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，提供者会将 providerInfo 的信息写到本地文件(注册中心)中。</p>
<p>而消费者则会从注册中心订阅服务列表的信息。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ProviderGroup&gt; <span class="title">subscribe</span><span class="params">(ConsumerConfig config)</span> </span>&#123;</span><br><span class="line">    String key = LocalRegistryHelper.buildListDataId(config, config.getProtocol());</span><br><span class="line">    List&lt;ConsumerConfig&gt; listeners = notifyListeners.get(key);</span><br><span class="line">    <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        listeners = <span class="keyword">new</span> ArrayList&lt;ConsumerConfig&gt;();</span><br><span class="line">        notifyListeners.put(key, listeners);</span><br><span class="line">    &#125;</span><br><span class="line">    listeners.add(config);</span><br><span class="line">    <span class="comment">// 返回已经加载到内存的列表（可能不是最新的)</span></span><br><span class="line">    ProviderGroup group = memoryCache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        group = <span class="keyword">new</span> ProviderGroup();</span><br><span class="line">        memoryCache.put(key, group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码会被 DefaultConsumerBootstrap 调用，根据消费者的配置信息，生成一个 key，然后将消费者添加到通知列表中（当数据变化时，通知消费者，由定时任务执行）。</p>
<p>然后，从内存中取出key 对应的服务分组，并返回集合（就是提供者注册的信息）。</p>
<p>这段代码会在 AbstractCluster 的 init 方法中调用—— <code>List&lt;ProviderGroup&gt; all = consumerBootstrap.subscribe();</code>。</p>
<p>服务分组的数据结构是 ProviderInfo，是一个抽象的服务提供列表，其中包含服务的信息，比如地址，协议类型，主机地址，端口，路径，版本，动态参数，静态参数，服务状态等等，其中就包括<strong>权重</strong>。</p>
<p>获取权重的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProviderStatus status = getStatus();</span><br><span class="line">    <span class="keyword">if</span> (status == ProviderStatus.WARMING_UP) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 还处于预热时间中</span></span><br><span class="line">            Integer warmUpWeight = (Integer) getDynamicAttr(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT);</span><br><span class="line">            <span class="keyword">if</span> (warmUpWeight != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> warmUpWeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 getStatus 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProviderStatus <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status == ProviderStatus.WARMING_UP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; (Long) getDynamicAttr(ProviderInfoAttrs.ATTR_WARM_UP_END_TIME)) &#123;</span><br><span class="line">            <span class="comment">// 如果已经过了预热时间，恢复为正常</span></span><br><span class="line">            status = ProviderStatus.AVAILABLE;</span><br><span class="line">            setDynamicAttr(ProviderInfoAttrs.ATTR_WARM_UP_END_TIME, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑如下：</p>
<p>获取服务状态，如果是预热状态，则获取预热状态的权重值，反之，如果不是，反之正常值（默认 100）。</p>
<p>获取状态的方法则是判断时间，如果当前时间大于预热时间，则修改状态为可用。并删除动态参数列表中的“预热时间”。</p>
<p>那么，什么时候会获取权重呢？</p>
<p>如果看过之前文章的同学肯定知道，在负载均衡的时候，会调用。</p>
<p>我们看看默认的随机均衡算法。还记得当时，楼主有个地方不是很明白，我们要根据权重随机，当时看来，并没有什么用处，今天明白了。再上一遍代码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@ AbstractLoadBalancer.<span class="function">java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(ProviderInfo providerInfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从provider中或得到相关权重,默认值100</span></span><br><span class="line">    <span class="keyword">return</span> providerInfo.getWeight() &lt; <span class="number">0</span> ? <span class="number">0</span> : providerInfo.getWeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取权重，默认 100.</p>
<p>再看随机算法的 doSelect 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@ RandomLoadBalancer.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProviderInfo <span class="title">doSelect</span><span class="params">(SofaRequest invocation, List&lt;ProviderInfo&gt; providerInfos)</span> </span>&#123;</span><br><span class="line">    ProviderInfo providerInfo = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> size = providerInfos.size(); <span class="comment">// 总个数</span></span><br><span class="line">    <span class="keyword">int</span> totalWeight = <span class="number">0</span>; <span class="comment">// 总权重</span></span><br><span class="line">    <span class="keyword">boolean</span> isWeightSame = <span class="keyword">true</span>; <span class="comment">// 权重是否都一样</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> weight = getWeight(providerInfos.get(i));</span><br><span class="line">        totalWeight += weight; <span class="comment">// 累计总权重</span></span><br><span class="line">        <span class="keyword">if</span> (isWeightSame &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; weight != getWeight(providerInfos.get(i - <span class="number">1</span>))) &#123;</span><br><span class="line">            isWeightSame = <span class="keyword">false</span>; <span class="comment">// 计算所有权重是否一样</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !isWeightSame) &#123;</span><br><span class="line">        <span class="comment">// 如果权重不相同且权重大于0则按总权重数随机</span></span><br><span class="line">        <span class="keyword">int</span> offset = random.nextInt(totalWeight);</span><br><span class="line">        <span class="comment">// 并确定随机值落在哪个片断上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            offset -= getWeight(providerInfos.get(i));</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                providerInfo = providerInfos.get(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果权重相同或权重为0则均等随机</span></span><br><span class="line">        providerInfo = providerInfos.get(random.nextInt(size));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> providerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断各个服务的权重是否相同，如果不同，进入第二个 if。</p>
<p>关键点来了，如果权重不同，那么从总的权重中，随机一个数，一次从服务列表的权重递减。知道该值小于0，那么就使用该服务。</p>
<p>这样就能<strong>大致</strong>保证权重小的被击中的几率较小。具体取决于 Java 的随机算法，但是我们还是比较相信 Java 的。</p>
<p>我们来推倒一下这个算法。</p>
<p>假设有 A， B， C， 3 个服务，每个服务默认权重 100，其中 C 现在处于预热阶段，则 C 的权重等于 10.</p>
<p>那么总权重 210。</p>
<p>如果C落在第一位，那么一定会选中C的情况是权重落在0-9之间；<br>如果C落在第二位，那么一定会选中C的情况是权重落在100-109之间；<br>如果C是在第三位，那么一定会选中C的情况是权重落在200-209；</p>
<p>符合权重。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在看来，预热权重还是挺简单的，主要在负载均衡出进行处理就行。</p>
<p>今天就到这里，bye！！！</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA--源码分析-—-自动故障剔除</title>
    <url>/2018/05/07/2018/2018-05-07-SOFA--%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94-%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E5%89%94%E9%99%A4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>集群中通常一个服务有多个服务提供者。其中部分服务提供者可能由于网络，配置，长时间 fullgc ，线程池满，硬件故障等导致长连接还存活但是程序已经无法正常响应。单机故障剔除功能会将这部分异常的服务提供者进行降级，使得客户端的请求更多地指向健康节点。当异常节点的表现正常后，单机故障剔除功能会对该节点进行恢复，使得客户端请求逐渐将流量分发到该节点。单机故障剔除功能解决了服务故障持续影响业务的问题，避免了雪崩效应。可以减少人工干预需要的较长的响应时间，提高系统可用率。</p>
<p>这种功能叫做自动故障剔除。</p>
<p>而 SOFA 是怎么实现的呢？</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>自动故障剔除的运行机制：</p>
<ul>
<li>单机故障剔除会统计一个时间窗口内的调用次数和异常次数，并计算每个服务对应ip的异常率和该服务的平均异常率。</li>
<li>当达到ip异常率大于服务平均异常率到一定比例时，会对该服务+ip的维度进行权重降级。</li>
<li>如果该服务+ip维度的权重并没有降为0，那么当该服务+ip维度的调用情况正常时，则会对其进行权重恢复。</li>
<li>整个计算和调控过程异步进行，不会阻塞调用。</li>
</ul>
<p>根据官方例子，使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FaultToleranceConfig faultToleranceConfig = <span class="keyword">new</span> FaultToleranceConfig();</span><br><span class="line">        <span class="comment">// 是否开启调控.</span></span><br><span class="line">        faultToleranceConfig.setRegulationEffective(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 是否进行降级</span></span><br><span class="line">        faultToleranceConfig.setDegradeEffective(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 时间窗口大小</span></span><br><span class="line">        faultToleranceConfig.setTimeWindow(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 每次权重降级的比率</span></span><br><span class="line">        faultToleranceConfig.setWeightDegradeRate(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">FaultToleranceConfigManager.putAppConfig(<span class="string">&quot;appName&quot;</span>, faultToleranceConfig);</span><br></pre></td></tr></table></figure>

<p>如上，该应用会在打开了单机故障剔除开关，每20s的时间窗口进行一次异常情况的计算，如果某个服务+ip的调用维度被判定为故障节点，则会进行将该服务+ip的权重降级为0.5倍。</p>
<p>可以看到，这个功能面向框架用户的 API 就是这个 FaultToleranceConfig 类，即故障容错配置。</p>
<p>用户可以配置某个服务是否开启调控，是否进行降级，实际窗口大小（秒），每次权重降级的比率。</p>
<p>那么，SOFA 是如何实现的呢？</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先说明，由于这个功能相比较之前的功能，代码要复杂一些，因此，本次分析主要分析主流程，不会面面俱到。关于详细的代码细节，我们将在后面的源码分析中详细解释。</p>
<h5 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h5><p>SOFA 对于该功能的设计使用了 Modle 的方式，简单来说，就是一个可扩展，可热插拔的中间件。SOFA  的中间件和 RPC 框架都是通过  Modle 的方式来实现的。</p>
<p>如何实现呢？</p>
<p>RPC 初始化的时候，会调用 RpcRuntimeContext 类的静态块，该静态块内部会初始化其他模块，即调用 ModuleFactory.installModules() 方法。该方法会加载配置文件中所有 Module 接口的 SPI 文件。然后循环调用 install 方法，即初始化。</p>
<p>目前的源码中只有一个 Module 的实现类，即 FaultToleranceModule 。故障容错模块。该类的 install 方法 会创建一个订阅者，在事件总线中订阅两个事件：ClientSyncReceiveEvent 和 ClientAsyncReceiveEvent。然后创建一个事件窗口调控器。并初始化该调控器。</p>
<p>TimeWindowRegulator  是故障调控的核心类，内部包含以下属性：</p>
<ol>
<li>measureCounter 度量计数器，每执行一次度量任务，就加一。</li>
<li>measureScheduler 度量定时任务线程池，使用 RATE 模式，即从任务开始时间开始计算。如果任务的时间超过了间隔时间，间隔时间将失效。这里的间隔时间是 1 秒。</li>
<li>regulationExecutor 计算线程池，即在定时任务线程池中提交计算任务给这个线程池，以实现快速返回。该线程池核心大小为 2. </li>
<li>measureModels 度量模型，一个存放 MeasureModel 对象的 List。</li>
<li>measureStrategy 计算策略（根据度量结果，判断是否需要执行降级或者恢复） </li>
<li>weightDegradeStrategy 降级策略: 调整权重 </li>
<li>logDegradeStrategy 降级策略: 只打印日志</li>
<li>recoverStrategy 恢复策略：调整权重</li>
<li>listener 调用统计监听器，当发生事件时，会调用监听器的方法。</li>
</ol>
<p>属性很多，暂时不详细解释。说主流程。</p>
<p>该类的 intit 方法是初始化这些属性，并注册监听器。注册方式是调用 InvocationStatFactory.addListener(listener) 方法。而这个监听器是该类的内部类 —— TimeWindowRegulatorListener。</p>
<p>好，初始化完毕之后，开始说流程。</p>
<p>当 RPC 框架调用了发送消息的方法，并返回（或者失败）后，就会向事件总线 EventBus 丢一个事件。例如 ClientSyncReceiveEvent 事件，该事件需要包含以下属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerConfig consumerConfig;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ProviderInfo   providerInfo;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SofaRequest    request;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SofaResponse   response;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Throwable      throwable;</span><br></pre></td></tr></table></figure>

<p>基本包含了此次调用的所有信息。</p>
<p>此时，就会触发订阅者的 onEvent 方法。即 FaultToleranceSubscriber 的 onEvent 方法。该方法会判断，如果用户启用了自动故障剔除功能，则根据 consumerConfig 和 providerInfo 得到一个调用统计器对象，并对调用次数加一。</p>
<p>关键的方法在 onEvent 中调用的 InvocationStatFactory.getInvocationStat(consumerConfig, providerInfo); 该方法会创建一个 InvocationStat  调用统计器对象，放入 Map 中，而对应的 key 则是根据上面两个参数生成的 InvocationStatDimension 统计维度对象。</p>
<p>创建完  InvocationStat  调用统计器对象后，调用所有监听器的 onAddInvocationStat 方法，表示，我添加了一个监听器了，你可以做点什么了。还记得 TimeWindowRegulator 初始化的时候会添加一个监听器吗。就是这里的监听器。</p>
<p>内部类 TimeWindowRegulatorListener  的方法逻辑如下：<br>调用度量策略对象的 buildMeasureModel 方法，传入调用统计器。返回一个度量模型。然后，将这个模型添加进 List（measureModels 属性） 中。并调用外部类的 startRegulate 方法，开始进行调控。</p>
<p>startRegulate 方法就是启动了定时任务，使用了一个原子 boolean 变量进行状态判断。</p>
<p>定时任务的内容是什么呢？</p>
<p>答：运行 MeasureRunnable 任务。<br>该任务首先会对度量计数器加一。然后循环 List 中的 MeasureModel 度量模型。并判断该 MeasureModel 是否到达了用户设定的时间窗口（取于用户设置的时间大小）。</p>
<p>如果到达了时间窗口，并调用 measureStrategy 度量策略对象（serviceHorizontal）的 measure 方法，参数则是度量模型，返回一个度量的结果对象 —— MeasureResult。</p>
<p>得到这个对象后，向计算线程池提交一个 RegulationRunnable 任务，该任务内容如下：<br>拿到刚刚传入的度量结果拿到度量结果详情的集合 —— measureResultDetails，循环这些集合，并执行 doRegulate 方法，进行调控。</p>
<p>该方法就是真正的对服务进行调控的方法了。首先，一个服务有 3 个状态：健康，异常，忽略。状态来自于刚刚的 measure 方法。</p>
<p>如果用户设置了可以降级的话，则判断服务的度量状态，如果异常了且不超过一个服务的最大调控 IP 数，则执行权重降级逻辑。反之，打印日志。</p>
<p>如果度量状态是正常的，则执行权重恢复，并从降级 IP 列表中删除。</p>
<p>如果用户没有设置可以降级，且度量状态是异常，那么，执行日志降级。即对异常 IP 记性异常信息的日志打印。</p>
<p>当对权重进行降级之后，能够被负载均衡击中的几率就会对应的小很多。甚至了无法击中。</p>
<p>以上，就是 SOFA 自动故障剔除功能的基本实现流程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是那句话，由于这个功能比较繁杂，限于篇幅，今天看的是总流程，总结一下这个流程。</p>
<p>RPC 框架在启动的时候，会自动加载故障容错模块，并监听客户端发送事件。同时会初始化故障容错相关的类和监听器。</p>
<p>当发生订阅事件的时候，会调用 onEvent 方法，进而调用 TimeWindowRegulatorListener 的监听器方法。该方法会将度量模型添加进 List 中。</p>
<p>定时任务每隔一秒会调度 MeasureRunnable 任务，内容是根据用户设置的时间窗口处理 List 中的调度模型。</p>
<p>定时任务会向计算任务线程池提交一个 RegulationRunnable 任务。用于处理度量结果中的数据。该任务会循环度量结果的所有度量结果详情，并调用 doRegulate 方法进行调控。</p>
<p>最后，doRegulate 方法则是根据 度量结果详情 的状态判断是否应该对服务 + IP 进行权重降级或者权重恢复，再或者是打印日志 —— 这依据用户设置。</p>
<p>以上就是 SOFA  自动故障剔除的基本流程。后面我们会详细分析自动故障剔除的细节代码。敬请期待。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析—-自定义路由寻址</title>
    <url>/2018/05/07/2018/2018-05-07-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E5%AF%BB%E5%9D%80/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言


<p>SOFA-RPC 中对服务地址的选择也抽象为了一条处理链，由每一个 Router 进行处理。同 Filter 一样， SOFA-RPC 对 Router 提供了同样的扩展能力。</p>
<p>那么就看看 SOFA  是如何处理的。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>官方教程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Extension(value = &quot;customerRouter&quot;)</span></span><br><span class="line"><span class="meta">@AutoActive(consumerSide = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRouter</span> <span class="keyword">extends</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ConsumerBootstrap consumerBootstrap)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needToLoad</span><span class="params">(ConsumerBootstrap consumerBootstrap)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ProviderInfo&gt; <span class="title">route</span><span class="params">(SofaRequest request, List&lt;ProviderInfo&gt; providerInfos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> providerInfos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>新建扩展文件 META-INF/services/sofa-rpc/com.alipay.sofa.rpc.client.Router 。内容如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">customerRouter=com<span class="selector-class">.alipay</span><span class="selector-class">.sofa</span><span class="selector-class">.rpc</span><span class="selector-class">.custom</span>.CustomRouter</span><br></pre></td></tr></table></figure>
<p>如上自定义了一个 CustomerRouter ，生效于所有消费者。其中 init 参数 ConsumerBootstrap 是引用服务的包装类，能够拿到 ConsumerConfig ，代理类，服务地址池等对象。 needToLoad 表示是否生效该 Router ， route 方法即筛选地址的方法。</p>
<p>可以看到，Router 也是通过 SOFA 的扩展机制实现的，通过定义一个 SPI 文件，能够有效的解耦。</p>
<p>然后我们再来看看他的原理。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>在 SOFA  中， Router 是个抽象类，内部定义了 4 个方法：</p>
<pre><code class="java">//初始化
public void init(ConsumerBootstrap consumerBootstrap) &#123;
&#125;

//是否自动加载
public boolean needToLoad(ConsumerBootstrap consumerBootstrap) &#123;
    return true;
&#125;
// 筛选Provider
public abstract List&lt;ProviderInfo&gt; route(SofaRequest request, List&lt;ProviderInfo&gt; providerInfos);

//记录路由路径记录
protected void recordRouterWay(String routerName) &#123;
    if (RpcInternalContext.isAttachmentEnable()) &#123;
        RpcInternalContext context = RpcInternalContext.getContext();
        String record = (String) context.getAttachment(RpcConstants.INTERNAL_KEY_ROUTER_RECORD);
        record = record == null ? routerName : record + &quot;&gt;&quot; + routerName;
        context.setAttachment(RpcConstants.INTERNAL_KEY_ROUTER_RECORD, record);
    &#125;
&#125;
</code></pre>
<p>子类必须实现  route 方法，该方法的参数是 SofaRequest 和一个 ProviderInfo List。然后，返回值是筛选过的 ProviderInfo List。即用户可以在自定义的 Router 中筛选 Router 使用。负载均衡会从用户的 ProviderInfo List 中选择一个 ProviderInfo 进行调用。</p>
<p>路由顺序按照 Extension 注解的 order 进行从小到大排序。</p>
<p>同时， SOFA  上下文 RpcInternalContext 会记录此次调用的路径，也就是路由名字。</p>
<p>而目前框架中有 3 个实现类：</p>
<ol>
<li>DirectUrlRouter 直连路由，needToLoad 判断条件是客户端是否设置了只来路由。路由规则是：从地址保持器中选取直连地址，然后添加到 List 中。</li>
<li>ExcludeRouter 要排除的过滤器，目前暂没有定义。用户可自己扩展。</li>
<li>RegistryRouter 从注册中心获取地址进行路由。needToLoad 条件是：如果没有设置直连地址且从注册中心订阅服务。路由规则：从地址保持器中获取默认的（注册中心）服务列表，并添加进 List 返回。</li>
</ol>
<p>其中，这个地址保持/管理器是什么鬼呢？</p>
<p>每个客户端都有一个地址管理器 —— AddressHolder。管理着服务的分组。SingleGroupAddressHolder 是 AddressHolder 的具体实现类，也是通过扩展机制实现的。他是一个只支持单个分组的地址选择器（额外存一个直连分组）。</p>
<p>他内部有 2 个 List， 一个是直连地址列表，另一个是注册中心的地址列表。</p>
<p>在 Cluster 初始化的时候，会先初始化 routerChain Router 链，该实例中包含了一个 Router 数组，用于保存路由实例。</p>
<p>同时还会初始化服务端列表，即调用 consumerBootstrap.subscribe() 方法，该方法在 DefaultConsumerBootstrap 中实现如下：</p>
<ol>
<li>如果直连地址（逗号或者分号分割）不是空，则返回一个包装了直连地址的 List<ProviderGroup>。</li>
<li>如果直连地址是空的，则从注册中心获取服务列表。</li>
</ol>
<p>得到服务列表后，则添加到地址管理器中。同时向事件总线丢一个 ProviderInfoUpdateAllEvent 事件。包括建立长连接——也就是初始化 RpcClient，在调用 updateAllProviders 方法后，会异步的在一个 initPool 线程池中启动多个线程初始化长连接。</p>
<p>好了，现在地址管理器里面已经有连接了。</p>
<p>当客户端调用的时候，也就是 doInvoke 方法，会先从从 routerChain 中获取过滤后的 List<ProviderInfo> ，然后，调用负载均衡的 select 方法，从这些可选的路由中选取一个 ProviderInfo 进行调用。</p>
<p>以上，就是自定义路由寻址，地址管理器的实现原理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SOFA 为框架用户定义了 Router ，用户可以实现 route 方法，并在该方法中实现过滤策略，从而返回一个用户设置的服务列表，值得注意的是，用户需要定义 order 属性，因为 Router 是从小到大排序的，顺序对于整体逻辑来说非常重要。</p>
<p>和 Router 息息相关的还有地址管理器 —— AddressHolder，该类会管理服务列表，客户端在初始化的时候，会将地址都保存到 AddressHolder 中，在之后的负载均衡选择服务的时候，会从地址管理器中获取服务列表（已经路由过滤的）进行选择。</p>
<p>还有一点需要注意：地址管理器每次 update 的时候，会全量更新连接管理器。如果有新增的服务，就会建立长连接。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>从--Sofa-XXX--标签开始看-SOFA-Boot-如何融入-Spring</title>
    <url>/2018/05/01/2018/2018-05-01-%E4%BB%8E--sofa-XXX--%E6%A0%87%E7%AD%BE%E5%BC%80%E5%A7%8B%E7%9C%8B-SOFA-Boot-%E5%A6%82%E4%BD%95%E8%9E%8D%E5%85%A5-Spring/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>SOFA-Boot  现阶段支持 XML 的方式在 Spring 中定义 Bean，通过这些标签，我们就能从 Spring 容器中取出 RPC 中的引用，并进行调用，那么他是如何处理这些自定义标签的呢？一起来看看。</p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>官方例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:sofa</span>=<span class="string">&quot;http://sofastack.io/schema/sofaboot&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://sofastack.io/schema/sofaboot   http://sofastack.io/schema/sofaboot.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alipay.sofa.boot.examples.demo.rpc.bean.PersonServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:service</span> <span class="attr">ref</span>=<span class="string">&quot;personServiceImpl&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alipay.sofa.boot.examples.demo.rpc.bean.PersonService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.rest</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">&quot;personReferenceBolt&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alipay.sofa.boot.examples.demo.rpc.bean.PersonService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">&quot;personReferenceRest&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alipay.sofa.boot.examples.demo.rpc.bean.PersonService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sofa:binding.rest</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personFilter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alipay.sofa.boot.examples.demo.rpc.bean.PersonServiceFilter&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显眼的 sofa 标签。那么如何知道他是怎么处理这些标签的内容的呢？</p>
<p>答：从上面的 xmlns 命名空间可以找到。如果写过自定义标签的话，一定很熟悉了。</p>
<p>如果没有写过的话，就简单介绍一下。Spring 支持用户自定标签，需要遵守以下规范。</p>
<ol>
<li><p>编写 xsd 文件，就是定义标签的属性。</p>
</li>
<li><p>继承抽象类 <code>NamespaceHandlerSupport</code> 并实现 init 方法，此类就是处理命名空间的类，不仅需要实现 init 方法，你还需要继承 <code>AbstractSingleBeanDefinitionParser</code> 类，自行解析标签。通常写法是这样：<br><code>registerBeanDefinitionParser(&quot;tagName&quot;,new UserBeanDefinitionParser());</code></p>
</li>
<li><p>在做完上面的步骤后，你需要在 META-INF 目录下编写 <code>spring.handlers</code> 和 <code>spring.schemas</code> 文件，前者 key 为命名空间名称，value 为 <code>NamespaceHandlerSupport</code> 的具体实现；后者 key 为 xsd 命名空间，value 为 xsd 具体文件（classpath 下）。</p>
</li>
</ol>
<p>完成上面的步骤后，Spring 在加载 xml 配置文件的时候，会检查命名空间，如果是自定义的，则会根据命名空间的 key 找到对应的解析器，也就是 <code>NamespaceHandlerSupport</code> 对自定义标签进行解析。</p>
<p>So，我们的目的是看 sofa 标签是如何解析的，则找到解析 sofa 的<code>NamespaceHandlerSupport</code>。</p>
<h2 id="寻找解析-sofa-标签的源头"><a href="#寻找解析-sofa-标签的源头" class="headerlink" title="寻找解析 sofa 标签的源头"></a>寻找解析 sofa 标签的源头</h2><p>通过 IDEA 或者别的工具全局搜索，我们找到了源码中位于 start 模块下，resources 下的 META-INF 目录，目录下有以下几个文件：</p>
<ol>
<li>rpc.xsd</li>
<li>sofaboot.xsd</li>
<li>spring.handlers</li>
<li>spring.schemas</li>
</ol>
<p>这几个文件我们是比较关注的，重点看 handlers 文件。内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http\://sofastack.io/schema/sofaboot=com.alipay.sofa.infra.config.spring.namespace.handler.SofaBootNamespaceHandler</span><br></pre></td></tr></table></figure>

<p><code>SofaBootNamespaceHandler</code> 明显就是明明空间处理类，继承了 Spring 的 <code>NamespaceHandlerSupport</code>。</p>
<p>该类的 init 方法通过 Java 的 SPI 进行扩展，找到 SofaBootTagNameSupport 的标签支持类，目前有 2 个实现： ServiceDefinitionParser 和 ReferenceDefinitionParser。</p>
<p>两个类支持不同的 element。一个是引用服务，一个是发布服务。</p>
<p>这样就比较清晰了。在得到两个类之后，注册到 Spring 的 parsers map 中。key 是 element 名字，value 是解析器。</p>
<p>具体的解析上面说了，service 和 reference。</p>
<p>Sofa 在这个设计上使用了模板模式，使用一个抽象类 <code>AbstractContractDefinitionParser</code>，并定义一个 doParseInternal 抽象方法让子类去实现。</p>
<p>抽象父类将一些公用的属性进行解析，下图中都是公用的属性：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-03c5b80b0b9be698.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>你咋确定是公用的属性呢？首先，xml 解析后，肯定是要注入到 Bean 里面去的，那么这个 Bean 是什么呢？实际上，在 <code>AbstractSingleBeanDefinitionParser</code>  抽象类中，会有一个返回 Bean 类型的方法，对应着一个 tag，而他们的父类就是<code>  AbstractContractFactoryBean</code>。</p>
<p>该类公用属性就对应上面图片中的定义。</p>
<p>有了这些基础的信息，还是不能够直接使用的，毕竟都是字符串。我们要看看 SOFA 是如何将自己和 Spring 容器融合在一起的。</p>
<h2 id="如何融入-Spring？"><a href="#如何融入-Spring？" class="headerlink" title="如何融入 Spring？"></a>如何融入 Spring？</h2><p>来看看他们的子类， ReferenceDefinitionParser 类（ServiceFactoryBean 类似）。对应的  Bean 是 ReferenceFactoryBean，该类单独定义了负载均衡（loadBalance）的属性。</p>
<p>啊，从这个类的名字看，很熟悉，之前在分析 Spring 源码的时候，就看见过 FactoryBean。可以通过 getObject 方法修改返回的 Bean。</p>
<p>来看看这个类的 类图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-bcc952b2247a1059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如我们所料，继承了 Spring 中关键的扩展点。而他的 getObject 方法将返回一个代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> proxy;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>具体创建代理的方法是 <code>com.alipay.sofa.runtime.service.component.ReferenceComponent</code> 类的 createProxy 方法，然后调用适配器。适配器的作用就是胶水的作用，将 Spring 容器和第三方框架粘合起来，Spring 提供的接口则是 FactoryBean 等接口，而第三方框架可以在 getObject 方法中大有作为。</p>
<p>SOFA-Boot 的适配器在 <code>om.alipay.sofa.rpc.boot.runtime.adapter</code> 包中，具体实现则是 RpcBindingAdapter  类，其中 outBinding 方法用于发布服务，inBinding 方法用于引用服务，这里直接使用的就是 SOFA-RPC 的 consumerConfig 和 providerConfig。这就应该很熟悉了吧。哈哈。</p>
<p>来点代码看看(已去除异常处理)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">outBinding</span><span class="params">(Object contract, RpcBinding binding, Object target, SofaRuntimeContext sofaRuntimeContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String uniqueName = ProviderConfigContainer.createUniqueName((Contract) contract, binding);</span><br><span class="line">    ProviderConfig providerConfig = ProviderConfigContainer.getProviderConfig(uniqueName);</span><br><span class="line"></span><br><span class="line">    providerConfig.export();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ProviderConfigContainer.isAllowPublish()) &#123;</span><br><span class="line">        Registry registry = RegistryConfigContainer.getRegistry();</span><br><span class="line">        providerConfig.setRegister(<span class="keyword">true</span>);</span><br><span class="line">        registry.register(providerConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">inBinding</span><span class="params">(Object contract, RpcBinding binding, SofaRuntimeContext sofaRuntimeContext)</span> </span>&#123;</span><br><span class="line">    ConsumerConfig consumerConfig = ConsumerConfigHelper.getConsumerConfig((Contract) contract, binding);</span><br><span class="line">    ConsumerConfigContainer.addConsumerConfig(binding, consumerConfig);</span><br><span class="line"></span><br><span class="line">    Object result = consumerConfig.refer();</span><br><span class="line">    binding.setConsumerConfig(consumerConfig);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So，当 Spring 容器使用 getObject 方法的时候，获取的就是这个代理对象啦。是不是很简单?</p>
<p>有一点需要注意一下，ServiceFactoryBean 的设计和 ReferenceFactoryBean 确实是类似，但是！但是！他的 getObject 方法就是实现类本身，这是 RPC 框架本身的设计决定的，因为它不需要代理，只需要发布服务就行，当收到了客户端传来的信息，就直接调用实现类的指定方法就好了，没有客户端这么复杂。</p>
<p>当然，SOFA 中还有一个组件的概念，我们有时间会好好看看这块的设计。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次我们从 SOFA-Boot 配置文件的 xml 标签开始，对他如何融入 Spring 进行了分析，实际上，整体和我们联想的类似，使用 Spring 的 FactoryBean 的 getObject 方法返回代理，如果是客户端的话，在 getObject 方法中，会创建一个动态代理，这就要使用 SOFA-RPC 了，所以，融合 RPC 和 Spring 的任务肯定是个适配器。SOFA 的实现就是 RpcBindingAdapter 类。在该类中，将 RPC 和 Spring 适配。</p>
<p>而发布服务相比较引用服务就简单一点了，整体上就是通过注解将服务发布，当然也是使用的 RpcBindingAdapter 进行适配。但是没有使用代理（不需要）。</p>
<p>好了，这次研究 SOFA 和 Spring 融合的过程就到这里啦。</p>
<p>bye ！</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-—-连接管理器</title>
    <url>/2018/05/08/2018/2018-05-08-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>RPC 框架需要维护客户端和服务端的连接，通常是一个客户端对应多个服务端，而客户端看到的是接口，并不是服务端的地址，服务端地址对于客户端来讲是透明的。</p>
<p>那么，如何实现这样一个 RPC 框架的网络连接呢？</p>
<p>我们从 SOFA 中寻找答案。</p>
<h2 id="连接管理器介绍"><a href="#连接管理器介绍" class="headerlink" title="连接管理器介绍"></a>连接管理器介绍</h2><p>先从一个小 demo 开始看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsumerConfig&lt;HelloService&gt; consumerConfig = <span class="keyword">new</span> ConsumerConfig&lt;HelloService&gt;()</span><br><span class="line">    .setInterfaceId(HelloService.class.getName()) <span class="comment">// 指定接口</span></span><br><span class="line">    .setProtocol(<span class="string">&quot;bolt&quot;</span>) <span class="comment">// 指定协议</span></span><br><span class="line">    .setDirectUrl(<span class="string">&quot;bolt://127.0.0.1:9696&quot;</span>); <span class="comment">// 指定直连地址</span></span><br><span class="line"></span><br><span class="line">HelloService helloService = consumerConfig.refer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  System.out.println(helloService.sayHello(<span class="string">&quot;world&quot;</span>));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，一个 ConsumerConfig 对应一个接口服务，并指定了直连地址。</p>
<p>然后调用 ref 方法。每个 ConsumerConfig 绑定了一个 ConsumerBootstrap，这是一个非单例的类。</p>
<p>而每个 ConsumerBootstrap 又绑定了一个 Cluster，这是真正的客户端。该类包含了一个客户端所有的关键信息，例如：</p>
<ol>
<li>Router 路由链</li>
<li>loadBalance 负载均衡</li>
<li>addressHolder 地址管理器</li>
<li>connectionHolder 连接管理器</li>
<li>filterChain 过滤器链</li>
</ol>
<p>这 5 个实例是 Cluster 的核心。一个客户端的正常使用绝对离不开这 5 个元素。</p>
<p>我们之前分析了 5 个中的 4 个，今天分析最后一个 —— 连接管理器。</p>
<p>他可以说是 RPC 网络通信的核心。</p>
<p>地址管理器代表的是：一个客户端可以拥有多个接口。<br>连接管理器代表的是：一个客户端可以拥有多个 TCP 连接。</p>
<p>很明显，地址管理器的数据肯定比连接管理器要多。因为通常一个 TCP 连接（Server 端）可以含有多个接口。</p>
<p>那么 SOFA 是如何实现连接管理器的呢？</p>
<p>从 AbstractCluster 的 init 方法中，我们知道，该方法初始化了 Cluster。同时也初始化了 connectionHolder。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接管理器</span></span><br><span class="line">connectionHolder = ConnectionHolderFactory.getConnectionHolder(consumerBootstrap);</span><br></pre></td></tr></table></figure>

<p>使用了 SPI 的方式进行的初始化。目前 RPC 框架的具体实现类只有一个 AllConnectConnectionHolder。即长连接管理器。</p>
<p>该类需要一个 ConsumerConfig 才能初始化。</p>
<p>该类中包含很多和连接相关的属性，有 4 个 Map，未初始化的 Map，存活的节点列表，存活但亚健康的列表，失败待重试的列表。这些 Map 的元素都会随着服务的网络变化而变化。</p>
<p>而这些 Map 中的元素则是：ConcurrentHashMap&lt;ProviderInfo, ClientTransport&gt; 。</p>
<p>即每个服务者的信息对应一个客户端传输。那么这个 ClientTransport 是什么呢？看过之前文章的都知道，这个一个 RPC 和 Bolt 的胶水类。该类的默认实现 BoltClientTransport 包含了一个 RpcClient 属性，注意，该属性是个静态的。也就是说，是所有实例公用的。并且，BoltClientTransport 包含一个 ProviderInfo 属性。还有一个 Url 属性，Connection 属性（网络连接）。</p>
<p>我们理一下：一个 ConsumerConfig 绑定一个 Cluster，一个 Cluster 绑定一个 connectionHolder，一个 connectionHolder 绑定多个 ProviderInfo 和 ClientTransport。</p>
<p>因为一个客户端可以和多个服务进行通信。</p>
<h2 id="代码如何实现？"><a href="#代码如何实现？" class="headerlink" title="代码如何实现？"></a>代码如何实现？</h2><p>在 Cluster 中，会对 connectionHolder 进行初始化，在 Cluster 从注册中心得到服务端列表后，会建立长连接。</p>
<p>从这里开始，地址管理器开始运作。</p>
<p>Cluster 的 updateAllProviders 方法是源头。该方法会将服务列表添加到 connectionHolder 中。即调用 connectionHolder.updateAllProviders(providerGroups) 方法。该方法会全量更新服务端列表。</p>
<p>如果更新的时候，发现有新的服务，便会建立长连接。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!needAdd.isEmpty()) &#123;</span><br><span class="line">    addNode(needAdd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addNode 方法就是添加新的节点。该方法会多线程建立 TCP 连接。</p>
<p>首先会根据 ProviderInfo 信息创建一个 ClientTransport，然后向线程池提交一个任务，任务内容是 initClientTransport（），即初始化客户端传输。</p>
<p>该方法代码如下(精简过了)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClientTransport</span><span class="params">(String interfaceId, ProviderInfo providerInfo, ClientTransport transport)</span> </span>&#123;</span><br><span class="line">        transport.connect();</span><br><span class="line">        <span class="keyword">if</span> (doubleCheck(interfaceId, providerInfo, transport)) &#123;</span><br><span class="line">            printSuccess(interfaceId, providerInfo, transport);</span><br><span class="line">            addAlive(providerInfo, transport);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printFailure(interfaceId, providerInfo, transport);</span><br><span class="line">            addRetry(providerInfo, transport);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关键是调用 transport 的 connect 方法建立连接。</p>
<p>该方法的默认实现在 BoltClientTransport 中，符合我们的预期。我们知道， BoltClientTransport 有一个 RpcClient 的静态实例。这个实例在类加载的时候，就会在静态块中初始化。初始化内容则是初始化他的一些属性，例如地址解析器，连接管理器，连接监控等等。</p>
<p>我们再看 BoltClientTransport 的 connect 方法，该方法主要逻辑是初始化连接。方式则是通过 RpcClient 的 getConnection 方法来获取，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection = RPC_CLIENT.getConnection(url, url.getConnectTimeout());</span><br></pre></td></tr></table></figure>

<p>传入一个 URL 和超时时间。 RpcClient 则是调用连接管理器的 getAndCreateIfAbsent 方法获取，同样传入 Url，这个方法的名字很好，根据 URL 获取连接，如果没有，就创建一个。</p>
<p>有必要看看具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getAndCreateIfAbsent</span><span class="params">(Url url)</span> <span class="keyword">throws</span> InterruptedException, RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// get and create a connection pool with initialized connections.</span></span><br><span class="line">    ConnectionPool pool = <span class="keyword">this</span>.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(),</span><br><span class="line">        <span class="keyword">new</span> ConnectionPoolCall(url));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != pool) &#123;</span><br><span class="line">        <span class="keyword">return</span> pool.get();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;[NOTIFYME] bug detected! pool here must not be null!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会继续调用自身的 getConnectionPoolAndCreateIfAbsent 方法，传入 URL 的唯一标识，和一个 ConnectionPoolCall 对象（实现了 Callable）。</p>
<p>然后阻塞等待返回连接。</p>
<p>我们看看这个 ConnectionPoolCall 的 call 方法实现。该方法调用了连接管理器的 doCreate 方法。传入了 URL 和一个连接池。然后 call 方法返回连接池。</p>
<p>doCreate 方法中，重点就是 create 方法，传入了一个 url，返回一个 Connection，并放入连接池。默认池中只有一个长连接。</p>
<p>而 create 方法则是调用连接工厂的 createConnection 方法。然后调用 doCreateConnection 方法。该方法内部给了我们明确的答案：调用 Netty 的 Bootstrap 的 connect 方法。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout);</span><br><span class="line">ChannelFuture future = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(targetIP, targetPort));</span><br></pre></td></tr></table></figure>

<p>熟悉 Netty 的同学一眼便看出来了。这是一个连接服务端的操作。而这个 BootStrap 的初始化则是在 RpcClient 初始化的时候进行的。注意：BootStrap 是可以共享的。</p>
<p>可以看到， ConnectionPoolCall 的 call 方法就是用来创建 Netty 连接的。回到 getAndCreateIfAbsent 方法里，继续看 getConnectionPoolAndCreateIfAbsent 方法的实现。</p>
<p>该方法内部将 Callable 包装成一个 FutureTask，目的应该是为了以后的异步运行吧，总之，最后还是同步调用了 run 方法。然后调用 get 方法阻塞等待，等待刚刚 call 方法返回的连接池。然后返回。</p>
<p>得到连接池，连接池调用 get 方法，从池中根据策略选取一个连接返回。目前只有一个随机选取的策略。</p>
<p>这个 Connection 连接实例会保存在 BoltClientTransport 中。</p>
<p>在客户端进行调用的时候， RpcClient 会根据 URL 找到对应的连接，然后，获取这个连接对应的 Channel ，向服务端发送数据。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">conn.getChannel().writeAndFlush(request).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!f.isSuccess()) &#123;</span><br><span class="line">            conn.removeInvokeFuture(request.getId());</span><br><span class="line">            future.putResponse(commandFactory.createSendFailedResponse(</span><br><span class="line">                conn.getRemoteAddress(), f.cause()));</span><br><span class="line">            logger.error(<span class="string">&quot;Invoke send failed, id=&#123;&#125;&quot;</span>, request.getId(), f.cause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上，就是 SOFA 的连接的原理和设计。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>连接管理器是我们分析 SOFA—RPC  Cluster 中的最后一个模块，他管理着一个客户端对应的所有服务网络连接。</p>
<p>connectionHolder 内部包含多个 Map，Map 中的 key 是 Provider，value 是 ClientTransport，ClientTransport 是 RpcClient 和 SOFA 的胶水类，通常一个 Provider 对应一个 ClientTransport。ClientTransport 其实就是一个连接的包装。</p>
<p>ClientTransport 获取连接的方式则是通过 RpcClient 的 连接管理器获取的。该连接管理器内部包含一个连接工厂，会根据 URL 创建连接。创建连接的凡是则是通过 Netty 的 BootStrap 来创建。</p>
<p>当我们使用  Provider 对应的 ClientTransport 中的 RpcClient 发送数据的时候，则会根据 URL 找到对应 Connection，并获取他的 Channel ，向服务端发送数据。</p>
<p>好了，以上就是 SOFA—RPC 连接管理的分析。</p>
<p>篇幅有限，如有错误，还请指正。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-—-泛化调用</title>
    <url>/2018/05/09/2018/2018-05-09-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94-%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>通常 RPC 调用需要客户端使用服务端提供的接口，而具体的形式则是使用 jar 包，通过引用 jar 包获取接口的的具体信息，例如接口名称，方法名称，参数类型，返回值类型。</p>
<p>但也存在一些情况，例如客户端没有 jar 包，或者是跨语言的调用，这个时候，就需要客户端使用字符串进行泛化调用。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>还是根据官方的例子来看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsumerConfig&lt;GenericService&gt; consumerConfig = <span class="keyword">new</span> ConsumerConfig&lt;GenericService&gt;()</span><br><span class="line">           .setInterfaceId(<span class="string">&quot;com.alipay.sofa.rpc.quickstart.HelloService&quot;</span>)</span><br><span class="line">           .setGeneric(<span class="keyword">true</span>);</span><br><span class="line">GenericService testService = consumerConfig.refer();</span><br><span class="line"></span><br><span class="line">String result = (String) testService.$invoke(<span class="string">&quot;sayHello&quot;</span>, <span class="keyword">new</span> String[] &#123; <span class="string">&quot;java.lang.String&quot;</span> &#125;,<span class="keyword">new</span> Object[] &#123; <span class="string">&quot;1111&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>我们看到，实际上，设置接口 ID 是和普通的调用时类似的，只是需要增加一个 Generic 属性为 true。</p>
<p>然后就返回了一个 GenericService 类型的代理对象，通过这个对象，就可以对服务发起调用，而调用的方式，则是使用 GenericService 的 $invoke 方法，需要传递方法名称，参数类型，参数值。并指定返回值。</p>
<p>SOFA 是如何实现的呢？</p>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>既然和普通的调用只是变化了 Generic 属性，那么，我们就看看这个属性在哪些地方使用。</p>
<p>我们很快便找到了一个过滤器: ConsumerGenericFilter，该过滤器的生效条件则是 “客户端是否配置了泛型”。如果设置泛型，则添加到过滤链中。</p>
<p>而该过滤器的 invoke 方法肯定是对调用进行了一些特殊的操作，具体如下：</p>
<ol>
<li><strong>根据方法名称得到序列化的类型</strong>，例如普通序列化，泛型序列化，混合序列化。我们这里的例子返回的值是 0(普通序列化)，然后设置序列化工厂类型，即普通序列化（根据方法名不同而不同）。</li>
<li>从  Request 对象中拿到方法名称，参数类型的字符串，方法参数。并重新设置到 Request 对象中，相当于重新整理了一遍。</li>
<li>然后根据刚刚设置的方法名重新设置调用类型。</li>
</ol>
<p>这样就将泛型的调用修改成和普通调用一样了。<br>同时注意：发起调用时，该过滤器的默认 order 是 -18000，因此他会在大部分（除了异常处理和上下文）之前执行。</p>
<p>在使用 Bolt 的 RpcClient 进行调用的时候，会根据序列化类型决定是否进行泛型的序列化。</p>
<p>具体过程是，当调用时，会创建 InvokeContext 上下文，会在 Map 中存储自定义的序列化器，其中 key 是 <code>SerializeFactoryType</code>，value 是 <code>0</code>（我们这里），在 RpcRemoting 的 invokeXXX 方法中，会创建一个  RemotingCommand 对象，即执行 <code>toRemotingCommand</code> 方法，根据 InvokeContext 中的 <code>SerializeFactoryType</code> 获取到序列化工厂的枚举值，并设置到 RemotingCommand 对象中。</p>
<p>在 SofaRpcSerialization 类中，会根据 invokeContext 中存储的序列化枚举值得到序列化器，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据SerializeType信息决定序列化器</span></span><br><span class="line"><span class="keyword">boolean</span> genericSerialize = genericSerializeRequest(invokeContext);</span><br><span class="line"><span class="keyword">if</span> (genericSerialize) &#123;</span><br><span class="line">    output.setSerializerFactory(genericSerializerFactory);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    output.setSerializerFactory(serializerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据SerializeType信息决定序列化器。而泛型的具体序列化器工厂则是 GenericMultipleClassLoaderSofaSerializerFactory 类，该类的会生成序列化器和反序列化器。并在 Bolt 中使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从 SOFA 的设计中可以看出，泛化调用主要依赖于 GenericService 这个类和对应的 ConsumerGenericFilter 过滤器，如果一个客户端设置泛化了，那么调用过程中则会启用这个过滤器。</p>
<p>这个过滤器会将请求的数据重新整理。并修改成普通调用的样子。</p>
<p>同时也会设置一个泛型调用的序列化枚举放置在上下文中，上下文在 Bolt 中会根据枚举值动态获取不同的序列化器和反序列化器，对输出参数和返回值经进行处理。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>Spring-声明式事务（二）——传播属性</title>
    <url>/2018/05/14/2018/2018-05-14-Spring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>众所周知，Spring 的事务属性众多，楼主今天将对 Spring 最常用的事务 —— 声明式事务，进行彻底的解释，包括楼主也写了很多的测试例子。代码地址: <a href="https://github.com/stateIs0/Transactional">使用 tk-mybatis 的 demo 测试了 Spring 的事务</a></p>
<h2 id="传播属性"><a href="#传播属性" class="headerlink" title="传播属性"></a>传播属性</h2><p>传播属性相对隔离属性，使用的较少，类型也较多。同时有些概念也必将繁杂，难以定义，楼主也是写了很多的测试代码，才得出一些结论。</p>
<p>Spring 事务中有 7 个传播属性：</p>
<ol>
<li>PROPAGATION_REQUIRED</li>
<li>PROPAGATION_SUPPORTS</li>
<li>PROPAGATION_MANDATORY</li>
<li>PROPAGATION_REQUIRES_NEW</li>
<li>PROPAGATION_NOT_SUPPORTED</li>
<li>PROPAGATION_NEVER</li>
<li>PROPAGATION_NESTED</li>
</ol>
<p>一张表格搞定：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7b505395fbac1215.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这张表格是楼主测试了无数遍得来的，大家可以用楼主代码的例子跑跑看。</p>
<p>总之，默认的 Required 足够使用了。所有事务的嵌套都符合定义。</p>
<p>接口与接口之间的事务嵌套使用默认的不会影响业务逻辑。</p>
<p>但注意，由于动态代理的特殊性，如果接口内部的事务方法嵌套，将会导致内层的事务失效，因为它已经不在 Spring 的管理范围之内了。</p>
<p>当然，这张表格可能测的范围还不是百分百的足够，但已经可以理解传播的作用了。如果有兴趣，可以在例子中加入测试代码。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA-源码分析-—-调用方式</title>
    <url>/2018/05/09/2018/2018-05-09-SOFA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E2%80%94-%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>SOFARPC 提供了多种调用方式满足不同的场景。 </p>
<p>例如，同步阻塞调用；异步 future 调用，Callback 回调调用，Oneway 调用。</p>
<p>每种调用模式都有对应的场景。类似于单进程中的调用模式。在单进程中，我们可以使用 JDK 的 Future 实现异步，可以通过观察者实现回调。</p>
<p>那么，在 RPC 框架中，这些功能如何实现呢？</p>
<p>我们一个个开始看。</p>
<h2 id="同步调用-Sync"><a href="#同步调用-Sync" class="headerlink" title="同步调用 Sync"></a>同步调用 Sync</h2><p>每个 ConsumerConfig 都有一个 invokeType 属性，在 SOFA 中，对应的常量是 <code>RpcConstants.INVOKER_TYPE_SYNC</code>。</p>
<p>直接受到这个属性影响的是 AbstractCluster 的 doSendMsg 方法。该方法会从 request 中取出 invokeType 属性，而这个值是什么时候设置进入这个 request 的呢？在 DefaultClientProxyInvoker 类中的  decorateRequest 方法里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!consumerConfig.isGeneric()) &#123;</span><br><span class="line">    <span class="comment">// 找到调用类型， generic的时候类型在filter里进行判断</span></span><br><span class="line">    request.setInvokeType(consumerConfig.getMethodInvokeType(request.getMethodName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里判断，如果不是泛型调用，则将 config 中的值设置到 request 中。</p>
<p>回到 DefaultClientProxyInvoker 中，如果是同步调用（默认），则调用 ClientTransport 的 syncSend 方法，并等待一个 response。通过层层调用，最终会来到 BaseRemoting 类的 invokeSync 方法。</p>
<p>该方法会创建一个 Future ，并将这个 Future 放到 Connection（和 Channel 是一对一的关系） 的里一个 Map 中，key 是一个 id， value 则是  Future，然后发送数据给服务器，当 Channel 收到服务器返回的数据时，会重 Channle 中取出对应的 Channel 中的  Connection 对象，然后取出 Connection 对象中对应 key 的 Future，这个 Key 来自服务端传递过来的，类似于 cookie。</p>
<p>很明显，这么做能很大的提高xiaolv，例如，客户端并发使用同一个 Channel 向服务端发送数据，客户端不用串行等待数据的返回，实际上，对于 Bolt 来说，调用是异步的，每次用户调用都会传递一个 Future，Channel 发送数据完之后，不必等待数据返回，而是继续发送数据，当 Channel 收到服务端返回的数据后，便从 Channel 中取出对应的 Future（服务端传递来的 ID 标识），完成 Future 的唤醒。</p>
<p>而对于用户来说，看起来是同步的，因为 Future 会阻塞等待结果，类似 JDK 的 Future。只是用户感知不到而已，在等待的过程中，Channel 或者说 Connection 一直在工作，例如发送数据，例如处理别的 Future 发送来的数据。</p>
<p>而整个网络层的效率也是非常的高，不涉及任何的业务操作，写出数据是异步的，拿到数据，只需唤醒等待的线程即可。</p>
<p>总结一下，整个同步调用的过程是：客户端发送数据的时候，会创建一个 Future，并将这个 Future 放进到 Connection 的 Map 中，key 为 Future ID，value 是 Future（一个 Connection 绑定一个  Channel），然后异步向服务端发送数据，发送完毕后 Channel 又会立即响应其他的调用。当 Channel 收到服务端的响应数据，Channle 会取出 Connection ，找到对应 ID 的 Future ，这个 ID 就是服务端和客户端的约定。找到 Future 后，便将返回值注入到 Future 的 result 中，然后唤醒阻塞等待返回值的线程。</p>
<h2 id="异步调用-Future"><a href="#异步调用-Future" class="headerlink" title="异步调用 Future"></a>异步调用 Future</h2><p>异步调用的 invokeType 对应的常量是 <code>RpcConstants.INVOKER_TYPE_FUTURE</code>，异步调用会立即返回一个 Future，然后通过 get 方法阻塞等待返回值。使用方式是：<code>BoltResponseFuture future1 = (BoltResponseFuture) SofaResponseFuture.getFuture();</code></p>
<p>具体源码在 AbstractCluster 类的 doSendMsg 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RpcConstants.INVOKER_TYPE_FUTURE.equals(invokeType)) &#123;</span><br><span class="line">    <span class="comment">// 开始调用</span></span><br><span class="line">    ResponseFuture future = transport.asyncSend(request, timeout);</span><br><span class="line">    <span class="comment">// 放入线程上下文</span></span><br><span class="line">    RpcInternalContext.getContext().setFuture(future);</span><br><span class="line">    response = <span class="keyword">new</span> SofaResponse();</span><br></pre></td></tr></table></figure>

<p>当 Bolt 返回一个 Future 后，将其设置到 ThreadLocal 中，然后返回一个空的 response。用户在使用 SofaResponseFuture 获取 Future 的时候，其实就是从 RpcInvokeContext 中获取。可以看出，不是一个上下文，这里 RpcInvokeContext  是面向业务开发者使用的，而 RpcInternalContext 则是框架使用的。在 DefaultClientProxyInvoker 的 decorateResponse 方法中，会进行上下文转换，将框架内部上下文的数据复制到业务上下文中。</p>
<p>关键在于异步调用，在 BoltClientTransport 的 doInvokeAsync 方法中，会根据是否含有监听器判断是异步还是回调，如果没有监听器，则是异步 Future 模式，而如果是异步的话，就会转成回调模式（因为实现类似）。</p>
<p>具体实现则是创建一个 BoltFutureInvokeCallback 对象，该对象内部有一个 onResponse 方法，该方法会在任务完成之后回调。同时也会创建一个 BoltResponseFuture 对象，该对象会有 setXXX 方法，在 Callback 的 onResponse 方法中会调用 setXXX 方法，进行结果赋值和唤醒。</p>
<p>onResponse 会由一个 RpcInvokeCallbackListener 对象唤醒，在他的内部类 CallbackTask 的 run 方法中，会异步回调这个方法。</p>
<p>而这个对象的创建时机在 BaseRemoting 的 invokeWithCallback 方法的第一行：调用 createInvokeFuture 方法。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> InvokeFuture <span class="title">createInvokeFuture</span><span class="params">(Connection conn, RemotingCommand request, InvokeContext invokeContext, InvokeCallback invokeCallback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultInvokeFuture(</span><br><span class="line">	    request.getId(), </span><br><span class="line">	    <span class="keyword">new</span> RpcInvokeCallbackListener( RemotingUtil.parseRemoteAddress(conn.getChannel())), </span><br><span class="line">	    invokeCallback, </span><br><span class="line">	    request.getProtocolCode().getFirstByte(), </span><br><span class="line">        <span class="keyword">this</span>.getCommandFactory(), </span><br><span class="line">        invokeContext);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>在 RpcResponseProcessor 类中，在 doProcess 方法收到数据之后，会调用 future 的 executeInvokeCallback 方法。和同步方式不同的是，虽然都是一个 InvokeFuture 实现，同步只会调用 putResponse 赋值并唤醒。</p>
<p>而  Future 的模式则要复杂的多，该方法会执行监听器（RpcInvokeCallbackListener）的 onResponse 方法，并传递自己。 而在监听器的 onResponse 方法中，会创建一个任务，异步执行 Future 中的任务。</p>
<p>我们当前的 Future 任务则是拿到返回值，并唤醒阻塞线程。</p>
<p>整体依赖和流程大概如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c46a87332e6472f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>总结一下异步调用的过程：异步调用在 SOFA 内部包装成了回调的方式，使用一个 Callback 封装了  面向用户的 ResponsFuture, 再使用一个监听器封装 Callback,  监听器监听 InvokeFuture ，当 InvokeFuture 响应服务器的时候，会回调监听器，监听器再回调 Callback，Callback 再唤醒 ResponseFuture，用户就可以得到数据了。</p>
<h2 id="单向-oneWay"><a href="#单向-oneWay" class="headerlink" title="单向 oneWay"></a>单向 oneWay</h2><p>单向的使用一般是不关心结果的，使用方式则是很简单的将 invokeType 设置成 <code>RpcConstants.INVOKER_TYPE_ONEWAY</code>，。</p>
<p>SOFA 内部的区别处理也在 AbstractCluster 类的 doSendMsg 方法中，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单向调用</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RpcConstants.INVOKER_TYPE_ONEWAY.equals(invokeType)) &#123;</span><br><span class="line">    <span class="keyword">long</span> start = RpcRuntimeContext.now();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        transport.oneWaySend(request, timeout);</span><br><span class="line">        response = <span class="keyword">new</span> SofaResponse();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (RpcInternalContext.isAttachmentEnable()) &#123;</span><br><span class="line">            <span class="keyword">long</span> elapsed = RpcRuntimeContext.now() - start;</span><br><span class="line">            context.setAttachment(RpcConstants.INTERNAL_KEY_CLIENT_ELAPSE, elapsed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中，可以看到，这里只是返回了一个空的对象。</p>
<p>而在 Bolt 中的实现也非常的简单，仅仅是调用了 Channel 的 writeAndFlush 方法，只有在失败的时候，才会由响应，成功是没有任何响应的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">oneway</span><span class="params">(<span class="keyword">final</span> Connection conn, <span class="keyword">final</span> RemotingCommand request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn.getChannel().writeAndFlush(request).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!f.isSuccess()) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;Invoke send failed. The address is &#123;&#125;&quot;</span>,</span><br><span class="line">                        RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == conn) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Conn is null&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Exception caught when sending invocation. The address is &#123;&#125;&quot;</span>,</span><br><span class="line">                RemotingUtil.parseRemoteAddress(conn.getChannel()), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>单向调用就是这么简单。所以，如果你试图获取返回值，那么得到的永远是 Nnll。</p>
<h2 id="回调-Callback"><a href="#回调-Callback" class="headerlink" title="回调 Callback"></a>回调 Callback</h2><p>在 SOFA 中， 有 3 种回调级别，目的是应用各种不同的场景。</p>
<ol>
<li>接口级别，即调用这个接口的所有方法，都会引发回调。</li>
<li>方法级别，针对某个方法，会引发回调。</li>
<li>调用级别，某次调用，会引发回调。</li>
</ol>
<h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><ol>
<li>接口级别：只需要设置 ConsumerConfig 的 onReturn 方法即可。例如下面这样，子类实现 SofaResponseCallback 即可：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SofaResponseCallback sofaResponseCallbackImpl = <span class="keyword">new</span> SofaResponseCallbackImpl();</span><br><span class="line"></span><br><span class="line">ConsumerConfig&lt;HelloService&gt; consumer = <span class="keyword">new</span> ConsumerConfig&lt;HelloService&gt;()</span><br><span class="line">            .setInterfaceId(HelloService.class.getName())</span><br><span class="line">            .setInvokeType(RpcConstants.INVOKER_TYPE_CALLBACK)</span><br><span class="line">            .setOnReturn(sofaResponseCallbackImpl)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法级别：需要单独创建一个 MethodConfig，然后设置到 ConsumerConfig 的 Methods 属性中：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SofaResponseCallback sofaResponseCallbackImpl = <span class="keyword">new</span> SofaResponseCallbackImpl();</span><br><span class="line"></span><br><span class="line">MethodConfig methodConfig = <span class="keyword">new</span> MethodConfig();</span><br><span class="line">methodConfig.setName(<span class="string">&quot;sayHello&quot;</span>)</span><br><span class="line">            .setInvokeType(RpcConstants.INVOKER_TYPE_CALLBACK)</span><br><span class="line">            .setOnReturn(sofaResponseCallbackImpl );</span><br><span class="line"></span><br><span class="line">ConsumerConfig&lt;HelloService&gt; consumerConfig = <span class="keyword">new</span> ConsumerConfig&lt;HelloService&gt;()</span><br><span class="line">            .setApplication(applicationConfig)</span><br><span class="line">            .setInterfaceId(HelloService.class.getName())</span><br><span class="line">            .setTimeout(<span class="number">5000</span>)</span><br><span class="line">            .setMethods(Collections.singletonList(methodConfig))</span><br><span class="line">            .setDirectUrl(<span class="string">&quot;bolt://127.0.0.1:22222?appName=future-server&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>只需要像上面一样，设置 sayHello 方法的回调实现，然后将方法配置设置到 ConsumerConfig 中。就可以在每次调用该方法时，引发回调。</p>
<ol start="3">
<li>调用级别：他的优先级最高，每次调用都会引发回调。使用方式如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SofaResponseCallback sofaResponseCallbackImpl = <span class="keyword">new</span> SofaResponseCallbackImpl();</span><br><span class="line"></span><br><span class="line">RpcInvokeContext.getContext().setResponseCallback(sofaResponseCallbackImpl);</span><br></pre></td></tr></table></figure>

<p>可以看出，通过在上下文的设置，就能生效，每次调用都会引发回调。</p>
<p>知道了如何使用，再来看看如何实现。</p>
<h5 id="源码分析回调"><a href="#源码分析回调" class="headerlink" title="源码分析回调"></a>源码分析回调</h5><p>主要逻辑还是在 AbstractCluster 的 doSendMsg 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Callback调用</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RpcConstants.INVOKER_TYPE_CALLBACK.equals(invokeType)) &#123;</span><br><span class="line">    <span class="comment">// 调用级别回调监听器</span></span><br><span class="line">    SofaResponseCallback sofaResponseCallback = request.getSofaResponseCallback();</span><br><span class="line">    <span class="keyword">if</span> (sofaResponseCallback == <span class="keyword">null</span>) &#123;</span><br><span class="line">        SofaResponseCallback methodResponseCallback = consumerConfig</span><br><span class="line">            .getMethodOnreturn(request.getMethodName());</span><br><span class="line">        <span class="keyword">if</span> (methodResponseCallback != <span class="keyword">null</span>) &#123; <span class="comment">// 方法的Callback</span></span><br><span class="line">            request.setSofaResponseCallback(methodResponseCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    transport.asyncSend(request, timeout);</span><br><span class="line">    response = <span class="keyword">new</span> SofaResponse();</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>从源码中，可以看出，优先使用调用级别的回调，如果没有，才寻找方法级别的回调。而接口级别的回调则是默认机制。</p>
<p>因此，他们的优先级排序为 调用级别 —&gt; 方法级别 —-&gt; 回调级别。</p>
<p>request 中的回调设置在 DefaultClientProxyInvoker 的 decorateRequest 方法中，即装饰 request，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RpcInvokeContext invokeCtx = RpcInvokeContext.peekContext();</span><br><span class="line">RpcInternalContext internalContext = RpcInternalContext.getContext();</span><br><span class="line"><span class="keyword">if</span> (invokeCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果用户设置了调用级别回调函数</span></span><br><span class="line">    SofaResponseCallback responseCallback = invokeCtx.getResponseCallback();</span><br><span class="line">    <span class="keyword">if</span> (responseCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.setSofaResponseCallback(responseCallback);</span><br><span class="line">        invokeCtx.setResponseCallback(<span class="keyword">null</span>); <span class="comment">// 一次性用完</span></span><br><span class="line">        invokeCtx.put(RemotingConstants.INVOKE_CTX_IS_ASYNC_CHAIN,</span><br><span class="line">            isSendableResponseCallback(responseCallback));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从 RpcInvokeContext  复制到 request 中。且用完之后，立即删除，这点需要注意！！也就是说，仅仅使用一次。</p>
<p>那么 consumerConfig.getMethodOnreturn（）方法会根据方法名获取到一个回调对对象，如何实现呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到方法名对应的自定义参数列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName 方法名，不支持重载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> method onReturn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SofaResponseCallback <span class="title">getMethodOnreturn</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (SofaResponseCallback) getMethodConfigValue(methodName, RpcConstants.CONFIG_KEY_ONRETURN,</span><br><span class="line">        getOnReturn());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到方法级配置，找不到则返回默认值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName   方法名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configKey    配置key，例如参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValue 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 配置值 method config value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getMethodConfigValue</span><span class="params">(String methodName, String configKey, Object defaultValue)</span> </span>&#123;</span><br><span class="line">    Object value = getMethodConfigValue(methodName, configKey);</span><br><span class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? defaultValue : value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SofaResponseCallback <span class="title">getOnReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> onReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到方法级配置，找不到则返回null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName 方法名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configKey  配置key，例如参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 配置值 method config value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getMethodConfigValue</span><span class="params">(String methodName, String configKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configValueCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String key = buildmkey(methodName, configKey);</span><br><span class="line">    <span class="keyword">return</span> configValueCache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是获取方法级回调的实现。</p>
<p>通过获取 configValueCache 的值，如果没有，则使用接口级别的回调设置。即默认值。那么，我们好像没有设置过这个 configValueCache 的值，从哪里来的呢？</p>
<p>在 AbstractInterfaceConfig 的 getConfigValueCache 方法中，我们能够看到从 methods Map 中转移数据到 configValueCache 中。而这个方法的调用时机则是 FilterInvoker 的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">FilterInvoker</span><span class="params">(AbstractInterfaceConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.configContext = config.getConfigValueCache(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>具体转移代码入下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Map&lt;String, Object&gt; <span class="title">getConfigValueCache</span><span class="params">(<span class="keyword">boolean</span> rebuild)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configValueCache != <span class="keyword">null</span> &amp;&amp; !rebuild) &#123;</span><br><span class="line">        <span class="keyword">return</span> configValueCache;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; context = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">32</span>);</span><br><span class="line">    Map&lt;String, String&gt; providerParams = getParameters();</span><br><span class="line">    <span class="keyword">if</span> (providerParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.putAll(providerParams); <span class="comment">// 复制接口的自定义参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, MethodConfig&gt; methodConfigs = getMethods();</span><br><span class="line">    <span class="keyword">if</span> (CommonUtils.isNotEmpty(methodConfigs)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MethodConfig methodConfig : methodConfigs.values()) &#123;</span><br><span class="line">            String prefix = RpcConstants.HIDE_KEY_PREFIX + methodConfig.getName() + RpcConstants.HIDE_KEY_PREFIX;</span><br><span class="line">            Map&lt;String, String&gt; methodparam = methodConfig.getParameters();</span><br><span class="line">            <span class="keyword">if</span> (methodparam != <span class="keyword">null</span>) &#123; <span class="comment">// 复制方法级自定义参数</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : methodparam.entrySet()) &#123;</span><br><span class="line">                    context.put(prefix + entry.getKey(), entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 复制方法级参数属性</span></span><br><span class="line">            BeanUtils.copyPropertiesToMap(methodConfig, prefix, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制接口级参数属性</span></span><br><span class="line">    BeanUtils.copyPropertiesToMap(<span class="keyword">this</span>, StringUtils.EMPTY, context);</span><br><span class="line">    configValueCache = Collections.unmodifiableMap(context);</span><br><span class="line">    <span class="keyword">return</span> configValueCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 configValueCache 没有初始化或者需要重建，则执行下面的逻辑，首先拿到 methods Map，然后 for 循环到 configValueCache Map 中。</p>
<p>那么如何使用呢？</p>
<p>注意，此时 ，Cluster 的 doSendMsg 方法中，request 已经有回调对象了，注意，回调 Callback 和 Future 调用的是同一个方法，即 transport.asyncSend(request, timeout);</p>
<p>在 BoltClientTransport 的 doInvokeAsync 方法中，会判断 request 中，是否含有回调，如果有，则执行回调逻辑，如果没有，则将 Future 转成回调。</p>
<p>而回调的逻辑是，根据监听器等属性创建一个 BoltInvokerCallback 对象包装  SofaResponseCallback 对象，然后，再创建一个 RpcInvokeCallbackListener 对象包装他，再创建一个 InvokeFuture 包装监听器  发起 RPC 调用。</p>
<p>InvokeFuture  会在 RpcResponseProcessor 类的 doProcess 方法被回调，这点逻辑和异步 Future 的逻辑类似。回调他的 putResponse 方法和 executeInvokeCallback 方法。</p>
<p>然后，在 executeInvokeCallback 方法中，则调用 RpcInvokeCallbackListener 的 onResponse 方法。</p>
<p>RpcInvokeCallbackListener 则创建一个 CallbackTask 任务，提交给线程池，任务内容是执行 BoltInvokerCallback  的 onResponse 方法。</p>
<p>BoltInvokerCallback 则会调用 SofaResponseCallback 的 的 onAppXXXX 方法。完成最终用户的调用。</p>
<p>整体设计图和流程图和异步 Future 类似（内部是 Callback 实现）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-fd9b6b5a0d8ea83d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>可以看到，和异步 Future 唯一不同的就是面向用户的 API 不同和内部一个 Callback 不同。<br>异步 Future 面向用户的 API 是 BoltResponseFuture 。<br>回调 Callback 面向用户的是 SofaResponseCallback。</p>
<p>但内部的原理都是一样的。都是使用  RpcInvokeCallbackListener  和 DefaultInvokeFuture 回调实现。</p>
<p>DefaultInvokeFuture 设置在 Channel 中，当收到返回值后，便调用他的方法，接着完成这个链式返回，直到调用用户设置的 API。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们分析了 SOFA 的调用 API，包括同步，异步 Future，回调 Callback，单向 oneWay。</p>
<p>其中单向实现最简单，同步也比较简单。</p>
<p>异步的内部实现和回调的内部实现完全一样，只是展示给用户的 API 不同。都是通过观察者模式实现的。</p>
<p>我们思考一下： 为什么要使用这么多层次包装呢?</p>
<p>首先 InvokeFuture 和 RpcInvokeCallbackListener 是面向网络层的。也就是 Bolt 内部的接口。</p>
<p>他们对于 SOFA—RPC 来讲，是统一的。</p>
<p>而 SOFA 对于异步和回调则使用了不同的 API：<br>异步使用了 BoltResponseFuture 和 BoltFutureInovkeCallback。<br>回调使用 SofaResponseCallback 和 BoltInvokerCallback。</p>
<p>为什么在 Bolt 层和用户层需要再加 InvokeCallback 这一层呢？</p>
<p>InvokeCallback 这一层可以将用户层和网络层很好的解耦，如果网络层发生变化，那么，只需要变动中间层就可以了，用户层不会受到影响。</p>
<p>好了，今天就到这里。bye！</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>使用并发工具实现-RPC-调用流量控制</title>
    <url>/2018/05/14/2018/2018-05-14-%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0-RPC-%E8%B0%83%E7%94%A8%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>RPC 服务中，每个服务的容量都是有限的，即资源有限，只能承受住给定的网络请求，所以，在设计 RPC 框架的时候，一定要考虑流量控制这个问题。而 Java 中，实现流量控制有很多中方式，今天说 2 种。</p>
<h2 id="Semaphore-实现流控"><a href="#Semaphore-实现流控" class="headerlink" title="Semaphore 实现流控"></a>Semaphore 实现流控</h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Executor timeTask = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">  ((ScheduledExecutorService) timeTask).scheduleAtFixedRate(</span><br><span class="line">      () -&gt; semaphore.release(<span class="number">100</span> - semaphore.availablePermits()), <span class="number">1000</span>, <span class="number">1000</span>,</span><br><span class="line">      TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">  Executor pool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (semaphore.tryAcquire()) &#123;</span><br><span class="line">            callRpc(num, j);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;call fail&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callRpc</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  System.out.println(String.format(<span class="string">&quot;%s - %s: %d %d&quot;</span>, <span class="keyword">new</span> Date(), Thread.currentThread(), num, j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，我们模拟了 100 个线程，每个线程无限调用 RPC。</p>
<p>同时使用另一个定时任务，定时更新 Semaphore 可用许可为 100。</p>
<p>客户端线程调用时，会尝试获取信号量，当获取成功时，才会调用调用 RPC，反之，打印失败。</p>
<p>这个小程序实现了每秒钟限制 100 个请求的 RPC 的流量控制。</p>
<h2 id="AtomicInteger-实现流控"><a href="#AtomicInteger-实现流控" class="headerlink" title="AtomicInteger 实现流控"></a>AtomicInteger 实现流控</h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Executor timeTask = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">  ((ScheduledExecutorService) timeTask).scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      count.getAndSet(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">  Executor pool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (count.get() &gt;= <span class="number">0</span>) &#123;<span class="comment">// 快速判断，否则大量的 CAS 操作将会定时任务更新计数器 count</span></span><br><span class="line">            <span class="keyword">if</span> (count.decrementAndGet() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              callRpc(num, j);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callRpc</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  System.out.println(String.format(<span class="string">&quot;%s - %s: %d %d&quot;</span>, <span class="keyword">new</span> Date(), Thread.currentThread(), num, j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和上面的类似，只是使用的 API 不同，这里使用的是 CAS。通过对 CAS 递减，达到流控的目的。</p>
<p>注意，这里有一个双重判断，先判断 count.get() &gt;= 0，为什么呢？</p>
<p>如果直接使用 decrementAndGet 方法，则会使用 CAS，100 个线程并发使用 CAS ，将会导致定时任务的 CAS 操作不够及时。</p>
<p>所以，先判断，是否小于0 ，如果小于0了，就不必尝试 CAS，避免影响定时任务。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程-——-谈谈线程中断</title>
    <url>/2018/05/15/2018/2018-05-15-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E2%80%94%E2%80%94-%E8%B0%88%E8%B0%88%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->## 前言

<p>如何中断一个线程，肯定不会使用 stop。而是使用 interrupt 方法。同时，我们知道，中断一个线程只是打个标志位。不会真的中断线程，但，如果线程是阻塞状态的呢？</p>
<p>而 Java 中，想要阻塞一个线程有很多种方式。</p>
<ol>
<li>synchronized</li>
<li>Object.wait()</li>
<li>Lock</li>
<li>Condition.await()</li>
<li>LockSupport.park()</li>
<li>Thread.join（）</li>
</ol>
<p>当然上面都是很简单的说说，API 并不是那么的详细。像 Lock 的 api 就有响应中断的。<br>还有 Thread.sleep()。这个大家都知道，肯定是响应中断的。</p>
<p>下面就来解决我们的问题。</p>
<h2 id="解开迷雾"><a href="#解开迷雾" class="headerlink" title="解开迷雾"></a>解开迷雾</h2><p>仔细分析一下，中断其实有 2 种状态，运行时中断，阻塞时中断。</p>
<p>顾名思义，运行时中断指的是线程运行时，我们中断他，当然，这个对线程毫无影响，只能通过标志位来判断。</p>
<p>而阻塞时中断就分为 2 种。一种是在等待锁的时候中断，一种是进入锁的时候，wait 的时候中断。</p>
<p>例如一个 synchronized 同步块，当多线程访问同步块时，同步块外的就是等待锁的状态。进入锁了，执行 wait 方法，也是阻塞的状态。</p>
<p>虽然都是阻塞的状态，但这两种阻塞状态是不同的。</p>
<p>基于前言中的阻塞方式，我们一个个来分析。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-172602219fb3fbf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>非 Lock 接口，即 synchronized 和 Object 还有 Thread 的相关方法，除了 synchronized 不会响应中断，其他的都会响应中断并抛出异常。</p>
<p>Lock 接口，无论是使用 lock 系列方法，还是 Condition 的 await 系列方法，都可随心所欲，想使用什么模式，就使用什么模式。在日常的开发，这个特性还是非常有用的。</p>
<p>相比而言，Lock 相关的接口更加的灵活，对于线程中断的响应和处理可自行设置，而非 Lock 接口则需要了解他们的中断特性. </p>
<p><strong>例如 sleep 方法和 wait 方法则会清除中断状态。</strong></p>
<p><strong>Lock 系列方法抛出异常后，也是会清除中断状态的。</strong></p>
<p>Lock 清除中断状态的手段则是 Thread.interrupted 方法。</p>
<p>为什么要清除中断状态呢？如果下次有线程再次中断，此时便可以判断。</p>
<p><strong>有点需要注意，Thread.interrupted 静态方法和 Thraed#isInterrupted() 成员方法的区别</strong></p>
<p>他们都是调用的 Thread 类的 <code>private native boolean isInterrupted(boolean ClearInterrupted)</code> 方法。</p>
<p>这个方法有个布尔参数，true 是清除中断状态，false 则不清除。使用的时候需要注意。</p>
<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>线程池的 shutDown 和 shutDownNow 方法是通过设置线程的中断来停止线程的。</p>
<p>shutDown 必须等待任务执行完毕，才会执行线程池线程的 interrupt 方法。<br>shutDownNow 则不会，直接执行 interrupt 方法。</p>
<p>所以，当你执行一个 shutDown 方法的时候，必须等待任务执行完毕才能设置中断状态。你代码中设置的那些响应中断方法是起不到作用的。真正起作用的，是线程池内部设置的状态变量。设置中断的目的则是打断阻塞在队列上的线程。</p>
<p>当你执行 shutDownNow 方法的时候，线程池会执行所有活动线程的 interrupt 方法，如果你的任务中恰好有以上的那些 响应中断 的方法。那么，就可以立即中断线程。如果没有，老实等待任务执行结束。</p>
<h2 id="有趣的事情"><a href="#有趣的事情" class="headerlink" title="有趣的事情"></a>有趣的事情</h2><p>线程池的 Worker 初始化的时候，会将 AQS 的 state 变量设置为 -1 ，防止用户执行 shutDown 方法试图停止线程。当将要执行真正的任务的时候，会将这个 AQS 变量设置为 0，这个时候，用户执行 shutDwon 方法才有效。那么 shutDownNow 方法呢？同样的，也判断了 state 变量必须大于等于 0 才能执行 interrupt 方法。保证线程池整体的状态安全。</p>
<p>其实，这篇文章还是有点杂乱，东西有点多。但总体还是围绕线程中断来讲的。</p>
<p>熟悉这些 API 的使用，对于并发编程来说，还是非常重要的。</p>
<h2 id="再次总结"><a href="#再次总结" class="headerlink" title="再次总结"></a>再次总结</h2><p>本文说了哪些东西：</p>
<ol>
<li>Java 中同步和锁相关的 API 哪些可响应中断，哪些不可响应中断。总结下来就是 Lock 更灵活的对待中断。</li>
<li>Thread 类的两个判断中断的方法，静态方法会清除中断状态，成员方法则不会。</li>
<li>线程池的 shutDownNow 方法会根据任务中是否有响应中断的 API 来决定是否立即中断任务，如果有，则立即中断，反之，等待任务完成。</li>
<li>线程池有趣的现象：Worker 初始化的时候，有一个变量设置成 -1 ，防止初始化的时候，用户调用 shutDown 和 shutDownNow 方法。</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>Spring-声明式事务（三）——其余属性</title>
    <url>/2018/05/14/2018/2018-05-14-Spring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%85%B6%E4%BD%99%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>众所周知，Spring 的事务属性众多，楼主今天将对 Spring 最常用的事务 —— 声明式事务，进行彻底的解释，包括楼主也写了很多的测试例子。代码地址: <a href="https://github.com/stateIs0/Transactional">使用 tk-mybatis 的 demo 测试了 Spring 的事务</a></p>
<h2 id="readOnly-属性"><a href="#readOnly-属性" class="headerlink" title="readOnly 属性"></a>readOnly 属性</h2><p>该属性的文档中说道：这不是一个百分百限制读操作之外的属性。</p>
<p>什么意思呢？虽然从字面意思看，是只读，但具体看数据库的实现。</p>
<p>mysql 数据库中，如果设置了这个属性，那么驱动将返回一个异常。<br>oracle 和 sqlServer 则不会，他们会忽略错误。</p>
<p>因此，在不同的数据库下使用要注意这点。</p>
<h2 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h2><p>该属性单位是秒，不是毫秒。</p>
<p>从字面上看，是定义这个事务的超时时间。</p>
<p>我们会想当然的认为这是从事务的方法开始到方法的结束。</p>
<p>但，不是这样的。</p>
<p>是从事务方法的开始，到 SQL 语句执行的结束，因此，SQL 语句后面的代码执行时间都不算在 timeout 中的。</p>
<p>这点非常重要。</p>
<p>这样将导致下面的代码可能无法达到你想要的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 3)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  userInfoMapper</span><br><span class="line">      .insert(<span class="keyword">new</span> UserInfo().setUsername(<span class="string">&quot;timeout&quot;</span>).setPassword(<span class="string">&quot;timeout&quot;</span>));</span><br><span class="line">    Thread.sleep(<span class="number">3100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，我们想让这个事务耗时超过 3 秒，那么就可以触发 timeout ，让 insert 无法提交。然而这时不可能的。因为，我们刚刚说，Sql 执行结束后，超时的计时就结束了。</p>
<p>而下面的例子则可以正确的触发 timeout：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 3)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread.sleep(<span class="number">3100</span>);</span><br><span class="line">  userInfoMapper</span><br><span class="line">      .insert(<span class="keyword">new</span> UserInfo().setUsername(<span class="string">&quot;timeout&quot;</span>).setPassword(<span class="string">&quot;timeout&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，从事务的开始到 sql 执行结束的总时间超过了 timeout 设定的时间。成功触发 timeout 机制 —— 抛出异常。</p>
<h2 id="rollbackFor-和-noRollbackFor"><a href="#rollbackFor-和-noRollbackFor" class="headerlink" title="rollbackFor 和 noRollbackFor"></a>rollbackFor 和 noRollbackFor</h2><p>定义一个 Class 数组，需要继承自 Throwable，也就是异常。</p>
<p>事务需要回滚，那么什么样的异常才能让事务回滚？</p>
<p>默认是 RuntimeException 和 Error。代码如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d18c935b9ff79df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>用户可以自定义回滚类似和反回滚类型。</p>
<p>上面的两个属性是相反的。</p>
<h2 id="rollbackForClassName-和-noRollbackForClassName"><a href="#rollbackForClassName-和-noRollbackForClassName" class="headerlink" title="rollbackForClassName 和 noRollbackForClassName"></a>rollbackForClassName 和 noRollbackForClassName</h2><p>这两个其实和上面的是一样的功能，只是这里使用了字符串，在某些类加载器不同的场合，也许有用武之地。注意，这里只需要写简单类名即可，无需写全类名。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>ConcurrentHashMap-扩容分析拾遗</title>
    <url>/2018/05/16/2018/2018-05-16-ConcurrentHashMap-%E6%89%A9%E5%AE%B9%E5%88%86%E6%9E%90%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>这是一篇对 transfer 方法的拾遗，关于之前那篇文章的一些一笔带过，或者当时不知道的地方进行回顾。</p>
<h2 id="疑点-1-为什么将链表拆成两份的时候，0-在低位，1-在高位？"><a href="#疑点-1-为什么将链表拆成两份的时候，0-在低位，1-在高位？" class="headerlink" title="疑点 1. 为什么将链表拆成两份的时候，0 在低位，1 在高位？"></a>疑点 1. 为什么将链表拆成两份的时候，0 在低位，1 在高位？</h2><p>回顾一下 transfer 的相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">Node&lt;K,V&gt; lastRun = f; </span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">    <span class="comment">// 取于桶中每个节点的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">    <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">        runBit = b; </span><br><span class="line">        lastRun = p; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;<span class="comment">// 如果最后更新的 runBit 是 0 ，设置低位节点</span></span><br><span class="line">    ln = lastRun;</span><br><span class="line">    hn = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    hn = lastRun; <span class="comment">// 如果最后更新的 runBit 是 1， 设置高位节点</span></span><br><span class="line">    ln = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">    <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">    <span class="comment">// 如果与运算结果是 0，那么就还在低位</span></span><br><span class="line">    <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>) <span class="comment">// 如果是0 ，那么创建低位节点</span></span><br><span class="line">        ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 1 则创建高位</span></span><br><span class="line">        hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键看上面注释的代码，如果 runBit 是 0，那么就设置在低位节点，反之，如果是 1，设置在高位。</p>
<p>为什么这么设计呢？当时楼主一笔带过，称之为<code>这个貌似没有什么特殊含义</code>，实在是愚蠢之极。</p>
<p>今天解释一下。</p>
<p>这要从 ConcurrentHashMap 的取于下标算法开始说起。</p>
<p>我们知道，在 putVal 方法中，会通过取于对象的 hash 值获取下标。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>也就是 <code>(n - 1) &amp; hash)</code>，这个 n 就是 length。这个其实相当于 hash % n（<code>n 必须是2的指数</code>）。但是比 % 更高效。</p>
<p>复习一下与运算：<code>第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0</code>.</p>
<p>然后开始推导：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash),取于算法。</span><br><span class="line">假设，我们的 table 长度是 <span class="number">16</span>，也就是 <span class="number">10000</span>，减一就是 <span class="number">01111.</span> 取于下面这个数。这个数特别之处在于,</span><br><span class="line">他的右起第 <span class="number">5</span> 位是 <span class="number">0</span>。如果是 <span class="number">10000</span> &amp; 这个数，结果是 <span class="number">0.</span></span><br><span class="line"><span class="number">000000001111</span>                     <span class="number">000000010000</span> </span><br><span class="line"><span class="number">010101001001</span> <span class="comment">// 结果 9            010101001001 // &amp;运算结果： 0</span></span><br><span class="line"></span><br><span class="line">当我们扩容后，<span class="number">16</span> 变成 <span class="number">32</span>，也就是 <span class="number">10000.</span> 再看看 (n - <span class="number">1</span>) &amp; hash) 的结果：</span><br><span class="line"></span><br><span class="line"><span class="number">000000011111</span>                    </span><br><span class="line"><span class="number">010101001001</span> <span class="comment">// 结果还是 9</span></span><br><span class="line"></span><br><span class="line">从这里可以看出，如果 &amp; 运算是 <span class="number">0</span> ，那么即使扩容，下标也是不变的。</span><br><span class="line"></span><br><span class="line">再看看另一种情况，换一个 hash 数字，右起第五位是 <span class="number">1</span> ：           </span><br><span class="line"><span class="number">000000001111</span>                      <span class="number">000000010000</span></span><br><span class="line"><span class="number">010101010001</span> <span class="comment">// 结果 1             010101010001 // &amp;运算结果： 1</span></span><br><span class="line"></span><br><span class="line">这里的 &amp; 与运算后，结果是 <span class="number">1</span>，和上面的不同。同时， (n - <span class="number">1</span>) &amp; hash) 的结果也是 <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">当扩容后，结果是什么样子呢？</span><br><span class="line"><span class="number">000000011111</span></span><br><span class="line"><span class="number">010101010001</span> <span class="comment">// 结果变化：10001 == 17</span></span><br><span class="line"></span><br><span class="line">可以看到，(n - <span class="number">1</span>) &amp; hash) 的结果是 <span class="number">17</span>，<span class="number">17</span> - <span class="number">1</span>，刚好是 <span class="number">16</span>，而这个 <span class="number">16</span> 的原因是我们的二进制进了一位。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在明白了吧？0 在低位，1 在高位不是随便设计的。这里让我想到了一致性 hash 算法：<code>当桶的数量变化了，那么 hash 的位置也会变化</code>。</p>
<p><strong>这里的设计是为了防止下次取值的时候，hash 不到正确的位置。</strong></p>
<p>实际上，JDK 1.8 的 HashMap 也是这么实现的重新散列。文章<a href="https://www.jianshu.com/p/468c638e0e83">深入理解 HashMap put 方法（JDK 8逐行剖析）</a>。其中 resize 方法和这里高度类似。</p>
<h2 id="疑点-2：为什么会有-i-gt-n-i-n-gt-nextn-的判断？"><a href="#疑点-2：为什么会有-i-gt-n-i-n-gt-nextn-的判断？" class="headerlink" title="疑点 2：为什么会有 i &gt;= n || i + n &gt;= nextn 的判断？"></a>疑点 2：为什么会有 i &gt;= n || i + n &gt;= nextn 的判断？</h2><p>回顾一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123; </span><br><span class="line">        nextTable = <span class="keyword">null</span>;</span><br><span class="line">        table = nextTab;</span><br><span class="line">        sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个判断在当时看来是没有可能存在的。到现在也没明白为什么。。。。</p>
<p>如果有大佬知道，请指点一二。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程——ConcurrentHashMap#addCount()-分析</title>
    <url>/2018/05/16/2018/2018-05-16-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ConcurrentHashMap$addCount()-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>ConcurrentHashMap 精华代码很多，前面分析了 helpTransfer 和 transfer 和 putVal 方法，今天来分析一下 addCount 方法，该方法会在 putVal 方法中调用。</p>
<p>该方法可以配合 size 方法一起查看，关于该方法，楼主也写了一篇文章分析过：<a href="https://www.jianshu.com/p/88881fdfcf4c">并发编程 —— ConcurrentHashMap size 方法原理分析</a></p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>当插入结束的时候，会调用该方法，并传入一个 1 和 binCount 参数。从方法名字上，该方法应该是对哈希表的元素进行计数的。</p>
<p>一起来看看 addCount 是如何操作的。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码加注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 putVal 传入的参数是 1， binCount，binCount 默认是0，只有 hash 冲突了才会大于 1.且他的大小是链表的长度（如果不是红黑数结构的话）。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 如果计数盒子不是空 或者</span></span><br><span class="line">    <span class="comment">// 如果修改 baseCount 失败</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果计数盒子是空（尚未出现并发）</span></span><br><span class="line">        <span class="comment">// 如果随机取余一个数组位置为空 或者</span></span><br><span class="line">        <span class="comment">// 修改这个槽位的变量失败（出现并发了）</span></span><br><span class="line">        <span class="comment">// 执行 fullAddCount 方法。并结束</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要检查,检查是否需要扩容，在 putVal 方法调用时，默认就是要检查的。</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容） 且</span></span><br><span class="line">        <span class="comment">// table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 根据 length 得到一个标识</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 sc 的低 16 位不等于 标识符（校验异常 sizeCtl 变化了）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 1 （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 65535（帮助线程数已经达到最大）</span></span><br><span class="line">                <span class="comment">// 如果 nextTable == null（结束扩容了）</span></span><br><span class="line">                <span class="comment">// 如果 transferIndex &lt;= 0 (转移状态变化了)</span></span><br><span class="line">                <span class="comment">// 结束循环 </span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 更新 sizeCtl 为负数后，开始扩容。</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法加了注释以后，还是挺长的。</p>
<p>总结一下该方法的逻辑：</p>
<p>x 参数表示的此次需要对表中元素的个数加几。check 参数表示是否需要进行扩容检查，大于等于0 需要进行检查，而我们的 putVal 方法的 binCount 参数最小也是 0 ，因此，每次添加元素都会进行检查。（除非是覆盖操作）</p>
<ol>
<li>判断计数盒子属性是否是空，如果是空，就尝试修改 baseCount 变量，对该变量进行加 X。</li>
<li>如果计数盒子不是空，或者修改 baseCount 变量失败了，则放弃对 baseCount 进行操作。</li>
<li>如果计数盒子是 null 或者计数盒子的 length 是 0，或者随机取一个位置取于数组长度是 null，那么就对刚刚的元素进行 CAS 赋值。</li>
<li>如果赋值失败，或者满足上面的条件，则调用 fullAddCount 方法重新死循环插入。</li>
<li>这里如果操作 baseCount 失败了（或者计数盒子不是 Null），且对计数盒子赋值成功，那么就检查 check 变量，如果该变量小于等于 1. 直接结束。否则，计算一下 count 变量。</li>
<li>如果 check 大于等于 0 ，说明需要对是否扩容进行检查。</li>
<li>如果 map 的 size 大于 sizeCtl（扩容阈值），且 table 的长度小于 1 &lt;&lt; 30，那么就进行扩容。</li>
<li>根据 length 得到一个标识符，然后，判断 sizeCtl 状态，如果小于 0 ，说明要么在初始化，要么在扩容。</li>
<li>如果正在扩容，那么就校验一下数据是否变化了（具体可以看上面代码的注释）。如果检验数据不通过，break。</li>
<li>如果校验数据通过了，那么将 sizeCtl 加一，表示多了一个线程帮助扩容。然后进行扩容。</li>
<li>如果没有在扩容，但是需要扩容。那么就将 sizeCtl 更新，赋值为标识符左移 16 位 —— 一个负数。然后加 2。 表示，已经有一个线程开始扩容了。然后进行扩容。然后再次更新 count，看看是否还需要扩容。</li>
</ol>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>总结下来看，addCount 方法做了 2 件事情：</p>
<ol>
<li><p>对 table 的长度加一。无论是通过修改 baseCount，还是通过使用 CounterCell。当 CounterCell 被初始化了，就优先使用他，不再使用 baseCount。</p>
</li>
<li><p>检查是否需要扩容，或者是否正在扩容。如果需要扩容，就调用扩容方法，如果正在扩容，就帮助其扩容。</p>
</li>
</ol>
<p>有几个要点注意：</p>
<ol>
<li><p>第一次调用扩容方法前，sizeCtl 的低 16 位是加 2 的，不是加一。所以  sc == rs + 1 的判断是表示是否完成任务了。因为完成扩容后，sizeCtl == rs + 1。</p>
</li>
<li><p>扩容线程最大数量是 65535，是由于低 16 位的位数限制。</p>
</li>
<li><p>这里也是可以帮助扩容的，类似 helpTransfer 方法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程——ConcurrentHashMap#helpTransfer()-分析</title>
    <url>/2018/05/16/2018/2018-05-16-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ConcurrentHashMap$helpTransfer()-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>ConcurrentHashMap 鬼斧神工，并发添加元素时，如果 map 正在扩容，其他线程甚至于还会帮助扩容，也就是多线程扩容。就这一点，就可以写一篇文章好好讲讲。今天一起来看看。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>为什么帮助扩容？</p>
<p>在 putVal 方法中，如果发现线程当前 hash 冲突了，也就是当前 hash 值对应的槽位有值了，且如果这个值是 -1 （MOVED），说明 Map 正在扩容。那么就帮助 Map 进行扩容。以加快速度。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line"><span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        tab = initTable();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                     <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">            <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">    &#125; <span class="comment">// 如果对应槽位不为空，且他的 hash 值是 -1，说明正在扩容，那么就帮助其扩容。以加快速度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">        tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>

<p>传入的参数是：成员变量 table 和 对应槽位的 f 变量。</p>
<p>怎么验证 hash 值是 MOVED 就是正在扩容呢?</p>
<p>在 Cmap（ConcurrentHashMap 简称） 中，定义了一堆常量，其中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br></pre></td></tr></table></figure>

<p><code>hash for forwarding nodes</code>，说明这个为了移动节点而准备的常量。</p>
<p>在 Node 的子类 ForwardingNode 的构造方法中，可以看到这个变量作为 hash 值进行了初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">    <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个构造方法只在一个地方调用了，即 transfer（扩容） 方法。</p>
<p>点到为止。</p>
<p>关于扩容后面再开一篇。</p>
<p>好了，如何帮助扩容呢？那要看看 <code>helpTransfer </code> 方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helps transfer if a resize is in progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 如果 table 不是空 且 node 节点是转移类型，数据检验</span></span><br><span class="line">    <span class="comment">// 且 node 节点的 nextTable（新 table） 不是空，同样也是数据校验</span></span><br><span class="line">    <span class="comment">// 尝试帮助扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">// 根据 length 得到一个标识符号</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">    	<span class="comment">// 如果 nextTab 没有被并发修改 且 tab 也没有被并发修改</span></span><br><span class="line">    	<span class="comment">// 且 sizeCtl  &lt; 0 （说明还在扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">// 如果 sizeCtl 无符号右移  16 不等于 rs （ sc前 16 位如果不等于标识符，则标识符变化了）</span></span><br><span class="line">        	<span class="comment">// 或者 sizeCtl == rs + 1  （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></span><br><span class="line">        	<span class="comment">// 或者 sizeCtl == rs + 65535  （如果达到最大帮助线程的数量，即 65535）</span></span><br><span class="line">        	<span class="comment">// 或者转移下标正在调整 （扩容结束）</span></span><br><span class="line">        	<span class="comment">// 结束循环，返回 table</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果以上都不是, 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">            	<span class="comment">// 进行转移</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="comment">// 结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 sizeCtl 变量：</p>
<p>-1 :代表table正在初始化,其他线程应该交出CPU时间片<br>-N: 表示正有N-1个线程执行扩容操作（高 16 位是 length 生成的标识符，低 16 位是扩容的线程数）<br>大于 0: 如果table已经初始化,代表table容量,默认为table大小的0.75,如果还未初始化,代表需要初始化的大小</p>
<p>代码步骤：</p>
<ol>
<li>判 tab 空，判断是否是转移节点。判断 nextTable 是否更改了。</li>
<li>更加 length 得到标识符。</li>
<li>判断是否并发修改了，判断是否还在扩容。</li>
<li>如果还在扩容，判断标识符是否变化，判断扩容是否结束，判断是否达到最大线程数，判断扩容转移下标是否在调整（扩容结束），如果满足任意条件，结束循环。</li>
<li>如果不满足，并发转移。</li>
</ol>
<p>这里有一个花费了很长时间纠结的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sc == rs + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个判断可以在 addCount 方法中找到答案：默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1。</p>
<p>如果 sizeCtl  == 标识符 + 1 ，说明库容结束了，没有必要再扩容了。</p>
<p>总结一下：</p>
<p>当 Cmap put 元素的时候，如果发现这个节点的元素类型是 forward 的话，就帮助正在扩容的线程一起扩容，提高速度。其中， sizeCtl 是关键，该变量高 16 位保存 length 生成的标识符，低 16 位保存并发扩容的线程数，通过这连个数字，可以判断出，是否结束扩容了。</p>
<p>如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9fd0441a1f41116b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程——ConcurrentHashMap#transfer()-扩容逐行分析</title>
    <url>/2018/05/16/2018/2018-05-16-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ConcurrentHashMap$transfer()-%E6%89%A9%E5%AE%B9%E9%80%90%E8%A1%8C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>ConcurrentHashMap 是并发中的重中之重，也是最常用的数据结果，之前的文章中，我们介绍了 putVal 方法。<a href="https://www.jianshu.com/p/77fda250bddf">并发编程之 ConcurrentHashMap（JDK 1.8） putVal 源码分析</a>。其中分析了 initTable  方法和 putVal 方法，但也留下了一句话：</p>
<blockquote>
<p>这篇文章仅仅是 ConcurrentHashMap 的开头，关于 ConcurrentHashMap 里面的精华太多，值得我们好好学习。</p>
</blockquote>
<p>说道精华，他的扩容方法绝对是精华，要知道，ConcurrentHashMap 扩容是高度并发的。</p>
<p>今天来逐行分析源码。</p>
<h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><p>首先说结论。源码加注释我会放在后面。该方法的执行逻辑如下：</p>
<ol>
<li><p>通过计算 CPU 核心数和 Map 数组的长度得到每个线程（CPU）要帮助处理多少个桶，并且这里每个线程处理都是平均的。默认每个线程处理 16 个桶。因此，如果长度是 16 的时候，扩容的时候只会有一个线程扩容。</p>
</li>
<li><p>初始化临时变量 nextTable。将其在原有基础上扩容两倍。</p>
</li>
<li><p>死循环开始转移。多线程并发转移就是在这个死循环中，根据一个 finishing 变量来判断，该变量为 true 表示扩容结束，否则继续扩容。</p>
<p>3.1 进入一个 while 循环，分配数组中一个桶的区间给线程，默认是 16. 从大到小进行分配。当拿到分配值后，进行 i– 递减。这个 i 就是数组下标。（<code>其中有一个 bound 参数，这个参数指的是该线程此次可以处理的区间的最小下标，超过这个下标，就需要重新领取区间或者结束扩容，还有一个 advance 参数，该参数指的是是否继续递减转移下一个桶，如果为 true，表示可以继续向后推进，反之，说明还没有处理好当前桶，不能推进</code>)</p>
</li>
<li><p>2 出 while 循环，进 if 判断，判断扩容是否结束，如果扩容结束，清空临死变量，更新 table 变量，更新库容阈值。如果没完成，但已经无法领取区间（没了），该线程退出该方法，并将 sizeCtl 减一，表示扩容的线程少一个了。如果减完这个数以后，sizeCtl 回归了初始状态，表示没有线程再扩容了，该方法所有的线程扩容结束了。（<code>这里主要是判断扩容任务是否结束，如果结束了就让线程退出该方法，并更新相关变量</code>）。然后检查所有的桶，防止遗漏。</p>
</li>
<li><p>3 如果没有完成任务，且 i 对应的槽位是空，尝试 CAS 插入占位符，让 putVal 方法的线程感知。</p>
</li>
<li><p>4 如果 i 对应的槽位不是空，且有了占位符，那么该线程跳过这个槽位，处理下一个槽位。</p>
</li>
<li><p>5 如果以上都是不是，说明这个槽位有一个实际的值。开始同步处理这个桶。</p>
</li>
<li><p>6 到这里，都还没有对桶内数据进行转移，只是计算了下标和处理区间，然后一些完成状态判断。同时，如果对应下标内没有数据或已经被占位了，就跳过了。</p>
</li>
<li><p>处理每个桶的行为都是同步的。防止 putVal 的时候向链表插入数据。<br>4.1 如果这个桶是链表，那么就将这个链表根据 length 取于拆成两份，取于结果是 0 的放在新表的低位，取于结果是 1 放在新表的高位。</p>
</li>
<li><p>2 如果这个桶是红黑数，那么也拆成 2 份，方式和链表的方式一样，然后，判断拆分过的树的节点数量，如果数量小于等于 6，改造成链表。反之，继续使用红黑树结构。</p>
</li>
<li><p>3 到这里，就完成了一个桶从旧表转移到新表的过程。</p>
</li>
</ol>
<p>好，以上，就是 transfer 方法的总体逻辑。还是挺复杂的。再进行精简，分成 3 步骤：</p>
<ol>
<li>计算每个线程可以处理的桶区间。默认 16.</li>
<li>初始化临时变量 nextTable，扩容 2 倍。</li>
<li>死循环，计算下标。完成总体判断。</li>
<li>1 如果桶内有数据，同步转移数据。通常会像链表拆成 2 份。</li>
</ol>
<p>大体就是上的的 3 个步骤。</p>
<p>再来看看源码和注释。</p>
<h2 id="再看源码分析"><a href="#再看源码分析" class="headerlink" title="再看源码分析"></a>再看源码分析</h2><p>源码加注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment"> * above for explanation.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * transferIndex 表示转移时的下标，初始为扩容前的 length。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 我们假设长度是 32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 将 length / 8 然后除以 CPU核心数。如果得到的结果小于 16，那么就使用 16。</span></span><br><span class="line">    <span class="comment">// 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 16 个桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range 细分范围 stridea：TODO</span></span><br><span class="line">    <span class="comment">// 新的 table 尚未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容  2 倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 更新</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            <span class="comment">// 扩容失败， sizeCtl 使用 int 最大值。</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// 结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新成员变量</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 更新转移下标，就是 老的 tab 的 length</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新 tab 的 length</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 创建一个 fwd 节点，用于占位。当别的线程发现这个槽位中是 fwd 类型的节点，则跳过这个节点。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 首次推进为 true，如果等于 true，说明需要再次推进一个下标（i--），反之，如果是 false，那么就不能推进下标，需要将当前的下标处理完毕才能继续推进</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 完成状态，如果是 true，就结束此方法。</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// 死循环,i 表示下标，bound 表示当前线程可以处理的当前桶区间最小下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// 如果当前线程可以向后推进；这个循环就是控制 i 递减。同时，每个线程都会进入这里取得自己需要转移的桶的区间</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 对 i 减一，判断是否大于等于 bound （正常情况下，如果大于 bound 不成立，说明该线程上次领取的任务已经完成了。那么，需要在下面继续领取任务）</span></span><br><span class="line">            <span class="comment">// 如果对 i 减一大于等于 bound（还需要继续做任务），或者完成了，修改推进状态为 false，不能推进了。任务成功后修改推进状态为 true。</span></span><br><span class="line">            <span class="comment">// 通常，第一次进入循环，i-- 这个判断会无法通过，从而走下面的 nextIndex 赋值操作（获取最新的转移下标）。其余情况都是：如果可以推进，将 i 减一，然后修改成不可推进。如果 i 对应的桶处理成功了，改成可以推进。</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;<span class="comment">// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">            <span class="comment">// 这里的目的是：1. 当一个线程进入时，会选取最新的转移下标。2. 当一个线程处理完自己的区间时，如果还有剩余区间的没有别的线程处理。再次获取区间。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果小于等于0，说明没有区间了 ，i 改成 -1，推进状态变成 false，不再推进，表示，扩容结束了，当前线程可以退出了</span></span><br><span class="line">                <span class="comment">// 这个 -1 会在下面的 if 块里判断，从而进入完成状态判断</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;<span class="comment">// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">            &#125;<span class="comment">// CAS 修改 transferIndex，即 length - 区间值，留下剩余的区间值供后面的线程使用</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;<span class="comment">// 这个值就是当前线程可以处理的最小当前区间最小下标</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>; <span class="comment">// 初次对i 赋值，这个就是当前线程可以处理的当前区间的最大下标</span></span><br><span class="line">                advance = <span class="keyword">false</span>; <span class="comment">// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进，这样对导致漏掉某个桶。下面的 if (tabAt(tab, i) == f) 判断会出现这样的情况。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 如果 i 小于0 （不在 tab 下标内，按照上面的判断，领取最后一段区间的线程扩容结束）</span></span><br><span class="line">        <span class="comment">//  如果 i &gt;= tab.length(不知道为什么这么判断)</span></span><br><span class="line">        <span class="comment">//  如果 i + tab.length &gt;= nextTable.length  （不知道为什么这么判断）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123; <span class="comment">// 如果完成了扩容</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;<span class="comment">// 删除成员变量</span></span><br><span class="line">                table = nextTab;<span class="comment">// 更新 table</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 更新阈值</span></span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">// 结束方法。</span></span><br><span class="line">            &#125;<span class="comment">// 如果没完成</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;<span class="comment">// 尝试将 sc -1. 表示这个线程结束帮助扩容了，将 sc 的低 16 位减一。</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<span class="comment">// 如果 sc - 2 不等于标识符左移 16 位。如果他们相等了，说明没有线程在帮助他们扩容了。也就是说，扩容结束了。</span></span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">// 不相等，说明没结束，当前线程结束方法。</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;<span class="comment">// 如果相等，扩容结束了，更新 finising 变量</span></span><br><span class="line">                i = n; <span class="comment">// 再次循环检查一下整张表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>) <span class="comment">// 获取老 tab i 下标位置的变量，如果是 null，就使用 fwd 占位。</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);<span class="comment">// 如果成功写入 fwd 占位，再次推进一个下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">// 如果不是 null 且 hash 值是 MOVED。</span></span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed // 说明别的线程已经处理过了，再次推进一个下标</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 到这里，说明这个位置有实际值了，且不是占位符。对这个节点上锁。为什么上锁，防止 putVal 的时候向链表插入数据</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 判断 i 下标处的桶节点是否和 f 相同</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;<span class="comment">// low, height 高位桶，低位桶</span></span><br><span class="line">                    <span class="comment">// 如果 f 的 hash 值大于 0 。TreeBin 的 hash 是 -2</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 对老长度进行与运算（第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0）</span></span><br><span class="line">                        <span class="comment">// 由于 Map 的长度都是 2 的次方（000001000 这类的数字），那么取于 length 只有 2 种结果，一种是 0，一种是1</span></span><br><span class="line">                        <span class="comment">//  如果是结果是0 ，Doug Lea 将其放在低位，反之放在高位，目的是将链表重新 hash，放到对应的位置上，让新的取于算法能够击中他。</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f; <span class="comment">// 尾节点，且和头节点的 hash 值取于不相等</span></span><br><span class="line">                        <span class="comment">// 遍历这个桶</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">// 取于桶中每个节点的 hash 值</span></span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="comment">// 如果节点的 hash 值和首节点的 hash 值取于结果不同</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b; <span class="comment">// 更新 runBit，用于下面判断 lastRun 该赋值给 ln 还是 hn。</span></span><br><span class="line">                                lastRun = p; <span class="comment">// 这个 lastRun 保证后面的节点与自己的取于值相同，避免后面没有必要的循环</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;<span class="comment">// 如果最后更新的 runBit 是 0 ，设置低位节点</span></span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun; <span class="comment">// 如果最后更新的 runBit 是 1， 设置高位节点</span></span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;<span class="comment">// 再次循环，生成两个链表，lastRun 作为停止条件，这样就是避免无谓的循环（lastRun 后面都是相同的取于结果）</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="comment">// 如果与运算结果是 0，那么就还在低位</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>) <span class="comment">// 如果是0 ，那么创建低位节点</span></span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span> <span class="comment">// 1 则创建高位</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其实这里类似 hashMap </span></span><br><span class="line">                        <span class="comment">// 设置低位链表放在新链表的 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 设置高位链表，在原有长度上加 n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将旧的链表设置成占位符</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// 继续向后推进</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="comment">// 如果是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">// 遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="comment">// 和链表相同的判断，与运算 == 0 的放在低位</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125; <span class="comment">// 不是 0 的放在高位</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果树的节点数小于等于 6，那么转成链表，反之，创建一个新的树</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">// 低位树</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 高位数</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 旧的设置成占位符</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// 继续向后推进</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>代码加注释比较长，有兴趣可以逐行对照，有 2 个判断楼主看不懂为什么这么判断，知道的同学可以提醒一下。</p>
<p>然后，说说精华的部分。</p>
<ol>
<li>Cmap 支持并发扩容，实现方式是，将表拆分，让每个线程处理自己的区间。如下图：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9085b57399ff2318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>假设总长度是 64 ，每个线程可以分到 16 个桶，各自处理，不会互相影响。</p>
<ol start="2">
<li>而每个线程在处理自己桶中的数据的时候，是下图这样的：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-13c7cd70508724c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>扩容前的状态。</p>
<p>当对 4 号桶或者 10 号桶进行转移的时候，会将链表拆成两份，规则是根据节点的 hash 值取于 length，如果结果是 0，放在低位，否则放在高位。</p>
<p>因此，10 号桶的数据，黑色节点会放在新表的 10 号位置，白色节点会放在新桶的 26 号位置。</p>
<p>下图是循环处理桶中数据的逻辑：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9069a2e2dc85ff74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>处理完之后，新桶的数据是这样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-dcc2bb9654a884e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>transfer 方法可以说很牛逼，很精华，内部多线程扩容性能很高，</p>
<p>通过给每个线程分配桶区间，避免线程间的争用，通过为每个桶节点加锁，避免 putVal 方法导致数据不一致。同时，在扩容的时候，也会将链表拆成两份，这点和 HashMap 的 resize 方法类似。</p>
<p>而如果有新的线程想 put 数据时，也会帮助其扩容。鬼斧神工，令人赞叹。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>ConcurrentHashMap-源码阅读小结</title>
    <url>/2018/05/17/2018/2018-05-17-ConcurrentHashMap-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>每一次总结都意味着重新开始，同时也是为了更好的开始。ConcurrentHashMap 一直是我心中的痛。虽然不敢说完全读懂了，但也看了几个重要的方法，有不少我觉得比较重要的知识点。</p>
<p>然后呢，放一些楼主写的关于 ConcurrentHashMap 相关源码分析的文章链接：</p>
<ol>
<li><a href="https://www.jianshu.com/p/dc69edc17b32">ConcurrentHashMap 扩容分析拾遗</a></li>
<li><a href="https://www.jianshu.com/p/749d1b8db066">并发编程——ConcurrentHashMap#addCount() 分析</a></li>
<li><a href="https://www.jianshu.com/p/2829fe36a8dd">并发编程——ConcurrentHashMap#transfer() 扩容逐行分析</a></li>
<li><a href="https://www.jianshu.com/p/39b747c99d32">并发编程——ConcurrentHashMap#helpTransfer() 分析</a></li>
<li><a href="https://www.jianshu.com/p/88881fdfcf4c">并发编程 —— ConcurrentHashMap size 方法原理分析</a></li>
<li><a href="https://www.jianshu.com/p/77fda250bddf">并发编程之 ConcurrentHashMap（JDK 1.8） putVal 源码分析</a></li>
<li><a href="https://www.jianshu.com/p/468c638e0e83">深入理解 HashMap put 方法（JDK 8逐行剖析）</a></li>
<li><a href="https://www.jianshu.com/p/eb9ab4211163">深入理解 hashcode 和 hash 算法</a></li>
</ol>
<h2 id="putVal-方法总结"><a href="#putVal-方法总结" class="headerlink" title="putVal 方法总结"></a>putVal 方法总结</h2><p>说起 ConcurrentHashMap ，当然从入口开始说。该方法要点如下：</p>
<ol>
<li>不允许有 null key 和 null value。</li>
<li>只有在第一次 put 的时候才初始化 table。初始化有并发控制。通过 sizeCtl 变量判断（小于 0）。</li>
<li>当 hash 对应的下标是 null 时，使用  CAS 插入元素。 </li>
<li>当 hash 对应的下标值是 forward 时，帮助扩容，但有可能帮不了，因为每个线程默认 16 个桶，如果只有 16个桶，第二个线程是无法帮助扩容的。</li>
<li>如果 hash 冲突了，同步头节点，进行链表操作，如果链表长度达到 8 ，分成红黑树。</li>
<li>调用 addCount 方法，对 size 加一，并判断是否需要扩容（如果是覆盖，就不调用该方法）。</li>
<li>Cmap 的并发性能是 hashTable 的 table.length 倍。只有出现链表才会同步，否则使用 CAS 插入。性能极高。</li>
</ol>
<h2 id="size-方法总结"><a href="#size-方法总结" class="headerlink" title="size 方法总结"></a>size 方法总结</h2><ol>
<li>size 方法不准确，原因是由于并发插入，baseCount 难以及时更新。计数盒子也难以及时更新。</li>
<li>内部通过两个变量，一个是 baseCount，一个是 counterCells，counterCells 是并发修改 baseCount 后的备用方案。</li>
<li>具体更新 baseCount 和 counterCells 是在 addCount 方法中。备用方法 fullAddCount 则会死循环插入。</li>
<li>CounterCell 是一个用于分配计数的填充单元，改编自 LongAdder和Striped64。内部只有一个 volatile 的 value 变量，同时这个类标记了 <code>sun.misc.Contended </code>，这是一个避免伪共享的注解，用于替代之前的缓存行填充。多线程情况下，注解让性能提升 5 倍。</li>
</ol>
<h2 id="helpTransfer-方法总结"><a href="#helpTransfer-方法总结" class="headerlink" title="helpTransfer 方法总结"></a>helpTransfer 方法总结</h2><ol>
<li>当 Cmap 尝试插入的时候，发现该节点是 forward 类型，则会帮助其扩容。</li>
<li>每次加入一个线程都会将 sizeCtl 的低 16 位加一。同时会校验高 16 位的标示符。</li>
<li>扩容最大的帮助线程是  65535，这是低 16 位的最大值限制的。</li>
<li>每个线程默认分配 16 个桶，如果桶的数量是 16，那么第二个线程无法帮助其扩容。</li>
</ol>
<h2 id="transfer-方法总结"><a href="#transfer-方法总结" class="headerlink" title="transfer 方法总结"></a>transfer 方法总结</h2><ol>
<li>该方法会根据 CPU 核心数平均分配给每个 CPU 相同数量的桶。但如果不够 16 个，默认就是 16 个。</li>
<li>扩容是按照 2 倍进行扩容。</li>
<li>每个线程在处理完自己领取的区间后，还可以继续领取，如果有的话。这个是 transferIndex 变量递减 16 实现的。</li>
<li>每次处理空桶的时候，会插入一个 forward 节点，告诉 putVal 的线程：“我正在扩容，快来帮忙”。但如果只有 16 个桶，只能有一个线程扩容。</li>
<li>如果有了占位符，那就不处理，跳过这个桶。</li>
<li>如果有真正的实际值，那就同步头节点，防止 putVal 那里并发。</li>
<li>同步块里会将链表拆成两份，根据 hash &amp; length 得到是否是 0，如果是0，放在低位，反之，反之放在 length + i 的高位。这里的设计是为了防止下次取值的时候，hash 不到正确的位置。</li>
<li>如果该桶的类型是红黑树，也会拆成 2 个，这是必须的。然后判断拆分过的桶的大小是否小于等于 6，如果是，改成链表。</li>
<li>线程处理完之后，如果没有可选区间，且任务没有完成，就会将整个表检查一遍，防止遗漏。</li>
</ol>
<h2 id="addCount-方法总结"><a href="#addCount-方法总结" class="headerlink" title="addCount 方法总结"></a>addCount 方法总结</h2><ol>
<li>当插入结束的时候，会对 size 进行加一。也会进行是否需要扩容的判断。</li>
<li>优先使用计数盒子（如果不是空，说明并发了），如果计数盒子是空，使用 baseCount 变量。对其加 X。</li>
<li>如果修改 baseCount 失败，使用计数盒子。如果此次修改失败，在另一个方法死循环插入。</li>
<li>检查是否需要扩容。</li>
<li>如果 size 大于等于 sizeCtl 阈值，且长度小于 1 &lt;&lt; 30，可以扩容成 1 &lt;&lt; 30，但不能扩容成 1 &lt;&lt; 31。</li>
<li>如果已经在扩容，帮助其扩容，和 helpTransfer 逻辑一样。</li>
<li>如果没有在扩容，自行开启扩容，更新 sizeCtl 变量为负数，赋值为标识符高 16 位 + 2。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ConcurrentHashMap 满是财富，都是精华代码，我们这次阅读只是管中窥豹，要知道其中包含 53 个类，6300 行代码，但这次确实收获很多。有时间一定再次阅读！！ </p>
<p>能力不高，水平有限，有些地方确实理解不了 Doug Lea 大师的设计，如果有什么错误，还请大家指出。不胜感激。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>Finalize()-原理，了解一下？</title>
    <url>/2018/05/24/2018/2018-05-24-finalize()-%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>在之前<a href="https://www.jianshu.com/p/f29d013c4f46">深入浅出 JVM GC（1）</a>我们知道，finalize 方法的作用是：</p>
<blockquote>
<p>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。<br>注意：当对象没有覆盖 finalize 方法，或者 finalize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”。也就是说，finalize 方法只会被执行一次。<br>=========================================================<br>如果这个对象被判定为有必要执行 finalize 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个虚拟机自动建立的，优先级为 8 的 Finalizer 线程去执行它。<br>注意：如果一个对象在 finalize 方法中运行缓慢，将会导致队列后的其他对象永远等待，严重时将会导致系统崩溃。<br>=========================================================<br>finalize 方法是对象逃脱死亡命运的最后一道关卡。稍后 GC 将对队列中的对象进行第二次规模的标记，如果对象要在 finalize 中 “拯救” 自己，只需要将自己关联到引用上即可，通常是 this。<br>如果这个对象关联上了引用，那么在第二次标记的时候他将被移除出 “即将回收” 的集合；如果对象这时候还没有逃脱，那基本上就是真的被回收了。</p>
</blockquote>
<p>那么，就看看这个方法的具体原理。</p>
<h2 id="测试-demo"><a href="#测试-demo" class="headerlink" title="测试 demo"></a>测试 demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FinalizeTest f = <span class="keyword">new</span> FinalizeTest();</span><br><span class="line">    f = <span class="keyword">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finalize&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们的测试 demo，然后，我们在 finalize 方法中，打上断点。启动 JVM，得到以下堆栈。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ff5f179a0cfd5024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>可以看到，一个 FinalizerThread 的线程执行了我们的 finalize 方法。那么过程是如何的呢？</p>
<h2 id="堆栈分析"><a href="#堆栈分析" class="headerlink" title="堆栈分析"></a>堆栈分析</h2><p>这个 FinalizerThread 的初始化和启动在 Finalizer 的 static 块中，由 JVM 主动访问其外部类 Finalizer 初始化这个静态块。具体访问方法是 Finalizer 的 register 方法。</p>
<p>静态块会启动这个线程，这个线程的优先级是 8 ，比普通的线程要高一点，但是是 demon 线程。</p>
<p>这个线程的任务则是死循环从 Finalizer 的队列中，取出 Finalizer 对象，然后调用这些对象的 runFinalizer 方法。</p>
<p>而这个队列是一个 ReferenceQueue 队列 。里面存放的就是 Finalizer 对象，当一个对象需要执行 finalize 方法（未执行过且重写了该方法）的时候， JVM 会将这个对象包装成 Finalizer 实例，然后，链接到 Finalizer 链表中，并放入这个队列（详细的等会再讲）。</p>
<p>  而这个 runFinalizer 方法的具体逻辑则是获取 Finalizer 对象包装的引用，即实际对象（是枚举则跳过），执行这个对象的 finalize 方法。执行完毕后，清空 Finalizer。</p>
<p>到这里，一个对象的 finalize 方法就执行结束了。</p>
<h2 id="如何放入队列？"><a href="#如何放入队列？" class="headerlink" title="如何放入队列？"></a>如何放入队列？</h2><p>Finalizer 继承了 Reference 类，该类和 GC  密切相关。</p>
<p>而该类有一个高优先级的线程—— ReferenceHandler。他的任务则是死循环执行 tryHandlePending 方法。处理 Reference  的 pending 属性，而这个属性其实就是 Reference 自己。GC 的时候，会设置这个地址 pending 地址。这段代码在  Hotspot 中。有兴趣的可以看看。</p>
<p>当这个线程发现 pending 地址不是空，就会尝试将自身放到自己的 queue 属性队列中。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line"><span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br></pre></td></tr></table></figure>

<p>因此，当我们构造了一个 Finalizer 对象，这个对象会被 GC 设置到自该对象的 pending 属性中，然后 ReferenceHandler 线程会处理这个  pending 属性，具体处理则是将自己添加到构造函数设置的队列中。</p>
<p>这个时候，Finalizer 中的线程就可以从队列中取出这个 Finalizer 对象了。</p>
<p>而这一切都是虚拟机做的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>finalize 方法高度依赖 JVM 和 GC，当一个对象被标记后，便会被 JVM 包装成 Finalizer 对象，然后，被 JVM 设置到 Reference 的静态属性  pending 中，Reference 的内部线程则会将这个 pending 放入到构造函数的队列中。</p>
<p>Finalizer 的内部线程则会从队列中取出 Finalizer 对象，并调用其包装的实际对象的 finalize 方法。</p>
<p>所以，finalize 方法需要两个线程来处理他，一个是 ReferenceHandler ，一个是  FinalizerThread。</p>
<p>前者负责将 Finalizer 对象放入到 Reference 队列中，后者负责从队列中取出 Finalizer 对象并调用实际对象的 finalize 方法。</p>
<p>同时，GC 大概也要做 2 件事情，一个是创建 Finalizer 对象，一个是将该对象设置到自己的 pending 属性中。</p>
<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>在 Reference 的 tryHandlePending 方法中，有一个需要注意的地方，就是 Cleaner，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">    Reference&lt;Object&gt; r;</span><br><span class="line">    Cleaner c;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r = pending;</span><br><span class="line">                c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">                pending = r.discovered;</span><br><span class="line">                r.discovered = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// retry if waited</span></span><br><span class="line">                <span class="keyword">return</span> waitForNotify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c.clean();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断如果，这个引用时 Cleaner  类型，执行该类的 clean 方法就可以了，就不放入队列了。而这个 Cleaner  和  NIO 的直接内存相关，这点其实在楼主分析 Netty 的 noCleaner 策略时提过。</p>
<p>DirectByteBuffer 类中有个 Deallocator 线程，该线程的 run 方法就是调用 <code>unsafe.freeMemory(address)</code> 方法释放直接内存。</p>
<p>当构造 DirectByteBuffer 对象的时候，会创建一个相应的 Deallocator。</p>
<p>而这个 Cleaner 对象则包装了这个 Deallocator，当调用 Cleaner 的 clean 方法的时候，实际上，调用的是用 Deallocator 的 run 方法。这样，当 Cleaner 对象回收的时候，就可以顺手清理直接内存。</p>
<p>由于 DirectByteBuffer 对象中的 Cleaner 目前除了自己使用外，无他人使用，那么当 DirectByteBuffer 被回收时，Cleaner 也会被回收，自然，也就会执行 Finalizer 的逻辑了。</p>
<p>注意：这个 Deallocator 线程只有一个构造方法会创建它 —— <code>DirectByteBuffer(int cap)</code>. 对应的 ByteBuffer 构造方法应该是 <code> static ByteBuffer allocateDirect(int capacity)</code>。</p>
<p>使用的时候需要注意。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>Java-中最大的数据结构：LinkedHashMap-了解一下？</title>
    <url>/2018/05/19/2018/2018-05-19-Java-%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ALinkedHashMap-%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>Map 家族数量众多，其中 HashMap 和 ConcurrentHashMap 用的最多，而 LinkedHashMap 似乎则是不怎么用的，但是他却有着顺序。两种，一种是添加顺序，一种是访问顺序。</p>
<h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><p>LinkedHashMap 继承了 HashMap。那么如果是你，你怎么实现这两个顺序呢？</p>
<p>如果实现添加顺序的话，我们可以在该类中，增加一个链表，每个节点对应 hash 表中的桶。这样，循环遍历的时候，就可以按照链表遍历了。只是会增大内存消耗。</p>
<p>如果实现访问顺序的话，同样也可以使用链表，但每次读取数据时，都需要更新一下链表，将最近一次读取的放到链尾。这样也就能够实现。此时也可以跟进这个特性实现 LRU（Least Recently Used） 缓存。</p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>下面是个小 demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  map.put(i, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry entry : map.entrySet()) &#123;</span><br><span class="line">  System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">map.get(<span class="number">3</span>);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry entry : map.entrySet()) &#123;</span><br><span class="line">  System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="number">0</span>:<span class="number">0</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span></span><br><span class="line"><span class="number">2</span>:<span class="number">2</span></span><br><span class="line"><span class="number">3</span>:<span class="number">3</span></span><br><span class="line"><span class="number">4</span>:<span class="number">4</span></span><br><span class="line"><span class="number">5</span>:<span class="number">5</span></span><br><span class="line"><span class="number">6</span>:<span class="number">6</span></span><br><span class="line"><span class="number">7</span>:<span class="number">7</span></span><br><span class="line"><span class="number">8</span>:<span class="number">8</span></span><br><span class="line"><span class="number">9</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">0</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span></span><br><span class="line"><span class="number">2</span>:<span class="number">2</span></span><br><span class="line"><span class="number">4</span>:<span class="number">4</span></span><br><span class="line"><span class="number">5</span>:<span class="number">5</span></span><br><span class="line"><span class="number">6</span>:<span class="number">6</span></span><br><span class="line"><span class="number">7</span>:<span class="number">7</span></span><br><span class="line"><span class="number">8</span>:<span class="number">8</span></span><br><span class="line"><span class="number">9</span>:<span class="number">9</span></span><br><span class="line"><span class="number">3</span>:<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>首先构造方法是有意思的，比  HashMap 多了一个 accessOrder boolean 参数。表示，按照访问顺序来排序。最新访问的放在链表尾部。</p>
<p>如果是默认的，则是按照添加顺序，即 accessOrder 默认是 false。</p>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>如果看 LinkedHashMap 内部源码，会发现，内部确实维护了一个链表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表的头，最久访问的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表的尾，最新访问的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>

<p>而这个 LinkedHashMap.Entry 内部也维护了双向链表必须的元素，before，after：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在添加元素的时候，会追加到尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 get 的时候，会根据 accessOrder 属性，修改链表顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时注意：这里修改了 modCount，即使是读操作，并发也是不安全的。</p>
<h2 id="如何实现-LRU-缓存？"><a href="#如何实现-LRU-缓存？" class="headerlink" title="如何实现  LRU 缓存？"></a>如何实现  LRU 缓存？</h2><p>LRU 缓存：<code>LRU（Least Recently Used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</code></p>
<p>LinkedHashMap 并没有帮我我们实现具体，需要我们自己实现 。具体实现方法是 removeEldestEntry 方法。</p>
<p>一起来看看原理。</p>
<p>首先，HashMap 在 putVal 方法最后，会调用 afterNodeInsertion 方法，其实就是留给 LinkedHashMap 的。而 LinkedHashMap 的具体实现则是根据一些条件，判断是否需要删除 head 节点。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>evict 参数表示<code>是否需要删除某个元素</code>，而这个 if 判断需要满足的条件如上：head 不能是 null，调用 removeEldestEntry 方法，返回 true 的话，就删除这个 head。而这个方法默认是返回 false 的，等待着你来重写。</p>
<p>所以，removeEldestEntry 方法的实现通常是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span>&#123;    </span><br><span class="line">   <span class="keyword">return</span> size() &gt; capacity;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果长度大于容量了，那么就需要清除不经常访问的缓存了。afterNodeInsertion 会调用 removeNode 方法，删除掉 head 节点 —— 如果 accessOrder 是 true 的话，这个节点就是最不经常访问的节点。</p>
<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>LinkedHashMap 重写了一些 HashMap 的方法，例如 containsValue 方法，这个方法大家猜一猜，怎么重写比较合理？</p>
<p>HashMap 使用了双重循环，先循环外层的 hash 表，再循环内层的 entry 链表。性能可想而知。</p>
<p>但 LinkedHashMap 内部有个元素链表，直接遍历链表就行。相对而言而高很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也算一种空间换时间的策略吧。</p>
<p>get 方法当然也是要重写的。因为需要根据 accessOrder 更新链表。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>雪薇的总结的一下：</p>
<p>LinkedHashMap 内部包含一个双向链表维护顺序，支持两种顺序——添加顺序，访问顺序。</p>
<p>默认就是按照添加顺序来的，如果要改成访问顺序的话，构造方法中的 accessOrder 需要设置成 true。这样，每次调用  get 方法，就会将刚刚访问的元素更新到链表尾部。</p>
<p>关于 LRU，在accessOrder 为 true 的模式下，你可以重写 removeEldestEntry 方法，返回 <code>size() &gt;  capacity </code>，这样，就可以删除最不常访问的元素。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>Java-如何不使用-Volatile-和锁实现共享变量的同步操作</title>
    <url>/2018/06/01/2018/2018-06-01-Java-%E5%A6%82%E4%BD%95%E4%B8%8D%E4%BD%BF%E7%94%A8-volatile-%E5%92%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>熟悉  Java 并发编程的都知道，JMM(Java 内存模型) 中的 happen-before(简称 hb)规则，该规则定义了 Java 多线程操作的有序性和可见性，防止了编译器重排序对程序结果的影响。</p>
<p><strong>按照官方的说法：</strong></p>
<blockquote>
<p>当一个变量被多个线程读取并且至少被一个线程写入时，如果读操作和写操作没有 HB 关系，则会产生数据竞争问题。</p>
</blockquote>
<blockquote>
<p>要想保证<code>操作 B</code> 的线程看到<code>操作  A</code> 的结果（无论 <code>A</code> 和 <code>B</code> 是否在一个线程），那么在 <code>A</code> 和 <code>B</code> 之间必须满足 HB 原则，如果没有，将有可能导致重排序。</p>
</blockquote>
<blockquote>
<p>当缺少 HB 关系时，就可能出现重排序问题。</p>
</blockquote>
<h2 id="HB-有哪些规则？"><a href="#HB-有哪些规则？" class="headerlink" title="HB 有哪些规则？"></a>HB 有哪些规则？</h2><p>这个大家都非常熟悉了应该，大部分书籍和文章都会介绍，这里稍微回顾一下：</p>
<ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：在监视器锁上的解锁操作必须在同一个监视器上的加锁操作之前执行。</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li><strong>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</strong></li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ol>
<p>其中，传递规则我加粗了，这个规则至关重要。<strong>如何熟练的使用传递规则是实现同步的关键</strong>。</p>
<p>然后，再换个角度解释 HB：当一个操作 A HB 操作 B，那么，操作 A 对共享变量的操作结果对操作 B 都是可见的。</p>
<p>同时，如果 操作 B HB 操作 C，那么，操作 A 对共享变量的操作结果对操作 B 都是可见的。</p>
<p>而实现可见性的原理则是 cache protocol 和 memory barrier。通过缓存一致性协议和内存屏障实现可见性。</p>
<h2 id="如何实现同步？"><a href="#如何实现同步？" class="headerlink" title="如何实现同步？"></a>如何实现同步？</h2><p>在 Doug Lea 著作 《Java Concurrency in Practice》中，有下面的描述：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9e8447c31a2b4ccd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>书中提到：通过组合 hb 的一些规则，可以实现对某个未被锁保护变量的可见性。</p>
<p>但由于这个技术对语句的顺序很敏感，<strong>因此容易出错</strong>。</p>
<p>楼主接下来，将演示如何通过 volatile 规则和程序次序规则实现对一个变量同步。</p>
<p>来一个熟悉的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPrintDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (; <span class="number">100</span> &gt; num; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag &amp;&amp; (num == <span class="number">0</span> || ++num % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">          System.out.println(num);</span><br><span class="line">          flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (; <span class="number">100</span> &gt; num; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; (++num % <span class="number">2</span> != <span class="number">0</span>)) &#123;</span><br><span class="line">          System.out.println(num);</span><br><span class="line">          flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是两个线程间隔打印出 0 - 100 的数字。</p>
<p>熟悉并发编程的同学肯定要说了，这个 num 变量没有使用 volatile，会有可见性问题，即：t1 线程更新了 num，t2 线程无法感知。</p>
<p>哈哈，楼主刚开始也是这么认为的，但最近通过研究 HB 规则，我发现，去掉 num 的 volatile 修饰也是可以的。</p>
<p>我们分析一下，楼主画了一个图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-96543d5d6b43bcb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们分析这个图：</p>
<ol>
<li>首先，红色和黄色表示不同的线程操作。</li>
<li>红色线程对 num 变量做 ++，然后修改了 volatile 变量，这个是符合 <code>程序次序规则的</code>。也就是 1 HB 2.</li>
<li>红色线程对 volatile 的写 HB 黄色线程对 volatile 的读，也就是 2 HB 3.</li>
<li>黄色线程读取 volatile 变量，然后对 num 变量做 ++，符合 <code>程序次序规则</code>，也就是 3 HB 4.</li>
<li>根据<code>传递性规则</code>，1 肯定 HB 4. 所以，<strong>1 的修改对 4来说都是可见的。</strong></li>
</ol>
<p>注意：HB 规则保证上一个操作的结果对下一个操作都是可见的。</p>
<p>所以，上面的小程序中，线程 A 对 num 的修改，线程 B 是完全感知的 —— 即使 num 没有使用 volatile 修饰。</p>
<p>这样，我们就借助 HB 原则实现了对一个变量的同步操作，也就是在多线程环境中，保证了并发修改共享变量的安全性。并且没有对这个变量使用 Java 的原语：volatile 和 synchronized 和 CAS（假设算的话）。</p>
<p>这可能看起来不安全（实际上安全），也好像不太容易理解。因为这一切都是 HB 底层的 cache protocol 和 memory barrier 实现的。</p>
<h2 id="其他规则实现同步"><a href="#其他规则实现同步" class="headerlink" title="其他规则实现同步"></a>其他规则实现同步</h2><ol>
<li>利用线程终结规则实现：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Thread tb = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  Thread ta = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      tb.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="comment">//NO</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ta.start();</span><br><span class="line">  tb.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用线程 start 规则实现：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Thread tb = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;);</span><br><span class="line">  Thread ta = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    tb.start();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ta.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个操作，也可以保证变量 a 的可见性。</p>
<p>确实有点颠覆之前的观念。之前的观念中，如果一个变量没有被 volatile 修饰或 final 修饰，那么他在多线程下的读写肯定是不安全的 —— 因为会有缓存，导致读取到的不是最新的。</p>
<p>然而，通过借助 HB，我们可以实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然本文标题是通过 happen-before 实现对共享变量的同步操作，但主要目的还是更深刻的理解 happen-before，理解他的 happen-before 概念其实就是<strong>保证多线程环境中，上一个操作对下一个操作的有序性和操作结果的可见性。</strong></p>
<p>同时，通过灵活的使用<strong>传递性规则</strong>，再对规则进行组合，就可以将两个线程进行同步 —— 实现<strong>指定的共享变量不使用原语也可以保证可见性</strong>。虽然这好像不是很易读，但也是一种尝试。</p>
<p>关于如何组合使用规则实现同步，Doug Lea 在 JUC 中给出了实践。</p>
<p>例如老版本的  FutureTask 的内部类 Sync（已消失），通过 tryReleaseShared 方法修改 volatile 变量，tryAcquireShared 读取 volatile 变量，这是利用了 volatile 规则；</p>
<p>通过在 tryReleaseShared 之前设置非 volatile 的 result 变量，然后在 tryAcquireShared 之后读取 result 变量，这是利用了程序次序规则。</p>
<p>从而保证 result 变量的可见性。和我们的第一个例子类似：利用程序次序规则和 volatile 规则实现普通变量可见性。</p>
<p>而 Doug Lea 自己也说了，这个“借助”技术非常容易出错，要谨慎使用。但在某些情况下，这种“借助”是非常合理的。</p>
<p>实际上，BlockingQueue 也是“借助”了 happen-before 的规则。还记得 unlock 规则吗？当 unlock 发生后，内部元素一定是可见的。</p>
<p>而类库中还有其他的操作也“借助”了 happen-before 原则：并发容器，CountDownLatch，Semaphore，Future，Executor，CyclicBarrier，Exchanger 等。</p>
<p>总而言之，言而总之：</p>
<blockquote>
<p>happen-before 原则是 JMM 的核心所在，只有满足了 hb 原则才能保证有序性和可见性，否则编译器将会对代码重排序。hb 甚至将 lock 和 volatile 也定义了规则。</p>
</blockquote>
<blockquote>
<p>通过适当的对 hb 规则的组合，可以实现对普通共享变量的正确使用。</p>
</blockquote>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程之学习总结</title>
    <url>/2018/06/02/2018/2018-06-02-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       # 前言

<p>楼主自1月14号就停更了，这段时间一直在看JVM，因此没有更新任何文章，但楼主觉得有必要总结一下之前学习并发的过程，因为这一次的总结其实就是下一次的开始。主要时总结一下并发的学习路线，因为在楼主的工作环境中，并不是每天都在编写高并发的程序。然而，即使是这样，我们也要知道并发的每个知识点，这样才算一个合格的Java 程序员。那么如何系统的学习并发呢？学习路线是怎么样的呢？</p>
<h2 id="1-学会开始就成功了一半"><a href="#1-学会开始就成功了一半" class="headerlink" title="1. 学会开始就成功了一半"></a>1. 学会开始就成功了一半</h2><p>首先要确定的思想是：并发编程很复杂，不是看一两篇博客就搞定的。楼主学习学习并发主要看了4本书：</p>
<ol>
<li>《并发编程实战》</li>
<li>《并发编程的艺术》</li>
<li>《Java 高并发程序设计》</li>
<li>《深入理解 Java 虚拟机》第五部分：高效并发</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-f214182b528d54d3.jpg"></p>
<p>也就是上面的几本书。还有一个建议就是，看书最好是看实体的，有什么好处呢？好处就是，当你脑子里有一个疑惑的时候，你能够立马翻书去验证你的想法。而不是打开电子书，慢慢找。不过也有很多人喜欢电子书，毕竟地铁上看书不方便。具体买什么书可以根据自己的情况来。没有最好的，只有最合适的。还有一个问题，就是，看书不一定是从头到尾一字不漏的看，这和死读书差不多。楼主的读书经验是：先快速的将全书过一遍，大概会花一天时间，再找到自己感兴趣的点慢慢看，慢慢配合代码验证。这样效率会高一点。而且理解的会更加深刻。这也算一个学习的方法吧。</p>
<p>那么这四本书先看哪一个呢？楼主是先看的《Java 高并发程序设计》，国人写的。相比较于其余的3本，通俗易懂。注意，看这本书的时候，一定要配合着书敲代码。否则都是白瞎。</p>
<h2 id="2-逐渐深入"><a href="#2-逐渐深入" class="headerlink" title="2. 逐渐深入"></a>2. 逐渐深入</h2><p>在看完了 《Java 高并发程序设计》 后和写了一些 demo 后，我们应该会基本的并发编程了，知道如何使用 JDK 中的 API，也知道了一些基本的 Java 内存模型，一些关键字的理论。这个时候，我们仅仅是 How 的阶段，也就是使用的阶段。如果你是一个有追求的程序员，你肯定想深入了解并发中哪些奇怪的约定，奇怪的事情到底是如何发生的，那么，就需要继续读书，写代码。</p>
<p>这个时候，就需要看看《并发编程的艺术》和《深入理解 Java 虚拟机》第五部分：高效并发，这两本书，重点深入原理，配合 JVM 源码和 汇编深入解释并发的原理。读起来酣畅淋漓。将之前的哪些困惑一扫而空。至于为什么看两本，因为每本书都不是完美的，那些写书的作者的观点也会不同，因此，我们需要知道的更多，并对比他们的看法，才能更加深入的形成自己的思维模型。不能只跟着一本书走。</p>
<p>这两本书主要是理论，但请注意，其中的理论我们可以用代码来验证，才能更深刻的加深印象。</p>
<h2 id="3-深入源码"><a href="#3-深入源码" class="headerlink" title="3. 深入源码"></a>3. 深入源码</h2><p>在了解了原理之后，我们只是得到了理论知识，但很虚无，如果你是个好奇猫，那么你肯定想知道这些设计是如何实现的。幸运的是，从 Java 源码中，我们就能知道百分之90 了(剩下的在 HotSpot 源码中)。这个时候我们做什么呢？</p>
<p>硬肛！！！翻起我们之前写的那些 demo，比如 new Thread()，new ConcurrentHashMap（）,这些我们之前练习的 demo，配合我们的开发工具（强烈推荐 IDEA）,鼠标左键 + ctrl，进入源码查看如何实现。源码重点在 java.util.concurrent 包下。这些都是并发大师 Doug Lea 的杰作。值得反复品味。当然，看源码的时候，也可以顺带结合源码看看之前的书。加深印象。</p>
<p>只有看懂了源码，你才能说，你真正知道了原理。</p>
<p>在看源码的过程中，有痛苦，有快乐，起码楼主是这样的。痛苦的是：很多奇怪的地方看不懂。快乐的是：那些奇怪的地方终于搞懂了。这就是编程的乐趣吧。像一个侦探，慢慢的解开所有的疑惑，最后找到真相。</p>
<p>为什么说硬肛呢？从短期来说，看源码处理满足好奇心，并不能给你带来什么好处。如果看源码不能给你带来快乐，那么，很快，你就会坚持不下去，但是，请注意：这是你进阶高级 Java 程序员的一个标志。</p>
<p>当然，不是所有的源码都是要看的。这时候就体现出 demo  的重要性了，如果你之前没有 demo，那么你将无从下手。但是，如果你听了楼主的：边看书的同时也写了demo，那么这个时候，你就可以顺着demo看源码了，有什么好处呢？好处就是：你从源码层面了解了你使用的api的具体实现。从这个意义上说：你已经学会并发编程了。</p>
<p>也许，经过一到两个月的阅读源码的过程，你对 JUC （java.util.concurrent）包下的 API 已经了如执掌，恭喜你，你终于学会了并发编程。不读源码，不足以谈并发。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的3个步骤，基本就能搞定 Java 并发编程，看这篇文章的你，可以算一下时间，楼主估算了一下，如果你是在职的，那么你需要在工作之余完成这件事情，大概需要2个多月，当然这也要看你的 Java 基础好不好了，这和平时的积累有很多关系。如果你是个天才，当楼主没说。但大部分人都是凡人，都是靠着坚持和努力才能达到自己的目标。所以，请努力吧！</p>
<p>最后，当你看完了 JUC 的源码，感觉还不过瘾，HotSpot 的源码等着你，够你喝好久。因为楼主正在喝 HotSpot 的源码。哈哈哈哈。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo-1--融合-Spring-的三个入口</title>
    <url>/2018/06/30/2018/2018-06-30-Apollo-1--%E8%9E%8D%E5%90%88-Spring-%E7%9A%84%E4%B8%89%E4%B8%AA%E5%85%A5%E5%8F%A3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>Spring 作为 Java 世界非官方标准框架，任何一个中间件想要得到良好的发展，必须完美支持 Spring 的各种特性，即：无缝融入 Spring。</p>
<p>Apollo 作为分布式配置中心，服务于 Java 应用程序，Java 应用程序可以通过 Apollo 提供的 Client 获取远程配置信息。而如何将这个 Client 高度融合到用户的应用程序中呢？</p>
<p>这就需要针对 Spring 提供给我们的接口进行扩展。</p>
<p>在之前的文章中，已经大致聊过 Spring 的一些扩展接口：<a href="https://www.jianshu.com/p/685ced8abe92">深入理解Spring 之 Spring 进阶开发必知必会 之 Spring 扩展接口</a>。</p>
<p>而想融入 Spring，首先得找到入口，然后才能注册相关的类进行自己系统的初始化。<br>所以，如何找到并处理入口成了一门学问，我们今天看看 apollo 如何处理的。</p>
<h2 id="第一种入口：XML"><a href="#第一种入口：XML" class="headerlink" title="第一种入口：XML"></a>第一种入口：XML</h2><p>XML 是传统 Java 项目的配置文件，特别是 Spring MVC 项目。虽然现在都是使用的自动化配置，但仍然有一些遗留项目使用 XML，因此，支持 XML 是大部分中间件的必须工作。</p>
<p>支持 XML 需要准守 Spring 的几个约定：</p>
<ol>
<li>继承 <code>NamespaceHandlerSupport</code> 抽象类，重写 init  方法，调用 registerBeanDefinitionParser 方法，并传入自己继承的 <code>AbstractSingleBeanDefinitionParser</code> 子类用于解析标签，重写他的 getBeanClass 方法，返回一个 Bean，用于注册相关的 Bean。</li>
<li>classpath 下创建 META-INF 目录，创建 <code>spring.handlers</code> 文件，将 xml 配置中的 URL 指向 <code>NamespaceHandlerSupport</code>。</li>
<li>META-INF 目录下，创建 <code>apollo-1.0.0.xsd</code> xsd 文件，用于解释自定义标签。</li>
<li>META-INF 目录下，继续创建 <code>spring.schemas</code> 文件，将 xml 配置中的 xsd URL 指向  xsd 文件。</li>
</ol>
<p>如果你的 xml 配置中，引用了 apollo 的标签，Spring 将会根据 xml 中的 URL 找到 <code>spring.handlers</code> 中的 <code>NamespaceHandlerSupport</code> 类，并对标签进行解析。也会从 getBeanClass 得到一个设置的 bean，在这个 bean 里，做了 apollo 关键类的注册。</p>
<h2 id="第二种入口：-Import-注解"><a href="#第二种入口：-Import-注解" class="headerlink" title="第二种入口：@Import 注解"></a>第二种入口：@Import 注解</h2><p>相对于基于XML的配置，基于Java的配置是目前比较流行的方式。</p>
<p>@Import 注解的使用方式：</p>
<ol>
<li>定义一个自己的启动注解。并标注 @import 注解, 其实就是 xml 中的  import 标签，在该注解中，可以配置一个类，这个类就会注册进 Spring 的容器，成为 Bean，你就可以在这个 bean 里做文章。<br>在 apollo 中，使用方式如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="meta">@Target(ElementType.TYPE)</span> <span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(ApolloConfigRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableApolloConfig &#123;</span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;ConfigConsts.NAMESPACE_APPLICATION&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 从上面可以看出 `ApolloConfigRegistrar` 类是 apollo 注册进的 bean。这个 bean 用于处理 <span class="meta">@EnableApolloConfig</span> 注解，同时注册 apollo 关键 Bean 到 Spring  容器中。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 用户只需在 Spring 系统中的某个类上，标注 <span class="meta">@EnableApolloConfig</span> ，就可以通过 Spring 的方式（自动更新，注解等）使用 apollo 功能。</span><br><span class="line"></span><br><span class="line">## 第三种入口：SpringBoot Starter</span><br><span class="line"></span><br><span class="line">目前最流行的框架就是 Spring Boot ，兼容 SpringBoot 是一个大趋势。</span><br><span class="line"></span><br><span class="line">Spring Boot 提供 `spring-boot-autoconfigure` 让第三方框架兼容 Boot，称之为 starter。</span><br><span class="line"></span><br><span class="line">创建一个 starter 需要遵守几个约定：</span><br><span class="line"><span class="number">1.</span> maven 引入 `spring-boot-autoconfigure` artifact.</span><br><span class="line"><span class="number">2.</span> 创建一个类，实现`ApplicationContextInitializer` 接口，重写 initialize 方法，该方法在容器初始化的时候调用。</span><br><span class="line"><span class="number">3.</span> META-INF 创建 `spring.factories` 文件，Boot 启动时会自动扫描这个文件。需要在这个文件中写入一个步骤 <span class="number">2</span> 创建的类，类似 `org.springframework.context.ApplicationContextInitializer=\com.ctrip.framework.apollo.spring.boot.ApolloApplicationContextInitializer`。这个类的作用是提前（容器初始化前）加载关键配置到 Spring 环境。</span><br><span class="line"><span class="number">4.</span> 在  `spring.factories`  文件中，还需要让 boot 的 `EnableAutoConfiguration` 自动配置类指向一个自定义类。**这是 SpringBoot  starter 的关键**，例如：`org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ctrip.framework.apollo.spring.boot.ApolloAutoConfiguration`。ApolloAutoConfiguration 就会加入的 apollo 的配置 bean 中。你可以在这个配置 bean 中，创建一个关键 bean ，用于处理系统相关的初始化类。例如 apollo 的方式：</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(PropertySourcesConstants.APOLLO_BOOTSTRAP_ENABLED)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(PropertySourcesProcessor.class)</span><span class="comment">// 当Spring Context中不存在该Bean时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConfigPropertySourcesProcessor <span class="title">configPropertySourcesProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConfigPropertySourcesProcessor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 apollo 中，<code>ConfigPropertySourcesProcessor</code> 就是用来注册系统关键 bean 的。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文重点介绍了 3 种入口：</p>
<ol>
<li>XML 方式，通过在 getBeanClass 方法返回系统关键 Bean。</li>
<li>@Import 注解，通过在注解中定义 Bean，然后在该 Bean 中处理。</li>
<li>SpringBoot Starter 方式，通过 <code>spring.factories</code> 文件中定义自动配置类，可以注册系统关键 bean。</li>
</ol>
<p>在以后的开发中，如果想融入 Spring，就可以通过这 3 种方式自行处理。</p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo-3-定时-长轮询拉取配置的设计</title>
    <url>/2018/06/30/2018/2018-06-30-Apollo-3-%E5%AE%9A%E6%97%B6-%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%8B%89%E5%8F%96%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ![Apollo 基础模型](https://upload-images.jianshu.io/upload_images/4236553-b852957c3897832b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如上图所示，Apollo portal 更新配置后，进行轮询的客户端获取更新通知，然后再调用接口获取最新配置。不仅仅只有轮询，还有定时更新（默认 5 分钟一次）。目的就是让客户端能够稳定的获取到最新的配置。</p>
<p>一起来看看他的设计。</p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>具体的类是 <code>RemoteConfigRepository</code>，每一个 Config —— 也就是 namespace 都有一个 RemoteConfigRepository 对象，表示这个 Config 的远程配置仓库，可以利用这个仓库请求远程服务，得到配置。</p>
<p>RemoteConfigRepository 的构造方法需要一个 <code>namespace</code> 字符串，表明这个 Repository 所属的 Config 名称。</p>
<p>下面是该类的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RemoteConfigRepository</span><span class="params">(String namespace)</span> </span>&#123;</span><br><span class="line">    m_namespace = namespace;<span class="comment">// Config 名称</span></span><br><span class="line">    m_configCache = <span class="keyword">new</span> AtomicReference&lt;&gt;(); <span class="comment">//  Config 引用</span></span><br><span class="line">    m_configUtil = ApolloInjector.getInstance(ConfigUtil.class);<span class="comment">// 单例的 config 配置,存放 application.properties</span></span><br><span class="line">    m_httpUtil = ApolloInjector.getInstance(HttpUtil.class);<span class="comment">// HTTP 工具</span></span><br><span class="line">    m_serviceLocator = ApolloInjector.getInstance(ConfigServiceLocator.class);<span class="comment">// 远程服务 URL 更新类</span></span><br><span class="line">    remoteConfigLongPollService = ApolloInjector.getInstance(RemoteConfigLongPollService.class);<span class="comment">// 长轮询服务</span></span><br><span class="line">    m_longPollServiceDto = <span class="keyword">new</span> AtomicReference&lt;&gt;();<span class="comment">// 长轮询发现的当前配置发生变化的服务</span></span><br><span class="line">    m_remoteMessages = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    m_loadConfigRateLimiter = RateLimiter.create(m_configUtil.getLoadConfigQPS());<span class="comment">// 限流器</span></span><br><span class="line">    m_configNeedForceRefresh = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);<span class="comment">// 是否强制刷新</span></span><br><span class="line">    m_loadConfigFailSchedulePolicy = <span class="keyword">new</span> ExponentialSchedulePolicy(m_configUtil.getOnErrorRetryInterval(),<span class="comment">//1</span></span><br><span class="line">        m_configUtil.getOnErrorRetryInterval() * <span class="number">8</span>);<span class="comment">// 1 * 8;失败定时重试策略: 最小一秒,最大 8 秒.</span></span><br><span class="line">    gson = <span class="keyword">new</span> Gson();<span class="comment">// json 序列化</span></span><br><span class="line">    <span class="keyword">this</span>.trySync(); <span class="comment">// 第一次同步</span></span><br><span class="line">    <span class="keyword">this</span>.schedulePeriodicRefresh();<span class="comment">// 定时刷新</span></span><br><span class="line">    <span class="keyword">this</span>.scheduleLongPollingRefresh();<span class="comment">// 长轮询刷新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在构造方法中，就执行了 3 个本地方法，其中就包括定时刷新和长轮询刷新。这两个功能在 apollo 的 github 文档中也有介绍：</p>
<blockquote>
<p>1.客户端和服务端保持了一个长连接，从而能第一时间获得配置更新的推送。<br>   2.客户端还会定时从Apollo配置中心服务端拉取应用的最新配置。<br>  3.这是一个fallback机制，为了防止推送机制失效导致配置不更新。<br>  4.客户端定时拉取会上报本地版本，所以一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified。<br>  5.定时频率默认为每5分钟拉取一次，客户端也可以通过在运行时指定System Property: apollo.refreshInterval来覆盖，单位为分钟。</p>
</blockquote>
<p>所以，长连接是更新配置的主要手段，然后用定时任务辅助长连接，防止长连接失败。</p>
<p>那就看看长连接和定时任务的具体代码。</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>定时任务主要由一个单 core 的线程池维护这定时任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 定时任务,单个 core. 后台线程</span></span><br><span class="line">    m_executorService = Executors.newScheduledThreadPool(<span class="number">1</span>,</span><br><span class="line">        ApolloThreadFactory.create(<span class="string">&quot;RemoteConfigRepository&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">schedulePeriodicRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认 5 分钟同步一次.</span></span><br><span class="line">    m_executorService.scheduleAtFixedRate(</span><br><span class="line">        <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            trySync();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, m_configUtil.getRefreshInterval(), m_configUtil.getRefreshInterval(),<span class="comment">// 5</span></span><br><span class="line">        m_configUtil.getRefreshIntervalTimeUnit());<span class="comment">//单位：分钟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体就是每 5 分钟执行 sync 方法。我简化了一下 sync 方法，一起看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ApolloConfig previous = m_configCache.get();</span><br><span class="line">  <span class="comment">// 加载远程配置</span></span><br><span class="line">  ApolloConfig current = loadApolloConfig();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//reference equals means HTTP 304</span></span><br><span class="line">  <span class="keyword">if</span> (previous != current) &#123;</span><br><span class="line">    m_configCache.set(current);</span><br><span class="line">    <span class="comment">// 触发监听器</span></span><br><span class="line">    <span class="keyword">this</span>.fireRepositoryChange(m_namespace, <span class="keyword">this</span>.getConfig());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，拿到上一个 config 对象的引用，然后，加载远程配置，判断是否相等，如果不相等，更新引用缓存，触发监听器。</p>
<p>可以看出，关键是加载远程配置和触发监听器，这两个操作。</p>
<p>loadApolloConfig 方法主要逻辑就是通过 HTTP 请求从 configService 服务里获取到配置。大概步骤如下：</p>
<ol>
<li>首先限流。获取服务列表。然后根据是否有更新通知，决定此次重试几次，如果有更新，重试2次，反之一次。</li>
<li>优先请求通知自己的 configService，如果失败了，就要进行休息，休息策略要看是否得到更新通知了，如果是，就休息一秒，否则按照 SchedulePolicy 策略来。</li>
<li>拿到数据后，重置强制刷新状态和失败休息状态，返回配置。</li>
</ol>
<p><strong>触发监听器步骤：</strong></p>
<ol>
<li>循环远程仓库的监听器，调用他们的 onRepositoryChange 方法。其实就是 Config。</li>
<li>然后，更新 Config 内部的引用，循环向线程池提交任务—— 执行 Config 监听器的 onChange 方法。</li>
</ol>
<p>好，到这里，定时任务就算处理完了，总之就是调用 sync 方法，请求远程  configServer 服务，得到结果后，更新 Config 对象里的配置，并通知监听器。</p>
<p>再来说说长轮询。</p>
<h2 id="长连接-长轮询"><a href="#长连接-长轮询" class="headerlink" title="长连接 / 长轮询"></a>长连接 / 长轮询</h2><p>长轮询实际上就是在一个类似死循环里，不停请求 ConfigServer 的配置变化通知接口 notifications/v2，如果配置有变更，就会返回变更信息，然后向定时任务线程池提交一个任务，任务内容是执行 sync 方法。</p>
<p>在请求 ConfigServer 的时候，ConfigServer 使用了 Servlet 3 的异步特性，将 hold 住连接 30 秒，等到有通知就立刻返回，这样能够实现一个基于 HTTP 的长连接。</p>
<p>关于为什么使用 HTTP 长连接，初次接触 Apollo 的人都会疑惑，为什么使用这种方式，而不是”那种”方式？</p>
<p>下面是作者宋顺的回复：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-fd8d97b7ee24aaa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>总结一下：</p>
<ol>
<li>为什么不使用消息系统？太复杂，杀鸡用牛刀。</li>
<li>为什么不用  TCP 长连接？对网络环境要求高，容易推送失败。且有双写问题。</li>
<li>为什么使用 HTTP 长轮询？性能足够，结合 Servlet3 的异步特性，能够维持万级连接（一个客户端只有一个长连接）。直接使用 Servlet 的 HTTP 协议，比单独用 TCP 连接方便。HTTP 请求/响应模式，保证了不会出现双写的情况。<strong>最主要还是简单，性能暂时不是瓶颈</strong>。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文没有贴很多的代码。因为不是一篇源码分析的文章。</p>
<p>总之，Apollo 的更新配置设计就是通过定时轮询和长轮询进行组合而来。</p>
<p>定时轮询负责调用获取配置接口，长轮询负责调用配置更新通知接口，长轮询得到结果后，将提交一个任务到定时轮询线程池里，执行同步操作——也就是调用获取配置接口。</p>
<p>为什么使用 HTTP 长轮询？ 简单！简单！简单！</p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo-4-客户端-SDK-设计</title>
    <url>/2018/06/30/2018/2018-06-30-Apollo-4-%E5%AE%A2%E6%88%B7%E7%AB%AF-SDK-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       之前聊了客户端的一些功能，例如融入 Spring， @value 注解的自动刷新实现，长轮询等，这次从客户端的整体设计来聊聊。

<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-d5a191546f35ad20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图是 client 项目的包结构。</p>
<p>其中，核心包就是 internals 包，包含了客户端的主要功能逻辑。主要有以下功能：<br>0. 获取 ConfigService 服务的远程配置。</p>
<ol>
<li>长轮询/定时轮询 ConfigService。</li>
<li>监听机制——更新后，立即通知应用程序。</li>
<li>兼容 Spring 各个版本（这个是在 spring 包中，但我认为也算重要功能 <code>^_^</code>）。</li>
</ol>
<h5 id="首先说第一个功能：获取-ConfigService-服务的远程配置："><a href="#首先说第一个功能：获取-ConfigService-服务的远程配置：" class="headerlink" title="首先说第一个功能：获取 ConfigService 服务的远程配置："></a>首先说第一个功能：<strong>获取 ConfigService 服务的远程配置</strong>：</h5><p>实现此功能的类为：RemoteConfigRepository。该类有以下几个重要的方法：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-96df10239dd861a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol>
<li>构造方法：该方法里包含了很多初始化的过程，虽然我觉得应该放在 init 之类的方法中</li>
<li>getConfig() 根据 namespace 获取配置</li>
<li>onLongPollNotified() 当收到长连接通知时触发响应</li>
<li>addChangeListener() 添加监听器</li>
<li>removeChangeListener() 删除监听器</li>
</ol>
<p>注意：setUpstreamRepository 是空的。看注释，是个 fallback 设计。</p>
<p>其中，getConfig 方法是获取这个 namespace 的配置，返回的是 Properties 对象（就是个 Map）。然后，从这个对象中取出对应的值，就 ok 了。</p>
<h5 id="第二个功能：长轮询-定时轮询-ConfigService。"><a href="#第二个功能：长轮询-定时轮询-ConfigService。" class="headerlink" title="第二个功能：长轮询/定时轮询 ConfigService。"></a>第二个功能：长轮询/定时轮询 ConfigService。</h5><p>这个功能的主要实现类是：RemoteConfigLongPollService。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9c7d5aa0ae07d75f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>该类主要的方法有 2 个，构造方法和 submit 方法。注意，这个类是单例的（由 google 的 inject 实现）。<br>构造方法中，做了很多的初始化工作。而 submit 方法则是开启长轮询，轮询的方式是：携带 AppId 去请求 ConfigServcie，得到所有的 namespace 更新通知，然后通知对应的  RemoteConfigRepository 去请求真正的数据。大概的设计如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c07a2f5cf49b663c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>每一个 namespace 在一个应用中，都对应一个 RemoteConfigRepository，所有的 RemoteConfigRepository 都归属 RemoteConfigLongPollService 长轮询服务管理，当长轮询得到通知，便通知对应的 RemoteConfigRepository 进行服务请求以便执行更新本地缓存和通知监听器操作。</p>
<p>通知，作为 fallback 方案—— 定时轮询也充当了长轮询失效的最后屏障。</p>
<h5 id="第三个功能：监听机制——更新后，立即通知应用程序。"><a href="#第三个功能：监听机制——更新后，立即通知应用程序。" class="headerlink" title="第三个功能：监听机制——更新后，立即通知应用程序。"></a>第三个功能：监听机制——更新后，立即通知应用程序。</h5><p>从上图可以看出，轮询之后，如果有更新响应，则立即通知 RemoteConfigRepository，然后，RemoteConfigRepository 再次从配置中心拉取配置，从而更新本地 Config 对象的内容。</p>
<p>更新完毕后，则通知 Config 的“配置变化监听器”。也就是 ConfigChangeListener 的 onChange 方法。这个监听器是监听 Config 对象的。</p>
<p>实际上，每个 Config 对象在初始化的时候，都会往 RemoteConfigRepository 对象里添加一个监听器，实际上就是添加自己。</p>
<p>当 RemoteConfigRepository 发生变化的时候，触发 onRepositoryChange 方法，onRepositoryChange 又会触发 onChange 方法。大概的设计图就是下面这个样子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4423ed2d7c5e51a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上图中，紫色的 DefaultConfig 是核心，他依赖了  RemoteConfigRepository， 而 RemoteConfigRepository 反过来组合了他，同时 DefaultConfig 也聚合了用户实现的监听器 ConfigChangeListener 的子类。</p>
<p>那么，当远程 Repository 变化的时候，就可以通知 Client 的缓存 Config 对象，而 Config 缓存对象变化的时候，就可以通知用户的程序（监听器）。实现整体的监听机制。</p>
<p>总的来说，就是通过两层监听机制来实现的。其中 DefaultConfig 实现了两个角色，既是观察者，也是被观察者。</p>
<h5 id="第四个功能：兼容-Spring-各个版本"><a href="#第四个功能：兼容-Spring-各个版本" class="headerlink" title="第四个功能：兼容 Spring 各个版本"></a>第四个功能：兼容 Spring 各个版本</h5><p>首先，如果没有这个功能，Apollo 也会能够正常运行的，不过，你只能使用 API 的方式，不能使用注解，标签等 Spring 应用熟悉的方式。</p>
<p>如果想用 Spring 的方式使用 Apollo ，那么就得遵守 Spring 的约定，实现 Spring 的接口，将自己融入到 Spring 中。</p>
<p>其中，主要解决的问题就是，如何在 Spring 初始化的时候，Apollo 也初始化？这点我们在之前的文章中说了，也就是 Spring 的 3 个入口。在这些入口里初始化。</p>
<p>另外，将配置放置到 Spring 的环境中，也是一个工作，因为，如果不放到环境中，Spring 初始时需要的那些参数就无法取到了。</p>
<p>所以，要将 Config 对象包装成 Spring 熟悉的 ConfigPropertySource 对象，算是一个适配器模式吧。</p>
<p>在初始化配置的时候，会从远程配置中心拿到配置，包装成 ConfigPropertySource 对象，再利用 CompositePropertySource 组合属性配置（多个 namespace）聚合所有 Config 对象。</p>
<p>CompositePropertySource 最后会添加到 ConfigurableEnvironment 环境对象中，spring 就可以从这个对象 中取出配置进行初始化。</p>
<p>并且，在 SpringBoot 环境下，Apollo 可以优先加载指定的配置，这些配置在 SpringContext 容器初始化的时候就开始被注入到环境中，这样就可以将一些系统初始化的配置也放到配置中心了，尽量让本地少一点配置。这个功能的启用需要参数：<code>apollo.bootstrap.enabled=true</code>，配置的namespace 则是 <code>apollo.bootstrap.namespaces = XXX</code>。</p>
<p>并且，该配置的优先级是最高的，Apollo 将这个配置放在了 Spring 环境对象中的第一个位置，当循环获取配置的时候，优先获取这个配置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，关于 Apollo 客户端的设计，大概就是这些，总体来讲比较简单， 4 个功能：</p>
<ol>
<li>获取远程配置</li>
<li>长轮询/定时轮询</li>
<li>配置更新监听机制。</li>
<li>兼容 Spring。</li>
</ol>
<p>抛出一个问题：</p>
<p>Apollo 似乎没有给用户留扩展接口？如果能像 Spring，Mybatis 一样，留一个或者多个切面给用户，让用户能够在加载配置的时候，做一些事情啥的，或许更好。</p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo-2-如何支持-@Value-注解自动更新</title>
    <url>/2018/06/30/2018/2018-06-30-Apollo-2-%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81-@Value-%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言
Apollo 在 v0.10.0 版本后，支持自动更新。v0.10.0之前的版本在配置变化后不会重新注入，需要重启才会更新。

<p>也就是说，如果一个属性加入了 @Value 注解，并且这个配置在配置中心也存在，那么，配置中心修改属性值后，就会自动更新这个值。同时，有个开关可以控制这个功能是否关闭（默认开启)。<br>配置文件中写入 <code>apollo.autoUpdateInjectedSpringProperties = false</code> 即可关闭该功能。</p>
<h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>此次提交的 PR 详情可见  <a href="https://codecov.io/gh/ctripcorp/apollo/pull/972/diff">https://codecov.io/gh/ctripcorp/apollo/pull/972/diff</a>.</p>
<p>大致先说下实现思路：</p>
<p>Apollo 实现了<code> BeanPostProcessor</code> 接口，这个接口的作用则是<code>每个 bean 初始化成前后做操作</code>。</p>
<p>在 <code>postProcessBeforeInitialization</code> 方法中，会取出这个 Bean 的所有属性和方法，并判断他们是否含有 <code>@Value</code> 注解从而进行<strong>处理</strong>。</p>
<p>具体处理逻辑，则是: 将符合条件的属性封装成一个  <code>SpringValue</code> 对象，放在一个<code> Map</code> 中。当 <code>clien</code> 检测到配置发生变化时，就会更新这个 <code>Map</code> 里面的值，从而达到自动更新的目的。</p>
<p>当然，这只是大概的思路，具体细节则要复杂一些。接下来我们就说说具体的实现细节。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p><strong>相关类</strong>：</p>
<ol>
<li><code>SpringValue</code> @Value 注解的详细信息数据结构。</li>
<li><code>SpringValueRegistry</code> @Value 注册中心，保存了他的 key/value 机构。</li>
<li><code>SpringValueDefinitionProcessor</code> 针对 Spring 3.x 版本做的特殊操作。</li>
<li><code>SpringValueProcessor</code> 处理 @Value 注解的类。</li>
<li><code>ConfigPropertySourcesProcessor</code> 注册 SpringValueProcessor 到容器。</li>
<li><code>PropertySourcesProcessor</code> 将 Config 和自动更新监听器绑定，同时注入 Spring 环境。</li>
</ol>
<p><strong>逻辑步骤</strong>：</p>
<ol>
<li><p>无论是 XML 方式，注解方式，SpringBoot 方式，都会触发注册机制，即自动注册 <code>SpringValueProcessor</code>  处理器到 Spring 容器（他主要是个 <code>BeanPostProcessor</code>）。这是 apollo 自定义的 <code>@Value</code> 处理器。</p>
</li>
<li><p>不仅仅注册 <code>SpringValueProcessor</code> ，还注册 <code>PropertySourcesProcessor</code>，这是一个 <code>BeanFactoryPostProcessor</code>，即在 Spring bean 工厂初始化后，可以进行修改的一个类。这里的时机比 <code>SpringValueProcessor</code> 早。</p>
</li>
<li><p><code>PropertySourcesProcessor</code> 在具体方法中，会初始化所有的 Config(<code>ConfigService.getConfig(namespace)</code>)，并设置到 Spring 的环境中（存储所有的 Property，且同名状态下优先级最高，目的是让 Spring 自己注入到变量中）。同时，创建一个自动更新监听器，监听所有的 Config。</p>
</li>
<li><p><code>SpringValueProcessor</code>  在容器初始化 Bean 的时候，会处理所有带有 <code>@Value</code> 注解的类，并放入到 <code>SpringValueRegistry</code> 的 Map 中。注意：<code>SpringValueRegistry</code> 是单例的。而 自动更新监听器 也是包含一个 <code>SpringValueRegistry</code> 的。因此，每当一个 Config 变化的时候，都会触发 change 事件，并调用监听器的 onChange 方法，如果匹配，该方法则会更新 <code>SpringValueRegistry</code>  内部的值——完成自动更新。</p>
</li>
<li><p>这里有个问题：所有的配置都放在 <code>SpringValueRegistry</code> 中，一个 client 会持有多个 <code>namespace</code>，每个 <code>namespace</code> 可能会有重名的配置。那么会不会发生冲突呢？实际上，apollo 考虑到了这点，在设计 <code>namespace</code> 的时候，就有一个 order 属性，用于处理这种情况，<strong>order 越小，优先级越高</strong>。当一个配置没有显时的设置 <code>namespace</code> 时，apollo 将其归纳为优先级最高的 <code>namespace</code>——即 order 最小的 <code>namespace</code>。而实现优先级的则是 <code>Spring PropertySource</code> 内部的排序机制，说白了就是一个 List，优先级最高的下标为0，当循环匹配的时候，优先匹配下标为0的配置。</p>
</li>
<li><p>在 <code>shouldTriggerAutoUpdate</code> 方法里，有个判断很绕：<code>根据 key 获取 Spring 环境中的配置值，判断这个值和刚刚发生的变化值是否相等，如果相等，就更新 value，反之，跳过此次事件</code>。<br>解释一下：<strong>我们知道，<code>@value</code> 对应的是优先级最高的 <code>namespace</code>，<code>environment </code>获取的也是优先级最高的 namespace 的配置。</strong><br>如果一个配置更新了，但 <code>environment</code> 优先级最高的配置却没有更新，那么 <code>@value</code> 对应的更新事件就不应该触发。<br>如果一个配置更新了，<code>environment</code> 获取到的优先级最高的配置也更新了，那么 <code>@value</code> 对应的更新时间就应该触发。<br>这里，其实就是 <code>@value</code> 是否更新的重要判断。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于这个小功能，为什么要单独拉出来说一说呢？实际上，该功能涉及到的东西还是很多的。例如：</p>
<ol>
<li>一个普通的 Java 项目如何和 Spring 框架融合 —— 注册，初始化，注入 Spring 环境等操作。</li>
<li>如何玩转 Spring 的 <code>PropertySource</code> 的 order 机制。</li>
<li>每一个 <code>namespace</code> 都有一个长轮询，发生更新后，apollo 触发监听器的更新事件，其中包括<code>自动更新监听器</code>，但是，需要通过 <code>shouldTriggerAutoUpdate</code> 的判断才能进行更新，因为 @value 可能会和多个 namespace 重名，需要通过优先级来过滤。即：如果 Spring 环境中优先级最高的 config 更新了，那么 <code>@value</code> 对应的 field 就需要更新，反之，不能更新（<code>namespace</code> 不匹配）。</li>
</ol>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo-5-教你怎么把自己的配置放到-Spring-环境中</title>
    <url>/2018/07/02/2018/2018-07-02-Apollo-5-%E6%95%99%E4%BD%A0%E6%80%8E%E4%B9%88%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E6%94%BE%E5%88%B0-Spring-%E7%8E%AF%E5%A2%83%E4%B8%AD/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录：
0. 前言
1. 处理方案
2. 简单例子

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的时候，你可能需要在 Spring 环境中放入一些配置，但这些配置无法写死在配置文件中，只能运行时放入。那么，这个时候该怎么办呢？</p>
<p>Apollo  就是搞配置的，那么自然会遇到这个问题，他是如何处理的呢？</p>
<h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><p>首先要知道 Spring 环境中，一个配置的数据结构是什么？</p>
<p>是抽象类 <code>PropertySource&lt;T&gt; </code>， 内部是个 key value 结构。这个 T 可以是任意类型，取决于子类的设计。</p>
<p>子类可以通过重写 getProperty 抽象方法获取配置。</p>
<p>Spring 自身的 org.springframework.core.env.MapPropertySource 就重写了这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapPropertySource</span> <span class="keyword">extends</span> <span class="title">EnumerablePropertySource</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MapPropertySource</span><span class="params">(String name, Map&lt;String, Object&gt; source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, source);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.source.get(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.source.containsKey(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] getPropertyNames() &#123;</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(<span class="keyword">this</span>.source.keySet());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，他的泛型是 Map，getProperty 方法则是从 Map 中获取。</p>
<p><strong>Apollo 就直接利用了这个类。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e67471ed5a73e2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>两个不同的子类，不同的刷新逻辑。我们暂时不关心他们的不同。</p>
<p>这两个类都会被 RefreshableConfig 组合，添加到 Spring 的环境中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.env.ConfigurableEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreshableConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ConfigurableEnvironment environment; <span class="comment">// Spring 环境</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略代码</span></span><br><span class="line">    <span class="keyword">for</span> (RefreshablePropertySource propertySource : propertySources) &#123;</span><br><span class="line">      propertySource.refresh();</span><br><span class="line">      <span class="comment">// 注意：成功刷新后，放到 Spring 的环境中</span></span><br><span class="line">      environment.getPropertySources().addLast(propertySource);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 省略代码</span></span><br></pre></td></tr></table></figure>

<p>当从 Spring 的环境中获取配置的时候，具体代码是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">            <span class="comment">// 注意：这里调用的就是 propertySource.getProperty 方法，子类刚刚重写的方法</span></span><br><span class="line">			Object value = propertySource.getProperty(key);</span><br><span class="line">             <span class="comment">// 省略无关代码........</span></span><br><span class="line">			<span class="keyword">return</span> convertValueIfNecessary(value, targetValueType);</span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 维护了一个 PropertySource 的集合，这个结合是有顺序的，也就是说，排在最前面的优先级最高（遍历从下标 0 开始）。</p>
<p>而用户可以在 PropertySource 里，维护一个配置字典（Map），这样，就类似 2 维数组的这样一个数据结构。</p>
<p>所以，配置是可以重名的，重名时，以最前面的 PropertySource 中的配置为准。所以，Spring 留给了几个 API：</p>
<ol>
<li>addFirst(PropertySource&lt;?&gt; propertySource)</li>
<li>addLast(PropertySource&lt;?&gt; propertySource)</li>
<li> addBefore(String relativePropertySourceName, PropertySource&lt;?&gt; propertySource)</li>
<li>addAfter(String relativePropertySourceName, PropertySource&lt;?&gt; propertySource) </li>
</ol>
<p>从名字可以看出，通过这些 API，我们可以将 propertySource 插入到我们指定的地方。从而可以手动控制配置的优先级。</p>
<p>Spring 中有个现成的 CompositePropertySource 类，内部聚合了一个 PropertySource Set 集合，当 getProperty(String name) 的时候，就会遍历这个集合，然后调用这个 propertySource 的 getProperty(name)  方法。相当于 3 维数组。</p>
<p>大概的设计是这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-bf02da7a86e22149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>一个环境中，有多个 PS（PropertySource 简称），每个 PS 可以直接包含配置，也可以再包装一层 PS。</p>
<h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>我们这里有个简单的例子，需求：<br>程序里有个配置，但不能写死在配置文件中，只能在程序启动过程中进行配置，然后注入到 Spring 环境中，让 Spring 在之后的 IOC 中，可以正常的使用这些配置。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;timeout:1&#125;&quot;)</span></span><br><span class="line">  String timeout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ApplicationContext c = SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(c.getBean(DemoApplication.class).timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.properties 配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">timeout=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们在 bean 中定义了一个属性 timeout， 并在本地配置文件中写入了一个 100 的值，也在表达式中给了一个默认值 1。</p>
<p>那么现在打印出来的就是配置文件中的值：100.</p>
<p>但是，这不是我们想要的结果，所以需要修改代码。</p>
<p>我们加入一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span>, <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">    ((ConfigurableEnvironment) environment).getPropertySources()</span><br><span class="line">        <span class="comment">// 这里是 addFirst,优先级高于 application.properties 配置</span></span><br><span class="line">        .addFirst(<span class="keyword">new</span> PropertySource&lt;String&gt;(<span class="string">&quot;timeoutConfig&quot;</span>, <span class="string">&quot;12345&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">// 重点</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">getProperty</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;timeout&quot;</span>)) &#123;<span class="comment">//</span></span><br><span class="line">              <span class="keyword">return</span> source;<span class="comment">// 返回构造方法中的 source :12345</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，结果：12345</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">54.315</span>  INFO <span class="number">43393</span> --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans <span class="keyword">for</span> JMX exposure on startup</span><br><span class="line"><span class="number">2018</span>-<span class="number">07</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">26</span>:<span class="number">54.327</span>  INFO <span class="number">43393</span> --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in <span class="number">0.991</span> seconds (JVM running <span class="keyword">for</span> <span class="number">1.49</span>)</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>为什么加入了这个类，就能够代替配置文件中的属性呢？解释一下这个类的作用。</p>
<p>我们要做的事情就是在 Spring 的环境中，插入自定义的 PS 对象，以便容器获取的时候，能够通过 getProperty 方法获取对应的配置。</p>
<p>所以，我们要拿到 Spring 环境对象，还需要创建一个 PS 对象，并重写 getProperty 方法，同时，注意：自己的 PS 配置优先级需要高于容器配置文件的优先级，保险起见，放在第一位。</p>
<p>PS 构造方法的第一个参数没什么用，就是一个标识符，第二个参数就是 source，可以定义为任何类型，String，Map，都可以，我们这里简单期间，就是一个 String，直接返回这个值，如果是 Map，就调用 Map 的 get 方法。</p>
<p>为什么要实现 BeanFactoryPostProcessor 接口呢？ 实现 BeanFactoryPostProcessor 接口的目的是让该 Bean 的加载时机提前，高于目标 Bean 的初始化。否则，目标 Bean 中的 timeout 属性都注入结束了，后面的操作就没有意义了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说白了，就是不想写配置文件！！！ </p>
<p>而且也不想改老项目的代码，老项目即使在删除配置文件的情况下，依然能够使用配置中心！</p>
<p>这就需要熟悉 Spring 的配置加载逻辑和属性获取逻辑。</p>
<p>现在，我们知道，只需要拿到 Spirng 的环境对象，并向环境中添加自定义的  PS 对象，重写 PS 的 getProperty 方法，即可获取配置（注意优先级）。</p>
<p>还需要注意加载这个配置的 bean 的优先级也要很高，通常实现 BeanFactoryPostProcessor 接口就足够了，如果还不够，就需要做一些特殊操作。</p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>异步 Servlet 和同步 Servlet 的性能测试</title>
    <url>/2018/07/10/2018/2018-07-10-%E5%BC%82%E6%AD%A5%20Servlet%20%E5%92%8C%E5%90%8C%E6%AD%A5%20Servlet%20%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>最近在看 Servlet 3 的异步特性，在网上看了一些文章，有些不解，遂做了一些测试，测试的模拟场景：<strong>Web 容器工作线程较少，接口逻辑复杂耗时</strong>。</p>
<p>这个场景是大部分的业务场景，例如：Tomcat 的工作线程是 200，业务接口需要远程 RPC 调用，或者访问数据库进行复杂计算等耗时操作。</p>
<p>所以，还是比较有参考价值的。</p>
<h2 id="如何测试？"><a href="#如何测试？" class="headerlink" title="如何测试？"></a>如何测试？</h2><p>工具：idea，jmeter。</p>
<p><strong>服务端 idea</strong>：SpringBoot 默认容器 Tomcat，修改线程数为 2，没错就是 2，为了放大工作线程较少的 场景。同时，准备两个接口：异步接口和同步接口，分别模拟耗时 500ms。</p>
<p>代码如下：</p>
<p>1, 异步接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;async&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> ExecutorService workerPool = Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;async&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">async</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DeferredResult&lt;String&gt; defer = <span class="keyword">new</span> DeferredResult&lt;&gt;((<span class="keyword">long</span>) <span class="number">120000</span>);</span><br><span class="line">    workerPool.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      defer.setResult(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> defer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2, 同步接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;sync&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTestDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> ExecutorService workerPool =  Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/sync&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Future&lt;String&gt; future = workerPool.submit(() -&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello sync&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> future.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3, Tomcat 配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">server.tomcat.max-threads</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>客户端 jmeter：开启 200 线程分别访问两个接口。得到聚合报告</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-83078c3561d7f1fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程组设置：200 线程"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-552f0a8aa1b8993e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异步请求设置"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-74d935e1f7dd7adf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步请求设置"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7f072d720b200574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="聚合报告"></p>
<p>从聚合报告可以看出，两者差距巨大。<br>平均响应时间相差 45 倍，90% 的响应时间相差 73 倍，99% 的响应时间相差 66 倍。</p>
<p>同步 Servlet 只有在最初的 2 个请求中，响应时间在 500ms 左右，之后，由于线程数不够，后面的请求开始线性延时，最大响应时间为 44 秒（最后一个请求）。同时，错误率达到 11.50%。平均响应时间为 24 秒。</p>
<p>而异步 Servlet 则非常的稳定，错误率为 0 ，所有的请求响应时间都控制在 500ms 到 680ms 之间，平均时间为 541 ms，由于 Tomcat 线程数只有 2 个，这个结果可以接受。90% 的响应时间也是在 600 毫秒左右，属于正常水平。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>异步 Servlet 发布已久，但似乎 Java 社区使用的人还是不多，不知为何？但异步带来的性能提升不言而喻。在服务器线程数较少，业务耗时的场景下，异步能明显提高系统吞吐量，线程数之外的请求不会像同步请求一样被拖慢。</p>
<p>实际上，这和 Netty 的最佳实践是类似的，永远不要在 IO 线程上做耗时任务，原则是：耗时任务丢进业务线程池，异步操作结束从 IO 线程返回或者直接返回。</p>
<p>防止 IO 线程阻塞，影响后面的请求。</p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo 6 — ConfigService 获取配置接口</title>
    <url>/2018/07/15/2018/2018-07-16-Apollo%206%20%E2%80%94%20ConfigService%20%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 大纲

<p>看本文之前，建议看看 apollo 的官方文档，特别是数据库设计文档。</p>
<ol>
<li>主流程分析</li>
</ol>
<p>2.1 聊聊细节</p>
<p>2.2 loadConfig() 加载配置</p>
<p>2.3 auditReleases() 方法记录此次访问详情</p>
<h2 id="1-主流程分析"><a href="#1-主流程分析" class="headerlink" title="1. 主流程分析"></a>1. 主流程分析</h2><p>具体代码在 <code>com.ctrip.framework.apollo.configservice.controller.ConfigController#queryConfig</code> 方法中。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个 . 号是防止 Spring 框架去除了 . 号后面的字符,例如 xxx.json, xxx.properties</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;appId&#125;/&#123;clusterName&#125;/&#123;namespace:.+&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApolloConfig <span class="title">queryConfig</span><span class="params">(<span class="meta">@PathVariable</span> String appId, <span class="meta">@PathVariable</span> String clusterName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@PathVariable</span> String namespace,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@RequestParam(value = &quot;dataCenter&quot;, required = false)</span> String dataCenter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@RequestParam(value = &quot;releaseKey&quot;, defaultValue = &quot;-1&quot;)</span> String clientSideReleaseKey,//<span class="number">20180704093033</span>-648d208dc9c1c9be</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@RequestParam(value = &quot;ip&quot;, required = false)</span> String clientIp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@RequestParam(value = &quot;messages&quot;, required = false)</span> String messagesAsString,//&#123;<span class="string">&quot;details&quot;</span>:&#123;<span class="string">&quot;SampleApp+default+application&quot;</span>:<span class="number">19</span>&#125;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                                HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  String originalNamespace = namespace;</span><br><span class="line">  <span class="comment">//strip out .properties suffix 剔除后缀</span></span><br><span class="line">  namespace = namespaceUtil.filterNamespaceName(namespace);</span><br><span class="line">  <span class="comment">//fix the character case issue, such as FX.apollo &lt;-&gt; fx.apollo</span></span><br><span class="line">  <span class="comment">// 改名字</span></span><br><span class="line">  namespace = namespaceUtil.normalizeNamespace(appId, namespace);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Strings.isNullOrEmpty(clientIp)) &#123;</span><br><span class="line">    clientIp = tryToGetClientIp(request);<span class="comment">// 获取客户端 IP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换成对象（目前没有地方用到？）</span></span><br><span class="line">  ApolloNotificationMessages clientMessages = transformMessages(messagesAsString);</span><br><span class="line"></span><br><span class="line">  List&lt;Release&gt; releases = Lists.newLinkedList();</span><br><span class="line"></span><br><span class="line">  String appClusterNameLoaded = clusterName;</span><br><span class="line">  <span class="comment">// appID 如果不是占位符号</span></span><br><span class="line">  <span class="keyword">if</span> (!ConfigConsts.NO_APPID_PLACEHOLDER.equalsIgnoreCase(appId)) &#123;</span><br><span class="line">    <span class="comment">// 获取发布信息</span></span><br><span class="line">    Release currentAppRelease = configService.loadConfig(appId, clientIp, appId, clusterName, namespace,</span><br><span class="line">        dataCenter, clientMessages);</span><br><span class="line">    <span class="keyword">if</span> (currentAppRelease != <span class="keyword">null</span>) &#123;</span><br><span class="line">      releases.add(currentAppRelease);<span class="comment">// 添加进集合</span></span><br><span class="line">      <span class="comment">//we have cluster search process, so the cluster name might be overridden 这个解释看不懂??? 集群搜索过程指的是?</span></span><br><span class="line">      appClusterNameLoaded = currentAppRelease.getClusterName();<span class="comment">// 使用release 的集群名称.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关联类型?</span></span><br><span class="line">  <span class="comment">//if namespace does not belong to this appId, should check if there is a public configuration</span></span><br><span class="line">  <span class="comment">// 如果命名空间不属于这个 appId, 那么应该检查他是否是公共配置</span></span><br><span class="line">  <span class="keyword">if</span> (!namespaceBelongsToAppId(appId, namespace)) &#123;</span><br><span class="line">    Release publicRelease = <span class="keyword">this</span>.findPublicConfig(appId, clientIp, clusterName, namespace,</span><br><span class="line">        dataCenter, clientMessages);<span class="comment">// 获取公共配置</span></span><br><span class="line">    <span class="keyword">if</span> (!Objects.isNull(publicRelease)) &#123;</span><br><span class="line">      releases.add(publicRelease);<span class="comment">// 添加进集合</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (releases.isEmpty()) &#123;<span class="comment">// 空的话,返回 404</span></span><br><span class="line">    response.sendError(HttpServletResponse.SC_NOT_FOUND,<span class="comment">//404</span></span><br><span class="line">        String.format(</span><br><span class="line">            <span class="string">&quot;Could not load configurations with appId: %s, clusterName: %s, namespace: %s&quot;</span>,</span><br><span class="line">            appId, clusterName, originalNamespace));</span><br><span class="line">    Tracer.logEvent(<span class="string">&quot;Apollo.Config.NotFound&quot;</span>,</span><br><span class="line">        assembleKey(appId, clusterName, originalNamespace, dataCenter));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auditReleases(appId, clusterName, dataCenter, clientIp, releases);<span class="comment">// 保存实例信息,(就是配置灰度规则时的ip选择列表+ 实例列表)</span></span><br><span class="line">  <span class="comment">// + 号拼接所有的 release key</span></span><br><span class="line">  String mergedReleaseKey = releases.stream().map(Release::getReleaseKey)</span><br><span class="line">          .collect(Collectors.joining(ConfigConsts.CLUSTER_NAMESPACE_SEPARATOR));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mergedReleaseKey.equals(clientSideReleaseKey)) &#123;<span class="comment">// 如果客户端那边的 key 和这边的 key 一致,则 304</span></span><br><span class="line">    <span class="comment">// Client side configuration is the same with server side, return 304</span></span><br><span class="line">    response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);<span class="comment">// 返回 304</span></span><br><span class="line">    Tracer.logEvent(<span class="string">&quot;Apollo.Config.NotModified&quot;</span>,</span><br><span class="line">        assembleKey(appId, appClusterNameLoaded, originalNamespace, dataCenter));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// releaseKey 不一致,则创建 config 对象返回.</span></span><br><span class="line">  ApolloConfig apolloConfig = <span class="keyword">new</span> ApolloConfig(appId, appClusterNameLoaded, originalNamespace,</span><br><span class="line">      mergedReleaseKey);</span><br><span class="line">  apolloConfig.setConfigurations(mergeReleaseConfigurations(releases));<span class="comment">// 合并所有的配置, 其中,私有配置优先公共配置</span></span><br><span class="line"></span><br><span class="line">  Tracer.logEvent(<span class="string">&quot;Apollo.Config.Found&quot;</span>, assembleKey(appId, appClusterNameLoaded,</span><br><span class="line">      originalNamespace, dataCenter));</span><br><span class="line">  <span class="keyword">return</span> apolloConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码有点长，具体细节等下慢慢聊，这里说说主要逻辑：</p>
<ol>
<li><p>调整 namespace 的名字。获取客户端 IP（为了灰度）。</p>
</li>
<li><p>判断 appId 是不是占位符。如果不是，就尝试加载该 AppId 下的 Cluster 下的 namespace 的 release 配置。并添加进结果集。</p>
</li>
<li><p>判断是否是公共 namespac， 假设这个 namespace 不属于当前 AppId，那么就是公共配置，需要加载公共配置（通常就是管理的 namespace）。<strong>注意：这个时候，可能会有 2 个结果集：当前 AppId 发布的<code>重写公共配置的配置 </code>+ 公共配置。</strong></p>
</li>
<li><p>如果结果集合是空，返回 404。</p>
</li>
<li><p>auditReleases 方法会异步的保存此次客户端获取配置的详细信息到数据库中，portal 页面就可以看到这些信息了。</p>
</li>
<li><p>比较服务端的 key 和客户端的 key 是否相同，因为每次发布配置都会有一个唯一的 key 生成，这里比较一下，就可以知道配置是否发生更改，如果相同，返回  304.</p>
</li>
<li><p>如果不同，构造一个 Config 对象返回给客户端。这里有个注意的地方: <code>mergeReleaseConfigurations</code> 方法会将 release 集合反转一下，目的是让私有的重写配置优先于公共的配置。</p>
</li>
</ol>
<p>目前来看，不是很复杂，主要就是根据指定的 namespace 加载配置，并和客户端的 key 进行比较。如果不同，就返回新的配置。</p>
<h2 id="2-1-聊聊细节"><a href="#2-1-聊聊细节" class="headerlink" title="2.1 聊聊细节"></a>2.1 聊聊细节</h2><p>步骤1，2 都是处理 namespace，大小写，后缀什么的，优先使用服务端的名称。</p>
<p>转换了 messagesAsString 为 ApolloNotificationMessages 对象，目前没用到。</p>
<p>可以看到，比较重要的方法就是 configService.loadConfig 方法。这个方法是获取配置的核心方法。下面的获取公共配置的 findPublicConfig 方法内部也是调用的此方法。</p>
<p>然后还有 auditReleases 方法，这个其实就是记录此次客户端获取配置的详细信息的。</p>
<p>然后还有一个反转方法。这个很简单，大家可以自己看看。</p>
<p>先看看 configService.loadConfig  方法。</p>
<h2 id="2-2-loadConfig-加载配置"><a href="#2-2-loadConfig-加载配置" class="headerlink" title="2.2 loadConfig() 加载配置"></a>2.2 loadConfig() 加载配置</h2><p>说方法之前，先看看 ConfigService 这个接口。最上层的是监听器接口，用于监听消息变化。然后是 ConfigService 接口，定义 loadConfig 方法并返回 release 对象。</p>
<p>最下面是具体实现类，抽象类是用了模板模式，定义了获取配置的骨架，下面则有 2 个实现类，一个基于缓存，一个基于 DB。默认是 DB。具体使用哪个类要看 server_config 表里的配置，配置的 key 是 <code> config-service.cache.enabled</code>，value 要么 true 要么 false。</p>
<p>注意，使用缓存很耗费内存，小心 OOM 哦。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-91250356549325a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>看看抽象类里 loadConfig 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Release <span class="title">loadConfig</span><span class="params">(String clientAppId, String clientIp, String configAppId, String configClusterName,</span></span></span><br><span class="line"><span class="params"><span class="function">    String configNamespace, String dataCenter, ApolloNotificationMessages clientMessages)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// load from specified cluster fist  如果不是默认的 cluster(私有或者灰度)</span></span><br><span class="line">  <span class="keyword">if</span> (!Objects.equals(ConfigConsts.CLUSTER_NAME_DEFAULT, configClusterName)) &#123;</span><br><span class="line">    Release clusterRelease = findRelease(clientAppId, clientIp, configAppId, configClusterName, configNamespace,</span><br><span class="line">        clientMessages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Objects.isNull(clusterRelease)) &#123;</span><br><span class="line">      <span class="keyword">return</span> clusterRelease;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// try to load via data center 试图通过数据中心获取</span></span><br><span class="line">  <span class="keyword">if</span> (!Strings.isNullOrEmpty(dataCenter) &amp;&amp; !Objects.equals(dataCenter, configClusterName)) &#123;</span><br><span class="line">    Release dataCenterRelease = findRelease(clientAppId, clientIp, configAppId, dataCenter, configNamespace,</span><br><span class="line">        clientMessages);</span><br><span class="line">    <span class="keyword">if</span> (!Objects.isNull(dataCenterRelease)) &#123;</span><br><span class="line">      <span class="keyword">return</span> dataCenterRelease;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fallback to default release 从默认的 cluster 获取</span></span><br><span class="line">  <span class="keyword">return</span> findRelease(clientAppId, clientIp, configAppId, ConfigConsts.CLUSTER_NAME_DEFAULT, configNamespace,</span><br><span class="line">      clientMessages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：首先加载私有/灰度的 cluster，这个就是客户端配置文件里的 <code>apollo.cluster</code> 配置， 然后再加载 <code>server.properties</code> 配置文件的 idc 属性，最后加载默认的。</p>
<p>他们的优先级如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b220502cf8731b27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自 apollo wiki"></p>
<p>细心的你可以发现，3 个 if 判断力都是调用的 findRelease 方法，只是第四个参数不同，这个参数就是 configClusterName —— 不同的 cluster。</p>
<p>这个方法首先或加载灰度的，然后再加载普通的。所以，客户端的 IP 就显得重要了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> Release <span class="title">findRelease</span><span class="params">(String clientAppId, String clientIp, String configAppId, String configClusterName,</span></span></span><br><span class="line"><span class="params"><span class="function">      String configNamespace, ApolloNotificationMessages clientMessages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取灰度release id, 从应用的缓存中获取规则.</span></span><br><span class="line">    Long grayReleaseId = grayReleaseRulesHolder.findReleaseIdFromGrayReleaseRule(clientAppId, clientIp, configAppId,</span><br><span class="line">        configClusterName, configNamespace);</span><br><span class="line"></span><br><span class="line">    Release release = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (grayReleaseId != <span class="keyword">null</span>) &#123;<span class="comment">// 如果有灰度</span></span><br><span class="line"><span class="comment">//      return releaseRepository.findByIdAndIsAbandonedFalse(releaseId);// 没有放有回滚的发布</span></span><br><span class="line">      release = findActiveOne(grayReleaseId, clientMessages); <span class="comment">// 获取灰度 release</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (release == <span class="keyword">null</span>) &#123;<span class="comment">// 如果没有发布的新灰度</span></span><br><span class="line">      <span class="comment">// 获取最新的普通的发布活动</span></span><br><span class="line">      release = findLatestActiveRelease(configAppId, configClusterName, configNamespace, clientMessages);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 灰度 --&gt; 最新的</span></span><br><span class="line">    <span class="keyword">return</span> release;</span><br><span class="line">  &#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">步骤：调用` grayReleaseRulesHolder `的`findReleaseIdFromGrayReleaseRule ` 方法获取灰度发布 ID。当然，这也是个缓存。</span><br><span class="line"></span><br><span class="line">如果有灰度，则根据 id 获取对应的 release 信息，得到配置，release 里面包含了全量的配置信息（从数据库获取）。</span><br><span class="line"></span><br><span class="line">如果没有灰度，则获取最新的普通的发布信息（从数据库获取）。</span><br><span class="line"></span><br><span class="line">关键在于获取灰度 id。</span><br><span class="line"></span><br><span class="line">看看这个方法：</span><br><span class="line"></span><br><span class="line">```<span class="function">java</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> Long <span class="title">findReleaseIdFromGrayReleaseRule</span><span class="params">(String clientAppId, String clientIp, String</span></span></span><br><span class="line"><span class="params"><span class="function">      configAppId, String configCluster, String configNamespaceName)</span> </span>&#123;</span><br><span class="line">    String key = assembleGrayReleaseRuleKey(configAppId, configCluster, configNamespaceName);<span class="comment">// 组装 key</span></span><br><span class="line">    <span class="keyword">if</span> (!grayReleaseRuleCache.containsKey(key)) &#123;<span class="comment">// 从缓存中获取, 缓存是个 handler 监听器 + 定时任务</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//create a new list to avoid ConcurrentModificationException 如果存在,就处理</span></span><br><span class="line">    List&lt;GrayReleaseRuleCache&gt; rules = Lists.newArrayList(grayReleaseRuleCache.get(key));</span><br><span class="line">    <span class="keyword">for</span> (GrayReleaseRuleCache rule : rules) &#123;</span><br><span class="line">      <span class="comment">//check branch status 必须是激活的状态</span></span><br><span class="line">      <span class="keyword">if</span> (rule.getBranchStatus() != NamespaceBranchStatus.ACTIVE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;<span class="comment">// 如果匹配上了 ip 和 客户端的 appId, 就返回</span></span><br><span class="line">      <span class="keyword">if</span> (rule.matches(clientAppId, clientIp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> rule.getReleaseId();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>步骤：首先用 + 号将 appId，cluster，namespace 拼接，再从缓存中获取，获取的是该 key 对应的灰度规则。</p>
<p>而缓存由一个定时任务更新（60s） + 监听器更新。</p>
<p>如果存在，就循环比较规则，如果规则是激活状态，且 appId 和 ip 和当前客户端匹配，那么就返回这个灰度的 release Id。</p>
<p><strong>这个就是得到灰度 release Id 的具体逻辑，可以看到，这里是优先加载灰度的。</strong></p>
<p>那么这个定时任务 + 监听器具体是怎么样的呢？</p>
<p>刚刚说了，定时任务是 60 s 一次，相对于配置中心来说，及时性肯定是不够的，所以，他更多的是一种补偿措施，即监听器失效了，定时任务能够保证 60s 内配置是最新的。</p>
<p>而监听器才是最新的配置。具体方法则是 handleMessage 方法。这个方法会得到一个发布消息，包含 appId + clusterName + namespace，有了这个信息，就可以得到 release 信息了。</p>
<p>每当发布一个配置 ，或回滚一个配置，都会发送一个消息到数据库，ConfigService 会扫描得到这个消息，然后通知所有的监听器。执行监听器的 handlerMessage 方法。</p>
<p>在灰度规则监听器中，会检查灰度发布规则表，根据消息的内容（<code>appId + cluster + namespace 组成的唯一 namespace key</code>）并进行处理，处理的逻辑则是更新缓存中的规则内容。</p>
<p><strong>总结一下这个 loadConfig 方法：</strong></p>
<blockquote>
<p>这是 ConfigService 接口定义的方法，由 一个抽象类和 2 个派生类组成，默认使用 DB 模式的派生类，抽象类定义了 loadConfig 的方法骨架，利用模板模式，2 个子类可以根据自己的特性返回数据 —— release。loadConfig 里，在获取 release 的时候，会有一个查找顺序，首先找私有/灰度的 cluster，然后找 idc（这个一般公司用不到，携程内部的特性），最后找默认的。而他们调用的 findRelease 方法内部也会有一个查找顺序：首先根据灰度规则查找灰度发布 ID，如果没有，查找默认的最新发布 —— 也就是灰度的规则比默认的规则高。</p>
</blockquote>
<h2 id="2-3-auditReleases-方法记录此次访问详情"><a href="#2-3-auditReleases-方法记录此次访问详情" class="headerlink" title="2.3 auditReleases() 方法记录此次访问详情"></a>2.3 auditReleases() 方法记录此次访问详情</h2><p>这个方法主要是调用 instanceConfigAuditUtil 的 audit 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">auditReleases</span><span class="params">(String appId, String cluster, String dataCenter, String clientIp,</span></span></span><br><span class="line"><span class="params"><span class="function">                           List&lt;Release&gt; releases)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Strings.isNullOrEmpty(clientIp)) &#123;</span><br><span class="line">    <span class="comment">//no need to audit instance config when there is no ip</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Release release : releases) &#123;</span><br><span class="line">    instanceConfigAuditUtil.audit(appId, cluster, dataCenter, clientIp, release.getAppId(),</span><br><span class="line">        release.getClusterName(),</span><br><span class="line">        release.getNamespaceName(), release.getReleaseKey());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里的判断，如果没有 ip， 就不记录了。这里用的是 aduit 审计的概念，我想就是类似记录吧，方便后面进行复盘，查看啥的。</p>
<p>而这个 audit 方法具体的内容则是：构造一个 InstanceConfigAuditModel 对象放到一个阻塞队列中，由另一个线程异步处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">audit</span><span class="params">(String appId, String clusterName, String dataCenter, String</span></span></span><br><span class="line"><span class="params"><span class="function">      ip, String configAppId, String configClusterName, String configNamespace, String releaseKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.audits.offer(<span class="keyword">new</span> InstanceConfigAuditModel(appId, clusterName, dataCenter, ip,</span><br><span class="line">        configAppId, configClusterName, configNamespace, releaseKey));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 长度为 10000 的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> BlockingQueue&lt;InstanceConfigAuditModel&gt; audits = Queues.newLinkedBlockingQueue</span><br><span class="line">      (<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<p>那么异步执行的内容是怎么样的呢？</p>
<p>当然要看队列 poll 或者 take 后做什么了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  auditExecutorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!auditStopped.get() &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        InstanceConfigAuditModel model = audits.poll();</span><br><span class="line">        <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        doAudit(model);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Tracer.logError(ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类实现了 Spring 的 InitializingBean 接口，重写了 afterPropertiesSet 方法，这个方法会在属性注入完毕后执行。</p>
<p>方法其实就是提交了一个任务，任务内容则是从队列中取出对象，然后执行 doAudit 方法。如果取出是空，休眠 1 秒。</p>
<p>这个方法的主要内容就是更新客户端访问信息，或者创建客户端访问信息。使用 2 个缓存，存储 instanceId 和 releaseKey，这个是为了提高校验数据的性能。</p>
<p>而这个实例在数据库是这样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d4b127c8616a00d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Instance 表"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a9756f415935b821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InstanceConfig 表"></p>
<p>从 Instance 表结构看，记录是每台机器最新访问的记录，而 InstanceConfig 则是记录的此次访问的具体 namespace 的 发布信息。</p>
<p>对应的是控制台的实例列表：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-80cb0841855353b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6be410c980026a7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>关于这个方法的具体内容我就不贴了，感兴趣的可以自己看看，主要内容就是记录 Instance 的访问信息用于后台审计查看。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，apollo 客户端访问 ConfigService 获取配置的大概思路和具体细节就介绍完了。这里总结一下。</p>
<ol>
<li><p>获取配置的时候，可能会有 2 个结果集（关联类型），那么会将私有的优先（放到前面）。如果集合是空，返回 404 ，如果没有新的发布信息，返回 304.</p>
</li>
<li><p>当服务器加载配置信息的时候，有几个顺序，特别是集群的顺序：私有/灰度 cluster （apollo.cluster）—-&gt; 数据中心（server.properties 的 idc）—–&gt; 默认的 cluster。同时，加载集群内部配置的时候，也会优先加载灰度的配置（根据 IP），然后才是默认的配置。</p>
</li>
<li><p>最后，会记录此次访问的信息，方便后台审计。如果是 10 分钟之内访问的，即不会更新。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo 7 — ConfigService 消息扫描设计实现</title>
    <url>/2018/07/16/2018/2018-07-17-Apollo%207%20%E2%80%94%20ConfigService%20%E6%B6%88%E6%81%AF%E6%89%AB%E6%8F%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 目录

<ol>
<li>设计</li>
<li>代码实现</li>
<li>总结</li>
</ol>
<h2 id="1-设计"><a href="#1-设计" class="headerlink" title="1.设计"></a>1.设计</h2><p>Apollo 为了减少依赖，将本来 MQ 的职责转移到了 Mysql 中。具体表现为 Mysql  中的 ReleaseMessage 表。</p>
<p>具体官方文档可见：<a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1#211-%E5%8F%91%E9%80%81releasemessage%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">发送ReleaseMessage的实现方式</a></p>
<p>用张图简单的来表示一下 ：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6d2573985f45307c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>有人肯定要问了，为什么 Admin Service 和 Config Service 不放在一起呢？我曾提过 issue 问过作者，大概的答案是：两者职责不同，部署的实例数也不同，通常 Admin 会少一些，因为只服务于 Portal，而 Config 则要部署的多一些，因为需要服务于 Client。</p>
<p>第二则是两者的开发节奏也是不一样，Config Service 的更新会影响客户端，而 Admin 的更新则是影响 Portal，所以，分开他们，对服务的部署可以更加细粒度。</p>
<p>关于这个 issue：<a href="https://github.com/ctripcorp/apollo/issues/1204">为什么 admin 和 config 不合在一起呢 </a></p>
<p>高可用的话，可参考下图或链接 <a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1#%E5%9B%9B%E5%8F%AF%E7%94%A8%E6%80%A7%E8%80%83%E8%99%91">可用性考虑</a>:<br><img src="https://upload-images.jianshu.io/upload_images/4236553-90043d3f9fdc395b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>扯远了。</p>
<p>回到我们之前说的，之所以要使用 Mysql，是因为要减少依赖，为了替代 MQ，而之所以要使用 MQ，是为了解耦 Config 和 Admin，而之所以要使用 Config 和 Admin，则是因为设计，部署，开发节奏等原因。</p>
<p>那么，基于 Mysql 的消息的实现是怎么弄的呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c1122096ce2191a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上面是 apollo 文档对于<code>发送ReleaseMessage的实现方式</code>的描述。</p>
<p>我们来看看代码实现. </p>
<h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><p>在 <code>com.ctrip.framework.apollo.biz.message</code> 包下，有关于消息的实现，</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-da2a33db3c377dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>麻雀虽小，五脏俱全。</p>
<ol>
<li><p>MessageSender 接口定义了一个方法：<code>void sendMessage(String message, String channel);</code><br>这个 channel 就是 topic 了。 message 就是消息的具体内容了。</p>
</li>
<li><p>目前只有一个实现类 <code>DatabaseMessageSender</code>， 基于数据库的消息发送。就是把消息保存到 ReleaseMessage 表中。</p>
</li>
<li><p>Topics 定义消息主题，目前只有一个：<code>apollo-release</code>。</p>
</li>
<li><p>ReleaseMessageListener 消息监听器接口，定义了一个方法：<code>void handleMessage(ReleaseMessage message, String channel)</code>，需要实现此方法并注册到扫描器中，当有新的消息时，便会通知监听器。</p>
</li>
<li><p>ReleaseMessageScanner 消息扫描器，用于扫描数据库的 ReleaseMessage 表，如果有新数据，则通知监听器。</p>
</li>
</ol>
<p>目前监听器有以下实现：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ef4f3d5f64d33763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从左到右：</p>
<ol>
<li>ReleaseMessageServiceWithCache，ReleaseMessage 的缓存，用于长轮询判断是否以后新的消息。</li>
<li>GrayReleaseRulesHolder，灰度规则变化监听器。</li>
<li>ConfigService，分为缓存和默认，默认的 handleMessage 方法什么都不做，缓存实现则会对 cache 热身。</li>
<li>NotificationControllerV2 监听器，当客户端被长连接 Hold 住时，消息如果更新则唤醒客户端立即返回，保证及时性。</li>
<li>NotificationController 已废弃，不谈了。</li>
</ol>
<p>所以，每当 ReleaseMessageScanner 得到新的消息，都会触发这些监听器。这些监听器在哪里被添加的呢？</p>
<p>位置:<code>com.ctrip.framework.apollo.configservice.ConfigServiceAutoConfiguration.java</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-75508923db204cb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>ReleaseMessageScanner 的 afterPropertiesSet 方法会启动一个间隔 1 秒定时任务，执行 scanMessages 方法。</p>
<p>具体方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">scanAndSendMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//current batch is 500 批处理 500 条</span></span><br><span class="line">    <span class="comment">// 根据 maxIdScanned 找到比这个 id 大的 500 条数据,</span></span><br><span class="line">    List&lt;ReleaseMessage&gt; releaseMessages =</span><br><span class="line">        releaseMessageRepository.findFirst500ByIdGreaterThanOrderByIdAsc(maxIdScanned);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(releaseMessages)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始通知 handleMessage 监听器</span></span><br><span class="line">    fireMessageScanned(releaseMessages);</span><br><span class="line">    <span class="keyword">int</span> messageScanned = releaseMessages.size();<span class="comment">// 消息数量</span></span><br><span class="line">    maxIdScanned = releaseMessages.get(messageScanned - <span class="number">1</span>).getId();<span class="comment">// 更新最大 id</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> messageScanned == <span class="number">500</span>;<span class="comment">// 如果不足 500, 说明没有新消息了</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>方法很简单，首先根据最大的扫描 Id  找到 500 条消息，对这 500 条消息进行批处理，触发监听器。最后更新最大扫描 Id。如果此次取出的数据量超过 500 条，则认为还有数据，就继续处理。</p>
<p>很明显，每次处理这么多消息肯定很耗时，那么假设处理这些消息要 5 秒，那么定时任务的间隔是多少了呢？答：6 秒。因为定时任务的模式是 scheduleWithFixedDelay 模式，固定的间隔，以当前任务结束时间 + period 时间作为下一个任务的开始时间。</p>
<p>那么，admin 什么时候会向数据库发送消息（保存 ReleaseMessage）呢?</p>
<p>那么就要查看 sendMessage 方法被哪些地方调用就好了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e29490700794ebc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol>
<li><p>NamespaceBranchController</p>
</li>
<li><p>1 更新灰度规则 <code>updateBranchGrayRules</code></p>
</li>
<li><p>2 删除灰度分支 <code>deleteBranch</code></p>
</li>
<li><p>NamespaceService</p>
</li>
<li><p>1 删除命名空间 <code> NamespaceController#deleteNamespace</code></p>
</li>
<li><p>2 删除集群 <code>ClusterController#delete</code></p>
</li>
<li><p>3 删除灰度 <code>NamespaceBranchController#deleteBranch </code></p>
</li>
<li><p>4 删除命名空间分支<code>NamespaceService#deleteNamespace </code></p>
</li>
<li><p>ReleaseController</p>
</li>
<li><p>1 主/灰版本发布 <code>publish</code></p>
</li>
<li><p>2 全量发布 <code>updateAndPublish</code></p>
</li>
<li><p>3 回滚 <code>rollback </code></p>
</li>
</ol>
<p>这些地方被触发的时候，都会发送消息到数据库。因此，可能会重复触发，导致 ConfigService 重复消费。。。例如在放弃灰度和全量发布的时候，就会重复发送消息。</p>
<p>笔者就这个问题提了 issue，期待官方 fix 这个 bug。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本文重点分析了 apollo 关系消息这块的设计： 每当有 app， cluster，namespace， Release 等操作的时候，都会发送消息到数据库，ConfigService 会定时扫描数据库，有新消息了，就会立即通知各个监听器，确保配置实时推送到客户端。</p>
<p>同时，我们也发现了一个 bug，就是会重复发送消息，引起重复消费。</p>
<p>迫于种种限制，apollo 使用了这种设计，获取，如果可以使用 MQ 的话，一切会更加的简单。</p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo 8 — ConfigService 异步轮询接口的实现</title>
    <url>/2018/07/17/2018/2018-07-18-Apollo%208%20%E2%80%94%20ConfigService%20%E5%BC%82%E6%AD%A5%E8%BD%AE%E8%AF%A2%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ##  源码

<p>Apollo 长轮询的实现，是通过客户端轮询 <code>/notifications/v2</code> 接口实现的。具体代码在 com.ctrip.framework.apollo.configservice.controller.NotificationControllerV2.java。</p>
<p>这个类也是实现了 ReleaseMessageListener 监控，表明他是一个消息监听器，当有新的消息时，就会调用他的 hanlderMessage 方法。这个具体我们后面再说。</p>
<p>该类只有一个 rest 接口： pollNotification 方法。返回值是 DeferredResult，这是 Spring 支持 Servlet 3 的一个类，关于异步同步的不同，可以看笔者的另一篇文章 <a href="http://thinkinjava.cn/2018/07/%E5%BC%82%E6%AD%A5-Servlet-%E5%92%8C%E5%90%8C%E6%AD%A5-Servlet-%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">异步 Servlet 和同步 Servlet 的性能测试</a>。</p>
<p>该接口提供了几个参数：</p>
<ol>
<li>appId appId</li>
<li>cluster 集群名称</li>
<li>notificationsAsString 通知对象的 json 字符串</li>
<li>dataCenter，idc 属性</li>
<li>clientIp 客户端 IP， 非必传，为了扩展吧估计</li>
</ol>
<p>大家有么有觉得少了什么？ namespace 。</p>
<p>当然，没有 namespace 这个重要的参数是不存在的。</p>
<p>参数在 notificationsAsString 中。客户端会将自己所有的  namespace 传递到服务端进行查询。</p>
<p>是时候上源码了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line">  <span class="keyword">public</span> DeferredResult&lt;ResponseEntity&lt;List&lt;ApolloConfigNotification&gt;&gt;&gt; pollNotification(</span><br><span class="line">      <span class="meta">@RequestParam(value = &quot;appId&quot;)</span> String appId,<span class="comment">// appId</span></span><br><span class="line">      <span class="meta">@RequestParam(value = &quot;cluster&quot;)</span> String cluster,<span class="comment">// default</span></span><br><span class="line">      <span class="meta">@RequestParam(value = &quot;notifications&quot;)</span> String notificationsAsString,<span class="comment">// json 对象 List&lt;ApolloConfigNotification&gt;</span></span><br><span class="line">      <span class="meta">@RequestParam(value = &quot;dataCenter&quot;, required = false)</span> String dataCenter,<span class="comment">// 基本用不上, idc 属性</span></span><br><span class="line">      <span class="meta">@RequestParam(value = &quot;ip&quot;, required = false)</span> String clientIp) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;ApolloConfigNotification&gt; notifications =<span class="comment">// 转换成对象</span></span><br><span class="line">          gson.fromJson(notificationsAsString, notificationsTypeReference);</span><br><span class="line">          </span><br><span class="line">    <span class="comment">// Spring 的异步对象: timeout 60s, 返回304</span></span><br><span class="line">    DeferredResultWrapper deferredResultWrapper = <span class="keyword">new</span> DeferredResultWrapper();</span><br><span class="line">    Set&lt;String&gt; namespaces = Sets.newHashSet();</span><br><span class="line">    Map&lt;String, Long&gt; clientSideNotifications = Maps.newHashMap();</span><br><span class="line">    Map&lt;String, ApolloConfigNotification&gt; filteredNotifications = filterNotifications(appId, notifications);<span class="comment">// 过滤一下名字</span></span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, ApolloConfigNotification&gt; notificationEntry : filteredNotifications.entrySet()) &#123;</span><br><span class="line">      <span class="comment">// 拿出 key</span></span><br><span class="line">      String normalizedNamespace = notificationEntry.getKey();</span><br><span class="line">      <span class="comment">// 拿出 value</span></span><br><span class="line">      ApolloConfigNotification notification = notificationEntry.getValue();</span><br><span class="line">      <span class="comment">/* 添加到 namespaces Set */</span></span><br><span class="line">      namespaces.add(normalizedNamespace);</span><br><span class="line">      <span class="comment">// 添加到 client 端的通知, key 是 namespace, values 是 messageId</span></span><br><span class="line">      clientSideNotifications.put(normalizedNamespace, notification.getNotificationId());</span><br><span class="line">      <span class="comment">// 如果不相等, 记录客户端名字</span></span><br><span class="line">      <span class="keyword">if</span> (!Objects.equals(notification.getNamespaceName(), normalizedNamespace)) &#123;</span><br><span class="line">        <span class="comment">// 记录 key = 标准名字, value = 客户端名字</span></span><br><span class="line">        deferredResultWrapper.recordNamespaceNameNormalizedResult(notification.getNamespaceName(), normalizedNamespace);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="comment">// 记在 namespaces 集合, clientSideNotifications 也put (namespace, notificationId)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组装得到需要观察的 key,包括公共的.</span></span><br><span class="line">    Multimap&lt;String, String&gt; watchedKeysMap =</span><br><span class="line">        watchKeysUtil.assembleAllWatchKeys(appId, cluster, namespaces, dataCenter);<span class="comment">// namespaces 是集合</span></span><br><span class="line">    <span class="comment">// 得到 value; 这个 value 也就是 appId + cluster + namespace</span></span><br><span class="line">    Set&lt;String&gt; watchedKeys = Sets.newHashSet(watchedKeysMap.values());</span><br><span class="line">    <span class="comment">// 从缓存得到最新的发布消息</span></span><br><span class="line">    List&lt;ReleaseMessage&gt; latestReleaseMessages =<span class="comment">// 根据 key 从缓存得到最新发布的消息.</span></span><br><span class="line">        releaseMessageService.findLatestReleaseMessagesGroupByMessages(watchedKeys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果不关闭, 这个请求将会一直持有一个数据库连接. 影响并发能力. 这是一个 hack 操作*/</span></span><br><span class="line">    entityManagerUtil.closeEntityManager();</span><br><span class="line">    <span class="comment">// 计算出新的通知</span></span><br><span class="line">    List&lt;ApolloConfigNotification&gt; newNotifications =</span><br><span class="line">        getApolloConfigNotifications(namespaces, clientSideNotifications, watchedKeysMap,</span><br><span class="line">            latestReleaseMessages);</span><br><span class="line">    <span class="comment">// 不是空, 理解返回结果, 不等待</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(newNotifications)) &#123;</span><br><span class="line">      deferredResultWrapper.setResult(newNotifications);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 设置 timeout 回调:打印日志</span></span><br><span class="line">      deferredResultWrapper</span><br><span class="line">          .onTimeout(() -&gt; logWatchedKeys(watchedKeys, <span class="string">&quot;Apollo.LongPoll.TimeOutKeys&quot;</span>));</span><br><span class="line">      <span class="comment">// 设置完成回调:删除 key</span></span><br><span class="line">      deferredResultWrapper.onCompletion(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//取消注册</span></span><br><span class="line">        <span class="keyword">for</span> (String key : watchedKeys) &#123;</span><br><span class="line">          deferredResults.remove(key, deferredResultWrapper);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//register all keys 注册</span></span><br><span class="line">      <span class="keyword">for</span> (String key : watchedKeys) &#123;</span><br><span class="line">        <span class="keyword">this</span>.deferredResults.put(key, deferredResultWrapper);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 立即返回</span></span><br><span class="line">    <span class="keyword">return</span> deferredResultWrapper.getResult();<span class="comment">/** <span class="doctag">@see</span> DeferredResultHandler 是关键 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注释写了很多了，再简单说说逻辑：</p>
<ol>
<li>解析 JSON 字符串为 List&lt; ApolloConfigNotification&gt; 对象。</li>
<li>创建 Spring 异步对象。</li>
<li>处理过滤 namespace。</li>
<li>根据 namespace 生成需要监听的 key，格式为 appId + cluster + namespace，包括公共 namespace。并获取最新的 Release 信息。</li>
<li>关闭 Spring 实例管理器，释放数据库资源。</li>
<li>根据刚刚得到的 ReleaseMessage，和客户端的 ReleaseMessage 的版本进行对比，生成新的配置通知对象集合。</li>
<li>如果不是空 —— 立即返回给客户端，结束此次调用。如果没有，进入第 8 步。</li>
<li>设置 timeout 回调方法 —— 打印日志。再设置完成回调方法：删除注册的 key。</li>
<li>对客户端感兴趣的 key 进行注册，这些 key 都对应着 deferredResultWrapper 对象，可以认为他就是客户端。</li>
<li>返回 Spring 异步对象。该请求将被异步挂起。</li>
</ol>
<p>Apollo 的 DeferredResultWrapper 保证了 Spring 的 DeferredResult 对象，泛型内容是 List<ApolloConfigNotification>， 构造这个对象，默认的 timeout 是 60 秒，即挂起 60 秒。同时，对 setResult 方法进行包装，加入了对客户端 key 和服务端 key 的一个映射（大小写不一致） 。</p>
<p>我们刚刚说，Apollo 会将这些 key 注册起来。那么什么时候使用呢，异步对象被挂起，又是上面时候被唤醒呢？</p>
<p>答案就在 handleMessage 方法里。我们刚刚说他是一个监听器，当消息扫描器扫描到新的消息时，会通知所有的监听器，也就是执行 handlerMessage 方法。方法内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(ReleaseMessage message, String channel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String content = message.getMessage();</span><br><span class="line">  <span class="keyword">if</span> (!Topics.APOLLO_RELEASE_TOPIC.equals(channel) || Strings.isNullOrEmpty(content)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String changedNamespace = retrieveNamespaceFromReleaseMessage.apply(content);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//create a new list to avoid ConcurrentModificationException 构造一个新 list ,防止并发失败</span></span><br><span class="line">  List&lt;DeferredResultWrapper&gt; results = Lists.newArrayList(deferredResults.get(content));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建通知对象</span></span><br><span class="line">  ApolloConfigNotification configNotification = <span class="keyword">new</span> ApolloConfigNotification(changedNamespace, message.getId());</span><br><span class="line">  configNotification.addMessage(content, message.getId());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//do async notification if too many clients 如果有大量的客户端(100)在等待,使用线程池异步处理</span></span><br><span class="line">  <span class="keyword">if</span> (results.size() &gt; bizConfig.releaseMessageNotificationBatch()) &#123;</span><br><span class="line">    <span class="comment">// 大量通知批量处理</span></span><br><span class="line">    largeNotificationBatchExecutorService.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.size(); i++) &#123; <span class="comment">// 循环</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 假设一个公共 Namespace 有10W 台机器使用，如果该公共 Namespace 发布时直接下发配置更新消息的话，</span></span><br><span class="line"><span class="comment">         * 就会导致这 10W 台机器一下子都来请求配置，这动静就有点大了，而且对 Config Service 的压力也会比较大。</span></span><br><span class="line"><span class="comment">         * 即&quot;惊群效应&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i % bizConfig.releaseMessageNotificationBatch() == <span class="number">0</span>) &#123;<span class="comment">// 如果处理了一批客户端,休息一下(100ms)</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(bizConfig.releaseMessageNotificationBatchIntervalInMilli());</span><br><span class="line">        &#125;</span><br><span class="line">        results.get(i).setResult(configNotification);<span class="comment">// 通知每个等待的 HTTP 请求</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则,同步处理</span></span><br><span class="line">  <span class="keyword">for</span> (DeferredResultWrapper result : results) &#123;</span><br><span class="line">    result.setResult(configNotification);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>笔者去除了一些日志和一些数据判断。大致的逻辑如下：</p>
<ol>
<li>消息类型必须是 “apollo-release”。然后拿到消息里的 namespace 内容。</li>
<li><strong>根据 namespace 从注册器里拿出 Spring 异步对象集合</strong>。</li>
<li>创建通知对象。</li>
<li>如果有超过 100 个客户端在等待，那么就使用线程池批量执行通知。否则就同步慢慢执行。</li>
<li>每处理 100 个客户端就休息 100ms，防止发生惊群效应，导致大量客户端调用配置获取接口，引起服务抖动。</li>
<li>循环调用 Spring 异步对象的 setResult 方法，让其立即返回。</li>
</ol>
<p>具体的流程图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ca1bbe21c2a21b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>其中，灰色区域是扫描器的异步线程，黄色区域是接口的同步线程。他们共享 deferredResults 这个线程安全的 Map，实现异步解耦和实时通知客户端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，这就是 Apollo 的长轮询接口，客户端会不断的轮询服务器，服务器会 Hold住  60 秒，这是通过 Servlet 3 的异步 + NIO 来实现的，能够保持万级连接（Tomcat 默认 10000）。</p>
<p>通过一个线程安全的 Map + 监听器，让扫描器线程和 HTTP 线程共享 Spring 异步对象，即实现了消息实时通知，也让应用程序实现异步解耦。</p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo 9 — adminService 主 &amp; 灰度版本发布</title>
    <url>/2018/07/18/2018/2018-07-19-Apollo%209%20%E2%80%94adminService%20%E4%B8%BB%20&amp;%20%E7%81%B0%E5%BA%A6%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 目录
1. Controller 层
2. Service 层 publish 方法
3. 发送 ReleaseMessage 消息
4. 总结

<h2 id="1-Controller-层"><a href="#1-Controller-层" class="headerlink" title="1. Controller 层"></a>1. Controller 层</h2><p>主版本发布即点击主版本发布按钮：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c827c10ed25ebd7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>具体接口位置：<code>com.ctrip.framework.apollo.adminservice.controller</code> 包下 <code>ReleaseController#publish</code><br>实际上灰度版本发布也是调用这个接口的。<br>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主版本发布</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/apps/&#123;appId&#125;/clusters/&#123;clusterName&#125;/namespaces/&#123;namespaceName&#125;/releases&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReleaseDTO <span class="title">publish</span><span class="params">(<span class="meta">@PathVariable(&quot;appId&quot;)</span> String appId,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@PathVariable(&quot;clusterName&quot;)</span> String clusterName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@PathVariable(&quot;namespaceName&quot;)</span> String namespaceName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@RequestParam(&quot;name&quot;)</span> String releaseName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@RequestParam(name = &quot;comment&quot;, required = false)</span> String releaseComment,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@RequestParam(&quot;operator&quot;)</span> String operator,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@RequestParam(name = &quot;isEmergencyPublish&quot;, defaultValue = &quot;false&quot;)</span> <span class="keyword">boolean</span> isEmergencyPublish)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验存在与否</span></span><br><span class="line">  Namespace namespace = namespaceService.findOne(appId, clusterName, namespaceName);</span><br><span class="line">  <span class="keyword">if</span> (namespace == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(String.format(<span class="string">&quot;Could not find namespace for %s %s %s&quot;</span>, appId,</span><br><span class="line">                                              clusterName, namespaceName));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  Release release = releaseService.publish(namespace, releaseName, releaseComment, operator, isEmergencyPublish);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//send release message 发送消息到 ReleaseMessage</span></span><br><span class="line">  Namespace parentNamespace = namespaceService.findParentNamespace(namespace);</span><br><span class="line">  String messageCluster;</span><br><span class="line">  <span class="keyword">if</span> (parentNamespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">    messageCluster = parentNamespace.getClusterName();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    messageCluster = clusterName;</span><br><span class="line">  &#125;</span><br><span class="line">  messageSender.sendMessage(ReleaseMessageKeyGenerator.generate(appId, messageCluster, namespaceName),</span><br><span class="line">                            Topics.APOLLO_RELEASE_TOPIC);</span><br><span class="line">  <span class="keyword">return</span> BeanUtils.transfrom(ReleaseDTO.class, release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该层主要做了 2 件事情，1是调用 Service 层的 public 方法做真正的发布操作，2是发送“发布消息”到数据库——等待 ConfigService 消费。</p>
<p>所以，我们主要关注 Service 层的 publish 方法。</p>
<h2 id="2-Service-层-publish-方法"><a href="#2-Service-层-publish-方法" class="headerlink" title="2. Service 层 publish 方法"></a>2. Service 层 publish 方法</h2><p>该方法有些繁琐，主要流程图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7e6e131876893357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" publish 流程图"></p>
<p>可以通过比对流程图和代码来看。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Release <span class="title">publish</span><span class="params">(Namespace namespace, String releaseName, String releaseComment,</span></span></span><br><span class="line"><span class="params"><span class="function">                       String operator, <span class="keyword">boolean</span> isEmergencyPublish)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查锁</span></span><br><span class="line">  checkLock(namespace, isEmergencyPublish, operator);</span><br><span class="line">  <span class="comment">// 获取 item</span></span><br><span class="line">  Map&lt;String, String&gt; operateNamespaceItems = getNamespaceItems(namespace);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据当前 namespace 找到父 namespace, 也就是灰度的主版本.</span></span><br><span class="line">  Namespace parentNamespace = namespaceService.findParentNamespace(namespace);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//branch release // 父 namespace 不是 null, 说明当前就是灰度版本.</span></span><br><span class="line">  <span class="keyword">if</span> (parentNamespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 发布灰度版本.</span></span><br><span class="line">    <span class="keyword">return</span> publishBranchNamespace(parentNamespace, namespace, operateNamespaceItems,</span><br><span class="line">                                  releaseName, releaseComment, operator, isEmergencyPublish);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非灰度版本, 找到子版本</span></span><br><span class="line">  Namespace childNamespace = namespaceService.findChildNamespace(namespace);</span><br><span class="line"></span><br><span class="line">  Release previousRelease = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (childNamespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到上一个版本</span></span><br><span class="line">    previousRelease = findLatestActiveRelease(namespace);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//master release</span></span><br><span class="line">  Map&lt;String, Object&gt; operationContext = Maps.newHashMap();</span><br><span class="line">  <span class="comment">// 记录是否紧急发布</span></span><br><span class="line">  operationContext.put(ReleaseOperationContext.IS_EMERGENCY_PUBLISH, isEmergencyPublish);</span><br><span class="line">  <span class="comment">// 主版本发布</span></span><br><span class="line">  Release release = masterRelease(namespace, releaseName, releaseComment, operateNamespaceItems,</span><br><span class="line">                                  operator, ReleaseOperation.NORMAL_RELEASE, operationContext);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//merge to branch and auto release</span></span><br><span class="line">  <span class="comment">// 将主版本合并到灰度版本. 并自动发布</span></span><br><span class="line">  <span class="keyword">if</span> (childNamespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mergeFromMasterAndPublishBranch(namespace, childNamespace, operateNamespaceItems,</span><br><span class="line">                                    releaseName, releaseComment, operator, previousRelease,</span><br><span class="line">                                    release, isEmergencyPublish);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> release;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>检查锁：如果不是紧急发布，就需要检查锁，如果这个 namespace 的最后修改者就是当前用户，那么就抛出异常。禁止其修改。</p>
</li>
<li><p>根据 namespace 获取所有的 item，也就是配置。</p>
</li>
<li><p>判断当前的 namespace 是否有父 namespace，如果有，说明当前 namespace 是灰度 namespace，则进行灰度发布（主版本发布和灰度发布逻辑不同）。</p>
</li>
</ol>
<p>这里说下父子 namespace 在 apollo 的设计：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e94fb9c5c13105d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主体E-R Diagram  图片来自 apollo wiki"></p>
<p>从图中可以看出，namespace 和 cluster 是多对一的关系，而 cluster 有个字段：ParentClusterId，也就是说，cluster 是有层级的。每当创建一个灰度配置，实际上，就是创建了一个新的 cluster，这个新的 cluster 的名字就是 <code>时间戳-字符串</code>，大概是这样的：<code>20180705150428-1dc5208dc9e8146b</code>. 然后再在这个新 cluster 下面创建新的 namespace，那么，namespace 无形中也有了层级（父子）关系。</p>
<ol start="4">
<li><p>如果没有父 namespace，说明是主版本发布，那么就需要处理他的子 （灰度）版本，同时，为了后面比对灰度版本和上一个版本的区别（如果灰度修改了上一个版本的数据，就需要记录，否则，灰度数据和主版本将无法对应），还要记录上一个版本的 release 信息。</p>
</li>
<li><p><strong>发布主版本</strong>。并保存发布历史。</p>
</li>
<li><p>如果存在灰度版本，就更新灰度版本的配置，并发布灰度版本。</p>
</li>
</ol>
<p>关于灰度版本，这里多提一句，每次发布都是一个 release，release 对象有个 configuration，包含了此次发布的全量配置，因此，灰度发布的 configuration 中，包含了每次对应的主版本的配置，如果主版本发生了变化，那么灰度版本肯定也是要变更的。所以需要重新发布灰度版本。</p>
<p>其中关键的方法就是 <code>mergeConfiguration</code>，该方法表明了灰度发布的主要逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">mergeConfiguration</span><span class="params">(Map&lt;String, String&gt; baseConfigurations,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               Map&lt;String, String&gt; coverConfigurations)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//copy base configuration</span></span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : baseConfigurations.entrySet()) &#123;</span><br><span class="line">    result.put(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//update and publish</span></span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : coverConfigurations.entrySet()) &#123;</span><br><span class="line">    result.put(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法很简单：两个参数，主版本配置，灰度版本配置。首先将主版本配置保存到 Map 中，然后将灰度版本配置也 put 到 Map 中，利用 Map 唯一 Key 的特性，保证灰度版本覆盖主版本。</p>
<p>所以这个方法的 put 顺序决定了<strong>灰度版本覆盖主版本。</strong></p>
<p>publish 方法更多的细节不再赘述，有疑惑的地方可以交流。</p>
<h2 id="3-发送-ReleaseMessage-消息"><a href="#3-发送-ReleaseMessage-消息" class="headerlink" title="3. 发送 ReleaseMessage 消息"></a>3. 发送 ReleaseMessage 消息</h2><p>这个发送消息的操作本来应该是 MQ，apollo 为了减少依赖，直接使用的 mysql，但已经留好了MQ 的设计。关于 ReleaseMessage 的设计，我这里引用一下 apollo 的文档：</p>
<blockquote>
<p>Admin Service在配置发布后，需要通知所有的Config Service有配置发布，从而Config Service可以通知对应的客户端来拉取最新的配置。<br>从概念上来看，这是一个典型的消息使用场景，Admin Service作为producer发出消息，各个Config Service作为consumer消费消息。通过一个消息组件（Message Queue）就能很好的实现Admin Service和Config Service的解耦。<br>在实现上，考虑到Apollo的实际使用场景，以及为了尽可能减少外部依赖，我们没有采用外部的消息中间件，而是通过数据库实现了一个简单的消息队列。<br><strong>实现方式如下：</strong></p>
<ol>
<li> Admin Service在配置发布后会往ReleaseMessage表插入一条消息记录，消息内容就是配置发布的AppId+Cluster+Namespace，参见<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/message/DatabaseMessageSender.java">DatabaseMessageSender</a></li>
<li> Config Service有一个线程会每秒扫描一次ReleaseMessage表，看看是否有新的消息记录，参见<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/message/ReleaseMessageScanner.java">ReleaseMessageScanner</a></li>
<li> Config Service如果发现有新的消息记录，那么就会通知到所有的消息监听器（<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/message/ReleaseMessageListener.java">ReleaseMessageListener</a>），如<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-configservice/src/main/java/com/ctrip/framework/apollo/configservice/controller/NotificationControllerV2.java">NotificationControllerV2</a>，消息监听器的注册过程参见<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-configservice/src/main/java/com/ctrip/framework/apollo/configservice/ConfigServiceAutoConfiguration.java">ConfigServiceAutoConfiguration</a></li>
<li> NotificationControllerV2得到配置发布的AppId+Cluster+Namespace后，会通知对应的客户端</li>
</ol>
</blockquote>
<p>示意图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e1372f1232717d10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>apollo 定义了 MessageSender 接口，定义了一个 sendMessage 方法，这个方法目前只有基于 Mysql 的实现，即 DatabaseMessageSender 实现类。</p>
<p>该类会将数据直接保存到数据库。然后清理掉<code>比刚刚存的消息旧的消息</code>—— 防止消息表不断增大。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>发布分为主版本发布，灰度版本发布，全量发布，这次说了前两个，全量发布下次再说。</p>
<p>而主/灰发布的一个比较繁琐的地方就是两个版本的合并，<strong>灰度版本发布要合并主版本。主版本发布要更新灰度版本</strong>。</p>
<p>同时，灰度的设计也有点绕，中间隔了一层 cluster。</p>
<p>在发布成功之后，需要发送消息到数据库，让 ConfigService 能够感知到此次发布，并通知客户端。关于如何通知客户端，下次再说。</p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>如何从零设计一个配置中心</title>
    <url>/2018/07/21/2018/2018-07-22-%E5%A6%82%E4%BD%95%E4%BB%8E%E9%9B%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 0. 大概需要哪些组件？

<ol>
<li>无状态的配置服务 Service</li>
<li>软负载 Client，自动刷新配置</li>
<li>服务接入注册中心 Eureka</li>
<li>人性化的 WEB 控制台 </li>
<li>持久化配置 DB</li>
<li>MQ 消息组件，异步解耦客户端和 WEB 控制台。</li>
</ol>
<p>下图是分布式配置中心架构图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a98883a6918cb8c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="1-Client-功能："><a href="#1-Client-功能：" class="headerlink" title="1. Client 功能："></a>1. Client 功能：</h2><ol>
<li>软负载</li>
<li>服务发现（简洁部署时可不需要注册中心）</li>
<li>获取配置</li>
<li>长连接配置中心，支持服务端 push。</li>
<li>支持自动刷新配置，支持监听配置变化。</li>
<li>兼容 Spring</li>
<li>支持插件，支持用户做配置加解密操作。</li>
<li>Client 最好无配置，全部存放配置中心。</li>
<li>本地文件缓存。</li>
</ol>
<h2 id="2-Service-功能："><a href="#2-Service-功能：" class="headerlink" title="2. Service 功能："></a>2. Service 功能：</h2><ol start="0">
<li>服务注册，使客户端发现，简洁部署时可不需要注册中心。</li>
<li>支持海量客户端长连接。</li>
<li>无状态集群，高可用。</li>
<li>MQ 消费者，消费 WEB 控制台的消息并通知客户端。</li>
<li>支持客户端主动获取配置和被动获取配置。</li>
<li>支持和 WEB 控制合并部署。</li>
</ol>
<h2 id="3-WEB-控制台功能："><a href="#3-WEB-控制台功能：" class="headerlink" title="3. WEB 控制台功能："></a>3. WEB 控制台功能：</h2><ol>
<li>支持多环境，多应用，每个环境和应用对应不同权限。</li>
<li>支持灰度发布。</li>
<li>支持发布回滚。</li>
<li>配置权限管理，消息发布审计，消息获取审计。</li>
<li>支持第三方服务 restful 调用。</li>
<li>支持和 Service 合并部署。</li>
</ol>
<h2 id="4-支持简洁部署："><a href="#4-支持简洁部署：" class="headerlink" title="4. 支持简洁部署："></a>4. 支持简洁部署：</h2><p>分布式配置中心部署较为复杂，组件较多。</p>
<p>简洁部署适用于那些测试配置中心的用户，或者对可用性不是特别高的用户（Client 本地有文件缓存，Service 挂了也不影响）。</p>
<p>WEB 控制台，Service 可只使用一个 JVM，MQ 使用阻塞队列代替。Client 提供 Maven Jar 包。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-5a78973e5942f6cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D">apollo 配置中心介绍</a></p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Apollo 10 — adminService 全量发布</title>
    <url>/2018/07/18/2018/2018-07-20-Apollo%2010%20%E2%80%94%20adminService%20%E5%85%A8%E9%87%8F%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 目录

<ol>
<li>UI 界面</li>
<li>Portal 服务</li>
<li>admin 服务</li>
<li>总结</li>
</ol>
<h2 id="1-UI-界面"><a href="#1-UI-界面" class="headerlink" title="1. UI 界面"></a>1. UI 界面</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-c928a28afb3b6f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f965473b05543d8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-11704e0d594f7c79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"></p>
<h2 id="2-Portal-服务"><a href="#2-Portal-服务" class="headerlink" title="2. Portal 服务"></a>2. Portal 服务</h2><p>当我们点击上面的发布按钮的时候，调用的当然是 portal 的接口。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全量发布</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> appId SampleApp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> env DEV</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clusterName default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> namespaceName  application</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> branchName 分支/灰度名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deleteBranch true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model &#123;&quot;releaseTitle&quot;:&quot;20180716220550-gray-release-merge-to-master&quot;,&quot;releaseComment&quot;:&quot;&quot;,&quot;isEmergencyPublish&quot;:false&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PreAuthorize(value = &quot;@permissionValidator.hasReleaseNamespacePermission(#appId, #namespaceName)&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/apps/&#123;appId&#125;/envs/&#123;env&#125;/clusters/&#123;clusterName&#125;/namespaces/&#123;namespaceName&#125;/branches/&#123;branchName&#125;/merge&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReleaseDTO <span class="title">merge</span><span class="params">(<span class="meta">@PathVariable</span> String appId, <span class="meta">@PathVariable</span> String env,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="meta">@PathVariable</span> String clusterName, <span class="meta">@PathVariable</span> String namespaceName,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="meta">@PathVariable</span> String branchName, <span class="meta">@RequestParam(value = &quot;deleteBranch&quot;, defaultValue = &quot;true&quot;)</span> <span class="keyword">boolean</span> deleteBranch,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="meta">@RequestBody</span> NamespaceReleaseModel model)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是紧急发布,但该环境不允许紧急发布,抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (model.isEmergencyPublish() &amp;&amp; !portalConfig.isEmergencyPublishAllowed(Env.fromString(env))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(String.format(<span class="string">&quot;Env: %s is not supported emergency publish now&quot;</span>, env));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 合并主版本和灰度版本, 得到一个发布 dto</span></span><br><span class="line">  ReleaseDTO createdRelease = namespaceBranchService.merge(appId, Env.valueOf(env), clusterName, namespaceName, branchName,</span><br><span class="line">                                                           model.getReleaseTitle(), model.getReleaseComment(),</span><br><span class="line">                                                           model.isEmergencyPublish(), deleteBranch);</span><br><span class="line"></span><br><span class="line">  ConfigPublishEvent event = ConfigPublishEvent.instance();</span><br><span class="line">  event.withAppId(appId)</span><br><span class="line">      .withCluster(clusterName)</span><br><span class="line">      .withNamespace(namespaceName)</span><br><span class="line">      .withReleaseId(createdRelease.getId())</span><br><span class="line">      .setMergeEvent(<span class="keyword">true</span>)</span><br><span class="line">      .setEnv(Env.valueOf(env));</span><br><span class="line"></span><br><span class="line">  publisher.publishEvent(event);<span class="comment">// 发送邮件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createdRelease;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口职责不多：是否符合紧急发布的数据校验，调用 Service， 发布“配置发布”事件（发送邮件）。</p>
<p>看看调用 Service 的过程，该方法称为 merge ，实际上就是合并灰度和主版本的配置。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReleaseDTO <span class="title">merge</span><span class="params">(String appId, Env env, String clusterName, String namespaceName,</span></span></span><br><span class="line"><span class="params"><span class="function">                        String branchName, String title, String comment,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">boolean</span> isEmergencyPublish, <span class="keyword">boolean</span> deleteBranch)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算 changeSets</span></span><br><span class="line">  ItemChangeSets changeSets = calculateBranchChangeSet(appId, env, clusterName, namespaceName, branchName);</span><br><span class="line">  <span class="comment">// 调用 admin 服务</span></span><br><span class="line">  ReleaseDTO mergedResult =</span><br><span class="line">      releaseService.updateAndPublish(appId, env, clusterName, namespaceName, title, comment,</span><br><span class="line">                                      branchName, isEmergencyPublish, deleteBranch, changeSets);</span><br><span class="line"></span><br><span class="line">  Tracer.logEvent(TracerEventType.MERGE_GRAY_RELEASE,</span><br><span class="line">               String.format(<span class="string">&quot;%s+%s+%s+%s&quot;</span>, appId, env, clusterName, namespaceName));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mergedResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了 2 件事情： 计算 change 集合，调用 admin 服务。很明显，计算 change 对于 protal 非常重要。</p>
<p>calculateBranchChangeSet 方法主要将灰度配置和主版本配置合并。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ItemChangeSets <span class="title">calculateBranchChangeSet</span><span class="params">(String appId, Env env, String clusterName, String namespaceName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                String branchName)</span> </span>&#123;</span><br><span class="line">  NamespaceBO parentNamespace = namespaceService.loadNamespaceBO(appId, env, clusterName, namespaceName);<span class="comment">// 父版本 namespace</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentNamespace == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">&quot;base namespace not existed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentNamespace.getItemModifiedCnt() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">&quot;Merge operation failed. Because master has modified items&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;ItemDTO&gt; masterItems = itemService.findItems(appId, env, clusterName, namespaceName);<span class="comment">// 主版本 items </span></span><br><span class="line"></span><br><span class="line">  List&lt;ItemDTO&gt; branchItems = itemService.findItems(appId, env, branchName, namespaceName);<span class="comment">// 子版本 items </span></span><br><span class="line"></span><br><span class="line">  ItemChangeSets changeSets = itemsComparator.compareIgnoreBlankAndCommentItem(parentNamespace.getBaseInfo().getId(),</span><br><span class="line">                                                                               masterItems, branchItems);<span class="comment">// 得到 changeSet</span></span><br><span class="line">  changeSets.setDeleteItems(Collections.emptyList());<span class="comment">// 防止误删除，emm，灰度的内容并不是全量的，因此上面的计算有些问题，并且目前没有删除功能。所以这里可以置空。</span></span><br><span class="line">  changeSets.setDataChangeLastModifiedBy(userInfoHolder.getUser().getUserId());</span><br><span class="line">  <span class="keyword">return</span> changeSets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li>获取主版本的 namespace 详细信息，用于数据检验，id 赋值。</li>
<li>获取主版本的所有 item 配置，再获取灰度版本的所有 item 配置，注意，灰度版本的 item 只有其自身新增的和修改的配置，不是全量的（这将导致后面一个奇怪的现象）。</li>
<li>比较两者差异，得到 change 集合。</li>
<li>设置 deleteList 为空 —— 奇怪现象（<code>灰度的内容并不是全量的，因此上面的计算有些问题，并且目前没有删除功能。所以这里可以置空, 并且防止误删除</code>）。</li>
<li>设置修改人。</li>
</ol>
<p>这里需要注意的是计算差异到底是怎么计算的，为什么后面有置空 deleteItem 的操作。</p>
<p>我就不贴全部的方法了，贴一下对删除操作有影响的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 比较,忽略空格,返回一个改变的 items */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ItemChangeSets <span class="title">compareIgnoreBlankAndCommentItem</span><span class="params">(<span class="keyword">long</span> baseNamespaceId, List&lt;ItemDTO&gt; baseItems, List&lt;ItemDTO&gt; targetItems)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 忽略新增/修改 item 代码......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理删除,但这个逻辑似乎不对. 不过此类不知道数据来源,工具类没有问题.</span></span><br><span class="line">  <span class="keyword">for</span> (ItemDTO item: baseItems)&#123;<span class="comment">// 主版本</span></span><br><span class="line">    String key = item.getKey();</span><br><span class="line"></span><br><span class="line">    ItemDTO targetItem = targetItemMap.get(key);</span><br><span class="line">    <span class="keyword">if</span>(targetItem == <span class="keyword">null</span>)&#123;<span class="comment">//delete// 如果灰度版本里没有,说明删除了.</span></span><br><span class="line">      changeSets.addDeleteItem(item);<span class="comment">// 添加进删除集合</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> changeSets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这段代码里，循环主版本，逐个对比灰度版本，如果灰度版本里没有，就添加进 delete 集合，而我们知道，灰度版本的 item 只有修改的和新增的，这时，将导致误删除。</p>
<p><strong>但这个工具类的计算是没有问题的，有问题的是外层数据的完整性。</strong></p>
<p>因此需要在外面打个补丁：<code>changeSets.setDeleteItems(Collections.emptyList());</code></p>
<p>好，计算完 changeSet，就要调用 admin 服务了，并且把 changeSet 传递过去，然后返回一个 release 对象，表示发布成功，并发布事件。</p>
<p>在分析 admin 之前，总结一下 protal 的流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-bd30447caecf0a76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="3-admin-服务"><a href="#3-admin-服务" class="headerlink" title="3. admin 服务"></a>3. admin 服务</h2><p>从 portal 的代码中，可以看到，调用的是 admin 的 updateAndPublish 方法接口，看看这个接口：<br>位置 ： <code>com.ctrip.framework.apollo.adminservice.controller.ReleaseController.java</code><br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/apps/&#123;appId&#125;/clusters/&#123;clusterName&#125;/namespaces/&#123;namespaceName&#125;/updateAndPublish&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReleaseDTO <span class="title">updateAndPublish</span><span class="params">(<span class="meta">@PathVariable(&quot;appId&quot;)</span> String appId,// 应用名称</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@PathVariable(&quot;clusterName&quot;)</span> String clusterName,//集群</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@PathVariable(&quot;namespaceName&quot;)</span> String namespaceName,// 主版本名称</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestParam(&quot;releaseName&quot;)</span> String releaseName, // 发布名称</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestParam(&quot;branchName&quot;)</span> String branchName,// 灰度名称 cluster</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestParam(value = &quot;deleteBranch&quot;, defaultValue = &quot;true&quot;)</span> <span class="keyword">boolean</span> deleteBranch,// 是否删除灰度</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestParam(name = &quot;releaseComment&quot;, required = false)</span> String releaseComment,// 评论</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestParam(name = &quot;isEmergencyPublish&quot;, defaultValue = &quot;false&quot;)</span> <span class="keyword">boolean</span> isEmergencyPublish,// 是否紧急发布</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@RequestBody</span> ItemChangeSets changeSets)</span> </span>&#123;<span class="comment">// 这个是 portal 发来的</span></span><br><span class="line">  Namespace namespace = namespaceService.findOne(appId, clusterName, namespaceName);<span class="comment">// 找到分支</span></span><br><span class="line">  <span class="keyword">if</span> (namespace == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(String.format(<span class="string">&quot;Could not find namespace for %s %s %s&quot;</span>, appId,</span><br><span class="line">                                              clusterName, namespaceName));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 合并改变 并且发布</span></span><br><span class="line">  Release release = releaseService.mergeBranchChangeSetsAndRelease(namespace, branchName, releaseName,</span><br><span class="line">                                                                   releaseComment, isEmergencyPublish, changeSets);</span><br><span class="line">  <span class="comment">// 是否删除分支</span></span><br><span class="line">  <span class="keyword">if</span> (deleteBranch) &#123;</span><br><span class="line">    namespaceBranchService.deleteBranch(appId, clusterName, namespaceName, branchName,</span><br><span class="line">                                        NamespaceBranchStatus.MERGED, changeSets.getDataChangeLastModifiedBy());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存发布消息到数据库</span></span><br><span class="line">  messageSender.sendMessage(ReleaseMessageKeyGenerator.generate(appId, clusterName, namespaceName),</span><br><span class="line">                            Topics.APOLLO_RELEASE_TOPIC);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> BeanUtils.transfrom(ReleaseDTO.class, release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口接受 portal 调用，比较有趣的点是，这里的 changeSet 是 portal 计算的，而不是 admin 自己计算的。</p>
<p>然后，controller 层比较简单，数据校验，调用 Service，发送消息。</p>
<p>当然主要看看 Service。</p>
<p>主要是 releaseService 的 mergeBranchChangeSetsAndRelease 方法，看名字，任务很多：合并分支修改集合，并且发布。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Release <span class="title">mergeBranchChangeSetsAndRelease</span><span class="params">(Namespace namespace, String branchName, String releaseName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               String releaseComment, <span class="keyword">boolean</span> isEmergencyPublish,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               ItemChangeSets changeSets)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查锁</span></span><br><span class="line">  checkLock(namespace, isEmergencyPublish, changeSets.getDataChangeLastModifiedBy());</span><br><span class="line">  <span class="comment">/// 更新 item</span></span><br><span class="line">  itemSetService.updateSet(namespace, changeSets);</span><br><span class="line">  <span class="comment">// 找到最新发布的 release</span></span><br><span class="line">  Release branchRelease = findLatestActiveRelease(namespace.getAppId(), branchName, namespace</span><br><span class="line">      .getNamespaceName());</span><br><span class="line">  <span class="comment">// release Id</span></span><br><span class="line">  <span class="keyword">long</span> branchReleaseId = branchRelease == <span class="keyword">null</span> ? <span class="number">0</span> : branchRelease.getId();</span><br><span class="line">  <span class="comment">// 找到当前 namespace 的所有 Item(刚刚更新的)</span></span><br><span class="line">  Map&lt;String, String&gt; operateNamespaceItems = getNamespaceItems(namespace);</span><br><span class="line"></span><br><span class="line">  Map&lt;String, Object&gt; operationContext = Maps.newHashMap();</span><br><span class="line">  <span class="comment">// 构造操作上下文 sourceBranch=灰度名称 baseReleaseId=最新的releaseId isEmergencyPublish=是否紧急发布, 用于构建发布历史</span></span><br><span class="line">  operationContext.put(ReleaseOperationContext.SOURCE_BRANCH, branchName);</span><br><span class="line">  operationContext.put(ReleaseOperationContext.BASE_RELEASE_ID, branchReleaseId);</span><br><span class="line">  operationContext.put(ReleaseOperationContext.IS_EMERGENCY_PUBLISH, isEmergencyPublish);</span><br><span class="line">  <span class="comment">// ReleaseHistory Audit 主版本</span></span><br><span class="line">  <span class="keyword">return</span> masterRelease(namespace, releaseName, releaseComment, operateNamespaceItems,</span><br><span class="line">                       changeSets.getDataChangeLastModifiedBy(),</span><br><span class="line">                       <span class="comment">// 灰度合并回主分支发布</span></span><br><span class="line">                       ReleaseOperation.GRAY_RELEASE_MERGE_TO_MASTER, operationContext);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，步骤：</p>
<ol>
<li>检查锁，和普通发布一样，判断修改者和发布者是不是同一个人。</li>
<li>根据 Portal 传递来的 changeSets 更新 item。</li>
<li>找到最新发布的 release（构建发布历史的上下文）。</li>
<li>发布主版本。</li>
</ol>
<p>其中，updateSet 方法比较重要，要看看他是怎么更新 item 的。</p>
<p>方法很长，总之，就是将 changeSet 的内容保存到主版本的 namespace 下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ItemChangeSets <span class="title">updateSet</span><span class="params">(String appId, String clusterName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                String namespaceName, ItemChangeSets changeSet)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//  最后改变数据的人</span></span><br><span class="line">  String operator = changeSet.getDataChangeLastModifiedBy();</span><br><span class="line">  <span class="comment">// 改变数据的详细信息</span></span><br><span class="line">  ConfigChangeContentBuilder configChangeContentBuilder = <span class="keyword">new</span> ConfigChangeContentBuilder();</span><br><span class="line">  <span class="comment">// 如果创建了新的</span></span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(changeSet.getCreateItems())) &#123;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (ItemDTO item : changeSet.getCreateItems()) &#123;</span><br><span class="line">      <span class="comment">// 转换</span></span><br><span class="line">      Item entity = BeanUtils.transfrom(Item.class, item);</span><br><span class="line">      entity.setDataChangeCreatedBy(operator);</span><br><span class="line">      entity.setDataChangeLastModifiedBy(operator);</span><br><span class="line">      <span class="comment">// 保存 item 到数据库</span></span><br><span class="line">      Item createdItem = itemService.save(entity);</span><br><span class="line">      <span class="comment">// 保存到 builder createItems List 中</span></span><br><span class="line">      configChangeContentBuilder.createItem(createdItem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后记录审核</span></span><br><span class="line">    auditService.audit(<span class="string">&quot;ItemSet&quot;</span>, <span class="keyword">null</span>, Audit.OP.INSERT, operator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果有修改的数据</span></span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(changeSet.getUpdateItems())) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ItemDTO item : changeSet.getUpdateItems()) &#123;</span><br><span class="line">      <span class="comment">// 转换并寻找</span></span><br><span class="line">      Item entity = BeanUtils.transfrom(Item.class, item);</span><br><span class="line">      Item managedItem = itemService.findOne(entity.getId());</span><br><span class="line">      <span class="comment">// 不存在抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (managedItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(String.format(<span class="string">&quot;item not found.(key=%s)&quot;</span>, entity.getKey()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 之前的数据</span></span><br><span class="line">      Item beforeUpdateItem = BeanUtils.transfrom(Item.class, managedItem);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//protect. only value,comment,lastModifiedBy,lineNum can be modified</span></span><br><span class="line">      <span class="comment">// 将之前数据内容更新</span></span><br><span class="line">      managedItem.setValue(entity.getValue());</span><br><span class="line">      managedItem.setComment(entity.getComment());</span><br><span class="line">      managedItem.setLineNum(entity.getLineNum());</span><br><span class="line">      managedItem.setDataChangeLastModifiedBy(operator);</span><br><span class="line">      <span class="comment">// 更新</span></span><br><span class="line">      Item updatedItem = itemService.update(managedItem);</span><br><span class="line">      <span class="comment">// 更新 builder 中 value</span></span><br><span class="line">      configChangeContentBuilder.updateItem(beforeUpdateItem, updatedItem);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后审核 itemSet</span></span><br><span class="line">    auditService.audit(<span class="string">&quot;ItemSet&quot;</span>, <span class="keyword">null</span>, Audit.OP.UPDATE, operator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果有删除的</span></span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(changeSet.getDeleteItems())) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ItemDTO item : changeSet.getDeleteItems()) &#123;</span><br><span class="line">      <span class="comment">// 数据库删除</span></span><br><span class="line">      Item deletedItem = itemService.delete(item.getId(), operator);</span><br><span class="line">      <span class="comment">// 添加到 builder 中</span></span><br><span class="line">      configChangeContentBuilder.deleteItem(deletedItem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 审核</span></span><br><span class="line">    auditService.audit(<span class="string">&quot;ItemSet&quot;</span>, <span class="keyword">null</span>, Audit.OP.DELETE, operator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 builder 中有内容</span></span><br><span class="line">  <span class="keyword">if</span> (configChangeContentBuilder.hasContent())&#123;</span><br><span class="line">    <span class="comment">// 创建提交记录</span></span><br><span class="line">    createCommit(appId, clusterName, namespaceName,</span><br><span class="line">        configChangeContentBuilder.build(), <span class="comment">// 将 build 变成 json 保存</span></span><br><span class="line">                 changeSet.getDataChangeLastModifiedBy());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> changeSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在成功更新 itme 之后，便可以进行最终的发布了，发布很简单，就不展开讲了。</p>
<p>然后看看删除灰度，默认是要删除的。</p>
<p>步骤：</p>
<ol>
<li>找到灰度发布的最新  release。</li>
<li>更新灰度规则，置空灰度规则。</li>
<li>删除灰度 cluster 和关联的 namespace。置于灰度为什么和 cluster 关联，而不是和 namespace 关联，这是因为最初的 apollo 没有设计灰度，后面加上灰度的时候，为了避免 namespace 大幅修改，就在 cluster 里加入父子逻辑了（咨询过作者）。</li>
<li>记录发布历史。根据是否 merge 记录是放弃灰度还是合并后删除，方便审计。</li>
</ol>
<p>发布操作有很多类型，apollo 的常量如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReleaseOperation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> NORMAL_RELEASE = <span class="number">0</span>;<span class="comment">//普通发布</span></span><br><span class="line">  <span class="keyword">int</span> ROLLBACK = <span class="number">1</span>;<span class="comment">// 回滚</span></span><br><span class="line">  <span class="keyword">int</span> GRAY_RELEASE = <span class="number">2</span>;<span class="comment">// 灰度发布</span></span><br><span class="line">  <span class="keyword">int</span> APPLY_GRAY_RULES = <span class="number">3</span>;<span class="comment">// 灰度规则更新</span></span><br><span class="line">  <span class="keyword">int</span> GRAY_RELEASE_MERGE_TO_MASTER = <span class="number">4</span>;<span class="comment">// 灰度合并回主分支发布</span></span><br><span class="line">  <span class="keyword">int</span> MASTER_NORMAL_RELEASE_MERGE_TO_GRAY = <span class="number">5</span>;<span class="comment">// 主分支发布灰度自动发布</span></span><br><span class="line">  <span class="keyword">int</span> MATER_ROLLBACK_MERGE_TO_GRAY = <span class="number">6</span>;<span class="comment">// 主分支回滚灰度自动发布</span></span><br><span class="line">  <span class="keyword">int</span> ABANDON_GRAY_RELEASE = <span class="number">7</span>;<span class="comment">//放弃灰度</span></span><br><span class="line">  <span class="keyword">int</span> GRAY_RELEASE_DELETED_AFTER_MERGE = <span class="number">8</span>;<span class="comment">// 灰度版本合并后删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下 admin 的发布流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-44ee282e64da1d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>将 portal 和 admin 组合起来看，下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3aef348a7726dacb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>Apollo</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 持久化</title>
    <url>/2018/07/30/2018/2018-07-31-Redis%20%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录：
1. RDB
2. AOF
3. 持久化恢复
4. 问题排查和性能优化
    fork 操作
    子进程开销
    AOF 追加阻塞
    单机多实例部署
5. 总结

<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>Redis 相比较于 memcache，多了持久化的功能。而持久化分为 2 种，一种是 RDB（全量），一种是 AOF（增量）。</p>
<p>RDB 是旧的模式，现在基本上都使用 AOF。当然，今天两个都会一起聊聊。</p>
<h2 id="2-RDB"><a href="#2-RDB" class="headerlink" title="2 RDB"></a>2 RDB</h2><p>RDB 流程图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-2d318b57edc383a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<hr>
<p>RDB 特点：</p>
<ol>
<li>RDB 是一种快照模式，即——保存的是 key value 数据内容。</li>
<li>RDB 有 2 种持久方式，同步 save 模式和异步 bgsave 模式。由于 save 是同步的，所以可以保证数据一致性，而 bgsave 则不能。</li>
<li>save 可以在客户端显式触发，也可以在 shutdown 时自动触发；bgsave 可以在客户端显式触发，也可以通过配置由定时任务触发，也可以在 slave 节点触发。</li>
<li>save 导致 redis 同步阻塞，基本已经废弃。bgsave 则不会导致阻塞，但也有缺点：在 fork 时，需要增加内存服务器开销，因为当内存不够时，将使用虚拟内存，导致阻塞 Redis 运行。所以，需要保证空闲内存足够。</li>
<li>默认执行 shutdown 时，如果没有开启 AOF，则自动执行 bgsave。</li>
<li>每次的 RDB 文件都是替换的。</li>
</ol>
<p><strong>关于优化</strong>：Redis 会压缩 RDB 文件，使用  LZF 算法，让最终的 RDB 文件远小于内存大小，默认开启。但会消耗 CPU。</p>
<hr>
<p>RDB 缺点：</p>
<ol>
<li>无法秒级持久化。</li>
<li>老版本 Redis 无法兼容新版本 RDB。</li>
</ol>
<p>RDB 优点：</p>
<ol>
<li>文件紧凑，适合备份，全量复制场景。例如每 6 小时执行 bgsave，保存到文件系统之类的。</li>
<li>Redis 加载 RDB 恢复数据远远快于 AOF。</li>
</ol>
<hr>
<h2 id="3-AOF"><a href="#3-AOF" class="headerlink" title="3 AOF"></a>3 AOF</h2><p>由于 RDB 的数据实时性问题，AOF（append only file） 是目前 Redis 持久化的主流方式。</p>
<p>AOF 特点：</p>
<ol>
<li>默认文件名是 appendonly.aof。和 RDB 一样，保存在配置中 dir 目录下。</li>
<li>AOF 相比较于 RDB，每次都会保存<strong>写</strong>命令，数据实时性更高。</li>
<li>AOF 由于每次都会记录写命令，文件会很大，因此需要进行优化，称之为“重写机制”（下面详细说）。</li>
<li>AOF 每次保存的写命令都放在一个缓冲区，根据不同的策略（下面详细说）同步到磁盘。</li>
</ol>
<p>“重写机制” 细节：</p>
<ol>
<li>fork 子进程（类似 bgsave）</li>
<li>主进程会写到2个缓冲区，一个是原有的 “AOF 缓存区”，一个是专门为子进程准备的 “AOF 重写缓冲区”；</li>
<li>子进程写到到新的 AOF 文件中，批量的，默认 32m；写完后通知主进程。</li>
<li>主进程把“AOF 重写缓冲区”的数据写到新 AOF 文件中。</li>
<li>将新的 AOF 文件替换老文件。</li>
</ol>
<p>重写流程图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f2d95e31766d8697.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<hr>
<p>缓冲区同步策略，由参数 appendfsync 控制，一共3种：</p>
<ol>
<li>always：调用系统 fsync 函数，直到同步到硬盘返回；<code>严重影响 redis 性能</code>。</li>
<li>everysec：先调用 OS write 函数， 写到缓冲区，然后 redis 每秒执行一次 OS fsync 函数。<code>推荐使用这种方式</code>。</li>
<li>no: 只执行 write OS 函数，具体同步硬盘策略由 OS 决定；<code>不推荐，数据不安全，容易丢失数据</code>。</li>
</ol>
<hr>
<h2 id="4-持久化恢复"><a href="#4-持久化恢复" class="headerlink" title="4 持久化恢复"></a>4 持久化恢复</h2><p>AOF 和 RDB 文件都可以用于服务器重启时的数据恢复，具体流程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-972df43dc538c1b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从图中可以看出优先加载  AOF，当没有 AOF 时才加载 RDB。当 AOF 或者 RDB 存在错误，则加载失败。</p>
<hr>
<h2 id="5-问题排查和性能优化"><a href="#5-问题排查和性能优化" class="headerlink" title="5 问题排查和性能优化"></a>5 问题排查和性能优化</h2><p>Redis 持久化是影响 Redis 性能的高发地，也是面试中常问的问题。</p>
<h4 id="1-fork-操作"><a href="#1-fork-操作" class="headerlink" title="1. fork 操作"></a>1. fork 操作</h4><p>当 Redis 做 RDB 或者 AOF 重写时，必然要进行 fork 操作，对于 OS 来说，fork 都是一个重量级操作。<strong>而且</strong>，fork 还会拷贝一些数据，虽然不会拷贝主进程所有的物理空间，但会复制主进程的空间内存页表。对于 10GB 的 Redis 进程，需要复制大约 20MB 的内存页表，因此 fork 操作耗时跟进程总内存量息息相关，再加上，如果使用虚拟化技术，例如 Xen 虚拟机，fork 会更加耗时。</p>
<p>一个正常的 fork 耗时大概在 20毫秒左右。为什么呢，假设一个 Redis 实例的 OPS 在 5 万以上，如果 fork 操作耗时在秒级，那么僵拖慢几万条命令的执行，对生产环境影响明显。</p>
<p>我们可以在 Info stats 统计中查询 latest_fork_usec 指标获取最近一次 fork 操作耗时，单位微秒。</p>
<p>如何优化：</p>
<ul>
<li>优先使用物理机或者高效支持 fork 的虚拟化技术，避免使用 Xen。</li>
<li> 控制 redis 实例最大内存，尽量控制在 10GB 以内。</li>
<li> 合理配置 Linux 内存分配策略，避免内存不足导致 fork 失败。</li>
<li> 降低 fork 的频率，如适度放宽 AOF 自动触发时机，避免不必要的全量复制。</li>
</ul>
<h4 id="2-子进程开销"><a href="#2-子进程开销" class="headerlink" title="2. 子进程开销"></a>2. 子进程开销</h4><p>fork 完毕之后，会创建子进程，子进程负责 RDB 或者  AOF 重写，这部分过程主要涉及到 CPU，内存，硬盘三个地方的优化。</p>
<ul>
<li><p>CPU<br>写入文件的过程是 CPU 密集的过程，通常子进程对单核 CPU 利用率接近 90%。</p>
</li>
<li><p>*如何优化呢？**既然是 CPU 密集型操作，就不要绑定单核 CPU，因为这样会和父 CPU 进行竞争。同时，不要和其他 CPU 密集型服务不是在一个机器上。如果部署了多个 Redis 实例，尽力保证统一时刻只有一个子进程执行重写工作。</p>
</li>
<li><p>内存<br>子进程通过 fork 操作产生，占用内存大小等同于父进程，理论上需要两倍的内存完成持久化操作，但 Linux 有 copy on write 机制，父子进程会共享相同的物理内存页，当父进程处理写操作时，会把要修改的页创建对应的副本，而子进程在 fork 操作过程中，共享整个父进程内存快照。<br>即——<strong>如果重写过程中存在内存修改操作，父进程负责创建所修改内存页的副本。这里就是内存消耗的地方。</strong><br>如何优化呢？尽量保证同一时刻只有一个子进程在工作；避免大量写入时做重写操作。</p>
</li>
<li><p>硬盘<br>硬盘开销分析：子进程主要职责是将 RDB 或者 AOF 文件写入硬盘进行持久化，势必对硬盘造成压力，可通过工具例如 iostat，iotop 等，分析硬盘负载情况。</p>
</li>
</ul>
<p>如何优化：</p>
<ul>
<li>不要和其他高硬盘负载的服务放在一台机器上，例如 MQ，存储。</li>
<li>AOF 重写时会消耗大量硬盘 IO，可以开启配置 no-appendfsync-on-rewrite，默认关闭。表示在 AOF 重写期间不做 fsync 操作。</li>
<li>当开启 AOF 的 Redis 在高并发场景下，如果使用普通机械硬盘，每秒的写速率是 100MB左右，这时，Redis 的性能瓶颈在硬盘上，建议使用 SSD。</li>
<li>对于单机配置多个 Redis 实例的情况，可以配置不同实例分盘存储 AOF 文件，分摊硬盘压力。</li>
</ul>
<h4 id="3-AOF-追加阻塞"><a href="#3-AOF-追加阻塞" class="headerlink" title="3. AOF 追加阻塞"></a>3. AOF 追加阻塞</h4><p>当开启 AOF 持久化时，常用的同步硬盘的策略是“每秒同步” everysec，用于平衡性能和数据安全性，对于这种方式，redis 使用另一条线程每秒执行 fsync 同步硬盘，当系统资源繁忙时，将造成 Redis 主线程阻塞。</p>
<p>流程图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b062906f150945d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>通过上图可以发现：everysec 配置最多可能丢失 2 秒数据，不是 1 秒；如果系统 fsync 缓慢，将会导致 Redis 主线程阻塞影响效率。</p>
<p>问题定位：</p>
<ol>
<li>发生 AOF 阻塞时，会输入日志。用于记录 AOF fsync 阻塞导致拖慢 Redis 服务的行为。</li>
<li>每当 AOF 追加阻塞事件发生时，在 info Persistence 统计中，aof_delayed_fsync 指标会累加，查看这个指标方便定位 AOF 阻塞问题。</li>
<li>AOF 同步最多运行 2 秒的延迟，当延迟发生时说明硬盘存在性能问题，可通过监控工具 iotop 查看，定位消耗 IO 的进程。</li>
</ol>
<h4 id="4-单机多实例部署"><a href="#4-单机多实例部署" class="headerlink" title="4. 单机多实例部署"></a>4. 单机多实例部署</h4><p>Redis 单线程架构无法充分利用多核CPU，通常的做法是一台机器上部署多个实例，当多个实例开启 AOF 后，彼此之间就会产生CPU 和 IO 的竞争。</p>
<p>如何解决这个问题呢？</p>
<p>让所有实例的  AOF 串行执行。</p>
<p>我们通过 info Persistence 中关于 AOF 的信息写出 Shell 脚本，然后串行执行实例的 AOF 持久化。</p>
<p>整个过程如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-db6c9814ea70f9c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>通过不断判断 AOF 的状态，手动执行 AOF 重写，保证 AOF  不会存在竞争。具体的 Shell 编写以及 info 信息判断，可以查看下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-31fb51a2922f46b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>本文主要讲了 Redis 的持久化相关功能，持久化一直是影响 Redis 性能的高发地，也是面试中经常被问到的。包括 RDB 相关的特定和优缺点，AOF  的优缺点，事实上，由于 RDB 的数据实时性问题，目前用 AOF 比较多了。而持久化恢复也是优先 AOF。</p>
<p>关于持久化的问题排查，就很麻烦了，但无非几个方面，fork 耗时，子进程的 CPU，内存，硬盘开销，AOF 的同步阻塞，单机多实例部署。</p>
<p>这些优化，可以通过前面写的分析进行排查。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>《Redis 开发与运维》<br>《深入分布式缓存》</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 复制初体验</title>
    <url>/2018/08/02/2018/2018-08-03-Redis%20%E5%A4%8D%E5%88%B6%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>在分布式系统中，为了解决单点问题，通常会把数据复制多个副本部署在其他机器，满足故障恢复和负载均衡等需求。Redis 也是如此，他为我们提供了复制功能，实现类相同数据的多个 Redis 副本。复制功能是 Redis 高可用的基础，Redis 的哨兵和集群都是在此基础上实现的。</p>
<hr>
<h2 id="1-复制的配置"><a href="#1-复制的配置" class="headerlink" title="1 复制的配置"></a>1 复制的配置</h2><h5 id="1-如何建立复制？"><a href="#1-如何建立复制？" class="headerlink" title="1. 如何建立复制？"></a>1. 如何建立复制？</h5><ul>
<li>配置文件中加入 slaveof {masterIp} {masterport}</li>
<li>redis-server 命令后加入 –slaveof {masterIp} {masterport}</li>
<li>直接在从节点 redis-cli 中执行 slaveof {masterIp} {masterport}</li>
</ul>
<p>建立复制后，主节点的每次修改命令都会用异步的方式发送到从节点。</p>
<h5 id="2-如何断开复制链接？"><a href="#2-如何断开复制链接？" class="headerlink" title="2. 如何断开复制链接？"></a>2. 如何断开复制链接？</h5><ul>
<li>在从节点执行 <code>slaveof no one</code>。</li>
</ul>
<p>注意：<strong>当从节点从旧的主节点断开后，然后接入到新的节点，从节点会删除所有旧的数据。</strong></p>
<h5 id="3-连接的安全"><a href="#3-连接的安全" class="headerlink" title="3. 连接的安全"></a>3. 连接的安全</h5><p>对于数据比较重要的节点，主节点会通过 <code>requirepass</code> 参数进行密码验证，这时所有的客户端访问必须使用 <code>auth</code> 命令进行校验，因此需要在从节点胚子 masterauth 参数与主节点密码保持一致，这样从节点才可以正确的连接到主节点并发起复制流程。</p>
<h5 id="4-只读"><a href="#4-只读" class="headerlink" title="4. 只读"></a>4. 只读</h5><p>默认情况下，从节点使用 alave-read-only=yes 配置为只读模式。由于复制只能从主节点到从节点，对于从节点的任何修改，主节点都是无法感知的，修改从节点会造成数据不一致。因此，建议不要修改这个配置。</p>
<hr>
<h2 id="2-拓扑"><a href="#2-拓扑" class="headerlink" title="2 拓扑"></a>2 拓扑</h2><h5 id="1-一主一从"><a href="#1-一主一从" class="headerlink" title="1. 一主一从"></a>1. 一主一从</h5><p>一主一从是最简单的复制拓扑结构，用于主节点出现宕机时，从节点提供故障转移支持。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-855afacc4a83c9da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意：如果主节点因为提高性能关闭了 AOF 持久化功能，同时，主节点自动重启了，如果从节点继续复制主节点的话，从节点的数据也会被清空！</p>
<p>所以，如果想保留数据，正确的做法是先断开从节点和主节点的连接，然后再重启主节点。类似于一种故障转移机制。</p>
<h5 id="2-一主多从"><a href="#2-一主多从" class="headerlink" title="2. 一主多从"></a>2. 一主多从</h5><p>一主多从，又称星形拓扑结构，使得应用端可以利用多个从节点实现读写分离，对于读占比较大的场景，可以通过多个读节点分担主节点压力。</p>
<p>同时，在日常开发中，一些耗时命令（keys，sort），可以在其中一台上执行，防止干扰其他请求。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7dd9dab40ce0d74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>但是：如果写并发量很高，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点负载影响服务稳定性。</p>
<h5 id="3-树形结构"><a href="#3-树形结构" class="headerlink" title="3. 树形结构"></a>3. 树形结构</h5><p>又称（树状拓扑结构）,使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下复制。通过引入复制中间层，一主多从的缺点（多个从节点导致的消耗过多网络带宽）就解决了。</p>
<p>但是，也带来了新的问题，如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ed12c835335402e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如果图中节点故障，那么后面的节点也将无法收到主节点的信息，因此对于运维来讲，增添了许多复杂度，需要手动将节点启动。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是简单介绍了一下 redis 复制相关的内容，包括如何建立复制，断开复制，复制连接的安全，复制的只读状态，还有 Redis 拓扑相关，例如一主一从，一主多从，树形结构。</p>
<p>下一篇文章将重点介绍 Redis 复制的原理。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>《Redis 开发与运维》</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 复制原理</title>
    <url>/2018/08/03/2018/2018-08-04-Redis%20%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       目录：
1. 复制过程
2. 数据间的同步
3. 全量复制
4. 部分复制
5. 心跳
6. 异步复制

<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><h5 id="1-复制过程"><a href="#1-复制过程" class="headerlink" title="1. 复制过程"></a>1. 复制过程</h5><p>复制的过程步骤如下：</p>
<ol>
<li>从节点执行 slaveof 命令</li>
<li>从节点只是保存了 slaveof 命令中主节点的信息，并没有立即发起复制</li>
<li>从节点内部的定时任务发现有主节点的信息，开始使用 socket 连接主节点</li>
<li>连接建立成功后，发送 ping 命令，希望得到 pong 命令响应，否则会进行重连</li>
<li>如果主节点设置了权限，那么就需要进行权限验证；如果验证失败，复制终止。</li>
<li>权限验证通过后，进行数据同步，<strong>这是耗时最长的操作</strong>，主节点将把所有的数据全部发送给从节点。</li>
<li>当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，<strong>主节点就会持续的把写命令发送给从节点，保证主从数据一致性</strong>。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6e738a8f879eae66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<hr>
<h5 id="2-数据间的同步"><a href="#2-数据间的同步" class="headerlink" title="2. 数据间的同步"></a>2. 数据间的同步</h5><p>上面说的复制过程，其中有一个步骤是“同步数据集”，这个就是现在讲的‘数据间的同步’。</p>
<p>redis 同步有 2 个命令：sync 和 psync，前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令。我们会重点关注 2.8 的 psync 命令。</p>
<p>psync 命令需要 3 个组件支持：<br>1.主从节点各自复制偏移量<br>2.主节点复制积压缓冲区<br>3.主节点运行 ID</p>
<p><strong>主从节点各自复制偏移量</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">参与复制的主从节点都会维护自身的复制偏移量。</span><br><span class="line"></span><br><span class="line">主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 <span class="keyword">info</span> <span class="keyword">replication</span> </span><br><span class="line">中的 master_repl_offset 指标中。</span><br><span class="line"></span><br><span class="line">从节点每秒钟上报自身的的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。</span><br><span class="line"></span><br><span class="line">从节点在接收到主节点发送的命令后，也会累加自身的偏移量，统计信息在 <span class="keyword">info</span> <span class="keyword">replication</span> 中。</span><br><span class="line"></span><br><span class="line">通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。</span><br></pre></td></tr></table></figure>



<p><strong>主节点复制积压缓冲区</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">复制积压缓冲区是一个保存在主节点的一个固定长度的先进先出的队列。默认大小 <span class="number">1</span>MB。</span><br><span class="line"></span><br><span class="line">这个队列在 slave 连接是创建。这时主节点响应写命令时，不但会把命令发送给从节点，也会写入复制缓冲区。</span><br><span class="line"></span><br><span class="line">他的作用就是用于部分复制和复制命令丢失的数据补救。</span><br><span class="line"></span><br><span class="line">通过 <span class="keyword">info</span> <span class="keyword">replication</span> 可以看到相关信息。</span><br></pre></td></tr></table></figure>


<p><strong>主节点运行 ID</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">每个 redis 启动的时候，都会生成一个 40 位的运行 ID。</span><br><span class="line"></span><br><span class="line">运行 ID 的主要作用是用来识别 Redis 节点。如果使用 ip+port 的方式，那么如果主节点重启修改</span><br><span class="line">了 RDB/AOF 数据，从节点再基于偏移量进行复制将是不安全的。所以，当运行 id 变化后，从节点将</span><br><span class="line">进行全量复制。也就是说，redis 重启后，默认从节点会进行全量复制。</span><br><span class="line"></span><br><span class="line">如果在重启时不改变运行 ID 呢？</span><br><span class="line">可以通过 <span class="builtin-name">debug</span> reload 命令重新加载 RDB 并保持运行 ID 不变。从而有效的避免不必要的全量复制。</span><br><span class="line">他的缺点则是：<span class="builtin-name">debug</span> reload 命令会阻塞当前 Redis 节点主线程，因此对于大数据量的主节点或者</span><br><span class="line">无法容忍阻塞的节点，需要谨慎使用。</span><br><span class="line"></span><br><span class="line">一般通过故障转移机制可以解决这个问题。</span><br></pre></td></tr></table></figure>

<p><strong>psync 命令的使用方式</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">命令格式为 `psync &#123;runId&#125; &#123;<span class="built_in">offset</span>&#125;`</span><br><span class="line"></span><br><span class="line">runId : 从节点所复制主节点的运行 <span class="built_in">id</span></span><br><span class="line"><span class="built_in">offset</span>：当前从节点已复制的数据偏移量</span><br></pre></td></tr></table></figure>
<p>psync 执行流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-5181b4e3d9d3e5aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>流程说明：从节点发送 psync 命令给主节点，runId 就是目标主节点的 ID，如果没有默认为 -1，offset 是从节点保存的复制偏移量，如果是第一次复制则为 -1.</p>
<p>主节点会根据 runid 和 offset 决定返回结果：</p>
<ul>
<li>如果回复 +FULLRESYNC {runId} {offset} ，那么从节点将触发全量复制流程。</li>
<li>如果回复 +CONTINUE，从节点将触发部分复制。</li>
<li>如果回复 +ERR，说明主节点不支持 2.8 的 psync  命令，将使用 sync 执行全量复制。</li>
</ul>
<p>到这里，数据之间的同步就讲的差不多了，篇幅还是比较长的。主要是针对 psync 命令相关之间的介绍。</p>
<hr>
<h5 id="3-全量复制"><a href="#3-全量复制" class="headerlink" title="3. 全量复制"></a>3. 全量复制</h5><p>全量复制是  Redis 最早支持的复制方式，也是主从第一次建立复制时必须经历的的阶段。触发全量复制的命令是 sync 和 psync。之前说过，这两个命令的分水岭版本是 2.8，redis 2.8 之前使用 sync 只能执行全量不同，2.8 之后同时支持全量同步和部分同步。</p>
<p>流程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-fe63eaaf080e9e78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>介绍一下上图步骤：</p>
<ol>
<li>发送 psync 命令（spync ？ -1）</li>
<li>主节点根据命令返回  FULLRESYNC</li>
<li>从节点记录主节点 ID 和 offset</li>
<li><strong>主节点 bgsave 并保存 RDB 到本地</strong></li>
<li><strong>主节点发送 RBD 文件到从节点</strong></li>
<li><strong>从节点收到 RDB 文件并加载到内存中</strong></li>
<li>主节点在从节点接受数据的期间，将新数据保存到“复制客户端缓冲区”，当从节点加载 RDB 完毕，再发送过去。（如果从节点花费时间过长，将导致缓冲区溢出，最后全量同步失败）</li>
<li><strong>从节点清空数据后加载 RDB 文件，如果 RDB 文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置slave-server-stale-data 关闭</strong>.</li>
<li><strong>从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做 bgrewriteaof</strong>。</li>
</ol>
<p><strong>以上加粗的部分是整个全量同步耗时的地方。</strong></p>
<p>注意：</p>
<ol>
<li>如过 RDB 文件大于 6GB，并且是千兆网卡，Redis 的默认超时机制（60 秒），会导致全量复制失败。<strong>可以通过调大 repl-timeout 参数来解决此问题</strong>。</li>
<li>Redis 虽然支持无盘复制，即直接通过网络发送给从节点，但功能不是很完善，生产环境慎用。</li>
</ol>
<hr>
<h5 id="4-部分复制"><a href="#4-部分复制" class="headerlink" title="4. 部分复制"></a>4. 部分复制</h5><p>当从节点正在复制主节点时，如果出现网络闪断和其他异常，从节点会让主节点补发丢失的命令数据，主节点只需要将复制缓冲区的数据发送到从节点就能够保证数据的一致性，相比较全量复制，成本小很多。</p>
<p>步骤如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f153b591eab605a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol>
<li>当从节点出现网络中断，超过了 repl-timeout 时间，主节点就会中断复制连接。</li>
<li>主节点会将请求的数据写入到“复制积压缓冲区”，默认 1MB。</li>
<li>当从节点恢复，重新连接上主节点，从节点会将 offset 和主节点 id 发送到主节点</li>
<li>主节点校验后，如果偏移量的数后的数据在缓冲区中，就发送 cuntinue 响应 —— 表示可以进行部分复制</li>
<li>主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态。</li>
</ol>
<hr>
<h5 id="5-心跳"><a href="#5-心跳" class="headerlink" title="5. 心跳"></a>5. 心跳</h5><p>主从节点在建立复制后，他们之间维护着长连接并彼此发送心跳命令。</p>
<p>心跳的关键机制如下：</p>
<ol>
<li>中从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。</li>
<li>主节点默认每隔  10 秒对从节点发送  ping 命令，可修改配置 repl-ping-slave-period 控制发送频率。</li>
<li>从节点在主线程每隔一秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量。</li>
<li>主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-bccc6dd3a0d79441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意：为了降低主从延迟，一般把 redis 主从节点部署在相同的机房/同城机房，避免网络延迟带来的网络分区造成的心跳中断等情况。</p>
<hr>
<h5 id="6-异步复制"><a href="#6-异步复制" class="headerlink" title="6. 异步复制"></a>6. 异步复制</h5><p>主节点不但负责数据读写，还负责把写命令同步给从节点，写命令的发送过程是异步完成，也就是说主节点处理完写命令后立即返回客户度，并不等待从节点复制完成。</p>
<p>异步复制的步骤很简单，如下：</p>
<ol>
<li>主节点接受处理命令</li>
<li>主节点处理完后返回响应结果</li>
<li>对于修改命令，异步发送给从节点，从节点在主线程中执行复制的命令。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-bed1c5c1b0f3e43c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要分析了 Redis 的复制原理，包括复制过程，数据之间的同步，全量复制的流程，部分复制的流程，心跳设计，异步复制流程。</p>
<p>其中，可以看出，RDB  数据之间的同步非常耗时。所以，Redis 在 2.8 版本退出了类似增量复制的 psync 命令，当 Redis 主从直接发生了网络中断，不会进行全量复制，而是将数据放到缓冲区（默认 1MB）里，在通过主从之间各自维护复制 offset 来判断缓存区的数据是否溢出，如果没有溢出，只需要发送缓冲区数据即可，成本很小，反之，则要进行全量复制，因此，控制缓冲区大小非常的重要。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>《Redis 开发与运维》</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 复制运维及优化</title>
    <url>/2018/08/04/2018/2018-08-05-Redis%20%E5%A4%8D%E5%88%B6%E8%BF%90%E7%BB%B4%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>在理解了 Redis 的复制原理之后，一起来看看 Redis 复制有哪些坑，以及如何避免。</p>
<hr>
<h2 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h2><p>全量复制是一个非常耗费资源的操作，从一个经验来看，一个 6GB 的从节点发起全量复制的总耗时在 2 分钟所有，感受一下。</p>
<p>因此当数据量达到一定规模以后，由于全量复制涉及到多次持久化操作和网络数据传输，这期间会消耗大量 CPU，内存，硬盘，带宽，所以除了第一次全量复制不可避免，应当尽力避免其他场景发生的全量复制。</p>
<p>全量复制通常有 3 种情况：第一次全量复制，节点运行 ID 不匹配，复制积压缓冲区不足。</p>
<p><strong>第一次全量复制</strong>：由于是第一次建立复制，从节点没有数据，所以这个操作不可避免。当对数据量较大，网络流量较高的主节点添加从节点时，建议在低峰时进行操作，或者尽量避免规避大数据量的 Redis 节点。</p>
<p><strong>节点运行 ID 不匹配</strong>：当主从关系建立后，从节点会保存主节点的运行 ID，如果此时主节点因故障重启，那么他的运行 ID 会改变，从节点发现主节点运行 ID 不匹配时，会认为这是一个新的主节点，从而进行全量复制，并清空之前的数据。对于这种情况，应当从架构上进行规避，比如提供故障转移功能：当主节点发生故障后，手动提升从节点，或者采用支持自动故障转移的哨兵或集群方案。</p>
<p><strong>复制积压缓冲区不足</strong>：当主从节点网络中断后，从节点再次连上主节点时会发送 psync {runId} {offset} 命令请求部分复制，如果请求的偏移量不再主节点的积压缓冲区内，则无法提供给从节点数据，因此<strong>部分复制会退化成全量复制</strong>，针对这种情况，需要根据网络中断时长，写命令数据量，分析出合理的缓冲区大小，然后修改 repl_backlog_size 配置。从而避免因复制积压缓冲区不足造成的全量复制。</p>
<hr>
<h2 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h2><p>复制风暴指的是，大量从节点向同一个 Redis 主节点或者同一台物理机发起全量复制，此时将导致被发起的主节点或机器产生大量开销，例如 CPU，内存，硬盘，带宽等。</p>
<p>我们可以通过分析场景，然后做合理的规避。</p>
<p><strong>单主节点复制风暴：</strong>单主节点复制风暴指的是，一个主节点挂载多个从节点，当主节点重启恢复后，从节点会发起全量复制流程，这时主节点就会为从节点创建 RDB 快照，如果在快照创建完毕之前，有多个从节点都尝试与主节点记性全量同步，那么其他从节点将共享这份 RDB 快照。这点 Redis 做了优化。有效避免了创建多个快照。但是，同时向多个从节点发送 RDB 文件，仍然会导致网络带宽消耗严重，造成主节点的延迟变大。极端情况导致主从连接断开，导致复制失败。</p>
<p>解决方案首先可以减少主节点上挂载从节点的数量，或者采用树状结构。</p>
<p><strong>单机器</strong>：由于 Redis 是单线程架构，所以，通常会在一台物理机上部署多个实例，如果这台机器出现故障或网络长时间中断，当他重启恢复时，会有大量从节点针对这台机器的主节点进行全量复制，会造成当前机器带宽耗尽。<br>优化方案：1. 应当把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。2. 当主节点所在机器故障后提供<strong>故障恢复转移</strong>机制，避免机器恢复后进行密集的全量复制。</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><ol>
<li>数据延迟<br>Redis 复制数据的延迟由于异步特性是无法避免的，延迟多少取决于网络带宽和命令阻塞情况，例如出现刚刚在主节点写入数据后立刻在从节点上读取可能获取不到。</li>
</ol>
<p>而具体延迟多少，可以通过 info replication  的  offset 指标进行排查。</p>
<p>也可以通过监控程序通知客户端，让客户端换一个节点获取数据。</p>
<p>建议在进行读写分离架构前了解一下 Redis Cluster。</p>
<ol start="2">
<li>读到过期数据</li>
</ol>
<p>当主节点存到大量设置超时的数据，Redis 内部需要维护过期数据删除策略，删除策略主要由 2 种：惰性删除和定时删除。</p>
<p>惰性删除：每次访问数据的时候，主节点都检查是否过期，如果过期则执行 del 命令，然后异步发送 del 命令给从节点，注意：从节点永远不会主动删除数据，这也是为了保证数据一致性。</p>
<p>定时删除：Redis 主节点在内部定时任务会循环采样一定数量的键，当发现采样的键过期时执行 del 命令，之后再同步给从节点。<br>如果此时大量数据超时，定时任务速度更不上，且主节点没有被访问，也就无法执行 del，进而从节点也无法执行 del。客户端就会读到从节点的过期数据。Redis 3.2 版本已经解决了这个问题，在从节点读取数据时，会检查键的过期时间。</p>
<ol start="3">
<li>从节点故障问题</li>
</ol>
<p>对于从节点的故障问题，需要在客户端维护一个可用从节点可用列表，当从节点故障时，立刻切换到其他从节点或主节点。也可以通过 zk 等协调者解决。</p>
<p><strong>建议</strong>：综上所述，使用 Redis 做读写分离有一定的成本，Redis 本身的性能非常高，如果已经解决了使用不当等问题，单机 Redis 还是无法满足，那么笔者建议调研 Redis  Cluster 分布式解决方案，这样不止扩展读性能还可以扩展写性能，并且一致性和故障转移也可以得到保证。对于客户端的维护逻辑也相对容易。</p>
<h2 id="主从配置不一致"><a href="#主从配置不一致" class="headerlink" title="主从配置不一致"></a>主从配置不一致</h2><p>这个总体来说是比较简单的，同时也是一个容易忽视的问题，对于有些配置可以不一样，例如从节点开启 AOF，主节点关闭 AOF。但是，关于内存方面的配置一定要相同，例如 <code>maxmemory</code>，<code>hash-max-ziplist-entries</code> 等参数，当从节点的内存小于主节点，如果复制的数据量超过了从节点的 maxmemory，他会根据淘汰策略（maxmemory-policy）进行内存溢出控制，此时从节点数据已经丢失，但主从复制流程依然正常进行，复制偏移量也正常，但主从数据已经不一致。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要总结了 Redis 复制的运维及优化，包括规避全量复制，规避复制风暴，读写分离的优化，主从配置不一致。使用 Redis 不仅仅是 set get，能够合理的运维也是非常重要的。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>《Redis 开发与运维》</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 初次见面</title>
    <url>/2018/07/29/2018/2018-07-30-Redis%20%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 目录
1.  Redis 特性
2.  使用场景
3.  初次使用
  安装（Linux）
  配置
  启动 redis 的 3 种方法
  使用 redis 客户端
  关闭 redis 服务
4. Redis 版本说明
5. 引用

<h2 id="1-Redis-特性"><a href="#1-Redis-特性" class="headerlink" title="1 Redis 特性"></a>1 Redis 特性</h2><ol>
<li>速度快（基于内存，C 语言，单线程）</li>
<li> 基于 key value 键值对的数据结构服务器。全称 Remote Dictionary Server。包含 String，Hash, List, Set, SotrSet. 同时在字符串的基础上演变出位图（BitMaps） 和 HyperLogLog 两种数据数据结构。3.2 版本中加入 GEO（地理信息位置）。</li>
<li>丰富的功能。例如：键过期（缓存），发布订阅（消息队列）， Lua 脚本（自己实现 Redis 命令），事务，流水线（Pipeline 减少网络开销）。</li>
<li>简单稳定。</li>
<li>客户端语言多。</li>
<li>持久化（RDB，AOF）。</li>
<li>主从复制（分布式的基础）。</li>
<li>高可用（Sentinel）和分布式（Cluster）。</li>
</ol>
<h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2 使用场景"></a>2 使用场景</h2><ol>
<li><p>缓存</p>
<blockquote>
<p>合理的使用缓存能够明显加快访问的速度，同时降低数据源的压力。这也是 Redis 最常用的功能。Redis 提供了键值过期时间（<code>EXPIRE key seconds</code>）设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。</p>
</blockquote>
</li>
<li><p>排行榜</p>
<blockquote>
<p>每个网站都有自己的排行榜，例如按照热度排名的排行榜，发布时间的排行榜，答题排行榜等等。Redis 提供了列表（List）和有序集合（sorted set）数据结构，合理的使用这些数据结构可以很方便的构建各种排行榜系统。</p>
</blockquote>
</li>
<li><p>计数器</p>
<blockquote>
<p>计数器在网站应用中非常重要，例如，点赞数加一，浏览数加一，还有常用的限流操作，限制每个用户每秒访问系统的次数等等，Redis 支持计数功能（INCR key）而且计数的性能也非常好，计数的同时也可以设置超时时间，这样就可以实现限流。</p>
</blockquote>
</li>
</ol>
<ol start="4">
<li>社交网络<blockquote>
<p>赞/踩，粉丝，共同好友/喜好，推送，下拉刷新等是社交网站必备的功能，由于社交网站访问量通常比较大，而且传统的数据库不太适合保存这类数据，Redis 提供的数据结构可以相对比较容易实现这些功能。链接:<a href="https://blog.csdn.net/younger_z/article/details/51692720">Redis实战：如何构建类微博的亿级社交平台</a></p>
</blockquote>
</li>
</ol>
<ol start="5">
<li>消息队列<blockquote>
<p>Redis 提供的发布订阅（PUB/SUB） 和阻塞队列（blpop key1…keyN timeout ）的功能，虽然和专业的消息队列比，还不够强大，但对于一般的消息队列功能基本满足。</p>
</blockquote>
</li>
</ol>
<h2 id="3-初次使用"><a href="#3-初次使用" class="headerlink" title="3 初次使用"></a>3 初次使用</h2><ol>
<li>安装（Linux）<br>Centos yum install redis</li>
<li>配置<br>安装完成之后，会在 /usr/local/bin 目录目录下，多出几个可执行文件，称之为 redis shell。如下：</li>
</ol>
<table>
<thead>
<tr>
<th>可执行文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>redis-server</td>
<td>启动 redis 服务</td>
</tr>
<tr>
<td>redis-cli</td>
<td>redis 命令行客户端</td>
</tr>
<tr>
<td>redis-benchmark</td>
<td>redis 基准测试工具</td>
</tr>
<tr>
<td>redis-check-aof</td>
<td>redis AOF 持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-check-dump</td>
<td>redis RDB 持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td>启动 redis sentinel</td>
</tr>
</tbody></table>
<ol start="3">
<li>启动 redis 的 3 种方法</li>
<li>1 <strong>配置文件启动</strong><br>将配置写到配置文件中，例如写到 /opt/redis/redis.conf 中，执行 redis-server /opt/redis/redis.conf 即可启动 redis。redis 有 60 多个配置，常用的是：port（端口），logfile（日志文件），dir（redis 工作目录，存放持久化文件和日志文件），daemonize（是否以守护进程的方式启动 redis）。</li>
<li>2 <strong>运行启动</strong><br>在 redis-server 后面加入参数，格式为：redis-server –configkey1 configvaue1 –configkey2 configvalue2. 例如：redis-server –port 6380 ，即，将端口自定义为 6380.</li>
<li>3 <strong>默认启动</strong><br>直接 redis-server，默认端口 6379.</li>
</ol>
<p><strong>如果是生产环境的话，通常建议使用配置文件的方式启动。</strong></p>
<ol start="4">
<li>使用 redis 客户端<br>redis 客户端可以通过设置 ip 端口，连接 redis 服务器并执行命令。而使用redis-cli 的方式有 2 种。</li>
<li>1 交互式方式<br>通过 redis cli -h [host] -p [port] 的方式连接到 reids 服务。</li>
<li>2 命令式方式<br>通过 redis-cli -h [host] -p [port] [command] 就可以，是一次性的。</li>
</ol>
<p>注意：<strong>如果不指定 host，port ，默认连接 127.0.0.1:6379.</strong></p>
<ol start="5">
<li>关闭 redis 服务<br>redis 提供了 shutDown 命令来停止 redis 服务，例如停掉127.0.0.1：6379 服务，使用：redis-cli shutdown 即可。</li>
</ol>
<p>注意点：</p>
<ol>
<li>redis 关闭的过程：断开和客户端的连接，持久化文件生成。相对而言比较优雅。</li>
<li>不用使用 kill -9，过于粗暴，不但不会做持久化操作，还会造成缓冲区等资源不会优雅关闭。极端情况下造成 AOF 和复制丢失数据的情况。</li>
<li>shutdown 还有一个参数，代表是否在关闭 redis 前，生成持久化文件：<br>redis-cli shutdown nosave|save</li>
</ol>
<h2 id="4-Redis-版本说明"><a href="#4-Redis-版本说明" class="headerlink" title="4 Redis 版本说明"></a>4 Redis 版本说明</h2><p>redis 借鉴了 Linux 对于版本号的命名规则，版本号第二位如果是奇数，则为非稳定版本，如果是偶数，则为稳定版本。当前奇数版本就是下一个稳定版本的开发版本。</p>
<p>重大版本：2.8 提升了 sentinel 的可用性，使其可在生产环境使用；3.0 版本最大的功能：添加了分布式 Redis Cluster，填补了官方没有分布式实现的空白（之前都是用户自己实现的 sharding）。</p>
<h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5 引用"></a>5 引用</h2><p>《Redis 开发与运维》</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Jedis 如何支持 Sentinel</title>
    <url>/2018/08/04/2018/2018-08-06-Jedis%20%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%20Sentinel/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>Jedis 作为 Java 世界 Redis 的老牌客户端，很好的支持了 Sentinel，例如 Sentinel 的故障转移功能。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Jedis 提供了一个 Sentinel 构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JedisSentinelPool</span><span class="params">(String masterName, Set&lt;String&gt; sentinels,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> GenericObjectPoolConfig poolConfig, <span class="keyword">final</span> <span class="keyword">int</span> connectionTimeout, <span class="keyword">final</span> <span class="keyword">int</span> soTimeout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> String password, <span class="keyword">final</span> <span class="keyword">int</span> database, <span class="keyword">final</span> String clientName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.poolConfig = poolConfig;</span><br><span class="line">  <span class="keyword">this</span>.connectionTimeout = connectionTimeout;</span><br><span class="line">  <span class="keyword">this</span>.soTimeout = soTimeout;</span><br><span class="line">  <span class="keyword">this</span>.password = password;</span><br><span class="line">  <span class="keyword">this</span>.database = database;</span><br><span class="line">  <span class="keyword">this</span>.clientName = clientName;</span><br><span class="line"></span><br><span class="line">  HostAndPort master = initSentinels(sentinels, masterName);</span><br><span class="line">  initPool(master);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该构造方法做了 2件事情，初始化 Sentinel 和 Pool。我们先看看 initSentinel。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HostAndPort <span class="title">initSentinels</span><span class="params">(Set&lt;String&gt; sentinels, <span class="keyword">final</span> String masterName)</span> </span>&#123;</span><br><span class="line">   HostAndPort master = <span class="keyword">null</span>; </span><br><span class="line">   <span class="keyword">boolean</span> sentinelAvailable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (String sentinel : sentinels) &#123;<span class="comment">// 遍历 Sentinel 节点</span></span><br><span class="line">     <span class="keyword">final</span> HostAndPort hap = HostAndPort.parseString(sentinel);<span class="comment">// 解析 String 为 ip port</span></span><br><span class="line"></span><br><span class="line">     Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       jedis = <span class="keyword">new</span> Jedis(hap.getHost(), hap.getPort());<span class="comment">// 创建 Jedis 对象 </span></span><br><span class="line">       <span class="comment">// 执行 get-master-addr-by-name masterName 获取主节点信息</span></span><br><span class="line">       List&lt;String&gt; masterAddr = jedis.sentinelGetMasterAddrByName(masterName);</span><br><span class="line">       <span class="comment">// 标识符：Sentinel 存在</span></span><br><span class="line">       sentinelAvailable = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 如果主节点是空，或者返回长度不等于 2，跳过此 Sentinel</span></span><br><span class="line">       <span class="keyword">if</span> (masterAddr == <span class="keyword">null</span> || masterAddr.size() != <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果成功获取主节点，解析字符串成 HostAndPort 对象</span></span><br><span class="line">       master = toHostAndPort(masterAddr);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">         jedis.close();<span class="comment">// 每次循环归还 Redis 连接</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果 master 是 null，抛出异常</span></span><br><span class="line">   <span class="keyword">if</span> (master == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (sentinelAvailable) &#123;<span class="comment">// 细化异常，这个是 Sentinel 有问题</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JedisException(<span class="string">&quot;Can connect to sentinel, but &quot;</span> + masterName</span><br><span class="line">           + <span class="string">&quot; seems to be not monitored...&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JedisConnectionException(<span class="string">&quot;All sentinels down, cannot determine where is &quot;</span></span><br><span class="line">           + masterName + <span class="string">&quot; master is running...&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 遍历 哨兵</span></span><br><span class="line">   <span class="keyword">for</span> (String sentinel : sentinels) &#123;</span><br><span class="line">     <span class="keyword">final</span> HostAndPort hap = HostAndPort.parseString(sentinel);</span><br><span class="line">     <span class="comment">// 创建 master 监听器线程</span></span><br><span class="line">     MasterListener masterListener = <span class="keyword">new</span> MasterListener(masterName, hap.getHost(), hap.getPort());</span><br><span class="line">     masterListener.setDaemon(<span class="keyword">true</span>);<span class="comment">// 后台线程</span></span><br><span class="line">     masterListeners.add(masterListener);<span class="comment">// 添加到监听集合，后期优雅关闭</span></span><br><span class="line">     masterListener.start();<span class="comment">// 启动线程</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> master;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>方法很长，简单说说逻辑：</p>
<ol>
<li>遍历 Sentinel 字符串</li>
<li>根据字符串生成 HostAndPort 对象，然后创建一个 Jedis 对象。</li>
<li>使用 Jedis 对象发送 <code>get-master-addr-by-name masterName</code> 命令，得到 master 信息。</li>
<li>得到 master 信息后，再次遍历哨兵集合，为每个哨兵创建一个线程，监听哨兵的发布订阅消息，消息主题是  <code>+switch-master</code>. 当主节点发生变化时，将通过 pub/sub 通知该线程，该线程将更新 Redis 连接池。</li>
</ol>
<p>看看这个线程的主要内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// flag</span></span><br><span class="line">  running.set(<span class="keyword">true</span>);</span><br><span class="line">  <span class="comment">// 死循环</span></span><br><span class="line">  <span class="keyword">while</span> (running.get()) &#123;</span><br><span class="line">    <span class="comment">//创建一个 Jedis对象</span></span><br><span class="line">    j = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 继续检查</span></span><br><span class="line">      <span class="keyword">if</span> (!running.get()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// jedis 对象，通过 Redis pub/sub 订阅 switch-master 主题</span></span><br><span class="line">      j.subscribe(<span class="keyword">new</span> JedisPubSub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 分割字符串  </span></span><br><span class="line">          String[] switchMasterMsg = message.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">          <span class="comment">// 如果长度大于三</span></span><br><span class="line">          <span class="keyword">if</span> (switchMasterMsg.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 且 第一个 字符串的名称和当前 masterName 发生了 switch</span></span><br><span class="line">            <span class="keyword">if</span> (masterName.equals(switchMasterMsg[<span class="number">0</span>])) &#123;</span><br><span class="line">              <span class="comment">// 重新初始化连接池（第 4 个和 第 5 个）</span></span><br><span class="line">              initPool(toHostAndPort(Arrays.asList(switchMasterMsg[<span class="number">3</span>], switchMasterMsg[<span class="number">4</span>])));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="string">&quot;+switch-master&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisConnectionException e) &#123;</span><br><span class="line">      <span class="comment">// 如果连接异常</span></span><br><span class="line">      <span class="keyword">if</span> (running.get()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 默认休息 5 秒</span></span><br><span class="line">          Thread.sleep(subscribeRetryWaitTimeMillis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      j.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法已经写了很多注释，稍微说下逻辑：根据哨兵的 host 和 port 创建一个 jedis 对象，然后，这个 jedis 对象订阅了 pub/sub 消息，，消息的主题是 “+switch-master” ，如果收到消息了，就执行 onMessage 方法，该方法会根据新的  master 信息重新初始化 Redis 连接池。</p>
<p>那么如何初始化连接池的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">(HostAndPort master)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 比较 host  + port，如果不相等，就重新初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!master.equals(currentHostMaster)) &#123;</span><br><span class="line">    <span class="comment">// 修改当前 master</span></span><br><span class="line">    currentHostMaster = master;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      factory = <span class="keyword">new</span> JedisFactory(master.getHost(), master.getPort(), connectionTimeout,</span><br><span class="line">          soTimeout, password, database, clientName, <span class="keyword">false</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      initPool(poolConfig, factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 修改连接参数, 下次获取连接的时候，就可以生成新的连接</span></span><br><span class="line">      factory.setHostAndPort(currentHostMaster);</span><br><span class="line">      <span class="comment">// 清空旧的连接池</span></span><br><span class="line">      internalPool.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，在 Sentinel 构造器里面，也会调用这个方法，第一次调用的时候， factory 肯定是 null，第二次调用的时候，会设置 factory 的 hostAndPort 为新的 master 地址，然后清空原来的连接池。那么新的 getResource 方法就会从这个新的地址获取到新的连接了。</p>
<p>具体关于 JedisSentinelPool 的  getResource 方法就不细说了，大家可以自己看看，还是很简单的，</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到 Sentinel 的通知客户端机制，是需要客户端进行配合的，客户端需要通过 Sentinel 的 pub/sub 机制订阅哨兵节点的 <code>+switch-master</code> 主题，当 master 改变的时候，会通过 pub 通知客户端，客户端此时就可以优雅的更新连接池。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Mac 搭建 Redis 集群</title>
    <url>/2018/08/07/2018/2018-08-08-Mac%20%E6%90%AD%E5%BB%BA%20Redis%20%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 目录
1. redis 下载
2. 创建目录 + 配置文件
3. 关联所有节点
4. 分配 slot
5. 主从复制
总结

<h2 id="1-redis-下载"><a href="#1-redis-下载" class="headerlink" title="1. redis 下载"></a>1. redis 下载</h2><p>请使用 brew install redis 工具或从官网下载 <a href="http://download.redis.io/releases/redis-4.0.11.tar.gz">Redis 4.0.11 is the latest stable version</a>。</p>
<h2 id="2-创建目录-配置文件"><a href="#2-创建目录-配置文件" class="headerlink" title="2. 创建目录 + 配置文件"></a>2. 创建目录 + 配置文件</h2><p>我们准备创建 6 个节点，方便起见，创建 6 个工作目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir redisCluter</span><br><span class="line">cd redisCluster</span><br><span class="line">mkdir 7000 7001 7002 7003 7004</span><br></pre></td></tr></table></figure>

<p>目录创建好了，目录名就是端口号。接下来，需要给每个节点配置“配置文件”。<br>集群模式下，需要修改下面这些配置。</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 端口号，每个目录都不同</span></span><br><span class="line">port <span class="number">700</span>X</span><br><span class="line"><span class="meta"># 开启集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta">#节点超时实际，单位毫秒</span></span><br><span class="line">cluster-node-timeout <span class="number">5000</span></span><br><span class="line"><span class="meta">#集群内部配置文件(默认为 nodes.conf)</span></span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"><span class="meta"># 启动 AOF</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>将你下载的 redis 目录下的配置文件（通常在 /usr/local/redis-XXX/redis.conf）拷贝到每个目录下，然后逐一修改。<br>然后，逐一进入各个目录，执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>
<p>这个时候，每个目录下面都会出现几个文件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e3dbb5cc19666ae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>类似图中这样，但可能没有 rdb 文件，因为这是 shutdown redis 的时候生成的。</p>
<h2 id="3-关联所有节点"><a href="#3-关联所有节点" class="headerlink" title="3. 关联所有节点"></a>3. 关联所有节点</h2><p>刚刚我们已经把所有的节点启动了，但此时他们都是互相独立的单个集群节点。要想实现集群，必须将他们关联起来，随便进入一个节点的 redis-cli.<br>执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  7002 redis-cli -p 7000</span><br><span class="line">127.0.0.1:7000&gt; cluster meet 127.0.0.1 7001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7000&gt; cluster meet 127.0.0.1 7002</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7000&gt; cluster meet 127.0.0.1 7003</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7000&gt; cluster meet 127.0.0.1 7004</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7000&gt; cluster meet 127.0.0.1 7005</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>此时，所有的节点都关联起来了。</p>
<h2 id="4-分配-slot"><a href="#4-分配-slot" class="headerlink" title="4. 分配 slot"></a>4. 分配 slot</h2><p>我们知道，redis Cluster 是由 16384 个 slot 组成的，那么我们需要将这些槽分散到这其中 3 个节点里（3 主 3 从）。</p>
<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  7002 redis-cli -p 7000 cluster addslots &#123;0..5461&#125;</span><br><span class="line">➜  7002 redis-cli -p 7001 cluster addslots &#123;546..10922&#125;</span><br><span class="line">➜  7002 redis-cli -p 7002 cluster addslots &#123;10923..16383&#125;</span><br></pre></td></tr></table></figure>

<p>此时节点已经分配好了。通过以下命令验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7000 cluster nodes</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ef5ebddac902e54e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从图中可以看出，7004，7000， 7005 节点都已经有了 slot，但为什么不是刚刚设置的 7000，7001，7002 呢，因为楼主进行操作过了，但这不是重点。可以略过。</p>
<h2 id="5-主从复制"><a href="#5-主从复制" class="headerlink" title="5. 主从复制"></a>5. 主从复制</h2><p>主节点已经有了 slot，那么最后一步就是将主节点和从节点进行关联，形成主从复制的关系。</p>
<p>命令如下：<br>注意：需要在从节点的 cli 命令窗口关联主节点。不能反着来。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">redis</span>-cli -p <span class="number">7003</span> cluster replicate <span class="number">7000</span>的NodeID</span><br><span class="line"><span class="attribute">redis</span>-cli -p <span class="number">7004</span> cluster replicate <span class="number">7001</span>的NodeID</span><br><span class="line"><span class="attribute">redis</span>-cli -p <span class="number">7005</span> cluster replicate <span class="number">7002</span>的NodeID</span><br></pre></td></tr></table></figure>

<p>这个 <code>7000的NodeID</code> <code>7001的NodeID</code> <code>7002的NodeID</code> 其实就是执行 <code> redis-cli -p 7000 cluster nodes</code> 命令出现的那一串 16 进制字符串。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-74347069f00ee0f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如上图所示。</p>
<p>如果一切顺利，那么再次执行  <code> redis-cli -p 7000 cluster nodes</code>  命令，你会看到：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3adaa51ab7443ad4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意红框：master slave，slave 后面跟着的就是 master 的 NodeId。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>手动搭建 Redis Cluster 还是很麻烦的，需要下载，配置文件，启动节点，管理节点，分配 slot，管理主从复制等。</p>
<p>Redis 提供了一个小工具：redis-trib.rb，擦用 ruby 编写，内部也是通过这些命令的，直接使用命令有助有我们理解 Redis Cluster 的原理。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Mac 搭建 Redis Sentinel 集群</title>
    <url>/2018/08/08/2018/2018-08-09-Mac%20%E6%90%AD%E5%BB%BA%20Redis%20Sentinel%20%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 1. 创建目录并启动主从节点

<h4 id="1-主节点"><a href="#1-主节点" class="headerlink" title="1. 主节点"></a>1. 主节点</h4><p>执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ mkdir redisSentinel</span><br><span class="line">➜  ~ cd redisSentinel </span><br><span class="line">➜  redisSentinel mkdir master</span><br><span class="line">➜  redisSentinel cp /usr/local/redis-3.2.8/redis.conf master/redis.conf</span><br></pre></td></tr></table></figure>

<p>此时主节点目录已经创建好了，然后，配置主节点配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">port</span> <span class="number">8000</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<p>就简单修改这两个配置好了。<br>然后自动这个主节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  redisSentinel cd master </span><br><span class="line">➜  master redis-server redis.conf </span><br></pre></td></tr></table></figure>

<p>检查一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  master redis-cli -p 8000 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<p>主节点就好了，接下来创建从节点。</p>
<hr>
<h4 id="2-从节点"><a href="#2-从节点" class="headerlink" title="2. 从节点"></a>2. 从节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  master cd ..</span><br><span class="line">➜  redisSentinel mkdir slave</span><br></pre></td></tr></table></figure>

<p>拷贝配置文件到从节点中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  redisSentinel cp master/redis.conf slave/redis-8001.conf</span><br><span class="line">➜  redisSentinel cp master/redis.conf slave/redis-8002.conf</span><br></pre></td></tr></table></figure>

<p>这里我们将两个从节点的端口定为 8001 和 8002，然后修改配置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">port</span> <span class="string">800X</span></span><br><span class="line"><span class="string">damonnize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">slaveof</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure>

<p>加入了一个 slaveof 配置，表明该节点的主节点是 127.0.0.1:8000.</p>
<p>然后启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  redisSentinel cd slave </span><br><span class="line">➜  slave redis-server redis-8001.conf </span><br><span class="line">➜  slave redis-server redis-8002.conf</span><br></pre></td></tr></table></figure>

<p>现在主从节点已经关联好了，现在通过 info 命令看看是否成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  slave redis-cli -p 8000 info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=8001,state=online,offset=505,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=8002,state=online,offset=505,lag=1</span><br><span class="line">master_repl_offset:505</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:504</span><br></pre></td></tr></table></figure>


<p>进入了 8000 主节点中查看，看见 role 是 master，并且有 2 个从节点，8001 和 8002. 成功！</p>
<p>接着开始部署哨兵节点.</p>
<h2 id="2-部署哨兵节点"><a href="#2-部署哨兵节点" class="headerlink" title="2. 部署哨兵节点"></a>2. 部署哨兵节点</h2><p>首先创建配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  slave cd ..</span><br><span class="line">➜  redisSentinel mkdir sentinel</span><br><span class="line">➜  redisSentinel cd sentinel </span><br><span class="line">➜  sentinel cp /usr/local/redis-3.2.8/redis.conf redis-sentinel-26379.conf</span><br><span class="line">➜  sentinel cp /usr/local/redis-3.2.8/redis.conf redis-sentinel-26380.conf</span><br><span class="line">➜  sentinel cp /usr/local/redis-3.2.8/redis.conf redis-sentinel-26381.conf</span><br></pre></td></tr></table></figure>

<p>哨兵节点的默认端口是 26739。我们这里弄了 3 个哨兵节点。</p>
<p>然后修改配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 8000 2</span><br></pre></td></tr></table></figure>

<p>这里比较关键的是：<code>sentinel monitor mymaster 127.0.0.1 8000 2</code>,这个配置表示该哨兵节点需要监控 8000 这个主节点， 2 代表着判断主节点失败至少需要 2 个 Sentinel 节点同意。</p>
<p>启动 Sentinel 节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  sentinel redis-sentinel redis-sentinel-26379.conf </span><br><span class="line">➜  sentinel redis-sentinel redis-sentinel-26380.conf</span><br><span class="line">➜  sentinel redis-sentinel redis-sentinel-26381.conf</span><br></pre></td></tr></table></figure>

<p>启动成功后，看看哨兵的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  sentinel redis-cli -p 26380 info sentinel</span><br><span class="line"><span class="meta">#</span><span class="bash"> Sentinel</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:8000,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure>

<p>通过进入 26380 节点，使用 info Sentinel 命令，看到有个 master 节点，名称是 mymaster，地址是我们刚刚配置的 8000， 从节点有 2 个，哨兵有 3 个。</p>
<p>此时一个高可用的 Redis 集群就搭建好了。</p>
<p>当然如果是生产环境，所有实例建议部署在不同的机器上。</p>
<p>部署后的拓扑图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-77806db5e7db52bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="3-使用-Jedis-测试"><a href="#3-使用-Jedis-测试" class="headerlink" title="3. 使用 Jedis 测试"></a>3. 使用 Jedis 测试</h2><p>先在命令行往主节点写入一条数据:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  cachecloud git:(master) ✗ redis-cli -p 8000 set &quot;hello&quot; &quot;world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>Jedis 代码测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Set&lt;String&gt; sentinelSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  sentinelSet.add(<span class="string">&quot;127.0.0.1:26379&quot;</span>);</span><br><span class="line">  sentinelSet.add(<span class="string">&quot;127.0.0.1:26380&quot;</span>);</span><br><span class="line">  sentinelSet.add(<span class="string">&quot;127.0.0.1:26381&quot;</span>);</span><br><span class="line"></span><br><span class="line">  String masterName = <span class="string">&quot;mymaster&quot;</span>;</span><br><span class="line"></span><br><span class="line">  JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinelSet, <span class="keyword">new</span> GenericObjectPoolConfig(),</span><br><span class="line">      <span class="number">10000</span>, <span class="number">10000</span>, <span class="keyword">null</span>, Protocol.DEFAULT_DATABASE);</span><br><span class="line">  System.out.println(sentinelPool.getResource().get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">world</span><br></pre></td></tr></table></figure>

<p>成功！！！</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p> Sentinel  节点实际上就是个特殊的 Redis 节点。<br>回头看看搭建过程：</p>
<ol>
<li>搭建主从节点，通过修改配置文件，关联主从节点。</li>
<li>搭建哨兵节点集群，修改配置文件，通过 slaveof 监控主节点。</li>
</ol>
<p>就好啦。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 面试常见问答</title>
    <url>/2018/08/09/2018/2018-08-10-Redis%20%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E7%AD%94/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 1. 什么是缓存雪崩？怎么解决？

<p><img src="https://upload-images.jianshu.io/upload_images/4236553-14ea71c186a2d1e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>通常，我们会使用缓存用于缓冲对 DB 的冲击，如果缓存宕机，所有请求将直接打在 DB，造成 DB 宕机——从而导致整个系统宕机。</p>
<p>如何解决呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9747ca243c0c5390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>2 种策略（同时使用）：</p>
<ol>
<li>对缓存做高可用，防止缓存宕机</li>
<li>使用断路器，如果缓存宕机，为了防止系统全部宕机，限制部分流量进入 DB，保证部分可用，其余的请求返回断路器的默认值。</li>
</ol>
<h2 id="2-什么是缓存穿透？怎么解决？"><a href="#2-什么是缓存穿透？怎么解决？" class="headerlink" title="2. 什么是缓存穿透？怎么解决？"></a>2. 什么是缓存穿透？怎么解决？</h2><p>解释 1：缓存查询一个没有的 key，同时数据库也没有，如果黑客大量的使用这种方式，那么就会导致 DB 宕机。</p>
<p>解决方案：我们可以使用一个默认值来防止，例如，当访问一个不存在的 key，然后再去访问数据库，还是没有，那么就在缓存里放一个占位符，下次来的时候，检查这个占位符，如果发生时占位符，就不去数据库查询了，防止 DB 宕机。</p>
<p>解释 2： 大量请求查询一个刚刚失效的 key，导致 DB 压力倍增，可能导致宕机，但实际上，查询的都是相同的数据。</p>
<p>解决方案：可以在这些请求代码加上双重检查锁。但是那个阶段的请求会变慢。不过总比 DB 宕机好。</p>
<h2 id="3-什么是缓存并发竞争？怎么解决？"><a href="#3-什么是缓存并发竞争？怎么解决？" class="headerlink" title="3. 什么是缓存并发竞争？怎么解决？"></a>3. 什么是缓存并发竞争？怎么解决？</h2><p>解释：多个客户端写一个 key，如果顺序错了，数据就不对了。但是顺序我们无法控制。</p>
<p>解决方案：使用分布式锁，例如 zk，同时加入数据的时间戳。同一时刻，只有抢到锁的客户端才能写入，同时，写入时，比较当前数据的时间戳和缓存中数据的时间戳。</p>
<h2 id="4-什么是缓存和数据库双写不一致？怎么解决？"><a href="#4-什么是缓存和数据库双写不一致？怎么解决？" class="headerlink" title="4.什么是缓存和数据库双写不一致？怎么解决？"></a>4.什么是缓存和数据库双写不一致？怎么解决？</h2><p>解释：连续写数据库和缓存，但是操作期间，出现并发了，数据不一致了。<br>通常，更新缓存和数据库有以下几种顺序：</p>
<ol>
<li>先更新数据库，再更新缓存。</li>
<li>先删缓存，再更新数据库。</li>
<li>先更新数据库，再删除缓存。</li>
</ol>
<p> 三种方式的优劣来看一下：</p>
<ol>
<li><p>先更新数据库，再更新缓存。<br>这么做的问题是：当有 2 个请求同时更新数据，那么如果不使用分布式锁，将无法控制最后缓存的值到底是多少。也就是并发写的时候有问题。</p>
</li>
<li><p>先删缓存，再更新数据库。<br>这么做的问题：如果在删除缓存后，有客户端读数据，将可能读到旧数据，并有可能设置到缓存中，导致缓存中的数据一直是老数据。<br>有 2 种解决方案：1. 使用“双删”，即删更删，最后一步的删除作为异步操作，就是防止有客户端读取的时候设置了旧值。2. 使用队列，当这个 key 不存在时，将其放入队列，串行执行，必须等到更新数据库完毕才能读取数据。</p>
</li>
</ol>
<p>总的来讲，比较麻烦。</p>
<ol start="3">
<li>先更新数据库，再删除缓存<br>这个实际是常用的方案，但是有很多人不知道，这里介绍一下，这个叫 Cache Aside Pattern，老外发明的。如果先更新数据库，再删除缓存，那么就会出现更新数据库之前有瞬间数据不是很及时。<br>同时，如果在更新之前，缓存刚好失效了，读客户端有可能读到旧值，然后在写客户端删除结束后再次设置了旧值，非常巧合的情况。<br>有 2 个前提条件：缓存在写之前的时候失效，同时，在写客户度删除操作结束后，放置旧数据 —— 也就是读比写慢。设置有的写操作还会锁表。<br>所以，这个很难出现，但是如果出现了怎么办？使用双删！！！记录更新期间有没有客户端读数据库，如果有，在更新完数据库之后，执行延迟删除。</li>
</ol>
<p>还有一种可能，如果执行更新数据库，准备执行删除缓存时，服务挂了，执行删除失败怎么办？？？<br>这就坑了！！！ 不过可以通过订阅数据库的 binlog 来删除。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coolshell.cn/articles/17416.html">  缓存更新的套路</a><br><a href="https://www.cnblogs.com/rjzheng/p/9041659.html"> 原创  分布式之数据库和缓存双写一致性方案解析</a><br><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">Cache-Aside pattern</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Jedis 如何支持 Cluster</title>
    <url>/2018/08/06/2018/2018-08-07-Jedis%20%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%20Cluster/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录：
1. 初始化
2. 发送命令和重试机制
3. 总结

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面说了 Jedis（2.9.0） 如何支持 Redis  Sentinel 的，今天看看 Jedis 是如何支持 Redis Cluster 的。</p>
<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h2><p>Jedis Cluster 构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JedisCluster</span><span class="params">(Set&lt;HostAndPort&gt; jedisClusterNode, <span class="keyword">int</span> connectionTimeout, <span class="keyword">int</span> soTimeout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> maxAttempts, <span class="keyword">final</span> GenericObjectPoolConfig poolConfig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(jedisClusterNode, connectionTimeout, soTimeout, maxAttempts, poolConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： <code>Set&lt;HostAndPort&gt; jedisClusterNode</code> 中包含所有主从节点。</p>
<p>通过层层跟踪，我们来到了 initializeSlotsCache 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeSlotsCache</span><span class="params">(Set&lt;HostAndPort&gt; startNodes, GenericObjectPoolConfig poolConfig, String password)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (HostAndPort hostAndPort : startNodes) &#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(hostAndPort.getHost(), hostAndPort.getPort());</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">      jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">      cache.discoverClusterNodesAndSlots(jedis);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisConnectionException e) &#123;</span><br><span class="line">      <span class="comment">// try next nodes</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 cache 设计上就是 Redis Cluster slot 的缓存，每个 slot 都指向一个连接池。看看这个 cache 的内部结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterInfoCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, JedisPool&gt; nodes = <span class="keyword">new</span> HashMap&lt;String, JedisPool&gt;();<span class="comment">// ip：port 对应的连接池</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, JedisPool&gt; slots = <span class="keyword">new</span> HashMap&lt;Integer, JedisPool&gt;();<span class="comment">// slot 对应的连接池</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> rediscovering;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> GenericObjectPoolConfig poolConfig;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> connectionTimeout;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> soTimeout;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASTER_NODE_INDEX = <span class="number">2</span>;<span class="comment">// 主节点下标</span></span><br></pre></td></tr></table></figure>

<p>其中，在 <code>initializeSlotsCache </code>方法中，会遍历所有的节点信息，但是，只会执行一次 <code>cache.discoverClusterNodesAndSlots(jedis)</code>，如果失败了，就继续执行这个方法。为什么只需要执行一次呢？</p>
<p>来看看 <code>cache.discoverClusterNodesAndSlots</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discoverClusterNodesAndSlots</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">  w.lock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    reset();</span><br><span class="line">    List&lt;Object&gt; slots = jedis.clusterSlots();<span class="comment">// 节点的槽位集合:[[10924, 16383, [[B@4ae82894, 6386], [[B@543788f3, 6387]], [5462, 10923, [[B@6d3af739, 6384], [[B@1da51a35, 6385]], [0, 5461, [[B@16022d9d, 6382], [[B@7e9a5fbe, 6383]]]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object slotInfoObj : slots) &#123;<span class="comment">// 遍历集合</span></span><br><span class="line">      List&lt;Object&gt; slotInfo = (List&lt;Object&gt;) slotInfoObj;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (slotInfo.size() &lt;= MASTER_NODE_INDEX) &#123;<span class="comment">// 如果此节点信息少于3 个,跳过此次循环,一般是: slotIndex, slotIndex,&#123;ip byte[], port&#125;,&#123;ip byte[], port&#125;</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      List&lt;Integer&gt; slotNums = getAssignedSlotArray(slotInfo);<span class="comment">// 得到所有的 slot 数字</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// hostInfos</span></span><br><span class="line">      <span class="keyword">int</span> size = slotInfo.size();</span><br><span class="line">      <span class="comment">// 从第三位开始循环,是主节点信息</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = MASTER_NODE_INDEX; i &lt; size; i++) &#123;</span><br><span class="line">        List&lt;Object&gt; hostInfos = (List&lt;Object&gt;) slotInfo.get(i);<span class="comment">// 得到主节点信息</span></span><br><span class="line">        <span class="keyword">if</span> (hostInfos.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HostAndPort targetNode = generateHostAndPort(hostInfos); <span class="comment">// 解析出 ip + port</span></span><br><span class="line">        setupNodeIfNotExist(targetNode);<span class="comment">// 创建连接池,并放入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (i == MASTER_NODE_INDEX) &#123;<span class="comment">// 如果是主节点,就将该所有槽位指向同一个连接池</span></span><br><span class="line">          assignSlotsToNode(slotNums, targetNode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    w.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法作用如下：通过任意一个节点，得到所有主节点的信息。数据格式为：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-feb1829cb50d26aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>得到这些信息后，根据 ip  + port 创建连接池，并缓存所有的连接池，key 为 “ip：port”，value 则是对应的连接池，如果是主节点，则更进一步，将 solt 和连接池也全部缓存，便于查询。</p>
<p>该方法涉及的几个方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getAssignedSlotArray</span><span class="params">(List&lt;Object&gt; slotInfo)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; slotNums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  <span class="comment">// 0位是起始 slot, 1 位是截止 slot, 这里是得到所有的 slot</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> slot = ((Long) slotInfo.get(<span class="number">0</span>)).intValue(); slot &lt;= ((Long) slotInfo.get(<span class="number">1</span>)).intValue(); slot++) &#123;<span class="comment">// 初始是第一个, slot 不能大于第二个 slot</span></span><br><span class="line">    slotNums.add(slot);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slotNums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JedisPool <span class="title">setupNodeIfNotExist</span><span class="params">(HostAndPort node)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String nodeKey = getNodeKey(node); <span class="comment">// ip:port</span></span><br><span class="line">      JedisPool existingPool = nodes.get(nodeKey);<span class="comment">// 从 map 里获取缓存</span></span><br><span class="line">      <span class="keyword">if</span> (existingPool != <span class="keyword">null</span>) <span class="keyword">return</span> existingPool;<span class="comment">// 如果有,就不再初始化</span></span><br><span class="line">      <span class="comment">// 创建连接池</span></span><br><span class="line">      JedisPool nodePool = <span class="keyword">new</span> JedisPool(poolConfig, node.getHost(), node.getPort(),</span><br><span class="line">          connectionTimeout, soTimeout, password, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      nodes.put(nodeKey, nodePool);<span class="comment">// 缓存</span></span><br><span class="line">      <span class="keyword">return</span> nodePool;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assignSlotsToNode</span><span class="params">(List&lt;Integer&gt; targetSlots, HostAndPort targetNode)</span> </span>&#123;</span><br><span class="line">   w.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     JedisPool targetPool = setupNodeIfNotExist(targetNode);<span class="comment">// 获取该节点的连接池</span></span><br><span class="line">     <span class="keyword">for</span> (Integer slot : targetSlots) &#123;<span class="comment">// 将所有槽位指向该连接池</span></span><br><span class="line">       slots.put(slot, targetPool);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     w.unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>所以，当这个步骤成功以后，所有的 slot 和对应的连接池都初始化好了，后面就直接 break  了。如果途中失败了，则继续尝试。</p>
<h2 id="2-发送命令和重试机制"><a href="#2-发送命令和重试机制" class="headerlink" title="2 发送命令和重试机制"></a>2 发送命令和重试机制</h2><p>好了，我们已经知道，slot 和连接池是保存在 JedisClusterInfoCache 类中的，那么，我们使用 API 的时候又是怎么操作的呢？</p>
<p>以 set 方法为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JedisClusterCommand&lt;String&gt;(connectionHandler, maxAttempts) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">(Jedis connection)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> connection.set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.run(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会创建一个 Redis 命令对象，然后执行 run 方法，run 方法里会回调命令对象的 execute 方法。run 方法内部调用的是 runWithRetries  方法，看名字，这是一个带有重试机制的方法. 该方法有个参数就是 int attempts，用户自己设置的重试次数。</p>
<p>看看 runWithRetries 方法实现(因为包含了失败重试逻辑，所以很长)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> T <span class="title">runWithRetries</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> attempts, <span class="keyword">boolean</span> tryRandomNode, <span class="keyword">boolean</span> asking)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (attempts &lt;= <span class="number">0</span>) &#123;<span class="comment">// 重试次数</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> JedisClusterMaxRedirectionsException(<span class="string">&quot;Too many Cluster redirections?&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Jedis connection = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asking) &#123;<span class="comment">// 第一次 false，如果节点 A 正在迁移槽 i 至节点 B ， 那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时， 节点 A 会向客户端返回一个 ASK 错误， 指引客户端到节点 B 继续查找指定的数据库键</span></span><br><span class="line">      connection = askConnection.get();</span><br><span class="line">      connection.asking();<span class="comment">// 到目标节点打开客户端连接标识</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// if asking success, reset asking flag</span></span><br><span class="line">      asking = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (tryRandomNode) &#123;<span class="comment">// 如果是随机的</span></span><br><span class="line">        connection = connectionHandler.getConnection();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 默认不是随机的，通过 CRC16 算法获取 slot 对应的节点的连接池中的连接</span></span><br><span class="line">        connection = connectionHandler.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="keyword">return</span> execute(connection);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (JedisNoReachableClusterNodeException jnrcne) &#123;<span class="comment">// 集群不存在</span></span><br><span class="line">    <span class="keyword">throw</span> jnrcne;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (JedisConnectionException jce) &#123;<span class="comment">// 连接异常</span></span><br><span class="line">    <span class="comment">// release current connection before recursion</span></span><br><span class="line">    releaseConnection(connection);<span class="comment">//归还连接</span></span><br><span class="line">    connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attempts &lt;= <span class="number">1</span>) &#123;<span class="comment">// 如果重试次数只有一次，那就更新连接池，并抛出异常</span></span><br><span class="line">      <span class="keyword">this</span>.connectionHandler.renewSlotCache();</span><br><span class="line">      <span class="keyword">throw</span> jce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> runWithRetries(key, attempts - <span class="number">1</span>, tryRandomNode, asking);<span class="comment">// 否则递归重试，重试次数减一</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (JedisRedirectionException jre) &#123;<span class="comment">// 如果是重定向异常，例如 moved ，ASK</span></span><br><span class="line">    <span class="comment">// if MOVED redirection occurred,</span></span><br><span class="line">    <span class="keyword">if</span> (jre <span class="keyword">instanceof</span> JedisMovedDataException) &#123;<span class="comment">// 节点在接到一个命令请求时， 会先检查这个命令请求要处理的键所在的槽是否由自己负责， 如果不是的话， 节点将向客户端返回一个 MOVED 错误， MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点</span></span><br><span class="line">      <span class="comment">// 如果是 moved 错误，就更新连接池， ASK 就不必更新缓存，只需要临时访问就行</span></span><br><span class="line">      <span class="keyword">this</span>.connectionHandler.renewSlotCache(connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归还旧的连接</span></span><br><span class="line">    releaseConnection(connection);</span><br><span class="line">    connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果是 ASK </span></span><br><span class="line">    <span class="keyword">if</span> (jre <span class="keyword">instanceof</span> JedisAskDataException) &#123;</span><br><span class="line">      asking = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 设置 ThreadLocal，新的连接是 ASK 指定的节点</span></span><br><span class="line">      askConnection.set(<span class="keyword">this</span>.connectionHandler.getConnectionFromNode(jre.getTargetNode()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jre <span class="keyword">instanceof</span> JedisMovedDataException) &#123;<span class="comment">// 如果是 moved 错误，不处理错误，重试。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JedisClusterException(jre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重试</span></span><br><span class="line">    <span class="keyword">return</span> runWithRetries(key, attempts - <span class="number">1</span>, <span class="keyword">false</span>, asking);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    releaseConnection(connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要步骤如下：</p>
<ol>
<li> 默认是使用 CRC16 算法通过 key 得到 slot ，然后，根据 slot 得到 Jedis 连接，也就是从我们刚刚说的缓存里获取连接。</li>
<li>得到连接后，回调命令对象的 execute 方法。</li>
<li>如果发生了 JedisNoReachableClusterNodeException 异常，表明集群不存在，则直接抛出异常，结束方法。</li>
<li>如果发生了 JedisConnectionException 连接异常，则进行递归重试，如果重试次数只剩一次，则刷新连接池缓存。</li>
<li>如果发生了 JedisRedirectionException 重定向异常，如果返回的是 moved，则刷新连接池。如果是 ASK，则不刷新连接池，在下次递归中直接使用 ASK 返回的信息进行调用。下次递归时，先执行 asking 命令打开新的客户端连接，如果成功，则执行真正的命令。</li>
<li>最终，归还连接。</li>
</ol>
<p>大致的流程图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-6fba8444f50ae04a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里说一下 ASK 和 MOVED：</p>
<p>ASK：如果节点 A 正在迁移槽 i 至节点 B ， 那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时， 节点 A 会向客户端返回一个 ASK 错误， 指引客户端到节点 B 继续查找指定的数据库键。</p>
<p>MOVED：节点在接到一个命令请求时， 会先检查这个命令请求要处理的键所在的槽是否由自己负责， 如果不是的话， 节点将向客户端返回一个 MOVED 错误， MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</p>
<p>两者的共同点都是重定向，不同点是：ASK 是迁移过程中返回的，MOVED 是迁移结束后返回的。如返回 ASK ，那么就不必更新客户端缓存，因为客户端无法知道什么时候迁移完成，因此只能是临时性的重定向。但是 MOVED 重定向说明键对应的 slot 已经成功的转移到了新的节点，那么就可以换成这些连接。</p>
<p>注意：当重试次数不够时，会抛出 <code>throw new JedisClusterMaxRedirectionsException(&quot;Too many Cluster redirections?&quot;)</code> 异常，原因是节点宕机或请求超时触发了重试，而重试次数耗尽就会触发这个异常。</p>
<p>当 Cluster 进行故障发现到完成故障转移，需要一定的时间，节点宕机期间，所有指向这个节点的命令都会触发重试，当收到 moved 命令则会进行连接刷新 —— 也就是 renewSlotCache 方法。</p>
<p>注意：更新连接池的过程是串行加锁的！！</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renewClusterSlots</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//If rediscovering is already in process - no need to start one more same rediscovering, just return</span></span><br><span class="line">  <span class="keyword">if</span> (!rediscovering) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      w.lock();</span><br><span class="line">      rediscovering = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          discoverClusterSlots(jedis);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">          <span class="comment">//try nodes from all pools</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (JedisPool jp : getShuffledNodesPool()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          jedis = jp.getResource();</span><br><span class="line">          discoverClusterSlots(jedis);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisConnectionException e) &#123;</span><br><span class="line">          <span class="comment">// try next nodes</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rediscovering = <span class="keyword">false</span>;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注意：代码中使用了写锁，而获取连接池时则使用了读锁，读写锁是互斥的，这时将导致所有访问集群的线程阻塞！！！</p>
<p>当然，只有出现 MOVED 错误或者 JedisConnectionException 异常且无法继续重试时，才会进行刷新连接池操作。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>本文旨在分析 Jedis 如何支持 Redis Cluster，因为 Redis Cluster 需要客户端来支持分片。Jedis 内部使用了一个 JedisClusterInfoCache 保存 slot 和 pool，ip:port 和 pool 的映射关系，ip:port 的缓存更多是服务于 ask 时寻找节点。</p>
<p>在使用客户端是时候，Jedis 会有重试机制，用户可以设置重试次数，如果发生了 ask，客户端会自动根据返回值重定向，如果发生了 moved，则会刷新连接池中的 slot，因为集群发生了迁移。</p>
<p>需要注意的是，当集群进行迁移的时候，如果有客户端访问迁移的节点，那么将会导致刷新连接池，而这个连接池是有锁，当刷新的时候，使用的是写锁，将导致所有的读都会阻塞，所以，迁移尽量在业务低谷进行。</p>
<p>了解客户端的原理，有助于我们理解 Redis Cluster 的运行原理，也有助于我们平时编写代码，运维缓存，排查故障。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>总结一次 Pika 迁移遇到的坑</title>
    <url>/2018/08/23/2018/2018-08-24-%E6%80%BB%E7%BB%93%E4%B8%80%E6%AC%A1%20Pika%20%E8%BF%81%E7%A7%BB%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ![image](http://upload-images.jianshu.io/upload_images/4236553-479c77906630e421.gif?imageMogr2/auto-orient/strip)


<p>目录：</p>
<ul>
<li>前言</li>
</ul>
<ol>
<li>背景</li>
<li>方案</li>
<li>迁移步骤详细</li>
<li>坑点统计</li>
<li>总结</li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间一直在弄数据迁移，需要把阿里云经典网络的中间件等基础设施迁移到 VPC 网络，包括 Pika，代理 Pika 的 Codis，zookeeper ，Sentinel 等。</p>
<p>其中，pika 的坑是最多的（大概是用户少的原因？）。这里简单的把迁移方案，再到迁移过程遇到的坑总结一下，方便后人，也方便回溯。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>整件事情的大背景就是公司要把所有的服务从阿里云经典网络迁移到 VPC 网络，包括 KV 存储。当然还有其他的，例如文件服务，配置中心，发布平台等基础服务。笔者负责的则是配置中心和 Pika 迁移。同时，迁移过程要是平滑的，不能影响业务。这里主要讲讲 Pika 的迁移。（实际上，涉及到存储的在线迁移都是十分麻烦的）</p>
<h2 id="2-方案"><a href="#2-方案" class="headerlink" title="2 方案"></a>2 方案</h2><p>开始的时候，我们设计了 2 个方案。</p>
<ol>
<li>通过在新的网络环境增加 Pika 节点，使用 Codis 将老环境的数据迁移到新 Pika 中，同时，在新环境中增加 Codis 节点，也就是让 2 个 Codis 集群双写一个 Pika 实例，实现数据同步。</li>
</ol>
<p>优点：没有方案 二 的缺点。。。。<br>缺点： Codis 双写单实例 Piak， 理论上可以，但没有人这么做过，有风险。同时，老环境需要跨网络访问新环境 Pika，增减机器都需要配置 classLink —— 麻烦。</p>
<ol start="2">
<li>使用 Pika 的双主功能，新旧环境各有一个 Pika 实例，搭建成双主模式（数据一致性问题在业务接受范围内），完成数据同步。</li>
</ol>
<p>优点：没有方案一 的缺点。。。<br>缺点：Pika 双主方案不成熟，需要长期保持双主同步（稳定性问题），有一定的数据一致性问题。</p>
<p>最终，我们在测试了 Pika  的双写功能后，同时和业务沟通了双主同步的时间（时间不是很长）和对数据一致性的容忍度，选择了方案 2。</p>
<p>同时，我们还有 2  个问题：</p>
<p>第一，我们线上的版本是 2.3.0，这个版本有个 bug，我们希望升级一下，但是不能升级到 3.0.0(含) 以上版本（不支持 codis ，pika-hub,  geo 相关 API ，不过貌似有分支版本支持 Codis， 但需要到群里 @首席编外客服）。</p>
<p>第二，双主功能需要修改配置文件，且需要重启，但是业务要求不能重启。有 2 种办法：</p>
<ol>
<li>利用主从同步功能，新增从节点，在从节点添加双主配置，全同步主节点数据，然后手动故障转移从节点，完成双主配置修改。</li>
</ol>
<p><strong>但是：注意！pika 的 2.3.3 以上版本是不兼容以下版本的主从同步的！ 也就是说，如果想升级到 2.3.3 版本解决这个 bug，那么，就不能利用在线主从同步的功能，只能重启！ 所以这个方案我们放弃了</strong>。</p>
<ol start="2">
<li>利用 codis 的迁移 slot 的功能，将旧版本节点数据迁移到新节点。完成在线迁移。</li>
</ol>
<p>所以，当然是选择第二个办法。</p>
<h2 id="3-迁移步骤详细"><a href="#3-迁移步骤详细" class="headerlink" title="3 迁移步骤详细"></a>3 迁移步骤详细</h2><p>迁移步骤：</p>
<ol>
<li>在经典网络新建一个 2.3.6 版本 pika 实例，准备好双主配置（<code>server-id，master-ip，port</code>）。</li>
<li>使用 codis 的 <code>migrate some</code> 功能，将老 pika 节点的数据迁移到新 pika 节点。</li>
<li>在 VPC 网络新建一台 pika 实例，和步骤 1 的 pika 实例组成双主，并执行双主同步。</li>
<li>在 VPC 网络搭建 zk 集群，codis 代理等中间件。方便 VPC 环境的客户端访问。从而完成迁移。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-20a4bee830e68078.gif?imageMogr2/auto-orient/strip" alt="迁移过程动图"></p>
<h2 id="4-坑点统计"><a href="#4-坑点统计" class="headerlink" title="4 坑点统计"></a>4 坑点统计</h2><ol>
<li><p>Pika 2.3.3版本添加了主从Server ID认证机制，无法之前的所有版本无法建立主从关系，升级请注意! 如果线上的是 2.3.3 版本一下，是无法建立主从关系的（这个感觉坑的有点严重）。</p>
</li>
<li><p>pika3.0暂不支持codis，pika-hub，geo相关api。如果非要支持，可以使用分支代码。找首席编外客服。</p>
</li>
<li><p><code>3.0.0</code> 之前有个 bug，主库 rsync 失败可能无法再次 rsync 直到重启，这个需要注意。</p>
</li>
<li><p>双主模式有很多状态（<code>repl_state</code>）：双方都是 3 表示成功，如果主动复制节点状态是 0，则需要执行 slaveof 进行全同步，执行命令后，通常，被同步节点状态是 0，warning 日志显示发送文件中。主动复制节点状态状态此时通常为 4，表示正在接收对方 rsync 发送的数据，此时等待即可，同时日志显示正在 from master after trysync wait。当 rsync 全同步结束后，双方状态变为 3.</p>
</li>
</ol>
<ol start="5">
<li><p>如果 slaveof 失败，观察同步双方的 warning 日志，如果显示 rsync send file failed，可能是你的机器上没有安装 rsync。安装后便可支持同步。（这个是我花时间比较多的地方，由于日志不够明确，导致根本没有关注 rsync 是否安装这个事情，一直认为问题在网卡那里，导致耗时很久，过生日那天还在加班。。。）</p>
</li>
<li><p>注意 rsync 端口不要被占用，rsync 端口为： pika 端口号 + 3000，例如：pika 端口号为 9221，那么 rsync 端口号就是 12221.（ + 1000 是 binlog 接收端口， + 2000 是心跳端口，记得打开）。</p>
</li>
<li><p>如果还是同步失败，可能是网卡问题，通常默认路由是外网（如果你有 2 张网卡，可使用 ifconfig 查看），需要在 Pika.conf 配置文件中指定网卡，官方建议绑定内网网卡。外网网卡在 2.3.6 版本会有问题。</p>
</li>
<li><p>如果同步失败，想重新同步，记得删除主动同步方的 log/ 目录。</p>
</li>
<li><p>pika 会对数据进行压缩，大概平均 3-5 倍，所以，你看到的数据量和你写入的数据量会不太一样，不用担心。pika 的 info keyspace 命令结果不是实时的，需要使用 info keyspace 1 异步扫描 key，等待一会，就可以看到 key 的数量。</p>
</li>
<li><p>pika 的 slave read only 有可能失效，导致双写失败。需要使用 Config set slave-read-only no 修改一下。</p>
</li>
<li><p>如果想让 Codis（3.2） 迁移 pika ，那么需要修改 Codis 的<code> dashboard.toml</code> 配置文件为 <code>migration_method = &quot;sync&quot;</code>, 否则会报错。网上有文章说 3.0 支持 <code>“semi-aync”</code>（号称速度是  3000key / s ），但是我这边 3.2 版本不行，必须要修改成 sync。迁移速度在 300key / s 左右。同时，需要打开 <code>Pika.conf </code>配置文件中<code>slotmigrate : yes</code>开关。<br>相关 issue：<br><a href="https://github.com/Qihoo360/pika/issues/83">1. pika加入到codis3.0报错 </a>，<br><a href="https://github.com/Qihoo360/pika/issues/191">2. coids3.2使用pika做后端出现错误</a>，<br><a href="https://github.com/CodisLabs/codis/issues/508">3. Migrate的性能是不是很慢，8cpu 64G内存，迁移的速度是500key/s</a></p>
</li>
</ol>
<ol start="12">
<li>建议使用 SSD，否则会非常慢（但感觉使用 Pika 的大部分同学都是为了省钱，估计用所谓的高效云盘的会比较多）。</li>
</ol>
<p>以上是 Pika 需要注意的地方，建议在使用的时候，多看看每个版本的 Release Log，</p>
<p>另外，由于我是第一次接触 Codis，因此记录一下第一次使用 Codis 遇到的坑：</p>
<ol>
<li><p>Codis 的安装最好使用编译安装，二进制安装，貌似不能修改配置文件。编译的时候目录一定要和 github 上的文档一致。make 的时候，可能会出现错误，按照提示安装一个工具就好了。</p>
</li>
<li><p>dashboard.toml 配置文件中的 admin_addr 选项配置的是 0.0.0.0 网卡，建议换成 ip 地址，否则，proxy 会把机器 host 名字注册到 zk，客户度从 zk 拿到的是 host 名字，而不是 ip，除非你蛋疼的需要修改 host 文件。</p>
</li>
<li><p>在 proxy 配置文件中， jodis 的相关配置，就是 zk/etcd 的配置，例如，jodis_name 就是  “zookeeper”，jodis_addr 就是 “ip：2181”。这个其实就是把这个 proxy 注册到指定的注册中心里。方便客户端从注册中心拿到 proxy。</p>
</li>
<li><p>jodis 的使用：proxy 配置文件里做了 proxy 注册时的路径说明，2.0 版本的路径较长，我们使用的是  3.0 版本，路径是 /jodis//jodis/{PRODUCT_NAME}/proxy-{HASHID}。在使用 Jodis 客户端的时候，不必指定 hashId。</p>
</li>
</ol>
<p>客户端代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JedisResourcePool jedisPool = RoundRobinJedisPool.create()</span><br><span class="line"> .curatorClient(<span class="string">&quot;xx.xx.xx.xx:2181&quot;</span>, <span class="number">30000</span>)</span><br><span class="line"> .zkProxyDir(<span class="string">&quot;/jodis/xx-codis-xx&quot;</span>)</span><br><span class="line"> .build();</span><br><span class="line"></span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">jedis.set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String value = jedis.get(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">System.out.println(value);</span><br><span class="line">    </span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>零零散散说了很多，都是这两天遇到的坑，但基本总算迁移成功了，还剩下 Sentinel 没有搭建，但问题不大。</p>
<p>在整个迁移过程中，最大的感悟就是使用一个开源中间件真的有很多的坑要踩，幸好 pika 有个技术支持群，虽然网上文章不多，但技术支持群还算可以的。提问都能够很好的解答，这点赞一个。但不可否认，坑确实还挺多，特别是哪个高版本不支持低版本主从同步的问题，很蛋疼 —— 如果没有 Codis 的迁移功能，真的很麻烦，甚至要重启。</p>
<p>然后，换个角度想，如果你要做一个开源中间件，要想做好他，就需要有个好的生态，即：能够及时解答用户问题，快速解决 bug，用户也会有很多的内容输出帮助到其他人，例如在第一次使用 Codis 的时候，网上经验就很多，有些坑就不必踩，即使踩到了，也能很快搜索到解决办法。另外，在兼容第三方中间件的时候，也能够较好的支持，例如，如果 Pika 3.0 能较好的支持 Codis，那体验一定好很多，对 Pika 的开源发展也会好很多。</p>
<p>还有一个感触做软件的时候，日志一定要尽量明确，Pika 在全量同步时，依赖 rsync，如果用户没有安装 rsync ，Pika 的提示只是简单的提示  fail，事实上，这里的 Log 可以更详细些，当然我也提了建议，Pika 的开发人员表示后期会优化一下提示。（这个问题差点让我们放弃双主同步的方案）</p>
<p>好了，这个就是这次踩坑的经验之谈，如有不当，敬请指出！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-0274b5b0a38b20a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结尾放一张踩坑图"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>闲书 &lt;&lt;当我跑步时,我谈些什么&gt;&gt; 摘抄</title>
    <url>/2018/09/01/2018/2018-09-01-%E9%97%B2%E4%B9%A6%20%3C%3C%E5%BD%93%E6%88%91%E8%B7%91%E6%AD%A5%E6%97%B6,%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88%3E%3E%20%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于感觉到身体状态没有以前好了, 所以, 最近开始跑步, 大概坚持了一个月了已经,感觉不错, 耐力变的好了很多, 工作状态也好了很多,令人欣慰的是, 体重也下降了 5Kg.</p>
<p>和朋友谈及跑步, 他是个半马跑者, 很优秀. 交谈间提及村上的这本书, 其实之前我也听过,但没有买来看, 这次趁着跑步的节奏和当当打4折的节奏,就买来看了, 前后不到一天看完了.很薄.但感触很多.</p>
<p>这里就将我个人感触较多的字句摘抄一下,和大家分享.</p>
<h2 id="摘抄字句"><a href="#摘抄字句" class="headerlink" title="摘抄字句"></a>摘抄字句</h2><ol>
<li><p>在似乎可以写下去的地方，果断停下笔来，这样第二天重新着手时，便易于进入状态。</p>
</li>
<li><p>可是当你不顾一切的坚持跑完，便觉得仿佛所有的东西都是从躯体最深处挤榨了出来，一种类似自暴自弃的爽快感油然而生。</p>
</li>
<li><p>我觉得由于二十多年从不间断地跑步，我的躯体和精神大致朝着良好的方向得到了进化。</p>
</li>
<li><p>我不能说一个是一个适合团体竞技的人，这也许和我没有兄弟姐妹有关，和别人共同参与的赛事，总是难以全身心投入。</p>
</li>
<li><p>我从小不在乎胜负成败，无论何事，赢了别人也罢，输给别人也罢，都不太计较，倒是更关心是否达到为自己设定的标准。在这层意义上，长跑是与我的心跳完全吻合的体育运动。</p>
</li>
<li><p>写小说很像跑全程马拉松，对于创作者而言，其动机安安静静，确确实实的存在于自身内部，不应向外部去寻求形式与标准。</p>
</li>
<li><p>我超越了自己，哪怕只是那么一丁点儿，才更为重要。在长跑中，如果说有什么必须战胜的对手，那就是过去的自己。</p>
</li>
<li><p>现在的我还不想将音乐和电脑搅合到一起，就像不将友情，工作，和做爱搅合到一起一样。</p>
</li>
<li><p>我是那种不太以独处为苦的性情。</p>
</li>
<li><p>我在跑步时，究竟思量了些什么？老实说，在跑步时究竟思考过什么，我根本想不起来。可以说：我几乎从不曾思考正儿八经的事情。</p>
</li>
<li><p>我跑步，只是跑着。原则上是在空白中跑步。也许是为了获得空白而跑步。当然，人的心灵中不可能存在真正的空白。人类的精神还没有强大到足以坐拥真空的程度。</p>
</li>
<li><p>仔细想一想，正是自己跟别人多少有所不同，人才得以确立自我，一直作为独立的存在。而有时心灵所受的伤，便是人为了这种自立性不得不支付给世界的代价。</p>
</li>
<li><p>我也许是主动地追求孤绝。这是一把锋利的双刃剑，必须不断地物理性的运动身体，有时甚至穷尽体力，来排除身体内部负荷的孤绝感。</p>
</li>
<li><p>当受到一些变故时，我总是比平日跑的更多一点，让肉体更多的消耗一点，好重新认识自己是个能力有限的软弱人类——从最深处物理性的认识这一点。</p>
</li>
<li><p>倘若比作马匹，我恐怕不是专事比赛的赛马，更接近于从事杂役的驽马。</p>
</li>
<li><p>无论做什么事，一旦去做，我非得全力以赴不可，否则不得安心。如果因为模棱两可，三心二意以失败告终，懊悔之情只怕久久无法拂去。</p>
</li>
<li><p>如何保持身体健康，是我刚成为职业小说家那会儿：体力逐渐下降，体重则有所增加。所以必须找到一个既能维持体力，又能将体重保持得恰到好处的方法。跑步最适合，只需要一双合适的跑步的鞋。</p>
</li>
<li><p>一天中，身体机能最为活跃的时间因人而异，我是清晨的几小时。在这段时间里集中精力完成重要的工作。随后的时间自由分配。拜其所赐，这二十年来工作顺利，效率甚高。</p>
</li>
<li><p>“人不可能做到八面玲珑，四方讨巧。”说白了，就是此意。</p>
</li>
<li><p>跑步如同一日三餐，睡眠，家务和工作一样，被组编尽力生活循环。</p>
</li>
<li><p>我常常寻思：“人生真是不公平啊！”一些人不努力便得不到的东西，有些人无须努力便唾手可得。我这种为了不增加体重，每天得剧烈的运动，留意饮食，有所节制。何等费劲的人生啊！</p>
</li>
<li><p>人生是不公平的，这一段毋庸置疑。</p>
</li>
<li><p>学校就是这样一种地方：我们在学校里学到的最重要的东西，就是“最重要的东西在学习力学不到”这个真理。</p>
</li>
<li><p>跑步疲惫时觉得啤酒很美好，但事实并非如此，啤酒诚然好喝，却远不像我在奔跑时热切向往的那般美妙。失去理智的人怀抱的美好幻想，在现实世界中根本子虚乌有。</p>
</li>
<li><p>肌肉很像记忆力良好的动物，只要注意分阶段地增加负荷量，它就能自然的适应和承受。而过分奴役肌肉，它会发生故障。</p>
</li>
<li><p>如果忙就中断跑步了，我一辈子都无法跑步了。坚持跑步的理由不过一丝半点，中断跑步的理由却足够装满一辆大型载重卡车。</p>
</li>
<li><p>如果说小说家有什么重要资质，我将毫不犹豫的举出“集中力”来。没有它便不足以做成任何大事。我每天在早晨工作三四个小时，坐在书案前，将意识仅仅倾泻在正在写东西上，其他什么都不考虑。</p>
</li>
<li><p>集中力后面，则是耐力。值得庆幸的是：它可以通过后天训练获得，可以通过一点一点将极限值向上提升。有点作家，哪怕没有东西可写，每天也肯定在书桌前坐上好几个小时，独自一人集中精力。这似乎是一种日常训练。</p>
</li>
<li><p>曾经唾手可得的东西，超过一定年龄后，就不能轻易拿到了。</p>
</li>
<li><p>同样是十年，与其稀里糊涂的活，目的明确，生气蓬勃地活当然令人更满意。</p>
</li>
<li><p>写小说是“不健康的”，如果想处理不健康的东西，人们就必须尽量健康。这就是我的命题。</p>
</li>
<li><p>“我不是人，是一架纯粹的机器，所以什么也无须感觉，唯有向前奔跑。”</p>
</li>
<li><p>如果违背了自己定下的原则，哪怕只有一次，以后就将违背更多的原则。</p>
</li>
<li><p>我并非挑战记录的无邪青年，亦非一架无机的机器，不过是一介洞察了自身的局限，却尽力长期保持自己的能力与活力的职业小说家。</p>
</li>
<li><p>大部分的罪责都由全球变暖来扛，这个世界需要一个特定的恶人，可以供人们指名道姓，千夫所指：“全都怪你！”</p>
</li>
<li><p>不拘什么，按照喜欢的方式做喜欢的事，我就是这样生活的。纵然收到别人阻止，遭到恶意非难，我都不曾改变。</p>
</li>
<li><p>不伴随着痛苦，还有谁来挑战铁人三项和全程马拉松这种费时耗力的运动呢？正因为痛苦，正因为刻意经历这痛苦，我们才能从这个过程中发现自己活着的感觉，至少是发现一部分，才能最终认识到：生存的质量并非成绩，数字和名次之类固定的东西，而是包含于行为中的流动性的东西。</p>
</li>
<li><p>坚持体育运动，“调整和增强体力，以写好小说”，才是第一目的。</p>
</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后, 坚持体育运动, “调整和增强体力, 以写好代码”, 才是第一目的. ^_^</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>Netty LineBasedFrameDecoder 剖析（Netty Bug）</title>
    <url>/2018/09/04/2018/2018-09-04-Netty%20LineBasedFrameDecoder%20%E5%89%96%E6%9E%90%EF%BC%88Netty%20Bug%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言
Netty 自带多个粘包拆包解码器。今天介绍 LineBasedFrameDecoder，换行符解码器。看起来简单，但当前版本（2018-09-04）是一个 bug，此 bug 截止本文发布时，已被修复。

<h2 id="属性分析"><a href="#属性分析" class="headerlink" title="属性分析"></a>属性分析</h2><ol>
<li>maxLength （每个完整的包的最大长度）</li>
<li>failFast （是否快速失败，默认 false）</li>
<li>discarding （是否进入丢弃模式）</li>
<li>discardedBytes 丢弃字节数（用于抛出异常时提醒）</li>
<li>offset 用于优化每次读取效率（bug 就是这里）</li>
<li>stripDelimiter 是否应该剔除分隔符，默认剔除</li>
</ol>
<h2 id="decode-方法解析（包括-findEndOfLine-）"><a href="#decode-方法解析（包括-findEndOfLine-）" class="headerlink" title="decode 方法解析（包括 findEndOfLine()）"></a>decode 方法解析（包括 findEndOfLine()）</h2><p>虽然官方注释标注此解码器为换行符解码器，但我认为这是一个“换行符+最大长度”的一个解码器。</p>
<p>说下此解码器的逻辑：</p>
<p>首先限制单个包的大小，也是说，换行符和换行符之间的数据包的大小是用户配置的。超过最大则抛出异常。</p>
<p>每当有数据到来时，都会遍历缓冲区，找换行符，如果找到了，就返回数据；如果没找到，就记录此次读取到下标 offset，下次继续找。</p>
<p>如果找的过程中，长度超过用户设置的 maxLength，就进入丢弃模式：丢弃之前读取的所有字节，并根据 failFast 的属性决定什么时候抛出异常（如果是 true，则不等找到换行符，就抛出异常，反之，等找到换行符了，才抛出异常，这个异常是可以被用户的 exceptionCaught 方法捕获到的）。</p>
<p>整个流程大概如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1698361c890ff557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里有个注意的地方：每当发现长度超出 maxLength 时，应该丢弃之前的所有数据，并重置 offset，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (length &gt; maxLength) &#123;<span class="comment">// 如果大于愿意解码的最大长度,废弃</span></span><br><span class="line">    discardedBytes = length;<span class="comment">// 废弃字节数</span></span><br><span class="line">    buffer.readerIndex(buffer.writerIndex());<span class="comment">// 更新读下标</span></span><br><span class="line">    discarding = <span class="keyword">true</span>;<span class="comment">// 开启丢弃模式,因为tcp 包大小已经大于最大长度.</span></span><br><span class="line">    offset = <span class="number">0</span>;<span class="comment">// 最后一次扫描次数重置</span></span><br><span class="line">    <span class="keyword">if</span> (failFast) &#123;<span class="comment">// 如果是快速失败,抛出异常</span></span><br><span class="line">        fail(ctx, <span class="string">&quot;over &quot;</span> + discardedBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在丢弃模式的 netty 代码，却没有将 offset 重置为 0。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">·····忽略</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    discardedBytes += buffer.readableBytes();</span><br><span class="line">    buffer.readerIndex(buffer.writerIndex());</span><br><span class="line">    <span class="comment">// offset = 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注意：offset 的代码是我加的，本来是没有的。这将导致 findEndOfLine 方法的下标越界。</p>
<pre><code class="java">    private int findEndOfLine(final ByteBuf buffer) &#123;
        int totalLength = buffer.readableBytes();
        int i = buffer.forEachByte(buffer.readerIndex() + offset, totalLength - offset, ByteProcessor.FIND_LF);
        if (i &gt;= 0) &#123;
            offset = 0;
            if (i &gt; 0 &amp;&amp; buffer.getByte(i - 1) == &#39;\r&#39;) &#123;
                i--;
            &#125;
        &#125; else &#123;
            offset = totalLength;
        &#125;
        return i;
    &#125;
</code></pre>
<p>这里，注意：每次读取不到换行符的时候，offset 都会设置为这次的读下标，而 decode 方法中，已经执行了  buffer.readerIndex(buffer.writerIndex()) 方法，更新了读下标，当执行 forEach 方法的时候（+ offset），就会出现下标越界！</p>
<p>具体的重现方法我已经提了 issue：<a href="https://github.com/netty/netty/issues/8256">issue#8256 地址</a></p>
<p>作者诺曼（苹果基础架构工程师）也进行了修改并提交了代码：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-08b1b9209de9ec2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>而这个 bug 的作者本来是想优化这个代码的，初始代码是没有这个 offset 优化的，结果写出来个 bug， = =！：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-91aee44f4602d4d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d323039d0d8c039c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>最后，最重要的一点是，这个 bug 是艿艿发现的！有关 Netty，Dubbo等一切<br> Java开源框架的疑问都可以找他！他的公众号：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-39982e3e9eadbc08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结，此文虽然没什么技术含量，但是给我提了一个醒，强如 netty ，也会有 bug，因此要具有批判精神，即使再权威，我们也要有怀疑精神，去研究，去反向推导，才能有真正的收获。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>SOFA RPC 客户端设计模式</title>
    <url>/2018/09/09/2018/2018-09-09-SOFA%20RPC%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       图片来自 SOFA 官方。

<p><img src="https://upload-images.jianshu.io/upload_images/4236553-82965b1989adbc11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RPC 框架常见功能"></p>
<p>图片来自 SOFA 官方。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f5cee14c78bda441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" SOFA RPC 客户端调用流程"></p>
<p>笔者画的对应的 UML：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ddcbcbfb784b9a3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解释一下：User 就是用户使用的 API，会被 InvocationHandler 拦截，然后被实现了 Invoker 接口的具体实现类拦截，从这里开始，最核心的方法，就是：<code>SofaResponse invoke(SofaRequest request)</code> , 这个方法一直到上图中 Cluster 向 Remoting 发送信息才停止。期间会被层层过滤器处理 Request，Filter 也有 invoke 方法，但是包含 FilterInvoker，所以，他们是组合关系，每个过滤器都绑定了一个 FilterInvoker，这个维持了过滤器链表的关系，可以在过滤器与过滤器之间做一些事情，也是典型的职责链设计模式。</p>
<p>当走到最后一个 Invoker，这个 Invoker 会调用 Cluster 的 sendMsg 方法，将 Request  信息发送给 Remoting 模块，进入命令模式。这之前一直是职责链模式。</p>
<p>命令在 Remoting 里传播，Remoting 会对 Request 进行序列化，按照协议进行编码，最后通过网络发送给服务端。当然，返回值也是一个命令，流程类似。</p>
]]></content>
      <categories>
        <category>SOFA</category>
      </categories>
  </entry>
  <entry>
    <title>Think in Life</title>
    <url>/2018/10/03/2018/2018-10-03-ThinkInLife/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>


<p>a. <code>对的事情要坚持， 知道错了及时调整 + 4</code>，如何分清对错？需要多吃点亏。</p>
<p>b. 性格很难改，<code>诚实很重要</code> + 2，<code>诚实</code>对自己，知之为知之，不知为不知</p>
<p>c. <code>关注事物本质 + 3，平常心 + 1</code></p>
<p>e. 性价比就是性能不好</p>
<p>f. 社交很累，知心朋友不多，知心就好。最重要的是友谊，<code>要宽容，要友善，要诚实</code>，有几个好朋友就足够了</p>
<p>g. 做对的事情，然后把事情做对 + 1</p>
<p>i. 有些机会总会错过，只要抓住对的就足够了，不要冒险</p>
<p>j. 合格的人和合适的人，合适比合格更重要</p>
<p>k. 站在 10  年后看今天的一切 +2，放下眼前的诱惑。</p>
<p>m. 对的生意，对的人，对的价钱</p>
<p>n. 如果你总是呆在自己不喜欢的地方，你可能永远都不会知道自己真正喜欢什么。所以，多去尝试，去寻找。做自己喜欢的事情，就没有加班的概念了，因为你会想尽办法工作。<br><code>会火的 + 擅长的 + 喜欢的。优先做喜欢的。钱多不是好事情，会让你失去乐趣。做自己喜欢的事情最重要。</code></p>
<p>o. 说什么是没有用的，做才有用。</p>
<p>p. 要花时间想，什么是对的事情，什么是不对的事情。</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>简简单单写一个 Redis 客户端</title>
    <url>/2018/10/01/2018/2018-10-01-simple-redis-client/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章很简单，就是写一个 Java 版本的 Redis Client，而且不是一个生产级别的项目，只是一个验证类型的 demo。用于了解“实现一个 Redis Client” 需要注意哪些事情。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li><p>首先，Redis 是一个服务器，有 ip，有端口，那么，我们就可以用 Java 的 Socket 来和他交互，也可以用 telnet 来交互。说白了，就是一个 TCP 服务器，只要打开了  TCP 通道，然后进行一次连接 3 次握手，建立起全双工通道，就能够互相发送数据。</p>
</li>
<li><p>从我们之前的编程经验中，我知道，和一个服务器交互，通常是需要协议的，例如 HTTP 服务器，你需要 HTTP 协议，和 Dubbo 交互，你需要了解 Dubbo 协议，当然，这些都是建立在 TCP 协议之上的。那么，Redis 大概也是有协议的，我们后面再看。</p>
</li>
</ol>
<h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><p>思考了上面的两点，我们可以尝试动手。</p>
<p>我们可以先用 telnet 访问以下本地的 Redis Server，例如 ：<code>telnet  127.0.0.1 6379</code>，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  master telnet 127.0.0.1 6379</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">set baby hello</span><br><span class="line">+OK</span><br><span class="line">get baby</span><br><span class="line"><span class="meta">$</span><span class="bash">5</span></span><br><span class="line">hello</span><br><span class="line">del baby</span><br><span class="line">:1</span><br><span class="line">xxx</span><br><span class="line">-ERR unknown command &#x27;xxx&#x27;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li>我们连接上了本机的 Redis Server。</li>
<li>执行 set baby hello 命令，也就是保存一个键值对。</li>
<li>返回了 +OK 字符串</li>
<li>然后我们获取刚刚的 baby 字符串。</li>
<li>返回了 $5 <code>换行</code> hello</li>
<li>然后我们删除了 baby 字符串。</li>
<li>返回了 :1 ，1表示删除成功。</li>
<li>然后我们尝试执行一个不存在的命令。</li>
<li>返回了 <code>-ERR unknown command &#39;xxx&#39;</code>.</li>
</ol>
<p>我们使用  Redis 官方提供的 redis-cli 客户端执行这些命令看看结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  master redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set baby hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get baby</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; del baby</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xxx</span><br><span class="line">(error) ERR unknown command &#x27;xxx&#x27;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>很明显，redis-cli 客户端和 telnet 的使用区别就是返回值的不同，telnet 多了一些奇怪的字符，或者在一些返回值前面加入了一些符合，例如在 OK 前面加入了+ 号。在get baby 后，返回了一个 $5 字符串。我们猜想，telnet 得到的数据是 Redis-Server 真正返回的数据，redis-cli 对这些数据进行了处理。</p>
<p>好了，大概了解了操作，我们用 Java 写一个 Socket 访问一下 Redis Server。</p>
<h2 id="用-Java-Socket-访问-Redis-Server"><a href="#用-Java-Socket-访问-Redis-Server" class="headerlink" title="用 Java Socket 访问 Redis Server"></a>用 Java Socket 访问 Redis Server</h2><p>代码很简单，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Socket client = <span class="keyword">new</span> Socket();</span><br><span class="line"><span class="keyword">static</span> InputStream is;</span><br><span class="line"><span class="keyword">static</span> OutputStream os;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>));</span><br><span class="line">        is = client.getInputStream();</span><br><span class="line">        os = client.getOutputStream();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    writeAndFlush(<span class="string">&quot;set baby hello \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printResult();</span><br><span class="line">    <span class="comment">// result : +OK</span></span><br><span class="line"></span><br><span class="line">    writeAndFlush(<span class="string">&quot;get baby \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Sleep.sleep(<span class="number">1</span>);<span class="comment">// 等 redis 返回数据</span></span><br><span class="line"></span><br><span class="line">    printResult();</span><br><span class="line">    <span class="comment">// result : $5</span></span><br><span class="line">    <span class="comment">// result : hello</span></span><br><span class="line"></span><br><span class="line">    writeAndFlush(<span class="string">&quot;del baby \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Sleep.sleep(<span class="number">1</span>);<span class="comment">// 等 redis 返回数据</span></span><br><span class="line"></span><br><span class="line">    printResult();</span><br><span class="line">    <span class="comment">// result  :1</span></span><br><span class="line"></span><br><span class="line">    writeAndFlush(<span class="string">&quot;xxx \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Sleep.sleep(<span class="number">1</span>);<span class="comment">// 等 redis 返回数据</span></span><br><span class="line"></span><br><span class="line">    printResult();</span><br><span class="line">    <span class="comment">// -ERR unknown command `xxx`, with args beginning with:</span></span><br><span class="line"></span><br><span class="line">    writeAndFlush(<span class="string">&quot;mget hello baby \r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Sleep.sleep(<span class="number">1</span>);</span><br><span class="line">    printResult();</span><br><span class="line"></span><br><span class="line">    closeStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeAndFlush</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        os.write(content.getBytes());</span><br><span class="line">        os.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is.close();</span><br><span class="line">        os.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = is.available();</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[a];</span><br><span class="line">        is.read(b);</span><br><span class="line"></span><br><span class="line">        String result = <span class="keyword">new</span> String(b);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到， 使用 Java Socket 和使用 telnet 的效果是相同的。</p>
<p>所以，要想达到 redis-cli  的效果，那么就需要对返回值进行处理，例如 $5 、:1 这些符号，到底是什么意思？即：解析 redis 自己的应用层协议。</p>
<h2 id="Redis-序列化协议（RESP）"><a href="#Redis-序列化协议（RESP）" class="headerlink" title="Redis 序列化协议（RESP）"></a>Redis 序列化协议（RESP）</h2><p>答案就在 redis 的官方文档: <a href="http://redisdoc.com/topic/protocol.html">通信协议（protocol）</a></p>
<p>redis 协议称之为 RESP（REdis Serialization Protocol），即 redis 序列化协议。</p>
<p>该协议的设计目标：</p>
<ol>
<li>实现简单。</li>
<li>快速解析。</li>
<li>人类易读。</li>
</ol>
<p>所有的命令一律以 <code>\r\n</code> 结尾。</p>
<p>Redis 收到命令后，对命令进行处理，然后返回数据。</p>
<p>redis 1.2 版本后，支持批量回复：Buik Reply。</p>
<p>关于回复，有多种类型：<br>通过检查服务器发回数据的第一个字节， 可以确定这个回复是什么类型：</p>
<ul>
<li> 状态回复（status reply）的第一个字节是 <code>&quot;+&quot;</code></li>
<li>错误回复（error reply）的第一个字节是<code> &quot;-&quot;</code></li>
<li>整数回复（integer reply）的第一个字节是<code> &quot;:&quot;</code></li>
<li>批量回复（bulk reply）的第一个字节是 <code>&quot;$&quot;</code></li>
<li>多条批量回复（multi bulk reply）的第一个字节是<code> &quot;*&quot;</code></li>
</ul>
<p>我们回到我们的 Socket 小程序里，可以看到，</p>
<ul>
<li>当我执行 <code>set</code> 命令，返回的是 <code>+OK</code>，即这个是状态回复。</li>
<li>当我们执行 <code>xxx</code> 命令，返回值的开头是 - 号，即这个是错误回复。</li>
<li>当我们执行 <code>get</code> 命令，返回的是 <code>$5 hello</code>，即这个是批量回复，同时<code>5</code>表示后面将返回  5 个字节。字符串的最大长度为 512 MB。</li>
<li>当我们执行<code>del</code>命令，返回的是<code>:1</code>，表示这个是整数回复，只在操作真正被执行了的时候， 才返回 <code>1</code> ， 否则返回 0， 1表示<code> true</code>。</li>
<li>当我们执行 <code>mget hello baby  \r\n</code> 时，返回的第一个字符就是 * 号，表示这是一个多条批量回复。* 号后面的值记录了多条回复的数量，我们这里返回的是 <code>*2\r\n $5\r\n world \r\n $-1\r\n</code>， <code>*2</code> 表示后面有 2 条回复。<code>$5</code> 表示后面有 5 个字节。 <code>$-1</code> 表示 <code>baby</code> 这个<code>key</code> 是没有数据的，<code>-1</code> 表示什么都没有。</li>
</ul>
<p>通过对协议的解析，我们就能做出一个类似 redis-cli 的客户端。</p>
<p>我这里抛转引玉，写了一个最简单的，大家看看就好 ：）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">respParseHandler</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (result.startsWith(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">               <span class="comment">// 状态回复</span></span><br><span class="line">               System.out.println(result.substring(<span class="number">1</span>));</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (result.startsWith(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">               <span class="comment">// 错误回复</span></span><br><span class="line">               System.err.println(result.substring(<span class="number">1</span>));</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (result.startsWith(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">               <span class="comment">// 整数回复</span></span><br><span class="line">               <span class="keyword">if</span> (result.substring(<span class="number">1</span>).equalsIgnoreCase(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (result.startsWith(<span class="string">&quot;$&quot;</span>)) &#123;</span><br><span class="line">               <span class="comment">// 批量回复</span></span><br><span class="line">               <span class="keyword">if</span> (result.substring(<span class="number">1</span>, <span class="number">3</span>).equalsIgnoreCase(<span class="string">&quot;-1&quot;</span>)) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;no data, redis return -1&quot;</span>);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               <span class="keyword">int</span> line = result.indexOf(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">               System.out.println(result.substring(line + <span class="number">2</span>));</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (result.startsWith(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">               <span class="comment">// 多条批量回复</span></span><br><span class="line">               <span class="keyword">char</span> num = result.charAt(<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">int</span> first = result.indexOf(<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.valueOf(String.valueOf(num)); i++) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">int</span> next = result.indexOf(<span class="string">&#x27;$&#x27;</span>, first + <span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">                       respParseHandler(result.substring(first, next));</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       respParseHandler(result.substring(first));</span><br><span class="line">                   &#125;</span><br><span class="line">                   first = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>框架设计上的十点基本常识</title>
    <url>/2018/10/04/2018/2018-10-04-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%9A%84%E5%8D%81%E7%82%B9%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->最近一直在开发框架,对框架的设计有很多的疑惑,梁飞大神的这篇文章让我有了更多认识.这里收藏一下.也推荐阅读原文  :)

<ol>
<li><p>API 和 SPI 分离（用户 API 和 扩展 API 分离）</p>
</li>
<li><p>实体域（核心领域模型）， 服务域，会话域</p>
</li>
<li><p>在重要的过程上设置拦截接口（过滤器），允许外置行为，这是基本扩展方式</p>
</li>
<li><p>在重要的状态上留出监听事件接口</p>
</li>
<li><p>接口职责要单一，具有可组合性</p>
</li>
<li><p>微核插件式，平等对待第三方。微核不带有功能性，而是一个生命周期和集成容器，例如Spring 的 BeanFactory。<br> 平等对待第三方，则是作者要把自己当扩展者。</p>
</li>
<li><p>不要控制外部对象的生命周期，框架只需使用这些实例</p>
</li>
<li><p>可配置一定可编程，保持友好的默认约定</p>
</li>
<li><p>区分命令与查询，查询一定幂等、无副作用，命令一定是 void。方法尽量前置断言，类似 Spring。</p>
</li>
</ol>
<p>10 增量实扩展，而不是扩展式扩展，不要扩充原始核心概念。</p>
<p>参考：梁飞博客</p>
<p><a href="http://javatar.iteye.com/blog/706098">http://javatar.iteye.com/blog/706098</a></p>
<p><a href="http://javatar.iteye.com/blog/690845">http://javatar.iteye.com/blog/690845</a></p>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Cglib 实现多重代理</title>
    <url>/2018/10/05/2018/2018-10-05-%E4%BD%BF%E7%94%A8%20Cglib%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%87%8D%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       由于 Cglib 本身的设计，无法实现在 Proxy 外面再包装一层 Proxy（JDK  Proxy 可以），通常会报如下错误：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Caused by: java.lang.ClassFormatError: Duplicate method name <span class="string">&quot;newInstance&quot;</span> with signature <span class="string">&quot;..........</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at java.lang.ClassLoader.defineClass1(Native Method)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">... 10 more</span></span><br></pre></td></tr></table></figure>

<p>错误来源代码：</p>
<p>net.sf.cglib.proxy.Enhancer#generateClass(ClassVisitor v)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......省略代码</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下部分的字节码，每次生成 Proxy 实例都会插入。JVM 验证字节码时则会报错。</span></span><br><span class="line"><span class="keyword">if</span> (useFactory || currentData != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] keys = getCallbackKeys();</span><br><span class="line">    emitNewInstanceCallbacks(e);</span><br><span class="line">    emitNewInstanceCallback(e);</span><br><span class="line">    emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">    emitGetCallback(e, keys);</span><br><span class="line">    emitSetCallback(e, keys);</span><br><span class="line">    emitGetCallbacks(e);</span><br><span class="line">    emitSetCallbacks(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 dump 出来的字节码查看则更为直观：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-24e92aef6962fa1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-712ae04119ddbf3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>生成的字节码中，newInstance 方法是重复的。</p>
<p>dump 方法： <code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;./&quot;);</code></p>
<h2 id="如何处理？"><a href="#如何处理？" class="headerlink" title="如何处理？"></a>如何处理？</h2><p>实现多重代理，有一种蹩脚的方法，例如 JDK 和 Cglib 组合使用。或者你直接使用 JDK 代理。但有时候，针对类的操作还行不通。</p>
<p>笔者参考 Spring 的做法，实现了一个简单的多重代理。</p>
<p>Spring 的场景是：一个目标方法被多个 AOP 拦截，此时就需要多重代理。</p>
<p>Spring 创建代理的代码位于 ：org.springframework.aop.framework.CglibAopProxy#getProxy</p>
<p>Spring  AOP 拦截器类：org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor</p>
<p>该类的 intercept 方法是实现多重代理的核心。</p>
<p>每次调用目标方法，都会根据目标方法，和目标方法的多个拦截点生成一个调用对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成调用对象</span></span><br><span class="line">CglibMethodInvocation c = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy);</span><br><span class="line"><span class="comment">// 调用 </span></span><br><span class="line">c.proceed();</span><br></pre></td></tr></table></figure>

<p>然后调用父类  proceed 方法，其实就是一个过滤器模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">	<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">			<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Skip this interceptor and invoke the next in the chain. 递归.</span></span><br><span class="line">			<span class="keyword">return</span> proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意最后一行，这里就是调用拦截点的 invoke 方法，这个拦截点的具体实现类：AspectJAroundAdvice。</p>
<p>看下他的 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">      <span class="comment">// AOP 里熟悉的 ProceedingJoinPoint 参数!!!!</span></span><br><span class="line">	ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">	JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">	<span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，我们在业务中编写 AOP 拦截代码时，都会接触到这个 ProceedingJoinPoint 参数，然后调用他的 proceed 方法调用目标方法。</p>
<p>这个 ProceedingJoinPoint 类的 proceed 方法最终会回调 DynamicAdvisedInterceptor 对的 proceed 方法。直到所有的拦截点全部执行完毕。最终执行目标类的方法。</p>
<p>所以，你设置的每个被拦截的方法，如果这个方法会被拦截多次，那么就会有多个 MethodInterceptor（不是 cglib 的）实例形成调用链。然后通过  ProceedingJoinPoint 传递给你拦截使用。</p>
<p>铺垫了这么多，我们自己来实现一个简单的，不能像 Spring 这么复杂！！！！</p>
<h2 id="简单实现-Cglib-多重代理"><a href="#简单实现-Cglib-多重代理" class="headerlink" title="简单实现 Cglib 多重代理"></a>简单实现 Cglib 多重代理</h2><p>先说一下思路：事实上很简单，只需要再拦截器里放一个过滤器链即可，用户在过滤器里拦截多重调用。这些拦截器，就像你加 @Around 注解的方法，只不过我们这里没有 Spring 那么方便而已。</p>
<p>画个 UML 图 ：</p>
<p><img src="https://user-images.githubusercontent.com/24973360/46510651-f2372400-c87c-11e8-91db-a094e55219f4.png"></p>
<p>代码如下：</p>
<p>Test.java &amp; SayHello.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object proxy = ProxyFactory.create().getProxy(<span class="keyword">new</span> SayHello());</span><br><span class="line">        proxy.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello cglib !&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyFactory.java &amp; Interceptor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProxyFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProxyFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        en.setSuperclass(origin.getClass());</span><br><span class="line">        List&lt;Chain.Point&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Point1());</span><br><span class="line">        list.add(<span class="keyword">new</span> Point2());</span><br><span class="line">        en.setCallback(<span class="keyword">new</span> Interceptor(<span class="keyword">new</span> Chain(list, origin)));</span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">        Chain chain;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Interceptor</span><span class="params">(Chain chain)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.chain = chain;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> chain.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Chain.java &amp; Point.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Point&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chain</span><span class="params">(List&lt;Point&gt; list, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">if</span> (++index == list.size()) &#123;</span><br><span class="line">            result = (target.toString());</span><br><span class="line">            System.err.println(<span class="string">&quot;Target Method invoke result : &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Point point = list.get(index);</span><br><span class="line">            result = point.proceed(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="function">Object <span class="title">proceed</span><span class="params">(Chain chain)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Point1.java &amp; Point2.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point1</span> <span class="keyword">implements</span> <span class="title">Chain</span>.<span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">(Chain chain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;point 1 before&quot;</span>);</span><br><span class="line">        Sleep.sleep(<span class="number">20</span>);</span><br><span class="line">        Object result = chain.proceed();</span><br><span class="line">        Sleep.sleep(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;point 1 after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point2</span> <span class="keyword">implements</span> <span class="title">Chain</span>.<span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">(Chain chain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;point 2 before&quot;</span>);</span><br><span class="line">        Sleep.sleep(<span class="number">20</span>);</span><br><span class="line">        Object result = chain.proceed();</span><br><span class="line">        Sleep.sleep(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;point 2 after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>运行 Test main 结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a140462f4b6fa154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>符合预期。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>面试问烂的 Spring AOP 原理、SpringMVC 过程</title>
    <url>/2018/10/07/2018/2018-10-07-%E9%9D%A2%E8%AF%95%E9%97%AE%E7%83%82%E7%9A%84%20Spring%20AOP%20%E5%8E%9F%E7%90%86%E3%80%81SpringMVC%20%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       Spring AOP ，SpringMVC ，这两个应该是国内面试必问题，网上有很多答案，其实背背就可以。但今天笔者带大家一起深入浅出源码，看看他的原理。以期让印象更加深刻，面试的时候游刃有余。

<h2 id="Spring-AOP-原理"><a href="#Spring-AOP-原理" class="headerlink" title="Spring AOP 原理"></a>Spring AOP 原理</h2><p>简单说说 AOP 的设计：</p>
<ol>
<li>每个 Bean 都会被 JDK 或者 Cglib 代理。取决于是否有接口。</li>
<li>每个 Bean 会有多个“方法拦截器”。注意：拦截器分为两层，外层由 Spring 内核控制流程，内层拦截器是用户设置，也就是 AOP。</li>
<li>当代理方法被调用时，先经过外层拦截器，外层拦截器根据方法的各种信息判断该方法应该执行哪些“内层拦截器”。内层拦截器的设计就是职责连的设计。</li>
</ol>
<p>是不是贼简单。事实上，楼主之前已经写过一个简单的例子，地址：<a href="http://thinkinjava.cn/2018/10/%E4%BD%BF%E7%94%A8-Cglib-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%87%8D%E4%BB%A3%E7%90%86/">使用 Cglib 实现多重代理</a></p>
<p>看完之后更简单。</p>
<p>可以将 AOP 分成 2 个部分来扯，哦，不，来分析。。。<br>第一：代理的创建；<br>第二：代理的调用。</p>
<p>注意：我们尽量少贴代码，尽量用文字叙述，因为面试的时候，也是文字叙述，不可能让你把代码翻出来的。。。所以，这里需要保持一定的简洁，想知道细节，看 interface 21 源码，想知道的更细，看 Spring Framework 最新的 master 分支代码。</p>
<p>代码位置：com.interface21.aop 包下。</p>
<p>开始分析（扯）：</p>
<ol>
<li>代理的创建（按步骤）：</li>
</ol>
<ul>
<li>首先，需要创建代理工厂，代理工厂需要 3 个重要的信息：拦截器数组，目标对象接口数组，目标对象。</li>
<li>创建代理工厂时，默认会在拦截器数组尾部再增加一个默认拦截器 —— 用于最终的调用目标方法。</li>
<li>当调用 getProxy 方法的时候，会根据接口数量大余 0 条件返回一个代理对象（JDK or  Cglib）。</li>
<li>注意：创建代理对象时，同时会创建一个外层拦截器，这个拦截器就是 Spring 内核的拦截器。用于控制整个 AOP 的流程。</li>
</ul>
<ol start="2">
<li>代理的调用</li>
</ol>
<ul>
<li>当对代理对象进行调用时，就会触发外层拦截器。</li>
<li>外层拦截器根据代理配置信息，创建内层拦截器链。创建的过程中，会根据表达式判断当前拦截是否匹配这个拦截器。而这个拦截器链设计模式就是职责链模式。</li>
<li>当整个链条执行到最后时，就会触发创建代理时那个尾部的默认拦截器，从而调用目标方法。最后返回。</li>
</ul>
<p>题外话：Spring 的事务也就是个拦截器。</p>
<p>来张不是很标准的 UML 图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-52cc7fe83aba8a2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>关于调用过程，来张流程图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-115860c16ceed67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>大概就是这样子，具体更多的细节，请看源码，如果还不是很明白的话，请咨询本人，本人不确定这个图是否画的很浅显易懂 —— 最起码萌新看得懂才能称之为浅显易懂。</p>
<h2 id="Spring-MVC-过程"><a href="#Spring-MVC-过程" class="headerlink" title="Spring MVC 过程"></a>Spring MVC 过程</h2><p>先来张图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-154a7dd426ad864c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>代码位置：com.interface21.web.servlet.DispatcherServlet#doService </p>
<p>（没错，就是 Spring 1.0 的代码，大道至简，现在的 Spring 经过 15 年的发展，已经太过臃肿，从学习角度来说，interface 21 是最好的代码，不接受反驳）</p>
<p>代码如下：</p>
<h4 id="1-设置属性"><a href="#1-设置属性" class="headerlink" title="1. 设置属性"></a>1. 设置属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 设置属性</span></span><br><span class="line"><span class="comment">// Make web application context available</span></span><br><span class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make locale resolver available</span></span><br><span class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make theme resolver available</span></span><br><span class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br></pre></td></tr></table></figure>
<h4 id="2-根据-Request-请求的-URL-得到对应的-handler-执行链，其实就是拦截器和-Controller-代理对象。"><a href="#2-根据-Request-请求的-URL-得到对应的-handler-执行链，其实就是拦截器和-Controller-代理对象。" class="headerlink" title="2. 根据 Request 请求的 URL 得到对应的 handler 执行链，其实就是拦截器和 Controller 代理对象。"></a>2. 根据 Request 请求的 URL 得到对应的 handler 执行链，其实就是拦截器和 Controller 代理对象。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 找 handler 返回执行链</span></span><br><span class="line">HandlerExecutionChain mappedHandler = getHandler(request);</span><br></pre></td></tr></table></figure>

<h4 id="3-得到-handler-的适配器"><a href="#3-得到-handler-的适配器" class="headerlink" title="3. 得到 handler 的适配器"></a>3. 得到 handler 的适配器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This will throw an exception if no adapter is found</span></span><br><span class="line"><span class="comment">// 3. 返回 handler 的适配器</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<p>关于这个适配器，作用到底是啥呢？HandlerAdapter 注释写到：This interface is not intended for application developers. It is available to handlers who want to develop their own web workflow.<br>译：此接口不适用于应用程序开发人员。它适用于想要开发自己的Web工作流程的处理程序。</p>
<p>也就说说，如果你想要在处理 handler 之前做一些操作的话，可能需要这个，即适配一下这个 handler。例如 Spring 的测试程序做的那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object delegate)</span></span></span><br><span class="line"><span class="function">		    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                      <span class="comment">// 你可能需要 doSomething.......</span></span><br><span class="line">			((MyHandler) delegate).doSomething(request);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-循环执行-handler-的-pre-拦截器"><a href="#4-循环执行-handler-的-pre-拦截器" class="headerlink" title="4. 循环执行 handler 的 pre 拦截器"></a>4. 循环执行 handler 的 pre 拦截器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 循环执行 handler 的 pre 拦截器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappedHandler.getInterceptors().length; i++) &#123;</span><br><span class="line">	HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];</span><br><span class="line">	<span class="comment">// pre 拦截器</span></span><br><span class="line">	<span class="keyword">if</span> (!interceptor.preHandle(request, response, mappedHandler.getHandler())) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个没什么好讲的吧？</p>
<h4 id="5-执行真正的-handler，并返回-ModelAndView-Handler-是个代理对象，可能会执行-AOP"><a href="#5-执行真正的-handler，并返回-ModelAndView-Handler-是个代理对象，可能会执行-AOP" class="headerlink" title="5. 执行真正的 handler，并返回  ModelAndView(Handler 是个代理对象，可能会执行 AOP )"></a>5. 执行真正的 handler，并返回  ModelAndView(Handler 是个代理对象，可能会执行 AOP )</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5. 执行真正的 handler，并返回  ModelAndView(Handler 是个代理对象，可能会执行 AOP )</span></span><br><span class="line">ModelAndView mv = ha.handle(request, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>

<h4 id="6-循环执行-handler-的-post-拦截器"><a href="#6-循环执行-handler-的-post-拦截器" class="headerlink" title="6. 循环执行 handler 的 post 拦截器"></a>6. 循环执行 handler 的 post 拦截器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6. 循环执行 handler 的 post 拦截器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mappedHandler.getInterceptors().length - <span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">	HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];</span><br><span class="line">	<span class="comment">// post 拦截器</span></span><br><span class="line">	interceptor.postHandle(request, response, mappedHandler.getHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-根据-ModelAndView-信息得到-View-实例"><a href="#7-根据-ModelAndView-信息得到-View-实例" class="headerlink" title="7. 根据 ModelAndView 信息得到 View 实例"></a>7. 根据 ModelAndView 信息得到 View 实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View view = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mv.isReference()) &#123;</span><br><span class="line">	<span class="comment">// We need to resolve this view name</span></span><br><span class="line">	<span class="comment">// 7. 根据 ModelAndView 信息得到 View 实例</span></span><br><span class="line">	view = <span class="keyword">this</span>.viewResolver.resolveViewName(mv.getViewName(), locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-渲染-View-返回"><a href="#8-渲染-View-返回" class="headerlink" title="8. 渲染 View 返回"></a>8. 渲染 View 返回</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 8. 渲染 View 返回</span></span><br><span class="line">view.render(mv.getModel(), request, response);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>本人开源项目 Lu-Rpc</title>
    <url>/2018/10/16/2018/2018-10-16-%E6%9C%AC%E4%BA%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%20Lu-Rpc/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       Lu-Rpc 是个专为学习者准备的 RPC 框架, 初始架构非常简单, 可供初学者扩展和学习.

<p>Lu 可以认为是中文世界的撸, 即撸 Rpc— 造个 Rpc 轮子.</p>
<p>Lu-Rpc 架构图如下:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8786ca05934579d5.png?imageMogr2/auto-orient/"></p>
<p>Lu-Rpc 的领域模型设计借鉴 Dubbo, 服务域没有明显的界限. 核心域就是 Invoker, 非常合适作为核心领域模型的接口.</p>
<p>会话域可以是Request,也可以是 Invocation. 这个问题不大.</p>
<p>希望对 Dubbo， Motan，SOFA 等 RPC 感兴趣的，看过源码的，没看过源码的，都可以来接触这个项目。该项目可以让你迅速领会 RPC 框架的设计，更进一步的，如果你有兴趣，可以加入我们，一起造轮子，一起探讨 RPC 服务框架的设计！！！</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC（Remote Procedure Calls）</p>
<p>关于 RPC 的论文： <a href="http://birrell.org/andrew/papers/ImplementingRPC.pdf">Implementing Remote Procedure Calls </a></p>
<p>以下是论文中的 RPC 设计图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-018e51d4688bfe8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>项目地址: <a href="https://github.com/stateIs0/Lu-Rpc">https://github.com/stateIs0/Lu-Rpc</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>my open source</category>
      </categories>
  </entry>
  <entry>
    <title>闪电侠 Netty 小册里的骚操作</title>
    <url>/2018/10/13/2018/2018-10-13-%E9%97%AA%E7%94%B5%E4%BE%A0%20Netty%20%E5%B0%8F%E5%86%8C%E9%87%8C%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       即使这是一本小册，但基于“不提笔不读书”的理念，仍然有必要总结一下。此小册对于那些“硬杠 Netty 源码 却不曾在千万级生产环境上使用实操”的用户非常有用。当然，对那些没有 Netty 编程经验的人来说，更为有用。

<p>放个小册地址：<a href="https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b4db06d5188251afc257383#heading-2"><a href="https://juejin.im/book/5b4bc28bf265da0f60130116">Netty 入门与实战：仿写微信 IM 即时通讯系统</a>
</a></p>
<p>再次强烈推荐，一碗黄焖鸡/半杯 Luckin coffee/一包炫赫门 的价钱，可以让你学会使用 Java 界的 epoll 进行多路复用网络编程，不能说是不划算的 ：）</p>
<p>本文标题含有“骚操作”，为什么这么说呢？</p>
<p>作者是某团某评基础架构部技术专家，长期负责后台千万级别的推送系统，而这些推送系统自然是长连接实现的。可以想象，作者的这些实践经验不可谓不好用，纵然看过源码，提过 issue，本人也觉得这些操作非常好用，非常骚气。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们挑重点讲，虽然对于强迫症来讲，每一节都有笔记才是最吼的！</p>
<p>1 服务端启动流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过给 bind 方法添加监听器，用以自动绑定递增端口。算骚操作吧?</span><br><span class="line">2. attr 方法，为每条连接增加属性，能够实现全单例模式哟</span><br><span class="line">3. childOption 方法，关于 TCP连接的优化，SO_KEEPALIVE 底层心跳，TCP_NODELAY 延迟发送，SO_BACKLOG 等待队列</span><br></pre></td></tr></table></figure>

<p>2  客户端启动流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 还是通过监听器实现重试，但是是 connect 返回的 future，且重实间隔时间左移 1 位增加（性能优化，不使用乘二 ，优秀）。</span><br><span class="line">2. 重试不在主线程，而是使用 bootstrap.config().group().schedule 搞定时任务，和我想的不一样。优秀</span><br><span class="line">3. 客户端需要 CONNECT_TIMEOUT_MILLIS 属性</span><br></pre></td></tr></table></figure>

<p>3 客户端与服务端双向通信</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.客户端在 channelActive 立刻搞事情，嗯，rpc 通信通常也会做一些处理，例如打印客户端ip之类的。</span><br></pre></td></tr></table></figure>

<p>4  客户端与服务端通信协议编解码（扩展较多）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">emm，这个其实就是自定义应用层协议。</span><br><span class="line"><span class="bullet">1.</span> 4 字节魔数校验，例如 dubbo 就使用0xdabb进行校验，Java 字节码也使用 0xcafebabe 校验字节码。</span><br><span class="line"><span class="bullet">2.</span>  版本号肯定需要的</span><br><span class="line"><span class="bullet">3.</span> 序列化算法，肯定也需要的</span><br><span class="line"><span class="bullet">4.</span> 指令，肯定也是需要的，不过，也可以使用别的方式。</span><br><span class="line"><span class="bullet">5.</span> 后面的数据长度，也是需要的，方便拆包。</span><br><span class="line"></span><br><span class="line">其实这里可以参照 RPC 协议来看，这里更像一个简化的 RPC 协议。</span><br><span class="line">一般 RPC 框架首先获取协议类型，根据这个协议类型得到协议处理器，然后再处理（一个端口处理多个协议的场景）。</span><br><span class="line">生产级别的 RPC 通常较为复杂，以 SOFABolt 为例，需要以下字段：</span><br><span class="line"><span class="bullet">1.</span> 协议版本</span><br><span class="line"><span class="bullet">2.</span> 请求类型，即指令（Request，Response， oneway）</span><br><span class="line"><span class="bullet">3.</span> 指令版本</span><br><span class="line"><span class="bullet">4.</span> RequestID 负责数据对应</span><br><span class="line"><span class="bullet">5.</span> 序列号器</span><br><span class="line"><span class="bullet">6.</span> 协议开关（例如 CRC 校验，安全校验）</span><br><span class="line"><span class="bullet">7.</span> 响应码，约定异常，简化异常</span><br><span class="line"><span class="bullet">8.</span> 类名长度，Java rpc 框架必备</span><br><span class="line"><span class="bullet">9.</span> 请求头长度（参照 http header）</span><br><span class="line"><span class="bullet">10.</span> 请求体长度（参照http body）</span><br><span class="line"><span class="bullet">11.</span> 类名</span><br><span class="line"><span class="bullet">12.</span> 业务请求头内容（一般是 Map，SOFABolt 支持自定义，SOFARPC 里面藏着是否泛化调用等信息）</span><br><span class="line"><span class="bullet">13.</span> 业务请求体内容（一般就是个Request对象或 Response对象，里面包含约定的属性，例如参数，返回值，超级多，SOFARPC 有个属性类 RemotingConstants，这里都有）</span><br><span class="line"><span class="bullet">14.</span> CRC 校验码（金融场景必备）</span><br></pre></td></tr></table></figure>

<p>5  实现客户端与服务端收发消息</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 使用 hannel.attr(Attributes.<span class="keyword">LOGIN</span>).<span class="keyword">set</span>(<span class="keyword">true</span>) 绑定登录标识方便哟</span><br></pre></td></tr></table></figure>

<p>6  构建客户端与服务端 pipeline</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 常用的 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 但是需要强转哦，麻烦，</span><br><span class="line">   建议使用 SimpleChannelInboundHandler (还帮你释放内存哟)。</span><br><span class="line"><span class="bullet">2.</span> 不使用 MessageToByteEncoder ，可以自己编解码哦，虽然麻烦点</span><br></pre></td></tr></table></figure>

<p>7  拆包粘包理论与解决方案</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 常用拆包：固定长度，行拆包（有bug，我写过文章分析），分隔符，基于长度</span><br><span class="line"><span class="bullet">2.</span> 最通用的就是基于长度，只要你的自定义协议中包含长度域字段，就可以使用</span><br><span class="line"><span class="bullet">3.</span> LengthFieldBasedFrameDecoder 代替自己继承 ByteToMessageDecoder 哟。</span><br><span class="line"><span class="bullet">4.</span> 对 LengthFieldBasedFrameDecoder 扩展一下，校验魔数关闭错误连接美滋滋。</span><br></pre></td></tr></table></figure>

<p>8  channelHandler 的生命周期 </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 在 channelReadComplete 方法里执行 flush，批量刷新，性能提升美滋滋。</span><br><span class="line"><span class="bullet">2.</span> channelActive 和 channelInActive 增减连接，RPC 都这么干</span><br></pre></td></tr></table></figure>

<p>9 使用 channelHandler 的热插拔实现客户端身份校验</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. ctx.pipeline().<span class="comment">remove(this) 删除没有必要的 handler 美滋滋</span></span><br><span class="line"><span class="number">2</span>. handler<span class="comment">Removed 回调美滋滋</span></span><br></pre></td></tr></table></figure>

<p>10  客户端互聊原理与实现</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">Session</span> 通过 channel.attr(Attributes.<span class="keyword">SESSION</span>).<span class="keyword">set</span>(<span class="keyword">session</span>) 绑定连接美滋滋。</span><br><span class="line"><span class="number">2.</span> channel.attr(Attributes.<span class="keyword">SESSION</span>).<span class="keyword">set</span>(<span class="keyword">null</span>) 删除 <span class="keyword">session</span> 美滋滋</span><br><span class="line"><span class="number">3.</span> channel.attr(Attributes.<span class="keyword">SESSION</span>).<span class="keyword">get</span>() 美滋滋</span><br></pre></td></tr></table></figure>

<p>11 群聊的发起与通知 </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ChannelGroup c = ChannelGroup channelGroup = <span class="keyword">new</span> <span class="constructor">DefaultChannelGroup(<span class="params">ctx</span>.<span class="params">executor</span>()</span>) 批量处理连接美滋滋</span><br><span class="line"><span class="number">2.</span> channelGroup.writeAndFlush 批量写连接美滋滋</span><br></pre></td></tr></table></figure>
<h3 id="高能预警！！！！"><a href="#高能预警！！！！" class="headerlink" title="高能预警！！！！"></a>高能预警！！！！</h3><p>12  牛逼的性能优化</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 共享 handler</span><br><span class="line"><span class="bullet">2.</span> 压缩 handler - 合并编解码器 —— MessageToMessageCodec</span><br><span class="line"><span class="bullet">3.</span> 虽然有状态的 handler 不能搞单例，但是你可以绑定到 channel 属性上，强行单例</span><br><span class="line"><span class="bullet">4.</span> 缩短事件传播路径—— 放 Map 里，在第一个 handler 里根据指令来找具体 handler。</span><br><span class="line"><span class="bullet">5.</span> 更改事件传播源—— 用 ctx.writeAndFlush() 不要用 ctx.channel().writeAndFlush()</span><br><span class="line"><span class="bullet">6.</span> 减少阻塞主线程的操作—— 使用业务线程池，RPC 优化重点</span><br><span class="line"><span class="bullet">7.</span> 计算耗时，使用回调 Future</span><br></pre></td></tr></table></figure>

<p>13 心跳和空闲检测</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 空闲检测 IdleStateHandler 用起来很爽， channelIdle 和 userEventTriggered 都可以处理</span><br><span class="line"><span class="bullet">2.</span> 定时心跳 ctx.executor().scheduleAtFixedRate 很优秀</span><br><span class="line"><span class="bullet">3.</span> 通常空闲检测时间要比发送心跳的时间的两倍要长一些（3倍），这也是为了排除偶发的公网抖动，防止误判。美滋滋</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小小短文，无法尽数 Netty 精华，但对于新手来说，已经足够使用了。而我这里仅仅是做简单的阅读总结，更多的内容，还需要读者自己去研究小册，研究源码，研究 Netty 在 RPC 里的运用，方能成为 Netty 多路复用网络编程高手。</p>
<p>关于 RPC 里使用 Netty 的最佳范例，推荐蚂蚁金服开源框架 <a href="https://github.com/alipay/sofa-bolt">SOFABolt</a>，可以说是对 Netty 编程最佳实践的提炼，和此文相辅相成进行学习，可助汝纵横 Java 各种面试。</p>
<p>good luck！！！</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>面试被问烂的 Spring IOC(求求你别再问了)</title>
    <url>/2018/10/08/2018/2018-10-08-%E9%9D%A2%E8%AF%95%E8%A2%AB%E9%97%AE%E7%83%82%E7%9A%84%20Spring%20IOC(%E6%B1%82%E6%B1%82%E4%BD%A0%E5%88%AB%E5%86%8D%E9%97%AE%E4%BA%86)/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 广义的  IOC 

<ul>
<li>IoC(Inversion of Control) 控制反转，即“不用打电话过来，我们会打给你”。</li>
</ul>
<p>两种实现： 依赖查找（DL）和依赖注入（DI）。</p>
<p>IOC 和 DI 、DL 的关系（这个 DL，Avalon 和 EJB 就是使用的这种方式实现的 IoC）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c415d1c39ed74772.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>DL 已经被抛弃，因为他需要用户自己去是使用 API  进行查找资源和组装对象。即有侵入性。</li>
<li>DI 是 Spring 使用的方式，容器负责组件的装配。</li>
</ul>
<p>注意：Java 使用 DI 方式实现 IoC 的不止 Spring，包括 Google 的 Guice，还有一个冷门的 PicoContainer（极度轻量，但只提供 IoC）。</p>
<h2 id="Spring-的-IoC"><a href="#Spring-的-IoC" class="headerlink" title="Spring 的 IoC"></a>Spring 的 IoC</h2><p>Spring 的 IoC 设计支持以下功能：</p>
<ul>
<li>依赖注入</li>
<li>依赖检查</li>
<li>自动装配</li>
<li>支持集合</li>
<li>指定初始化方法和销毁方法</li>
<li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li>
</ul>
<p>其中，最重要的就是依赖注入，从 XML 的配置上说， 即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p>
<p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean  的依赖注入。</p>
<p>那么， Spring 如何设计容器的呢？</p>
<p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p>
<ul>
<li>BeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>BeanFactory 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 <strong>“低级容器”</strong>。</p>
<p>ApplicationContext 可以称之为 <strong>“高级容器”</strong>。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p>
<p>当然，除了这两个大接口，还有其他的辅助接口，但我今天不会花太多篇幅介绍他们。</p>
<p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，我这里通过常用的 ClassPathXmlApplicationContext 类，来展示整个容器的层级 UML 关系。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1e6ca4c8a58c9e8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>有点复杂？ 先不要慌，我来解释一下。</p>
<p>最上面的  BeanFactory 知道吧？我就不讲了。</p>
<p>下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p>
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p>
<p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p>
<p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p>
<p> 好，解释了低级容器和高级容器，我们可以看看一个 IoC 启动过程是什么样子的。说白了，就是 ClassPathXmlApplicationContext 这个类，在启动时，都做了啥。（由于我这是 interface21 的代码，肯定和你的 Spring 4.x 系列不同）。</p>
<p>下图是 ClassPathXmlApplicationContext 的构造过程，<strong>实际就是 Spring IoC 的初始化过程</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-db065eecf16176c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>注意，这里为了理解方便，有所简化。</p>
<p>这里再用文字来描述这个过程：</p>
<ol>
<li><p>用户构造 ClassPathXmlApplicationContext（简称 CPAC）</p>
</li>
<li><p>CPAC 首先访问了 “抽象高级容器” 的 final 的 refresh 方法，这个方法是模板方法。所以要回调子类（低级容器）的 refreshBeanFactory 方法，这个方法的作用是使用低级容器加载所有 BeanDefinition 和  Properties 到容器中。</p>
</li>
<li><p>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 setBeanFactory 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能，随着 Spring 的不断升级，功能越来越多，很多人在这里迷失了方向 ：）。</p>
</li>
</ol>
<p>简单说就是：</p>
<ol>
<li>低级容器 加载配置文件（从 XML，数据库，Applet），并解析成 BeanDefinition 到低级容器中。</li>
<li>加载成功后，高级容器启动高级功能，例如接口回调，监听器，自动实例化单例，发布事件等等功能。</li>
</ol>
<p>所以，一定要把 “低级容器” 和“高级容器” 的区别弄清楚。不能一叶障目不见泰山。</p>
<p>好，当我们创建好容器，就会使用 getBean 方法，获取 Bean，而 getBean 的流程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-da9a2f92e4dfa9db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从图中可以看出，getBean 的操作都是在低级容器里操作的。其中有个递归操作，这个是什么意思呢？</p>
<p>假设 ： 当 Bean_A 依赖着 Bean_B，而这个 Bean_A 在加载的时候，其配置的 ref = “Bean_B” 在解析的时候只是一个占位符，被放入了 Bean_A 的属性集合中，当调用 getBean 时，需要真正 Bean_B 注入到 Bean_A 内部时，就需要从容器中获取这个 Bean_B，因此产生了递归。</p>
<p>为什么不是在加载的时候，就直接注入呢？因为加载的顺序不同，很可能 Bean_A 依赖的 Bean_B 还没有加载好，也就无法从容器中获取，你不能要求用户把 Bean 的加载顺序排列好，这是不人道的。</p>
<p>所以，Spring 将其分为了 2 个步骤：</p>
<ol>
<li>加载所有的 Bean 配置成 BeanDefinition 到容器中，如果 Bean 有依赖关系，则使用占位符暂时代替。</li>
<li>然后，在调用 getBean 的时候，进行真正的依赖注入，即如果碰到了属性是 ref 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。</li>
</ol>
<p>可以看到，依赖注入实际上，只需要 “低级容器” 就可以实现。</p>
<p><strong>这就是 IoC。</strong></p>
<p>所以 ApplicationContext  refresh 方法里面的操作不只是 IoC，是高级容器的所有功能（包括 IoC），IoC 的功能在低级容器里就可以实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了这么多，不知道你有没有理解Spring  IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p>
<p>a. 加载配置文件，解析成 BeanDefinition 放在 Map 里。</p>
<p>b. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出  Class 对象进行实例化，同时，如果有依赖关系，将递归调用  getBean 方法 —— 完成依赖注入。</p>
<p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p>
<p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p>
<p>可以预见，随着 Spring 的不断发展，高级容器的功能会越来越多。</p>
<p>诚然，了解 IoC 的过程，实际上为了了解 Spring 初始化时，各个接口的回调时机。例如 InitializingBean，BeanFactoryAware，ApplicationListener 等等接口，这些接口的作用，笔者之前写过一篇文章进行介绍，有兴趣可以看一下，关键字：<a href="https://www.google.com/search?q=Spring+%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A+%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3&oq=Spring+%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A+%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3&aqs=chrome..69i57j69i65.626j0j1&sourceid=chrome&ie=UTF-8">Spring 必知必会 扩展接口</a>。</p>
<p>但是请注意，实现 Spring 接口代表着你这个应用就绑定死 Spring 了！代表 Spring 具有侵入性！要知道，Spring 发布时，无侵入性就是他最大的宣传点之一 —— 即 IoC 容器可以随便更换，代码无需变动。而现如今，Spring 已然成为 J2EE 社区准官方解决方案，也没有了所谓的侵入性这个说法。因为他就是标准，和 Servlet 一样，你能不实现 Servlet 的接口吗？: -)</p>
<p>好了，下次如果再有面试官问 Spring IoC 初始化过程，就再也不会含糊其词、支支吾吾了！！！</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>差距</title>
    <url>/2018/10/19/2018/2018-10-19-%E5%B7%AE%E8%B7%9D/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>

<ol>
<li>挖坟别人的博客，有点想法。</li>
<li>他们不仅工作经历久，且努力，且学历高。</li>
<li>反观自己在这 3 个方面都是弱势(培训班毕业一年多；不够努力；初中)。</li>
<li>虽然令人伤感，但这不绝不是挫败的借口，应是动力的源泉。</li>
<li>一定要成为领域专家，否则，将永远痛苦。</li>
<li>回想过往，令人痛苦，不能忘，也不敢忘。</li>
<li>我将竭尽全力，实现理想，无论前面是刀山火海还是万丈深渊，我将用生命诠释“虽生犹死，向死而生”。</li>
</ol>
<p>EOF</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>汇总梁飞博客设计文章</title>
    <url>/2018/10/20/2018/2018-10-20-%E6%B1%87%E6%80%BB%E6%A2%81%E9%A3%9E%E5%8D%9A%E5%AE%A2%E8%AE%BE%E8%AE%A1%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       这个链接是 “Java 设计” 标签的所有文章 : [Java 设计](http://javatar.iteye.com/category/7506)





<h4 id="下面是我摘选的其中几篇典型的设计文章"><a href="#下面是我摘选的其中几篇典型的设计文章" class="headerlink" title="下面是我摘选的其中几篇典型的设计文章."></a>下面是我摘选的其中几篇典型的设计文章.</h4><p><a href="http://javatar.iteye.com/blog/394883z">每次设计，你都会从什么问题想起？</a></p>
<p>这个类似 Java 并发编程常识，每遇到一个设计，都需要想到哪些问题？</p>
<p><a href="http://javatar.iteye.com/blog/1188028">以HTTL为例讲讲模块分包&amp;领域模型&amp;扩展框架</a></p>
<p>这个是从理论与实践角度，分析框架设计。</p>
<p><a href="http://javatar.iteye.com/blog/1041832">Dubbo扩展点重构</a></p>
<p>dubbo 最原始的设计和开源后做的重构设计，与 Dubbo 现如今的官方图有些许区别。</p>
<ol>
<li>第一步，微核心，插件式，平等对待第三方。 </li>
<li>第二步，每个扩展点只封装一个变化因子，最大化复用。 </li>
<li>第三步，全管道式设计，框架自身逻辑，均使用截面拦截实现。 </li>
<li>第四步，最少概念，一致性概念模型。 </li>
<li>第五步，分层，组合式扩展，而不是泛化式扩展。 </li>
</ol>
<p>EOF</p>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈中间件开发</title>
    <url>/2018/10/20/2018/2018-10-20-%E8%B0%88%E8%B0%88%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>本文主要是写给那些想从事中间件开发的同学看的 ：）</p>
<p>如果你没有这个打算，那么本文的学习路线非但不实用，还可能会影响你正常的工作 ：）</p>
<h2 id="什么是中间件开发？"><a href="#什么是中间件开发？" class="headerlink" title="什么是中间件开发？"></a>什么是中间件开发？</h2><p>随着国内软件行业的发展，国内互联网公司规模越来越大，业务越来越复杂，随之使用大量的中间件来提高后台服务性能。由此产生了中间件开发和维护人员。</p>
<p>诚然，在小公司，中间件，例如缓存，MQ，RPC 等服务，极大可能是由业务开发人员自己维护，或者委托第三方云平台运维（支付一些费用）。但，如果后台开发超过 200 人，基本就会组建自己的中间件或者基础架构团队，用于维护后台服务器基础架构和中间件。</p>
<p>更大规模的公司，则由于各种各样的原因（性能，KPI），会自己开发中间件，简称自研。这要求中间件团队需要更多的人员。</p>
<h2 id="中间件开发人员需要哪些素质？"><a href="#中间件开发人员需要哪些素质？" class="headerlink" title="中间件开发人员需要哪些素质？"></a>中间件开发人员需要哪些素质？</h2><p>既然需要中间件开发人员，那么中间件开发人员一般从哪里招聘呢？招聘的要求是什么？</p>
<p>通常，一个公司在刚开始组建中间件团队的时候，都会从公司内部挑选精英人才，或者挑选对中间件感兴趣的人才。这时候，可能你没有相关经验，但你仍然有机会参与到中间件开发中。反之，如果你没有中间件开发经验，想通过招聘的方式进入中间件行业，那么相对而言，会有些曲折。</p>
<p>那么，假设，你想从事中间件开发，但，你没有中间件开发经验，且，你的公司也没有组建中间件团队的打算。</p>
<p>该怎么突破？</p>
<p>答： 跳槽。跳槽到别的公司的中间件团队。</p>
<p>这里就涉及到了一个中间件团队需要哪些技能。因为跳槽肯定就要面试，如果你面试的是中间件岗位，那么自然，就需要准备中间件的相关知识。</p>
<p>另外，还有一点，在这个分工明确的时代，即使是中间件，也有很多种类，我这里稍微分一下，可能不是很准确。</p>
<ol>
<li>服务治理中间件，例如 RPC 相关中间件，限流熔断，链路追踪，分布式配置中心等等。你可以从 SpringCloud 里找到相关的产品。当然国内也有很多优秀的产品。</li>
<li>存储中间件，例如缓存，MQ等等，如果存储涉及到分布式（通常都会涉及），那么要求相对较高。</li>
<li>各种 Proxy，不论是数据库，还是 Cache，还是各种存储，通常单机无法承载海量数据，比较简单的办法就是使用 Proxy 进行代理，让应用透明的使用集群。出于性能考虑，这里通常会使用性能较高的产品，例如 goLang，C++ 等。Java 的长处——开发效率，在这个地方权重不大。</li>
<li>各种分布式中间件，例如 ZK 这种，这个我个人认为难度是较大的。分布式向来是软件开发中比较困难的一个点。特别是涉及到存储和一致性。</li>
<li>容器相关，k8s，docker等，容器化已经是大势所趋，其实我也不是很懂😀（听大佬们说的）。</li>
</ol>
<p>回到之前的话题: 一个中间件开发者需要哪些素质？</p>
<ol>
<li>语言基础。从 Java 程序员的角度，基础通常就是：集合，并发，JVM，Netty，IO、NIO（mmap，sendfile）</li>
<li>计算机基础，由于中间件开发人员经常和 OS 打交道，所以计算机基础也必不可少，例如文件系统（IO/磁盘），进程线程，内存管理。</li>
<li>网络基础，搞后台的人员，肯定要对网络熟悉了，熟悉在 Linux 下排查网络问题，熟悉 Epoll 原理等。</li>
<li>分布式相关知识，互联网海量数据背景下，分布式知识必不可少，CAP， Paxos，Raft，zab，2pc，3pc，base等等。最好能根据这些理论写出实现代码。</li>
<li>熟悉开源实现，即使你是业务开发人员，你也 100% 会接触开源项目，例如 Spring，那么，通常你需要对这种常用的开源代码有深刻的理解，不仅知晓其原理，也领会其设计。从大的角度看，你得看清整个框架的背景，设计和取舍，从小的角度看，你得看清框架的内部实现细节，有哪些有趣的地方（通常这种框架都会进行性能优化）。</li>
<li>了解行业风向标，中间件行业和业务开发稍有不同，每个中间件的版本升级都会让该领域的开发者们侧目（类似 iPhone 发布会），了解其特性，进而了解行业趋势，最后成为行业引领。</li>
</ol>
<h2 id="如何成为中间件开发人员？"><a href="#如何成为中间件开发人员？" class="headerlink" title="如何成为中间件开发人员？"></a>如何成为中间件开发人员？</h2><p>好，说完了中间件开发人员需要哪些素质，自然，如何成为中间件开发人员，就不言自明了。</p>
<p>说白了，以上 6 个点，都是硬骨头。</p>
<ol>
<li><p>对于已经开始工作的人来说，需要平时深刻的积累，说的难听一点，如果你的业务开发任务很重，你很难搞定上门的这些内容。</p>
</li>
<li><p>对于还在上学的同学来说，很爽，你可以用学校（不仅仅指大学，据我所知的大神，通常是初中/小学就开始编程，但这不是必须的）里大把的时间来学习，一个个的搞定这些知识点，和社招不同，如果你的知识达到上面的水平，那么 SP offer 应该是随便拿了 ：）</p>
</li>
</ol>
<p>我这里重点和那些平时开发任务不重，想搞中间件的同学聊聊。</p>
<p>我假设你是一个工作 3 年以内的 Java 开发人员，且你可能是培训生，半路出家，科班生，大专生，初中生，且你不在大厂，通常在一个后台开发不超过 200 人的创业公司，title 是 “Java 开发工程师”，并且有一个程序员的梦想，不想 get、set，不想 crud，不想 html 填空，不想和产品同学讨论，也不想和测试同学点点点……(感觉这里会得罪人)</p>
<p>你可能想跳槽。</p>
<p>那么你大概需要做以下准备：</p>
<ol>
<li>巩固 Java 基础，集合源码，并发源码，JVM 原理，Netty 原理源码，IO 相关（涉及到零拷贝文件存储），这些都是 Java 基础，通常是必须的。</li>
<li>分布式原理，最起码知晓理论知识，最好能写一个，哪怕参照开源的也行。</li>
<li>源码，Spring Mybatis Tomcat 等等，这些代码通常是你最先接触的，不妨从这里开始。RPC 中间件相关的，Dubbo，Motan，SOFA，挑一个吧，推荐 SOFA。</li>
<li>再熟悉熟悉（熟悉指源码和设计）分布式的相关产品，假设你是 Java 开发，推荐 RocketMQ，Apollo 配置中心等等中间件，其实都可以，MQ 相对复杂。</li>
<li>操作系统，通常，你在研究上面的内容时，会遇到操作系统的疑问，遇到不要绕过，尽量弄明白。</li>
<li>自己的产品，有就最好了，例如公众号，博客，教学视频，GitHub 项目等等，总之，是拿得出手的东西。</li>
<li>加大牛好友，了解行业风向标。也许你是一个矜持的人，但从事了这个行业，你有必要和行业里优秀的人学习(看看朋友圈就好)。</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通常看完本文，你会有一丝疲惫，甚至带有那么一丝难过：太他么难了！</p>
<p>如果你看完了本文内容，觉得 so easy，那么请左转阿里，或右转美团。</p>
<p>我假定你是前者。那么请你尊重你的梦想。</p>
<p>这里引用一段台词：</p>
<blockquote>
<p>如果你有梦想的话，就要去捍卫它。那些一事无成的人想告诉你你也成不了大器。如果你有理想的话，就要去努力实现。就这样。</p>
</blockquote>
<p>实际上，这句话也是写给我自己的。与君共勉。</p>
<p>最后，我所说的，都是错的。</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>Raft  客户端协议 Client Protocol</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8D%8F%E8%AE%AE%20Client%20Protocol/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 摘要

<p>名词：<br>线性化操作：每一次操作立即执行，在 TA 调用和收到回复之间，只执行一次。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol>
<li>客户端启动时，随机挑选一台服务器。<br>1.1 如过第一次挑选的不是 leader， 那么那个服务器会拒绝客户端的请求，并提供最近接收到的 leader 的信息（ip+port）；<br> 1.2 如果 leader 奔溃了，客户端请求超时。</li>
<li>客户端进行重试。</li>
</ol>
<p>如图 ：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-0840e29122537393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<hr>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ol>
<li> Raft 需要实现线性化语义，但是，上述操作没有考虑 leader 奔溃的情况。</li>
</ol>
<p>例如，leader 在提交这条日志后，在响应客户端<strong>之前</strong> 奔溃了，那么客户端会和新的 leader 重试这个指令，导致重复执行。</p>
<p>解决方案，其实和互联网的幂等操作相同：客户端给每一个指令指定一个唯一序列号，服务器状态机跟踪这个序列号，当服务器接收到这个指令时，首先校验序列号 —— 防止重复执行。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-87cbd02b8f580397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol start="2">
<li>上述操作没有考虑到另一种情况：leader 不知道自己已经被罢黜了。如果 leader 被罢黜，返回的就是脏数据。</li>
</ol>
<p>如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ac73b3ef634e8d7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如何解决？</p>
<ol>
<li>领导人必须有关于被提交日志的最新信息。但任期开始时是个例外，他可能不知道那哪些是已经被提交的。所以在任期开始时需要提交一条空白的日志条目来实现。</li>
<li>领导人在处理只读请求前，必须检查自己是否被废黜了（不能有脏数据），所以要先和集群的大多数节点交换一次心跳来处理这个问题。同时，领导人也可以通过依赖心跳机制来实现租约，但是这种方法依赖时间的正确性。</li>
</ol>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>客户端怎么做：</p>
<p>客户端需要提供每条消息的唯一序列号，同时，如果是第一次访问，需要处理服务器可能返回的 leader  address 进行重试。</p>
<p>如果 leader 宕机，也需要进行重试。</p>
<hr>
<p>服务端怎么做：</p>
<p>在写请求时，非 leader 不能处理写请求，需要返回当前 leader 信息给客户端。<br>在写请求时，leader 需要校验消息的序列号。<br>在读请求时，leader  需要通过心跳验证自己是否是 leader。同时，leader 需要有关于日志被提交时的最新信息，这通常能够保证，除了在任期开始时。所以， Raft 通过让 leader 在任期开始时提交一个空白的日志条目实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>框架设计原则（梁飞）</title>
    <url>/2018/10/20/2018/2018-10-20-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88%E6%A2%81%E9%A3%9E%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 大纲

<p>1 模块分包原则<br>2 框架扩展原则<br>3 领域划分原则<br>4 接口分离原则<br>5 组件协作原则<br>6 功能演进原则</p>
<p>我将对每个原则进行自己的解读，如有不对，还请指教 ：）</p>
<hr>
<h2 id="1-模块分包原则"><a href="#1-模块分包原则" class="headerlink" title="1 模块分包原则"></a>1 模块分包原则</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-cdc90616f48ca317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>说说我的理解。这里其实是从框架结构的解读来解读，这里的包指的是 Maven 的 module。</p>
<p>复用度，指的是 maven 包的复用。可以理解为工具类。这个工具类不应该变化无常。</p>
<p>稳定度：被依赖的包应该保持稳定，或者说，被依赖者应当比依赖者稳定，且不能成环状依赖。如果不稳定，将会影响其他的包。</p>
<p>抽象度，越抽象，越稳定。越具体，越容易变化。</p>
<p>同时，梁飞给出了一个公式，但是实践起来有点麻烦…….</p>
<p>关于模块分包，可以参见更详细的博客。 <a href="http://javatar.iteye.com/blog/1188028">以HTTL为例讲讲模块分包&amp;领域模型&amp;扩展框架</a></p>
<hr>
<h2 id="2-框架扩展原则"><a href="#2-框架扩展原则" class="headerlink" title="2 框架扩展原则"></a>2 框架扩展原则</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-1cc980030bdcc3d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是其实是说的比较多的东西了。</p>
<p>什么是微核心 + 插件？按照作者的说法，核心只负责装配插件。这样，无论是作者自己的功能，还是第三方的功能，都是平等的，再多的插件也不会影响软件架构，因为没有硬编码，且都是可以卸载的。甚至微核也是可以扩展的。：）</p>
<p>同时，插件的组装规则是统一的。说到这里，你应该想到了 IDEA，Maven，Eclipse 等等。</p>
<p>然后说外置生命周期。这个其实我是有一点不理解的。按照作者的说法，其实是说，框架只负责管理对象，对象的出生和死亡不由框架负责。即，用户应将实例注册到框架中。</p>
<p>但 Spring 似乎不是这么做的。同时，如果使用注册机制，那么就需要硬编码。或者说，Spring 本身就是管理 Bean 生命周期的框架，而 Dubbo 的职责不在于此？</p>
<p>最少化概念模型，这个其实是一种优化。</p>
<p>一致化数据模型：例如 URL 这种对象，就是一致化数据模型，拒绝使用 String 拼接，解析。</p>
<hr>
<h2 id="3-领域划分原则"><a href="#3-领域划分原则" class="headerlink" title="3 领域划分原则"></a>3 领域划分原则</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-f1c8ef84562c176c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是在框架设计中，是非常重要的。</p>
<p>PPT 中已经说的非常清楚，我就不再说明。其中，Invocation 一定要轻量。否则，对 GC 来说，将是很大的压力（使用对象池？性能不好。）</p>
<p>说说他的好处：</p>
<ol>
<li>结构清晰，这个不必讲吧。</li>
<li>充血模型……这个怎么理解？</li>
<li>可变和不可变状态分离，可变状态集中。通常实体域都是只读的，即不变状态。会话域都是可变状态。</li>
<li>所有领域模型线程安全。无锁编程（lock-free 非常重要）。</li>
</ol>
<p>关于他们的线程安全性：</p>
<ol>
<li>服务域无状态，天生线程安全。</li>
<li>实体域属性只读，线程安全。</li>
<li>会话域工作在栈中，线程安全。</li>
</ol>
<p>所以，需要保证他们是这么设计的，才能实现无锁编程。</p>
<hr>
<h2 id="4-接口分离原则"><a href="#4-接口分离原则" class="headerlink" title="4 接口分离原则"></a>4 接口分离原则</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-85cf6df6bdac6163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>关于接口分离，我认为是单一职责的一种实现。</p>
<p>其中提到 API 和 SPI，API 面向用户，SPI 面向开发者。两者必须分离。</p>
<p>声明式 API 和过程式 SPI ，没看懂，看懂的说一下。：）</p>
<p>API 可配置，一定可编程，这个不用说吧。</p>
<p>区分命令和查询，例如，不应该有 updateAndGet 这个方法（不包括原子类），应该分成 2  个方法，保证 get 方法幂等。</p>
<p>对称性接口：很简单，有 get 方法，就应该有 set 方法，有 add 就由 remove，称之为对称性和完备性。这样用户能自行推导出接口。</p>
<p>兼容性：如果接口加方法，应该是增加子接口的方式。其他的没看明白…….</p>
<hr>
<h2 id="5-组件协作原则"><a href="#5-组件协作原则" class="headerlink" title="5 组件协作原则"></a>5 组件协作原则</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-e38bd0a40b19206d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这个就比较爽了，我们知道 Dubbo 是管道式设计。一个 Invoker 贯通整个流程，事实上，web 服务器都是这么设计的。例如 Tomcat ，Netty。</p>
<p>关于派发，还记得 Spring 的 dispatchServlet 吗？</p>
<p>关于状态的共享：</p>
<ul>
<li>分布是什么？即通过行为传递（适合交互性系统）。</li>
<li>共享是什么？通过一个固定的点获取，称之为仓库（适合管理状态的系统）。</li>
</ul>
<p>主过程拦截，还记得 Mybatis 留给我们的插件吗？还记得 Spring 留给我们的拦截器吗？框架要在关键节点留出拦截点供用户扩展。</p>
<p>事件派发：观察者模式，Reactor 模式，另外提到 Proactor 模式，查了一下，通常在 GNU 编程中，由 OS 支持。</p>
<p>Dubbo 暴露、引用、调用事件，都预留了监听器。</p>
<p>关键路径，即在管道使用职责连模式进行拦截，保证每个拦截器职责单一。</p>
<p>非关键路径，需要有监听机制，不能影响主流程运行。</p>
<p>关于协作防御，我理解为防御性编程。</p>
<ol>
<li>分离可靠操作和不可靠操作。不可靠操作尽量范围要小。</li>
<li>状态分离，尽量无状态。状态要尽可能小。</li>
<li>对状态要尽早验证，因为如果失败，通常无人回滚。前后断言验证状态正确性。</li>
<li>异常防御，应该是预见性的异常，异常包含环境信息。</li>
<li>降低修改成本，防止埋雷：不要根据异常类型做分支判断。保持 null 和 empty 一致。</li>
</ol>
<hr>
<h2 id="6-功能演进原则"><a href="#6-功能演进原则" class="headerlink" title="6 功能演进原则"></a>6 功能演进原则</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-231023fac9a633b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>第一就是开闭原则，微核心加插件机制能够支持。<br>软件质量的下降，来源于修改。</p>
<p>加功能的姿势：应该是增量式，而不是扩充式，即不在原有基础上修改，而是新增加功能。</p>
<p>关于高阶：顶层接口尽量抽象，且不能依赖底层实现。这样，当底层实现变化时，高层无需变化。</p>
<p>例如 Dubbo 泛化，在顶层就足够抽象，底层实现方式不影响高层。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-60328aeaccfc19cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>以上是梁飞总结。</p>
<p>今天说的框架设计和现在大部分人喜欢说的架构设计有所不同，现在似乎只需要再 processon 上放几个阿里云组件，再连几条线，就是架构设计了 ：）</p>
<p>我个人认为，框架设计更能考验一个程序员对程序的抽象和管理能力（也许措辞不当？）</p>
<p>然后，再说说我的总结：关于一个系统的设计，这里应该指的是框架的设计，首先要知道用户需求（废话）。根据需求抽象出模型，再变成代码，且是可扩展，可复用的代码。</p>
<p>这里提到的 6 个原则，应该算是比较成熟的原则了。</p>
<p>微核 + 插件，非常理想化，例如 SOFA，也有自己的扩展机制。</p>
<p>关于领域模型设计，这 3 个模型的职责一定要划分清楚，同时实现无锁编程，这个对于系统的性能非常重要。</p>
<p>关于组件协作，一个系统有多个组件，通常需要进行状态的共享，在 Dubbo 中，使用行为进行传递，也就是会话域。</p>
<p>关于功能演进，请遵循开闭原则，但前提通常是有一个好的内核。</p>
<p>关于接口分离和模块分包，通常在后期重构能够达到更好的效果？</p>
<p>好了，洋洋洒洒说了不少，读者如有更好的见解，请与我分享，毕竟现在关注这块的人不多了。：）</p>
<p>EOF</p>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
  <entry>
    <title>Raft  领导选举 Leader Election</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%20%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE%20Leader%20election/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       目录
1. 心跳机制触发领导人选举
2. 选举过程
3. 选举规则
4. 注意点

<p>从之前的文章中，我们知道，在 Raft 中，所有节点初始都是跟随者，然后通过 Raft 的流程进行角色转换：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3a3807aa671bce4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 1 "></p>
<h2 id="1-心跳机制触发领导人选举"><a href="#1-心跳机制触发领导人选举" class="headerlink" title="1. 心跳机制触发领导人选举"></a>1. 心跳机制触发领导人选举</h2><p>当领导人成功当选后，会通过心跳机制维持自己的权威。具体细节如下：</p>
<ol>
<li>领导者周期性的向所有跟随者发送心跳包（即空白的日志条目）维持自己的权威。</li>
<li>如果一个跟随者在一段时间里，没有收到任何消息，称之为选举超时，那么，他就会认为没有可用的领导，并且发起重新选举。</li>
</ol>
<h2 id="2-选举过程"><a href="#2-选举过程" class="headerlink" title="2. 选举过程"></a>2. 选举过程</h2><p>可以大致分为 2 个过程：</p>
<ol>
<li>增加自己当前的任期号，并且转到候选人状态</li>
<li>并行的向集群中其他节点发送<code>请求投票</code> 的 RPC 消息，让他们给自己投票。这可能会带来 3 种结果。</li>
</ol>
<ul>
<li>自己赢得这次选举</li>
<li>其他的服务器赢得选举</li>
<li>一段时间过后，谁也没有获胜 ， 例如多个跟随者同时成为候选人，当这种情况发生，每一个候选人都会超时，然后他们会通过增加任期号的方式，继续尝试新一轮的选举。如果不加限制，将无限循环这个操作。为了解决这个问题，Raft 增加了一个“随机时间机制”，这个时间为 150 - 300 毫秒，这样就使得每个节点发送 RPC 请求的时间错开。</li>
</ul>
<h2 id="3-选举规则"><a href="#3-选举规则" class="headerlink" title="3. 选举规则"></a>3. 选举规则</h2><p>当然，并不是任何一个节点都可以成为领导人，就像你的team中的 leader一样，必须是符合公司晋升规则的人，才能成为领导人。那么，Raft 的规则是什么呢？</p>
<ol>
<li>当一个候选人获得了同一个任期号内的大多数选票，就成为领导人。</li>
<li>每个节点最多在一个任期内投出一张选票。并且按照先来先服务的原则。</li>
<li>一旦候选人赢得选举，立刻成为领导，并发送心跳维持权威，同时阻止新领导人的诞生。</li>
</ol>
<h2 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4. 注意点"></a>4. 注意点</h2><p>当候选人等待投票时，可能会收到“领导者” 的日志条目 RPC 请求。</p>
<p>怎么处理？</p>
<p>2 种方案。</p>
<ol>
<li>如果“领导者”的任期号不小于候选人当前的任期号，那么候选人承认该领导人，并回归到跟随者状态。</li>
<li>反之，如果领导人的任期号比自己小，候选人会拒绝此次 RPC 并继续保持候选人状态。</li>
</ol>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol>
<li>心跳机制和超时机制触发领导人选举</li>
<li>选举的 2 个过程：增加任期号，转换状态，发送请求投票的 RPC 消息，有 3 种结果，可能会触发随机时间的机制。</li>
<li>选举规则：在同一个任期内获得大多数选票。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Raft 基础</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       目录
1. 三个状态
2. 什么是任期
3. 节点之间的通信


<h2 id="1-三个状态"><a href="#1-三个状态" class="headerlink" title="1. 三个状态"></a>1. 三个状态</h2><p>Raft 设计了 3 个状态，用于表示节点的状态，分别是跟随者，候选者，领导者。</p>
<ol>
<li>领导者：通常只有一个领导人，并且其他节点都是跟随者。</li>
<li>跟随者：跟随者不会发送任何请求，只是简单的响应领导者或者候选人的请求，由领导人处理所有的客户端请求（如果客户端请求了跟随者，那么跟随者会将请求转发给领导者）</li>
<li>候选者：选举新的领导人时使用。</li>
</ol>
<p>3 个角色的转换关系和流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-3a3807aa671bce4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 1 "></p>
<p>可以看到，这张图里的几个概念：</p>
<ol>
<li>初始化：所有服务器启动时，都是跟随者</li>
<li>超时：当初始时， 没有收到领导人的心跳，便开始选举。如果候选者选举的时候，也超时了，便重新选举。</li>
<li>大多数的选票：成为领导人的关键是 —— 获取大多数服务器的选票，可以看做是鸽笼原理。</li>
</ol>
<h2 id="2-什么是任期"><a href="#2-什么是任期" class="headerlink" title="2. 什么是任期"></a>2. 什么是任期</h2><p>目录：</p>
<ol>
<li> 2 个阶段</li>
<li>任期</li>
<li>服务器之间的通信</li>
</ol>
<p>背景：由于机器的物理时间是不可靠的，所以需要一个逻辑时间。称之为任期（term）。</p>
<p><strong>从 2 个阶段开始说起</strong>：</p>
<p>集群节点通常有 2 个节点：</p>
<ol>
<li>选举阶段</li>
<li>领导者正常运行</li>
</ol>
<p>例外：当选举失败，会进行加时赛，即连续有 2 个选举过程。</p>
<p>见下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d7bfb023c238c533.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 2"></p>
<p>图 2 可见任期 3 选举失败，然后进行了重新选举。</p>
<p>重新选举会继续失败吗？</p>
<p>答：如果不做限制，是会理解失败的。</p>
<p>Raft 使用了一个限制来规避：每台服务器在选举的时候，使用一个随机数（150 -200），即每个服务器在不同的时间发出选举。防止冲突。称之为“加时赛”。</p>
<p><strong>任期号</strong></p>
<p>在上文中说道：由于机器的物理时间是不可靠的，所以需要一个逻辑时间。称之为任期（term）。</p>
<p>有关任期的几个特点：</p>
<ol>
<li>节点有可能观察不到任何一次选举或者任期。</li>
<li>任期充当逻辑时钟，服务器节点可以通过任期号查明过期的领导者或过期的信息。</li>
<li>每个节点存储当前任期号，单调递增。</li>
<li>服务器之间的每次通信，都会交换当前任期号，交换任期号的目的：<br>4.1 如果一个服务器的当前任期号比其他人小，则更新自己。<br>4.2 如果一个候选人或者领导人发现自己的任期号过期了，立刻将自己变成跟随者状态。<br>4.3 如果一个节点收到一个过期的任期号的请求，直接拒绝。</li>
</ol>
<h2 id="3-节点之间的通信"><a href="#3-节点之间的通信" class="headerlink" title="3. 节点之间的通信"></a>3. 节点之间的通信</h2><p>服务器之间通过 RPC 通信，即远程方法调用。</p>
<p>在 Raft 中，RPC 分成 3 种：</p>
<ol>
<li>请求投票： RequestVote 由候选人在选举任期发起</li>
<li>附加条目 AppendEntries 由领导人发起，用来复制日志和提供心跳。</li>
<li>为了传输快照单独增加的 RPC。</li>
</ol>
<p>备注：当服务没有及时收到 RPC 的响应时，会发起重试。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol>
<li>3 个状态的意义和他们之间切换</li>
<li>任期的设计背景，任期在节点通信时的作用，任期在增长策略。</li>
<li>节点直接的通信 RPC 类型以及策略。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Raft 安全性和一致性 Safety and Consistency</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%20Safety%20and%20consistency/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 背景



<p>为了增加一致性算法的正确性，即日志复制的正确性，Raft 又增加了一些安全机制，也就是打补丁。</p>
<p>我们一起来看看。</p>
<h2 id="选举的限制"><a href="#选举的限制" class="headerlink" title="选举的限制"></a>选举的限制</h2><p>首先说结论，<strong>Raft 保证所有之前的任期号中已经提交的日志条目在选举的时候，都会出现在新的领导人中</strong>。不需要额外传送这些日志给领导人 —— 这意味了保证了数据的单向流动，即只从领导人传给跟随者， 并且领导人从不会覆盖自身本地日志已经存在的日志条目。</p>
<p>如何实现？</p>
<p>Raft 使用投票的方式，来阻止一个候选人赢得选举 —— 除非这个候选人包含了所有已经提交的日志条目。</p>
<p>也就是说，如果想成为领导人，该节点必须包含所有已经提交的日志条目。</p>
<p>候选人为了赢得选举，必须联系集群中的大部分节点，那么，这些节点依据什么规则投票给 候选者 呢？</p>
<p>答：当候选者发送 RPC 给投票者时，RPC 中包含了候选人的日志信息，然后投票人会<strong>拒绝</strong>掉那些日志没有自己<strong>新</strong>的投票请求。</p>
<p>什么是新？<br>Raft 通过比较两个节点最后一条日志条目的<strong>索引值</strong>和<strong>任期号</strong>来定义谁的日志比较新。</p>
<ol>
<li>首先比较任期号，谁都任期号大，谁就新。</li>
<li>如果任期号相同，那谁的日志长，谁就新。</li>
</ol>
<p>通过这个规则来选举出日志最新的节点作为 leader。</p>
<h2 id="提交之前任期内的日志条目"><a href="#提交之前任期内的日志条目" class="headerlink" title="提交之前任期内的日志条目"></a>提交之前任期内的日志条目</h2><p>首先，领导人如何提交自己当前任期内的日志条目？</p>
<p>答：当自己发送出去的日志 RPC 被大多数 follower 存储到了服务器上，那么就可以提交。</p>
<p><strong>第二个问题：领导人如何提交之前任期内的日子呢</strong></p>
<p>例如，如果这个 leader 在发送 RPC 之后、本地提交之前，崩溃了，怎么办？</p>
<p>在之前的介绍里，如果 leader 崩溃了，后面的新 leader 会继续尝试复制这条记录。</p>
<p>Raft 论文中关于这个规则的介绍：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ab7494771157a645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>但是，这将带来一个问题：一个领导人不能断定“一个之前任期里的日志条目被保存到大多数服务器上的时候” 就一定提交了。</p>
<p>下图将展示这种情况：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-147533ed87f51669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 2"></p>
<p>按照之前既有的规则：</p>
<ol>
<li><p>在 (a) 中，S1 是领导者，部分的复制了索引位置 2 的日志条目。</p>
</li>
<li><p>在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。</p>
</li>
<li><p>然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。</p>
</li>
<li><p>这时会发生 2 种情况：<br>4.1.  如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志</p>
<p> 4.2.  反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）</p>
</li>
</ol>
<p>注意：这两种情况在目前的规则下，都是会发生的！！！</p>
<p>但是，d1 的状态是错误的！！！</p>
<p>为什么？因为 d1 覆盖了 (c) 的日志！！！要知道，当 （c）将日志复制到了大多数机器上，虽然 leader 没提交，但 follower 是有可能提交的。但是 d1 却将日志覆盖了，这将会导致 S2 和 S3 的状态机和日志不一致！！！</p>
<p>为什么会发生这个问题？</p>
<p>我们看看之前的选举规则，有没有漏洞。</p>
<ol>
<li>首先比较任期号，谁的任期号大，谁就新。</li>
<li>如果任期号相同，那谁的日志长，谁就新。</li>
</ol>
<p>最后，需要回顾一下 leader 选举的目标：<code>Raft 使用投票的方式，来阻止一个候选人赢得选举 —— 除非这个候选人包含了所有已经提交的日志条目。</code><br><code>也就是说，如果想成为领导人，该节点必须包含所有已经提交的日志条目</code></p>
<p>在 c 中，S5 满足这两个条件吗？答案是满足的，因为他的任期号（任期 2）确实比 follower（任期 1） 新。</p>
<p>但是，他达到 leader 的选举目标了吗？</p>
<p>显然，在 c 中，S5 不包含所有已经提交的日志条目，所以没达到。</p>
<p>为什么？因为 c  中，S1 提交了他的上一个任期的日志。导致任期号的生成和任期日志的提交不是原子的。</p>
<p>不是原子的会有什么影响？</p>
<p>这将会导致： 新 leader 如果提交“之前的任期日志”崩溃了，后面的 leader 的任期将大于刚刚提交的任期，这将让他成为 leader ，并覆盖日志。</p>
<p>如果是原子的：新 leader 不可能不包含上一个任期的日志。因为要想成为 leader，必须满足<code>任期 +  下标</code>的条件。</p>
<p>我们假设一下，如果 c 中，S1 不提交上个任期的日志，会怎么样？他不会将<code>日志 2</code> 发送到 follower 上，而是应该优先将<code>日志 4 </code>提交，顺便提交之前的<code>日志 2</code>，当成功提交<code>日志 4</code>，即使崩溃，S5 也无法成功获取选举（任期号过小）。</p>
<p>所以，Raft 又加了一条限制：leader 只能在自己当前任期的日志满足多数规则时，才能提交。历史时期的日志默认提交，类似上图的 d2 阶段，即，提交 日志4 时，一起提交 日志2（日志匹配特性的作用） ，可防止这种情况发生。</p>
<p>但如果没有日志可以提交怎么办？</p>
<p>答：提交一条空白日志，利用日志匹配特性，提交上个任期的日志。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d1daf773db66623a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>所以，提交之前任期内的日志条目是可行的，但必须是新的 leader 提交一条日志（可以是空白的）间接提交。</p>
<p>但，如果直接提交之前的日志，将会导致非原子操作，之前的任期将可能会被后面的 leader 覆盖日志，导致状态机和日志不一致。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这一段可以说，全是补丁，说白了，Raft 就是一个个补丁打起来的。</p>
<p>关于选举的限制：<br>Raft 的限制如下：<br>首先比较任期号，谁都任期号大，谁就新。<br>如果任期号相同，那谁的日志长，谁就新。</p>
<p>但是仅仅有这 2 个规则是不够的，如果有节点贸然提交了上个任期的日志却崩溃了，后面的节点将会覆盖日志。</p>
<p>所有，Raft 加了一条规定(补丁)：leader 只能在自己当前任期的日志满足多数规则时，才能提交。</p>
<p>也就是说， leader 只能提交自己任期的日志。不能直接提交别人的日志，就算提交，也是间接提交。</p>
<p>关于 “提交之前任期内的日志条目” 这一块内容，欢迎一起探讨。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p> EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Raft 拾遗</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 背景

<p>本文关注实现 Raft 的关键参数。仅做备忘。</p>
<h3 id="1-跟随者和候选人崩溃"><a href="#1-跟随者和候选人崩溃" class="headerlink" title="1. 跟随者和候选人崩溃"></a>1. 跟随者和候选人崩溃</h3><p>  相比较 leader 崩溃，这个要简单的多，当 follower 崩溃，leader 只需要不断重试即可，当 follower 重启，RPC 重试会成功，注意：RPC 重试是幂等的，因此重试不会造成任何问题。</p>
<h3 id="2-时间和可用性"><a href="#2-时间和可用性" class="headerlink" title="2. 时间和可用性"></a>2. 时间和可用性</h3><p>在 Raft 中，关于时间，有 3 种类型：</p>
<ol>
<li>广播时间（broadcastTime）：指一个节点并行的发送 RPC 给其他节点并收到响应的平均时间。</li>
<li>选举超时时间（electionTimeout）：如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时。</li>
<li>平均故障间隔时间（MTBF）：平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。</li>
</ol>
<p>Raft 规定，只要系统满足下面的时间要求，就可以选举并维持一个稳定的领导人。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">广播时间（<span class="keyword">broadcastTime） </span>&lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</span><br></pre></td></tr></table></figure>

<p>通常广播时间比选举超时时间小一个数量级，这样 leader 才能发送稳定的心跳来阻止跟随者进入选举状态；</p>
<p>选举超时时间一般比 MTBF 小几个数量级，这样整个系统才能正常运行。当 leader 崩溃后，整个系统的不可用时间，大约相当于选举时间超时时间。</p>
<p>广播时间和 MTBF 是由系统决定的，只有选举超时时间是我们自己选择的，通常广播时间大约是 0.5 毫秒到 20 毫秒（持久化需要时间），那么，选举超时时间通常在 10 毫秒 到 500 毫秒之间。</p>
<p>而 MTBF 时间，通常平均故障时间在几个月甚至更长，君不见美团的服务器可用性达到 7 个九 ：）因此很容易满足时间的需求。</p>
<h3 id="3-Raft-算法细节："><a href="#3-Raft-算法细节：" class="headerlink" title="3. Raft 算法细节："></a>3. Raft 算法细节：</h3><h5 id="1-状态"><a href="#1-状态" class="headerlink" title="1. 状态"></a>1. 状态</h5><ul>
<li>所有服务器上持久存在的</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-754f5c02d51687d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li><p> 所有服务器上经常变的<br><img src="https://upload-images.jianshu.io/upload_images/4236553-5033370cadf1e6f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>在领导人里经常变化的（选举后重新初始化）<br><img src="https://upload-images.jianshu.io/upload_images/4236553-88e260a766505eca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
</ul>
<h6 id="2-附加日志-RPC"><a href="#2-附加日志-RPC" class="headerlink" title="2. 附加日志 RPC"></a>2. 附加日志 RPC</h6><ul>
<li>具体指令</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-24284f83959f529a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="由领导人负责调用来复制日志指令，也会用作心跳"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-37b901ccf4f5564f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>接受者实现<ol>
<li>如果 <code>term &lt; currentTerm</code> 就返回 false </li>
<li>如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配，则返回 false </li>
<li>如果已经存在的日志条目和新的产生冲突（索引值相同但是任期号不同），删除这一条和之后所有的 </li>
<li>附加任何在已有的日志中不存在的条目</li>
<li>如果 <code>leaderCommit &gt; commitIndex</code>，令 commitIndex 等于 leaderCommit 和 新日志条目索引值中较小的一个</li>
</ol>
</li>
</ul>
<h6 id="3-请求投票-RPC"><a href="#3-请求投票-RPC" class="headerlink" title="3. 请求投票 RPC"></a>3. 请求投票 RPC</h6><ol>
<li>参数详情</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-02cf63a2ba756a84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="由候选人负责调用用来征集选票"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-0bdb58d871591bf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol start="2">
<li>接收者实现<ol>
<li>如果term &lt; currentTerm返回 false </li>
<li>如果 votedFor 为空或者就是 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他</li>
</ol>
</li>
</ol>
<h5 id="4-所有服务器需遵守的规则"><a href="#4-所有服务器需遵守的规则" class="headerlink" title="4. 所有服务器需遵守的规则"></a>4. 所有服务器需遵守的规则</h5><ol>
<li>所有服务器</li>
</ol>
<ul>
<li>如果commitIndex &gt; lastApplied，那么就 lastApplied 加一，并把log[lastApplied]应用到状态机中</li>
<li>如果接收到的 RPC 请求或响应中，任期号T &gt; currentTerm，那么就令 currentTerm 等于 T，并切换状态为跟随者</li>
</ul>
<ol start="2">
<li>跟随者</li>
</ol>
<ul>
<li>响应来自候选人和领导者的请求</li>
<li>如果在超过选举超时时间的情况之前都没有收到领导人的心跳，或者是候选人请求投票的，就自己变成候选人</li>
</ul>
<ol start="3">
<li>候选人</li>
</ol>
<ul>
<li>在转变成候选人后就立即开始选举过程<ul>
<li> 自增当前的任期号（currentTerm）</li>
<li>给自己投票</li>
<li>重置选举超时计时器</li>
<li>发送请求投票的 RPC 给其他所有服务器</li>
</ul>
</li>
<li>如果接收到大多数服务器的选票，那么就变成领导人</li>
<li>如果接收到来自新的领导人的附加日志 RPC，转变成跟随者</li>
<li>如果选举过程超时，再次发起一轮选举</li>
</ul>
<ol start="4">
<li>领导人</li>
</ol>
<ul>
<li><p>一旦成为领导人：发送空的附加日志 RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以阻止跟随者超时</p>
</li>
<li><p>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端</p>
</li>
<li><p>如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex，那么：发送从 nextIndex 开始的所有日志条目：<br>如果成功：更新相应跟随者的 nextIndex 和 matchIndex<br>如果因为日志不一致而失败，减少 nextIndex 重试</p>
</li>
<li><p>如果存在一个满足 <code>N &gt; commitIndex</code> 的 N，并且大多数的<code>matchIndex[i] ≥ N</code> 成立，并且 <code>log[N].term == currentTerm</code>成立，那么令 <code>commitIndex</code> 等于这个 N </p>
</li>
</ul>
<h3 id="4-日志压缩"><a href="#4-日志压缩" class="headerlink" title="4. 日志压缩"></a>4. 日志压缩</h3><p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md#7-%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9">中文论文“日志压缩”</a></p>
<p>因为这这块功能不是核心功能，暂时不考虑实现，后面再说 ：）</p>
<ol>
<li>快照的设计</li>
<li>快照的基础思想</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Raft 总结</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 重点

<h5 id="通常一致性算法保证以下几点："><a href="#通常一致性算法保证以下几点：" class="headerlink" title="通常一致性算法保证以下几点："></a>通常一致性算法保证以下几点：</h5><ol>
<li>安全性保证：在非拜占庭错误下，都能返回非错误的结果。</li>
<li>可用性：集群只要保证 n/2 + 1 节点可用，那么这个集群就是可用的。</li>
<li>不依赖物理时钟保证一致性：由于分布式的机器的物理时钟是不可靠的，因此，绝不会使用物理时钟。</li>
<li>性能：通常一条指令只需要一轮 RPC 调用即可返回结果，小部分节点响应较慢，不影响整体性能。</li>
</ol>
<h5 id="Raft-特点："><a href="#Raft-特点：" class="headerlink" title="Raft 特点："></a>Raft 特点：</h5><ol>
<li>日志复制是 Raft 的核心，保证日志复制一致是分布式一致性算法的核心。</li>
<li>Raft 设计的整体思路：将一致性工作进行分解（牺牲原子性，提高可理解性），并且从最简单的策略触发，使用遇到问题打补丁的方式，实现了一个可靠的一致性算法。</li>
<li>Raft 和 正统的 Paxos 不同的地方在于，Raft 的一致性前提：必须要有一个强领导者，这个强领导者，保证了日志复制的一致。</li>
<li>Raft 在处理成员增减的策略是：将可能出现两种配置的场景，原子化为一个配置。</li>
<li>日志复制基于状态机，相当于一个函数，当数据输入状态机，执行固定的指令，将状态改变。</li>
<li>Raft 为了实现可理解：做了 2 个工作，第一，只要可能，就将复杂问题分解，例如 Raft 被分成 leader 选举，日志复制，安全性和成员变更等几个部分；第二，通过减少状态的数量。</li>
</ol>
<h5 id="Raft-算法浓缩总结"><a href="#Raft-算法浓缩总结" class="headerlink" title="Raft 算法浓缩总结"></a>Raft 算法浓缩总结</h5><table>
<thead>
<tr>
<th>特性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>选举安全特性</td>
<td>对于一个给定的任期号，最多只会有一个领导人被选举出来</td>
</tr>
<tr>
<td>领导人只附加原则</td>
<td>领导人绝对不会删除或者覆盖自己的日志，只会增加</td>
</tr>
<tr>
<td>日志匹配原则</td>
<td>如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同</td>
</tr>
<tr>
<td>领导人完全特性</td>
<td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中</td>
</tr>
<tr>
<td>状态机安全特性</td>
<td>如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志</td>
</tr>
</tbody></table>
<p>注意：<code>日志匹配规则</code>，<code>领导人完全特性</code>，是非常非常核心的重点，保证这2个特性，才能实现一致性，同时，这两个特性在某个场合, 将是证明一致性的依据（当然，其他 3 个特性也非常的重要）。</p>
<h2 id="Raft-回顾"><a href="#Raft-回顾" class="headerlink" title="Raft 回顾"></a>Raft 回顾</h2><ol>
<li>状态： 节点在  3 个状态直接转换（跟随者， 候选者，领导者），同时，还有加时赛的概念。</li>
<li>leader 选举时，会交换任期号，如果任期比自己小，那么则直接拒接。如果 leader 发现自己任期号过期了，则直接恢复成跟随者状态。</li>
<li>任期：每个选举都是一个任期，即使没成功选举出 leader ，也会更新任期，任期充当逻辑时钟，是保证系统的一致性重要手段。</li>
<li>日志复制：日志由 3 部分组成：<code>下标</code>，<code>任期号</code>，<code>具体命令内容</code>。其中，下标和任期号是保证日志在系统中一致的重要属性。下标保证了日志的唯一，任期保证了日志在整个系统的一致。<br>刚刚上面说的  2 大特性，<code>日志匹配原则和领导人完全特性</code>，也是基于这个前提。</li>
<li>一致性检查： leader 每次同步日志，都会进行一致性检查（nextIndex + term）。</li>
<li>如果新 leader 和 followers  的日志不一致，以 leader 为准进行覆盖—— 即删除 follower 冲突的日志。</li>
<li>选举时：想成为leader，需要满足 2  个重要的规则，先判断任期号大小，再判断日志的下标大小。值较大的才能成为 leader。</li>
<li>7 号条件有缺陷：），因此需要增加限制条件，即 leader 不能直接提交之前任期的日志条目。</li>
<li>集群成员变化：通过使用 2 阶段提交的方式，而不是直接从 old 配置变成 new 配置，Raft 在中间使用 &lt;Cold,Cnew&gt; 这样一个共同配置，即可防止集群同时出现两个 leader。 </li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Raft 日志复制 Log Replication</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%20Log%20replication/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 背景

<p>Raft 是分布式一致性算法，保证的实际上是多台机器上数据的一致性，前面说的 leader 选举是为了保证日志复制的一致性。</p>
<p>简单来说，保证复制日志相同，才是分布式一致性算法的最终任务。</p>
<p>Leader 选举只是为了保证日志复制相同的辅助工作。实际上，在更为学术的 Paxos 里面，是没有 leader 的概念的（大部分 Paxos 的实现通常会加入 leader 机制提高性能）。</p>
<p><strong>所以，保证复制日志相同，就是分布式一致性算法的终极任务</strong>。</p>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>在 Raft 中，leader 会接收客户端的所有需求（follower 会将写请求转发给 leader），leader 会将数据以日志的方式通过 RPC 的方式同步给所有 followers，只要超过半数以上的 follower 反馈成功，这条日志就成功提交了。如果 RPC 请求超时，leader 就不停的进行 RPC 重试。</p>
<p>下面再从几个方面说说日志复制：</p>
<ol>
<li>复制过程</li>
<li>日志的组成</li>
<li>主从日志的一致性</li>
<li> 日志特性</li>
<li>日志的不正常情况</li>
</ol>
<h5 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h5><ol>
<li>客户端的每一个请求都包含被复制状态机执行的指令。</li>
<li>leader 把这个指令作为一条新的日志条目添加到日志中，然后并行发起 RPC 给其他的服务器，让他们复制这条信息。</li>
<li>假如这条日志被安全的复制，领导人就应用这条日志到自己的状态机中，并返回给客户端。</li>
<li>如果 follower 宕机或者运行缓慢或者丢包，领导人会不断的重试，知道所有的 follower 最终都存储了所有的日志条目。</li>
</ol>
<p>大概的流程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-c9ad172e3f41ea02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 1"></p>
<h5 id="日志的组成"><a href="#日志的组成" class="headerlink" title="日志的组成"></a>日志的组成</h5><p>日志的数据结构：</p>
<ol>
<li>创建日志时的任期号（用来检查节点日志是否出现不一致的情况）</li>
<li>状态机需要执行的指令（真正的内容）</li>
<li>索引：整数索引表示日志条目在日志中位置</li>
</ol>
<p>日志结构如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-466b0d0790cd1e8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 2"></p>
<p>上图显示，共有 8 条日志，提交了  7 条。提交的日志都将通过状态机持久化到磁盘中，防止宕机。</p>
<h5 id="主从日志的一致性"><a href="#主从日志的一致性" class="headerlink" title="主从日志的一致性"></a>主从日志的一致性</h5><p>然后谈谈主从日志的一致性问题，这个是分布式一致性算法要解决的根本问题。</p>
<p>Raft 为了保证主从日志的一致性，做了以下规则/限制（补丁）。</p>
<ol>
<li>Raft 保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行</li>
<li>领导人把指令作为一条新的日志条目添加到日志中后，将并行的发送 RPC 给 follower，让他们复制这条信息。</li>
<li>leader 将会跟踪最大的且即将被提交的日志条目的索引，并且这个索引会被包含在未来的所有附加日志 RPC 请求中，这样就能保证其他的服务器知道 leader 的索引提交位置。</li>
<li>一旦 follower 知道一条日志条目已经被提交，那么他也会将这条日志应用到自己的状态机中（按照日志的顺序）。</li>
</ol>
<h5 id="日志特性"><a href="#日志特性" class="headerlink" title="日志特性"></a>日志特性</h5><ol>
<li><p>如果在不同的日志中的两个日志条目的<code>索引</code> 和 <code>索引下标</code> 相同，那么他们的指令就是相同的。（<code>原因：leader 最多在一个任期里的一个日志索引位置创建一条日志条目，日志条目在日志的位置从来不会改变</code>）</p>
</li>
<li><p>如果在不同的日志里的 2 个日志条目拥有相同的任期号和索引，那么他们之前的日志项都是相同的。（<code>原因：每次 RPC 发送附加日志时，leader 会把这条日志条目的前面的日志的下标和任期号一起发送给 follower，如果 follower 发现和自己的日志不匹配，那么就拒绝接受这条日志，这个称之为一致性检查</code>）。<br>2.1 这里需要提一下 Raft 的日志匹配规则：<code>如果 2 个日志的相同的索引位置的日志条目的任期号相同，那么 Raft 就认为这个日志从头到这个索引之间全部相同</code> ，这个非常重要。</p>
</li>
</ol>
<h5 id="日志的不正常情况"><a href="#日志的不正常情况" class="headerlink" title="日志的不正常情况"></a>日志的不正常情况</h5><p>上面说的都是日志在正常情况下的表现，没有考虑到一些异常情况，例如 leader 崩溃。</p>
<p>即，正常情况下， leader 和 follower 的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败（查询上次已提交的日志条目的任期和下标）</p>
<p>然而，让我们考虑一下 leader 的崩溃：假设老的 leader 还没有完全复制完所有的日志条目，就崩溃了，这将导致 follower 的日志有可能比 leader 的日志多，也可能少，也可能多多少少。。。。</p>
<p>下图将展示 leader 和 follower 的日志的冲突情况：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8a3893a9355685c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 3"></p>
<p>从上图可以看出，所有的 follower 都和 leader 的日志冲突了，leader 的最后一条日志的任期是 6， 下标是 10 ，而其他 follower 的日志都与 leader 不匹配。</p>
<p>如何处理？</p>
<p>Raft 给出了一个方案（补丁）:通过强制 follower 直接复制 leader 的日志解决（意味着 follower 中的和 leader 冲突的日志将被覆盖）。</p>
<p>如何操作？</p>
<p>要使得 follower 的日志和 leader 进入一致状态，leader 必须找到 follower 最后一条和 leader 匹配的日志，然后把那条日志后面的日志全部删除。</p>
<p>依据这个限制，上图中的 a follower 不需要删除任何条目，b 也不需要删除，c follower 需要删除最后一个条目，d follower 需要删除最后 2 个任期为 7 的条目，e 需要删除最后 2 个任期为 4 的条目，f 则比较厉害，需要删除 下标为 3 之后的所有条目。</p>
<p>Raft 如何实现？</p>
<p>leader 为每一个 follower 维护一个下标，称之为 nextIndex，表示下一个需要发送给 follower 的日志条目的索引。</p>
<p>当一个新 leader 刚获得权力的时候，他将自己的最后一条日志的 index + 1，也就是上面提的 nextIndex 值，如果一个 follower 的日志和 leader 不一致，那么在下一次  RPC 附加日志请求中，一致性检查就会失败（不会插入数据）。</p>
<p>当这种情况发生，leader 就会把 nextIndex 递减进行重试，直到遇到匹配到正确的日志。</p>
<p>当匹配成功之后，follower 就会把冲突的日志全部删除，此时，follower 和 leader 的日志就达成一致。</p>
<h2 id="日志复制-Summary"><a href="#日志复制-Summary" class="headerlink" title="日志复制 Summary"></a>日志复制 Summary</h2><p>日志复制是分布式一致性算法的核心，所谓的一致性，就是集群多节点的数据一致性。</p>
<p>Raft 把每条日志都附加了 任期号和下标 来保证日志的唯一性。</p>
<p>依据这个限制，Raft 对日志有以下保证：如果 2 个日志的相同的索引位置的日志条目的任期号相同，那么 Raft 就认为这个日志从头到这个索引之间全部相同。</p>
<p>依据这个保证，当 leader 和 follower 日志冲突的时候，leader 将校验 follower 最后一条日志是否和 leader 匹配，如果不匹配，将递减查询，直到匹配，匹配后，删除冲突的日志。这样就实现了主从日志的一致性。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Raft 算法浓缩</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%E7%AE%97%E6%B3%95%E6%B5%93%E7%BC%A9/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## Raft 算法浓缩总结

<p>Raft 论文给出了下面的表格，用于总结 Raft 算法精华 。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>选举安全特性</td>
<td>对于一个给定的任期号，最多只会有一个领导人被选举出来</td>
</tr>
<tr>
<td>领导人只附加原则</td>
<td>领导人绝对不会删除或者覆盖自己的日志，只会增加</td>
</tr>
<tr>
<td>日志匹配原则</td>
<td>如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同</td>
</tr>
<tr>
<td>领导人完全特性</td>
<td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中</td>
</tr>
<tr>
<td>状态机安全特性</td>
<td>如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志</td>
</tr>
</tbody></table>
<p>实际上，这些精华都是一条条限制推出来的。让我们一起看看是怎么推出来的。</p>
<h2 id="选举安全特性"><a href="#选举安全特性" class="headerlink" title="选举安全特性"></a>选举安全特性</h2><p>描述： 对于一个给定的任期号，最多只会有一个领导人被选举出来</p>
<p>如何实现？</p>
<p>Raft 规定：每个节点最多只会对一个任期号投出一张选票，按照先来先服务的原则（随机时间的重要性），同时，当一个候选人从整个集群的大多数节点获得了<strong>针对同一个任期号</strong>的选票，那么他就赢得了这次选举并成为领导人。</p>
<h2 id="领导人只附加原则"><a href="#领导人只附加原则" class="headerlink" title="领导人只附加原则"></a>领导人只附加原则</h2><p>描述：领导人绝对不会删除或者覆盖自己的日志，只会增加。</p>
<p>这个不需要保证别的规则保证，服务器自己搞定。</p>
<h2 id="日志匹配原则"><a href="#日志匹配原则" class="headerlink" title="日志匹配原则"></a>日志匹配原则</h2><p>描述：如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-25e7f8f15615e9dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如何实现？</p>
<p>Raft 维护着以下特性：</p>
<ul>
<li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li>
<li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。</li>
</ul>
<p>第一个特性来自这样的一个事实，领导人最多在<strong>一个任期</strong>里在指定的<strong>一个日志索引位置</strong>创建<strong>一条日志条目</strong>，同时日志条目在日志中的位置也从来不会改变。</p>
<p>第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。</p>
<h2 id="领导人完全特性"><a href="#领导人完全特性" class="headerlink" title="领导人完全特性"></a>领导人完全特性</h2><p>解释：如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d0fa48517ec9a58f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>规则保证：</p>
<p>当一个 leader 提交了某条日志，然后崩溃了，候选者如果想当选 leader，必须满足以下条件：</p>
<ol>
<li>首先比较任期号，谁都任期号大，谁就新。</li>
<li>如果任期号相同，那谁的日志长，谁就新。</li>
<li>获取过半投票者的选票。</li>
</ol>
<p>同时，需要满足：leader 只能在自己当前任期的日志满足多数规则时，才能提交。</p>
<p>所以，当之前的 leader 成功提交最后一条日志，后面的候选者，必须包含过半已提交的最后一条日志的投票者的选票，才能成为 leader。</p>
<h2 id="状态机安全特性"><a href="#状态机安全特性" class="headerlink" title="状态机安全特性"></a>状态机安全特性</h2><p>描述： 如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-9864c6e0e794b0fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解释：</p>
<p>通过领导人完全特性，我们就能证明状态机安全特性，即如果已经服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。</p>
<p>在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。</p>
<p>现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Raft 配置变更 Configuration Changes 拾遗</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4%20Configuration%20changes%20%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 背景

<p>仔细思考了 Raft 关于配置变更的内容，发现论文中的搞法用代码根本无法实现…….然后开始了 search 的阶段，翻到知乎一篇文章和作者的博士论文，感觉用这个可以实现配置变更。</p>
<p>在这里稍微记录一下。</p>
<h2 id="新的发现"><a href="#新的发现" class="headerlink" title="新的发现"></a>新的发现</h2><p>知乎作者 孙建良 的一篇 《Raft 一致性协议》 专栏里，提到了 Raft 作者的长达 240 页的博士论文里，关于配置变更的详细实现。</p>
<p>首先，要解决的问题：分布式集群机器的增减。</p>
<p>新的发现是什么呢？</p>
<p>答：每次只向集群添加一个节点。</p>
<p>Raft phd 34 页：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-59e3a463884d9eac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>首先解释一下这幅图：蓝色方框里显示 old 配置的大多数，红色方框里显示 new 配置的大多数。我们以 b 为例，b 中，向原本 3 个节点的集群添加一个节点变成 4 个节点（暂时不考虑 2n + 1 问题），那么，如果 leader 崩溃，无论是新的配置，还是旧的配置，肯定存在节点交集。在 b 中，old 配置想赢得选举，必须有 2 个节点支持，new 配置要想赢的选举，必须有 3 个节点支持（新配置是 4 个节点），那么他们必然就有一个相交的节点。</p>
<p>这将带来什么影响？</p>
<p>任何一方想赢得选举，都必须争取这个节点的选票。换句话说，同一时刻，有且只有一个 leader 产生。无论是新的，还是旧的。这样就解决了之前那篇文章提到的“出现  2 个 leader 的问题”。</p>
<p>然后我们再假设一下：</p>
<p>我们有一个集群，现在有 3 个节点，然后我们添加一个节点，并更新了 leader 的配置为 4 节点，然后把复制到其他 2 个节点，这时，leader 出现了崩溃，重新选举。</p>
<p>这个时候，会有 2 个结果：</p>
<ol>
<li>新配置复制到了集群的大多数（大多数的值在这里必须大于 2 （包括 leaer 自身））。<ul>
<li>如果新配置复制到了大多数集群，那么新 leader 肯定使用的是新的配置。</li>
</ul>
</li>
<li>新配置没有复制到集群的大多数。<ul>
<li>如果新配置没有复制到大多数集群，那么新 leader 肯定使用的是老的配置。</li>
</ul>
</li>
</ol>
<h2 id="代码如何实现？"><a href="#代码如何实现？" class="headerlink" title="代码如何实现？"></a>代码如何实现？</h2><p>通过上面的分析，实现起来就比较简单了。</p>
<p>思路：</p>
<ol>
<li>每次只增加一个节点，如果要增加 2 个节点，必须等上次那个节点添加成功，才能继续添加。否则会出现双 leader 的情况。</li>
<li>添加节点时，新节点使用的自然是新的配置。</li>
<li>添加的第一步，是否应该是将新节点的日志和 leader 进行同步？如果同步，那么新节点将有可能成为 leader，如果不同步，新节点只能是 follower。</li>
<li>第二步，leader 将新的配置把自身先更新，然后并行的发送到其他 follower。等待反馈，如果大部分节点复制成功，那么，leader ，新的配置就成功了。</li>
</ol>
<p>意外：</p>
<p>如果 leader 复制的过程中出现了崩溃，那么就重新开始选举，此时，一共有 4 个节点，可以确定的是：leader + 新节点都是 new 配置，而，另外两个的配置不一定。关键就在于这两个节点的配置，如果有一个是新的配置，那么选举出来的，肯定是 new 配置的 leader。反之，肯定是 old 配置的 leader。</p>
<p>如果选举出来的是 new 配置节点，那么需要将这个集群的配置刷新，即在此将配置重新发送到所有 follower。</p>
<p>如果选举出来的是 old 配置节点，那么，old 集群 leader 也照样并行的刷新他所在的  3 个节点（包括自己）。 新的节点直接忽略。</p>
<p>在客户端，如果添加节点失败，则进行重试。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/29678067">Raft 一致性协议——知乎 孙建良</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/36547283">别再怀疑自己的智商了，Raft协议本来就不好理解 —– 老钱</a></p>
<p><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf">Raft 作者 240 页的博士论文</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Raft 配置变更 Configuration Changes</title>
    <url>/2018/10/26/2018/2018-10-26-Raft%20%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4%20Configuration%20changes/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 背景
什么是配置变更？

<p>说白了，就是动态增减服务器。</p>
<p>假设，一个 Raft 服务器集群的数量刚开始是 3 台，过了 2 个月，由于要搞类似 618，双11 大促，领导要增加系统可用性，那么就要增加到  5 台。</p>
<p>如果增加到  5 台，就带来了配置的变化，首当其冲的，就是 “服务器数量” 这个配置的变化，例如这个配置叫做 “server_count = 3”， 你需要将配置改成 “server_count = 5”。同时，每台服务器还需要知道其他 4 台服务器的 ip + port，这个配置实际上也是需要变化的。</p>
<p>并且，你需要在不停机的情况下，将新的 2 台服务器增加，并且将这些配置应用到另外 3 台旧的服务器上。</p>
<p>这个时候，你该怎么做？</p>
<p>假设是我，我会先将新的 2 台服务器配置完毕（新的配置）再启动。然后，将新的配置发送到旧的 3 台服务器。那 3 台服务器如果成功收到并提交了这个配置，使这个配置生效，那么整个集群的状态就一致了。</p>
<p>很完美。</p>
<p>但是，分布式肯定没有这么简单。假设，在成功启动 2 台新服务器后，老的集群发生了故障，重新开始选举，这个时候，是怎么样子的？</p>
<p>看下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-48eb59e481912f46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 1"></p>
<p>上图中，一共有 5 台服务器，S1，S2，S3 代表旧的服务器，S4，S5 代表着新的服务器。</p>
<p>绿色代表旧的配置，蓝色代表新的配置。</p>
<p>我们模拟一下：</p>
<ol>
<li>我们先启动了 S4 和 S5，成功启动。</li>
<li>然后我们将新的配置发送到 S1，S2，S3 中，试图让他们应用新的配置。</li>
<li>在某个时刻，S3 成功应用新的配置，同时，旧的系统发生了故障，并开始选举。</li>
<li> 5 台服务器一起开始选举，由于 S1 和 S2 还没有应用新的配置，所以，S1 和 S2 仍然以为只有 3 台服务器，并且在得到 2 张选票后，<strong>成功选出一个领导者</strong>；</li>
<li>而 S3，S4，S5 应用了新的配置，并且获得 3 台服务器的认可，<strong>也成功选出了领导人</strong>。</li>
<li>此时，整个系统出现了 2 个领导人。</li>
</ol>
<p>那么，是哪里出现了问题呢？</p>
<p>根本原因在于，<strong>在同一时刻，有 2 份配置生效了!!!</strong></p>
<p>自然就可以选出 2 个领导人。</p>
<p>所以，要防止这个问题发生，必须不能让 2 份配置同时生效。</p>
<h2 id="Raft-的实现"><a href="#Raft-的实现" class="headerlink" title="Raft 的实现"></a>Raft 的实现</h2><p>Raft 是怎么做的呢？</p>
<p>Raft 使用了一种 2 阶段提交的方案。</p>
<p>具体见下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-1f44bfdbe774ec77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 2 "></p>
<p>第一阶段：</p>
<ul>
<li> 发送新配置到旧服务器的 leader。leader 不会直接存储<code>新配置</code>，而是存储<code>旧配置 + 新配置</code>。同时，一旦这个配置被提交（成功同步到新旧集群的大部分跟随者中），那么，所有服务器必须用这个配置来做决定。也就是说，旧配置失效了，不能拿旧配置做任何决定，同时，此时的系统状态是一致的。这个状态称之为<strong>共同一致</strong>。</li>
</ul>
<p>第二阶段：</p>
<ul>
<li>当 <code>旧配置 + 新配置</code> 被成功提交，这个时候，leader 会创建一条<code>新配置</code> 复制到 followers 中。从而完成配置变更。</li>
</ul>
<p>从上图和上文的解释可以看出，这里不会出现<code>新配置</code> 和 <code>旧配置</code>同时出现的场景。因为他们都被融合在了 <code>旧配置 + 新配置</code> 中去了。即将两个配置融合成一个配置。</p>
<p>那么，图 1 的问题——同时有 2 个 leader 的问题就解决了。</p>
<h2 id="思考：共同一致能确保没有问题吗？"><a href="#思考：共同一致能确保没有问题吗？" class="headerlink" title="思考：共同一致能确保没有问题吗？"></a>思考：共同一致能确保没有问题吗？</h2><p>简化起见，我将 <code>新配置 + 旧配置</code> 称之为 <code>共同配置</code>。<br>为了阅读方便，我将 <code>旧配置</code> 称之为 <code>old 配置</code>，将<code>新配置</code> 称之为 <code>new 配置</code></p>
<p>从图 2 可以看出，一共有 2 个关键的节点：</p>
<ol>
<li>提交 “共同配置”</li>
<li>提交“new 配置”</li>
</ol>
<p>如果这个两个地方出现问题了，怎么办？</p>
<p>假设： <code>共同配置</code> 提交失败，会怎么样？例如提交的时候，老的 leader 崩溃了。</p>
<p>这要分 2 种情况来看：<br>1.新  leader 已经收到 “共同配置”，那么新 leader 将继续进行配置变更操作。<br>2. 新 leader 没有收到 “共同配置”，自然使用 old 配置。</p>
<p>假设：new 配置提交失败，会怎么样？例如提交的时候，leader 崩溃了。</p>
<p>这要看 new 配置有没有同步到大部分节点。</p>
<ol>
<li>假设已经同步到大部分节点，则集群使用“新配置” —— 完成配置变更。</li>
<li>假设没有同步到大部分节点，则集群使用 “共同配置”，继续进行配置变更。 </li>
</ol>
<h6 id="另一个问题：共同一致阶段，如果-leader-崩溃，使用什么策略进行选举？"><a href="#另一个问题：共同一致阶段，如果-leader-崩溃，使用什么策略进行选举？" class="headerlink" title="另一个问题：共同一致阶段，如果 leader 崩溃，使用什么策略进行选举？"></a>另一个问题：共同一致阶段，如果 leader 崩溃，使用什么策略进行选举？</h6><p>答：如果 共同配置 被应用了，那么，由于领导人完全特性（<code>如果某条日志在某个任期号中已经被提交，那那个条目必然出现在更大任期号的所有领导人中</code>），新的 leader 必然拥有 共同配置。</p>
<p>如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-fad1d042096fa9a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="最后，Raft-论文提出的-3-个问题"><a href="#最后，Raft-论文提出的-3-个问题" class="headerlink" title="最后，Raft 论文提出的 3 个问题"></a>最后，Raft 论文提出的 3 个问题</h2><h5 id="1-新的服务器在初始化时，没有存储任何日志条目。"><a href="#1-新的服务器在初始化时，没有存储任何日志条目。" class="headerlink" title="1. 新的服务器在初始化时，没有存储任何日志条目。"></a>1. 新的服务器在初始化时，没有存储任何日志条目。</h5><p>这个带来的问题是：由于没有存储任何日志条目，那么，就需要时间来补充日志条目，这实际上，是会影响可用性的。</p>
<p>Raft 使用了一种方法来避免：这个阶段的服务器是没有投票权力的。只有当器补充完日志条目了，才会加入集群。</p>
<h5 id="2-集群的领导人可能不是新配置的一员"><a href="#2-集群的领导人可能不是新配置的一员" class="headerlink" title="2.  集群的领导人可能不是新配置的一员"></a>2.  集群的领导人可能不是新配置的一员</h5><p>什么意思？<br>答： 当旧集群的 leader 提交了新配置，Leader 需要变成 follower。</p>
<p>为什么？ </p>
<p>答：当新的配置生效时，旧 leader 还使用的老的配置，例如新配置的服务器数量是 5 台，而老的 leader 仍然应用的是 3 台服务器。</p>
<p>新集群应该使用新的配置重新进行选举（不然使用新配置干嘛？）。</p>
<h5 id="3-移除不在新配置中的服务器可能会扰乱集群"><a href="#3-移除不在新配置中的服务器可能会扰乱集群" class="headerlink" title="3. 移除不在新配置中的服务器可能会扰乱集群"></a>3. 移除不在<code>新配置</code>中的服务器可能会扰乱集群</h5><p>当移除他们时，他们会重新进行选举，导致当前 leader 回退到 follower 状态。虽然新的 leader 会被选出来，但被移除的服务器会再次请求重新选举，循环反复，影响可用性。</p>
<p>Raft 的解决方式：</p>
<ol>
<li>当节点确认当前领导人存在时，则忽略请求投票的  RPC 请求。</li>
<li>当节点在最小选举超时时间里收到请求投票请求，他不会更新当前的任期号或者投出选票（从而扰乱集群）。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">英文 paper  pdf 地址</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Raft paper 中文翻译 —— 寻找一种易于理解的一致性算法（扩展版）</a></p>
<p><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&feature=youtu.be">Raft 作者讲解视频</a></p>
<p><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt">Raft 作者讲解视频对应的 PPT</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">一个简单的讲解 Raft 协议的动画</a></p>
<p>EOF</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Spring-声明式事务（一）——隔离属性</title>
    <url>/2018/05/14/2018/2018-05-14-Spring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E9%9A%94%E7%A6%BB%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       ## 前言

<p>众所周知，Spring 的事务属性众多，楼主今天将对 Spring 最常用的事务 —— 声明式事务，进行彻底的解释，包括楼主也写了很多的测试例子。代码地址: <a href="https://github.com/stateIs0/Transactional">使用 tk-mybatis 的 demo 测试了 Spring 的事务</a></p>
<p>东西很多，楼主分为 3 个部分来写，第一就是隔离属性了，第二是传播属性，第三是其他属性。</p>
<h2 id="隔离属性"><a href="#隔离属性" class="headerlink" title="隔离属性"></a>隔离属性</h2><p>事务要解决的是多线程并发修改数据库的问题。Mysql  innodb 引擎支持事务。类似 Java 中的各种锁，例如乐观锁（CAS），读写锁，悲观锁。事务也有很多级别。</p>
<p>每个隔离级别要解决的问题都是不同的。</p>
<p>一张表格来看看。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-8a9ba3753cfe91ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>以上是 Spring 事务每个隔离级别能够解决的问题。</p>
<p>再说说脏读，不可重复读，幻读的解释。</p>
<p>脏读场景：<br>1.事务 A 读取数据<br>2.事务 B 修改数据（未提交）<br>3.事务 A 读取数据已和第一次读的不同</p>
<p>不可重复读场景：<br>1.事务 A 读取数据<br>2.事务 B <strong>修改</strong>数据（提交）<br>3.事务 A 读取数据已和第一次不同</p>
<p>幻读场景：<br>1.事务 A 读取数据<br>2.事务 B <strong>新增</strong>数据<br>3.事务 A 再次读取的数据数量已和第一次的数量不同</p>
<p>注意: 幻读指的是读到的数据的数量,针对插入情况,会产生不一致情况,修改则不会.</p>
<p>再解释一下 4 个隔离级别：</p>
<ol>
<li>未提交读：表示另一个事务修改了数据，还没有提交，这个事务就可以读到了。</li>
<li>已提交读：表示另一个事务修改了数据，同时提交了，这个事务就可以读到了，如果没提交，就读不到。</li>
<li>可重复读：表示另一个事务即使修改了数据（已提交），这个事务也是看不到的，因此这个事务每次读到的数据都是一样的。这叫可重复读。但</li>
<li>可串行化：可以想象成 Java 语言的锁。一个个执行。毫无并发性。性能令人发指。</li>
</ol>
<p>其中关于可重复读需要解释一下在 mysql 场景下的幻读问题，按照标准，可重复读应该会导致幻读，但 mysql 如果在一个事务中，第二次读取的数据使用的是第一次的结果，因此不会产生幻读。</p>
<p>关于默认的级别，很多文章说是 “已提交读”，但经过详细的测试，应该是可重复读。</p>
<p>因此，大部分时候，使用默认的级别，就能得到和串行化相同的目的。而串行的成本则是非常的高昂，类似悲观锁。还有一点，mysql 的事务是借助行锁来实现的。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Builder-建造者模式</title>
    <url>/2018/06/14/2018/2018-06-14-Builder-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<span id="more"></span>       <!--more-->       ## 前言

<p>当一个对象的构造十分复杂时，我们需要将“构造过程”和他的“表示”进行分离，使得同样的构建过程可以表示不同的对象。</p>
<p>这个时候，需要使用 Builder 模式。用户只需指定建造者的类型就可以得到对应的产品。而具体如何构造用户并不关心。</p>
<p>而不同的对象的构造又是不同的，因此需要不同的建造者一一对应。</p>
<p>类图设计如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-d66a4ac920dbb05a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p><strong>Builer</strong> 相关：Builder, BuilderA, BuilderB</p>
<pre><code class="java">/** 抽象创建者 */
public abstract class Builder &#123;

  abstract Product getProduct();

  abstract void builderName();

  abstract void builderBody();
&#125;

/** 具体创建者，实际场景中，会有多个实现，即一个产品实现对应一个构建者 */
public class BuilderA extends Builder &#123;

  Product product = new ProductA();

  @Override
  Product getProduct() &#123;
    return product;
  &#125;

  /** 具体构建者需要知道如何构建对象 */
  @Override
  void builderName() &#123;
    product.name = &quot;Name A&quot;;
  &#125;

  @Override
  void builderBody() &#123;
    product.body = &quot;Body A&quot;;
  &#125;
&#125;

/** 具体创建者，实际场景中，会有多个实现，即一个产品实现对应一个构建者 */
public class BuilderB extends Builder &#123;

  Product product = new ProductB();

  @Override
  Product getProduct() &#123;
    return product;
  &#125;

  /** 具体构建者需要知道如何构建对象 */
  @Override
  void builderName() &#123;
    product.name = &quot;Name B&quot;;
  &#125;

  @Override
  void builderBody() &#123;
    product.body = &quot;Body B&quot;;
  &#125;
&#125;
</code></pre>
<p><strong>Product</strong> 相关：Product，ProductA，ProductB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 产品，可以被抽象 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String name;</span><br><span class="line">  String body;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">  String nameA = <span class="string">&quot;New A&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ProductB&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;nameA=&#x27;&quot;</span> + nameA + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, body=&#x27;&quot;</span> + body + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  String nameB = <span class="string">&quot;New B&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ProductB&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;nameB=&#x27;&quot;</span> + nameB + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, body=&#x27;&quot;</span> + body + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Director</strong> 相关：Director</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 指挥者 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 此方法可以固定构建对象的过程，只需要传递具体构建者即可 */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createProduct</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    builder.builderName();</span><br><span class="line">    builder.builderBody();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 测试客户端 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Builder a = <span class="keyword">new</span> BuilderA();</span><br><span class="line">    Builder b = <span class="keyword">new</span> BuilderB();</span><br><span class="line"></span><br><span class="line">    Director director = <span class="keyword">new</span> Director();</span><br><span class="line">    director.createProduct(a);</span><br><span class="line">    director.createProduct(b);</span><br><span class="line"></span><br><span class="line">    System.out.println(a.getProduct());</span><br><span class="line">    System.out.println(b.getProduct());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProductB&#123;nameA=<span class="string">&#x27;New A&#x27;</span>, name=<span class="string">&#x27;Name A&#x27;</span>, body=<span class="string">&#x27;Body A&#x27;</span>&#125;</span><br><span class="line">ProductB&#123;nameB=<span class="string">&#x27;New B&#x27;</span>, name=<span class="string">&#x27;Name B&#x27;</span>, body=<span class="string">&#x27;Body B&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出，通过构造不同的 Builder，可以得到对应的产品。大家可能会问，为什么不直接创建产品？实际上，生产环境中的构造过程远比 demo 复杂，将构造对象的复杂过程全部放入指挥者 Director 中，能够有效避免创建过程的错误。</p>
<p>通过使用 Builder，能够重复利用创建者，确保每次构造产品都是正确的。</p>
<p>即：</p>
<blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>这里的“同样的构建过程” 就是 Director 中的 createProduct 方法。</p>
<p>“不同的表示”，则是每个 Builder 实现对应一个具体产品的具体构建内容。具体内容可以根据业务需求进行创建。</p>
<p>Spring 框架中，Builder 模式无处不在。总之，Builder 就是为了构建不同的对象的同时，提供了稳定的构建过程，所有对象的构建过程都是被  Driector 指挥的。而对象的具体构建内容则是子类 Builder 来根据需求实现。有效的将对象的内容和构建过程分离，同时也保证了构建过程的稳定，不易出错。</p>
]]></content>
      <categories>
        <category>Java 设计</category>
      </categories>
  </entry>
</search>
